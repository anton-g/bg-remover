(function(){const o=document.createElement("link").relList;if(o&&o.supports&&o.supports("modulepreload"))return;for(const h of document.querySelectorAll('link[rel="modulepreload"]'))s(h);new MutationObserver(h=>{for(const a of h)if(a.type==="childList")for(const d of a.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&s(d)}).observe(document,{childList:!0,subtree:!0});function i(h){const a={};return h.integrity&&(a.integrity=h.integrity),h.referrerPolicy&&(a.referrerPolicy=h.referrerPolicy),h.crossOrigin==="use-credentials"?a.credentials="include":h.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(h){if(h.ep)return;h.ep=!0;const a=i(h);fetch(h.href,a)}})();var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$1=Symbol.for("react.element"),n$1=Symbol.for("react.portal"),p$2=Symbol.for("react.fragment"),q$2=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v$1=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z$2=Symbol.iterator;function A$1(e){return e===null||typeof e!="object"?null:(e=z$2&&e[z$2]||e["@@iterator"],typeof e=="function"?e:null)}var B$2={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$1=Object.assign,D$2={};function E$1(e,o,i){this.props=e,this.context=o,this.refs=D$2,this.updater=i||B$2}E$1.prototype.isReactComponent={};E$1.prototype.setState=function(e,o){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,o,"setState")};E$1.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function F$1(){}F$1.prototype=E$1.prototype;function G$2(e,o,i){this.props=e,this.context=o,this.refs=D$2,this.updater=i||B$2}var H$2=G$2.prototype=new F$1;H$2.constructor=G$2;C$1(H$2,E$1.prototype);H$2.isPureReactComponent=!0;var I$1=Array.isArray,J$1=Object.prototype.hasOwnProperty,K$1={current:null},L$1={key:!0,ref:!0,__self:!0,__source:!0};function M$1(e,o,i){var s,h={},a=null,d=null;if(o!=null)for(s in o.ref!==void 0&&(d=o.ref),o.key!==void 0&&(a=""+o.key),o)J$1.call(o,s)&&!L$1.hasOwnProperty(s)&&(h[s]=o[s]);var et=arguments.length-2;if(et===1)h.children=i;else if(1<et){for(var $=Array(et),c=0;c<et;c++)$[c]=arguments[c+2];h.children=$}if(e&&e.defaultProps)for(s in et=e.defaultProps,et)h[s]===void 0&&(h[s]=et[s]);return{$$typeof:l$1,type:e,key:a,ref:d,props:h,_owner:K$1.current}}function N$1(e,o){return{$$typeof:l$1,type:e.type,key:o,ref:e.ref,props:e.props,_owner:e._owner}}function O$2(e){return typeof e=="object"&&e!==null&&e.$$typeof===l$1}function escape(e){var o={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(i){return o[i]})}var P$1=/\/+/g;function Q$1(e,o){return typeof e=="object"&&e!==null&&e.key!=null?escape(""+e.key):o.toString(36)}function R$1(e,o,i,s,h){var a=typeof e;(a==="undefined"||a==="boolean")&&(e=null);var d=!1;if(e===null)d=!0;else switch(a){case"string":case"number":d=!0;break;case"object":switch(e.$$typeof){case l$1:case n$1:d=!0}}if(d)return d=e,h=h(d),e=s===""?"."+Q$1(d,0):s,I$1(h)?(i="",e!=null&&(i=e.replace(P$1,"$&/")+"/"),R$1(h,o,i,"",function(c){return c})):h!=null&&(O$2(h)&&(h=N$1(h,i+(!h.key||d&&d.key===h.key?"":(""+h.key).replace(P$1,"$&/")+"/")+e)),o.push(h)),1;if(d=0,s=s===""?".":s+":",I$1(e))for(var et=0;et<e.length;et++){a=e[et];var $=s+Q$1(a,et);d+=R$1(a,o,i,$,h)}else if($=A$1(e),typeof $=="function")for(e=$.call(e),et=0;!(a=e.next()).done;)a=a.value,$=s+Q$1(a,et++),d+=R$1(a,o,i,$,h);else if(a==="object")throw o=String(e),Error("Objects are not valid as a React child (found: "+(o==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":o)+"). If you meant to render a collection of children, use an array instead.");return d}function S$1(e,o,i){if(e==null)return e;var s=[],h=0;return R$1(e,s,"","",function(a){return o.call(i,a,h++)}),s}function T$2(e){if(e._status===-1){var o=e._result;o=o(),o.then(function(i){(e._status===0||e._status===-1)&&(e._status=1,e._result=i)},function(i){(e._status===0||e._status===-1)&&(e._status=2,e._result=i)}),e._status===-1&&(e._status=0,e._result=o)}if(e._status===1)return e._result.default;throw e._result}var U$1={current:null},V$1={transition:null},W$2={ReactCurrentDispatcher:U$1,ReactCurrentBatchConfig:V$1,ReactCurrentOwner:K$1};function X$1(){throw Error("act(...) is not supported in production builds of React.")}react_production_min.Children={map:S$1,forEach:function(e,o,i){S$1(e,function(){o.apply(this,arguments)},i)},count:function(e){var o=0;return S$1(e,function(){o++}),o},toArray:function(e){return S$1(e,function(o){return o})||[]},only:function(e){if(!O$2(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};react_production_min.Component=E$1;react_production_min.Fragment=p$2;react_production_min.Profiler=r;react_production_min.PureComponent=G$2;react_production_min.StrictMode=q$2;react_production_min.Suspense=w;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$2;react_production_min.act=X$1;react_production_min.cloneElement=function(e,o,i){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var s=C$1({},e.props),h=e.key,a=e.ref,d=e._owner;if(o!=null){if(o.ref!==void 0&&(a=o.ref,d=K$1.current),o.key!==void 0&&(h=""+o.key),e.type&&e.type.defaultProps)var et=e.type.defaultProps;for($ in o)J$1.call(o,$)&&!L$1.hasOwnProperty($)&&(s[$]=o[$]===void 0&&et!==void 0?et[$]:o[$])}var $=arguments.length-2;if($===1)s.children=i;else if(1<$){et=Array($);for(var c=0;c<$;c++)et[c]=arguments[c+2];s.children=et}return{$$typeof:l$1,type:e.type,key:h,ref:a,props:s,_owner:d}};react_production_min.createContext=function(e){return e={$$typeof:u,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:t,_context:e},e.Consumer=e};react_production_min.createElement=M$1;react_production_min.createFactory=function(e){var o=M$1.bind(null,e);return o.type=e,o};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(e){return{$$typeof:v$1,render:e}};react_production_min.isValidElement=O$2;react_production_min.lazy=function(e){return{$$typeof:y,_payload:{_status:-1,_result:e},_init:T$2}};react_production_min.memo=function(e,o){return{$$typeof:x,type:e,compare:o===void 0?null:o}};react_production_min.startTransition=function(e){var o=V$1.transition;V$1.transition={};try{e()}finally{V$1.transition=o}};react_production_min.unstable_act=X$1;react_production_min.useCallback=function(e,o){return U$1.current.useCallback(e,o)};react_production_min.useContext=function(e){return U$1.current.useContext(e)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(e){return U$1.current.useDeferredValue(e)};react_production_min.useEffect=function(e,o){return U$1.current.useEffect(e,o)};react_production_min.useId=function(){return U$1.current.useId()};react_production_min.useImperativeHandle=function(e,o,i){return U$1.current.useImperativeHandle(e,o,i)};react_production_min.useInsertionEffect=function(e,o){return U$1.current.useInsertionEffect(e,o)};react_production_min.useLayoutEffect=function(e,o){return U$1.current.useLayoutEffect(e,o)};react_production_min.useMemo=function(e,o){return U$1.current.useMemo(e,o)};react_production_min.useReducer=function(e,o,i){return U$1.current.useReducer(e,o,i)};react_production_min.useRef=function(e){return U$1.current.useRef(e)};react_production_min.useState=function(e){return U$1.current.useState(e)};react_production_min.useSyncExternalStore=function(e,o,i){return U$1.current.useSyncExternalStore(e,o,i)};react_production_min.useTransition=function(){return U$1.current.useTransition()};react_production_min.version="18.3.1";react.exports=react_production_min;var reactExports=react.exports;const React=getDefaultExportFromCjs(reactExports);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f=reactExports,k$1=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m$1=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$1={key:!0,ref:!0,__self:!0,__source:!0};function q$1(e,o,i){var s,h={},a=null,d=null;i!==void 0&&(a=""+i),o.key!==void 0&&(a=""+o.key),o.ref!==void 0&&(d=o.ref);for(s in o)m$1.call(o,s)&&!p$1.hasOwnProperty(s)&&(h[s]=o[s]);if(e&&e.defaultProps)for(s in o=e.defaultProps,o)h[s]===void 0&&(h[s]=o[s]);return{$$typeof:k$1,type:e,key:a,ref:d,props:h,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q$1;reactJsxRuntime_production_min.jsxs=q$1;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,reactDom={exports:{}},reactDom_production_min={},scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function o(tn,To){var Qo=tn.length;tn.push(To);e:for(;0<Qo;){var Jr=Qo-1>>>1,Lo=tn[Jr];if(0<h(Lo,To))tn[Jr]=To,tn[Qo]=Lo,Qo=Jr;else break e}}function i(tn){return tn.length===0?null:tn[0]}function s(tn){if(tn.length===0)return null;var To=tn[0],Qo=tn.pop();if(Qo!==To){tn[0]=Qo;e:for(var Jr=0,Lo=tn.length,Du=Lo>>>1;Jr<Du;){var _u=2*(Jr+1)-1,du=tn[_u],wu=_u+1,r_=tn[wu];if(0>h(du,Qo))wu<Lo&&0>h(r_,du)?(tn[Jr]=r_,tn[wu]=Qo,Jr=wu):(tn[Jr]=du,tn[_u]=Qo,Jr=_u);else if(wu<Lo&&0>h(r_,Qo))tn[Jr]=r_,tn[wu]=Qo,Jr=wu;else break e}}return To}function h(tn,To){var Qo=tn.sortIndex-To.sortIndex;return Qo!==0?Qo:tn.id-To.id}if(typeof performance=="object"&&typeof performance.now=="function"){var a=performance;e.unstable_now=function(){return a.now()}}else{var d=Date,et=d.now();e.unstable_now=function(){return d.now()-et}}var $=[],c=[],b=1,g=null,nt=3,at=!1,Ot=!1,At=!1,Ct=typeof setTimeout=="function"?setTimeout:null,St=typeof clearTimeout=="function"?clearTimeout:null,xt=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function Dt(tn){for(var To=i(c);To!==null;){if(To.callback===null)s(c);else if(To.startTime<=tn)s(c),To.sortIndex=To.expirationTime,o($,To);else break;To=i(c)}}function Qt(tn){if(At=!1,Dt(tn),!Ot)if(i($)!==null)Ot=!0,Bu(Zt);else{var To=i(c);To!==null&&Ho(Qt,To.startTime-tn)}}function Zt(tn,To){Ot=!1,At&&(At=!1,St(Er),Er=-1),at=!0;var Qo=nt;try{for(Dt(To),g=i($);g!==null&&(!(g.expirationTime>To)||tn&&!Js());){var Jr=g.callback;if(typeof Jr=="function"){g.callback=null,nt=g.priorityLevel;var Lo=Jr(g.expirationTime<=To);To=e.unstable_now(),typeof Lo=="function"?g.callback=Lo:g===i($)&&s($),Dt(To)}else s($);g=i($)}if(g!==null)var Du=!0;else{var _u=i(c);_u!==null&&Ho(Qt,_u.startTime-To),Du=!1}return Du}finally{g=null,nt=Qo,at=!1}}var gr=!1,vr=null,Er=-1,wo=5,Do=-1;function Js(){return!(e.unstable_now()-Do<wo)}function In(){if(vr!==null){var tn=e.unstable_now();Do=tn;var To=!0;try{To=vr(!0,tn)}finally{To?Wo():(gr=!1,vr=null)}}else gr=!1}var Wo;if(typeof xt=="function")Wo=function(){xt(In)};else if(typeof MessageChannel<"u"){var Ir=new MessageChannel,Yo=Ir.port2;Ir.port1.onmessage=In,Wo=function(){Yo.postMessage(null)}}else Wo=function(){Ct(In,0)};function Bu(tn){vr=tn,gr||(gr=!0,Wo())}function Ho(tn,To){Er=Ct(function(){tn(e.unstable_now())},To)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(tn){tn.callback=null},e.unstable_continueExecution=function(){Ot||at||(Ot=!0,Bu(Zt))},e.unstable_forceFrameRate=function(tn){0>tn||125<tn?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):wo=0<tn?Math.floor(1e3/tn):5},e.unstable_getCurrentPriorityLevel=function(){return nt},e.unstable_getFirstCallbackNode=function(){return i($)},e.unstable_next=function(tn){switch(nt){case 1:case 2:case 3:var To=3;break;default:To=nt}var Qo=nt;nt=To;try{return tn()}finally{nt=Qo}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(tn,To){switch(tn){case 1:case 2:case 3:case 4:case 5:break;default:tn=3}var Qo=nt;nt=tn;try{return To()}finally{nt=Qo}},e.unstable_scheduleCallback=function(tn,To,Qo){var Jr=e.unstable_now();switch(typeof Qo=="object"&&Qo!==null?(Qo=Qo.delay,Qo=typeof Qo=="number"&&0<Qo?Jr+Qo:Jr):Qo=Jr,tn){case 1:var Lo=-1;break;case 2:Lo=250;break;case 5:Lo=1073741823;break;case 4:Lo=1e4;break;default:Lo=5e3}return Lo=Qo+Lo,tn={id:b++,callback:To,priorityLevel:tn,startTime:Qo,expirationTime:Lo,sortIndex:-1},Qo>Jr?(tn.sortIndex=Qo,o(c,tn),i($)===null&&tn===i(c)&&(At?(St(Er),Er=-1):At=!0,Ho(Qt,Qo-Jr))):(tn.sortIndex=Lo,o($,tn),Ot||at||(Ot=!0,Bu(Zt))),tn},e.unstable_shouldYield=Js,e.unstable_wrapCallback=function(tn){var To=nt;return function(){var Qo=nt;nt=To;try{return tn.apply(this,arguments)}finally{nt=Qo}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa=reactExports,ca=schedulerExports;function p(e){for(var o="https://reactjs.org/docs/error-decoder.html?invariant="+e,i=1;i<arguments.length;i++)o+="&args[]="+encodeURIComponent(arguments[i]);return"Minified React error #"+e+"; visit "+o+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(e,o){ha(e,o),ha(e+"Capture",o)}function ha(e,o){for(ea[e]=o,e=0;e<o.length;e++)da.add(o[e])}var ia=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la={},ma={};function oa(e){return ja.call(ma,e)?!0:ja.call(la,e)?!1:ka.test(e)?ma[e]=!0:(la[e]=!0,!1)}function pa(e,o,i,s){if(i!==null&&i.type===0)return!1;switch(typeof o){case"function":case"symbol":return!0;case"boolean":return s?!1:i!==null?!i.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function qa(e,o,i,s){if(o===null||typeof o>"u"||pa(e,o,i,s))return!0;if(s)return!1;if(i!==null)switch(i.type){case 3:return!o;case 4:return o===!1;case 5:return isNaN(o);case 6:return isNaN(o)||1>o}return!1}function v(e,o,i,s,h,a,d){this.acceptsBooleans=o===2||o===3||o===4,this.attributeName=s,this.attributeNamespace=h,this.mustUseProperty=i,this.propertyName=e,this.type=o,this.sanitizeURL=a,this.removeEmptyString=d}var z$1={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){z$1[e]=new v(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var o=e[0];z$1[o]=new v(o,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){z$1[e]=new v(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){z$1[e]=new v(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){z$1[e]=new v(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){z$1[e]=new v(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){z$1[e]=new v(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){z$1[e]=new v(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){z$1[e]=new v(e,5,!1,e.toLowerCase(),null,!1,!1)});var ra=/[\-:]([a-z])/g;function sa(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var o=e.replace(ra,sa);z$1[o]=new v(o,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var o=e.replace(ra,sa);z$1[o]=new v(o,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var o=e.replace(ra,sa);z$1[o]=new v(o,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){z$1[e]=new v(e,1,!1,e.toLowerCase(),null,!1,!1)});z$1.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){z$1[e]=new v(e,1,!1,e.toLowerCase(),null,!0,!0)});function ta(e,o,i,s){var h=z$1.hasOwnProperty(o)?z$1[o]:null;(h!==null?h.type!==0:s||!(2<o.length)||o[0]!=="o"&&o[0]!=="O"||o[1]!=="n"&&o[1]!=="N")&&(qa(o,i,h,s)&&(i=null),s||h===null?oa(o)&&(i===null?e.removeAttribute(o):e.setAttribute(o,""+i)):h.mustUseProperty?e[h.propertyName]=i===null?h.type===3?!1:"":i:(o=h.attributeName,s=h.attributeNamespace,i===null?e.removeAttribute(o):(h=h.type,i=h===3||h===4&&i===!0?"":""+i,s?e.setAttributeNS(s,o,i):e.setAttribute(o,i))))}var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy"),Ia=Symbol.for("react.offscreen"),Ja=Symbol.iterator;function Ka(e){return e===null||typeof e!="object"?null:(e=Ja&&e[Ja]||e["@@iterator"],typeof e=="function"?e:null)}var A=Object.assign,La;function Ma(e){if(La===void 0)try{throw Error()}catch(i){var o=i.stack.trim().match(/\n( *(at )?)/);La=o&&o[1]||""}return`
`+La+e}var Na=!1;function Oa(e,o){if(!e||Na)return"";Na=!0;var i=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(o)if(o=function(){throw Error()},Object.defineProperty(o.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(o,[])}catch(c){var s=c}Reflect.construct(e,[],o)}else{try{o.call()}catch(c){s=c}e.call(o.prototype)}else{try{throw Error()}catch(c){s=c}e()}}catch(c){if(c&&s&&typeof c.stack=="string"){for(var h=c.stack.split(`
`),a=s.stack.split(`
`),d=h.length-1,et=a.length-1;1<=d&&0<=et&&h[d]!==a[et];)et--;for(;1<=d&&0<=et;d--,et--)if(h[d]!==a[et]){if(d!==1||et!==1)do if(d--,et--,0>et||h[d]!==a[et]){var $=`
`+h[d].replace(" at new "," at ");return e.displayName&&$.includes("<anonymous>")&&($=$.replace("<anonymous>",e.displayName)),$}while(1<=d&&0<=et);break}}}finally{Na=!1,Error.prepareStackTrace=i}return(e=e?e.displayName||e.name:"")?Ma(e):""}function Pa(e){switch(e.tag){case 5:return Ma(e.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return e=Oa(e.type,!1),e;case 11:return e=Oa(e.type.render,!1),e;case 1:return e=Oa(e.type,!0),e;default:return""}}function Qa$1(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case Ca:return(e.displayName||"Context")+".Consumer";case Ba:return(e._context.displayName||"Context")+".Provider";case Da:var o=e.render;return e=e.displayName,e||(e=o.displayName||o.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case Ga:return o=e.displayName||null,o!==null?o:Qa$1(e.type)||"Memo";case Ha:o=e._payload,e=e._init;try{return Qa$1(e(o))}catch{}}return null}function Ra(e){var o=e.type;switch(e.tag){case 24:return"Cache";case 9:return(o.displayName||"Context")+".Consumer";case 10:return(o._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=o.render,e=e.displayName||e.name||"",o.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return o;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa$1(o);case 8:return o===za?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof o=="function")return o.displayName||o.name||null;if(typeof o=="string")return o}return null}function Sa(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function Ta(e){var o=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(o==="checkbox"||o==="radio")}function Ua(e){var o=Ta(e)?"checked":"value",i=Object.getOwnPropertyDescriptor(e.constructor.prototype,o),s=""+e[o];if(!e.hasOwnProperty(o)&&typeof i<"u"&&typeof i.get=="function"&&typeof i.set=="function"){var h=i.get,a=i.set;return Object.defineProperty(e,o,{configurable:!0,get:function(){return h.call(this)},set:function(d){s=""+d,a.call(this,d)}}),Object.defineProperty(e,o,{enumerable:i.enumerable}),{getValue:function(){return s},setValue:function(d){s=""+d},stopTracking:function(){e._valueTracker=null,delete e[o]}}}}function Va(e){e._valueTracker||(e._valueTracker=Ua(e))}function Wa(e){if(!e)return!1;var o=e._valueTracker;if(!o)return!0;var i=o.getValue(),s="";return e&&(s=Ta(e)?e.checked?"true":"false":e.value),e=s,e!==i?(o.setValue(e),!0):!1}function Xa(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function Ya(e,o){var i=o.checked;return A({},o,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:i??e._wrapperState.initialChecked})}function Za$1(e,o){var i=o.defaultValue==null?"":o.defaultValue,s=o.checked!=null?o.checked:o.defaultChecked;i=Sa(o.value!=null?o.value:i),e._wrapperState={initialChecked:s,initialValue:i,controlled:o.type==="checkbox"||o.type==="radio"?o.checked!=null:o.value!=null}}function ab$1(e,o){o=o.checked,o!=null&&ta(e,"checked",o,!1)}function bb$1(e,o){ab$1(e,o);var i=Sa(o.value),s=o.type;if(i!=null)s==="number"?(i===0&&e.value===""||e.value!=i)&&(e.value=""+i):e.value!==""+i&&(e.value=""+i);else if(s==="submit"||s==="reset"){e.removeAttribute("value");return}o.hasOwnProperty("value")?cb$1(e,o.type,i):o.hasOwnProperty("defaultValue")&&cb$1(e,o.type,Sa(o.defaultValue)),o.checked==null&&o.defaultChecked!=null&&(e.defaultChecked=!!o.defaultChecked)}function db$2(e,o,i){if(o.hasOwnProperty("value")||o.hasOwnProperty("defaultValue")){var s=o.type;if(!(s!=="submit"&&s!=="reset"||o.value!==void 0&&o.value!==null))return;o=""+e._wrapperState.initialValue,i||o===e.value||(e.value=o),e.defaultValue=o}i=e.name,i!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,i!==""&&(e.name=i)}function cb$1(e,o,i){(o!=="number"||Xa(e.ownerDocument)!==e)&&(i==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+i&&(e.defaultValue=""+i))}var eb$1=Array.isArray;function fb$1(e,o,i,s){if(e=e.options,o){o={};for(var h=0;h<i.length;h++)o["$"+i[h]]=!0;for(i=0;i<e.length;i++)h=o.hasOwnProperty("$"+e[i].value),e[i].selected!==h&&(e[i].selected=h),h&&s&&(e[i].defaultSelected=!0)}else{for(i=""+Sa(i),o=null,h=0;h<e.length;h++){if(e[h].value===i){e[h].selected=!0,s&&(e[h].defaultSelected=!0);return}o!==null||e[h].disabled||(o=e[h])}o!==null&&(o.selected=!0)}}function gb$1(e,o){if(o.dangerouslySetInnerHTML!=null)throw Error(p(91));return A({},o,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function hb$1(e,o){var i=o.value;if(i==null){if(i=o.children,o=o.defaultValue,i!=null){if(o!=null)throw Error(p(92));if(eb$1(i)){if(1<i.length)throw Error(p(93));i=i[0]}o=i}o==null&&(o=""),i=o}e._wrapperState={initialValue:Sa(i)}}function ib$1(e,o){var i=Sa(o.value),s=Sa(o.defaultValue);i!=null&&(i=""+i,i!==e.value&&(e.value=i),o.defaultValue==null&&e.defaultValue!==i&&(e.defaultValue=i)),s!=null&&(e.defaultValue=""+s)}function jb$1(e){var o=e.textContent;o===e._wrapperState.initialValue&&o!==""&&o!==null&&(e.value=o)}function kb$1(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb$1(e,o){return e==null||e==="http://www.w3.org/1999/xhtml"?kb$1(o):e==="http://www.w3.org/2000/svg"&&o==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var mb$1,nb$1=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(o,i,s,h){MSApp.execUnsafeLocalFunction(function(){return e(o,i,s,h)})}:e}(function(e,o){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=o;else{for(mb$1=mb$1||document.createElement("div"),mb$1.innerHTML="<svg>"+o.valueOf().toString()+"</svg>",o=mb$1.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;o.firstChild;)e.appendChild(o.firstChild)}});function ob$1(e,o){if(o){var i=e.firstChild;if(i&&i===e.lastChild&&i.nodeType===3){i.nodeValue=o;return}}e.textContent=o}var pb$1={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb$1=["Webkit","ms","Moz","O"];Object.keys(pb$1).forEach(function(e){qb$1.forEach(function(o){o=o+e.charAt(0).toUpperCase()+e.substring(1),pb$1[o]=pb$1[e]})});function rb$1(e,o,i){return o==null||typeof o=="boolean"||o===""?"":i||typeof o!="number"||o===0||pb$1.hasOwnProperty(e)&&pb$1[e]?(""+o).trim():o+"px"}function sb$1(e,o){e=e.style;for(var i in o)if(o.hasOwnProperty(i)){var s=i.indexOf("--")===0,h=rb$1(i,o[i],s);i==="float"&&(i="cssFloat"),s?e.setProperty(i,h):e[i]=h}}var tb$1=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub$1(e,o){if(o){if(tb$1[e]&&(o.children!=null||o.dangerouslySetInnerHTML!=null))throw Error(p(137,e));if(o.dangerouslySetInnerHTML!=null){if(o.children!=null)throw Error(p(60));if(typeof o.dangerouslySetInnerHTML!="object"||!("__html"in o.dangerouslySetInnerHTML))throw Error(p(61))}if(o.style!=null&&typeof o.style!="object")throw Error(p(62))}}function vb$1(e,o){if(e.indexOf("-")===-1)return typeof o.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb$1=null;function xb$1(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var yb$1=null,zb$1=null,Ab$1=null;function Bb$1(e){if(e=Cb$1(e)){if(typeof yb$1!="function")throw Error(p(280));var o=e.stateNode;o&&(o=Db$1(o),yb$1(e.stateNode,e.type,o))}}function Eb$1(e){zb$1?Ab$1?Ab$1.push(e):Ab$1=[e]:zb$1=e}function Fb$1(){if(zb$1){var e=zb$1,o=Ab$1;if(Ab$1=zb$1=null,Bb$1(e),o)for(e=0;e<o.length;e++)Bb$1(o[e])}}function Gb$1(e,o){return e(o)}function Hb$1(){}var Ib$1=!1;function Jb$1(e,o,i){if(Ib$1)return e(o,i);Ib$1=!0;try{return Gb$1(e,o,i)}finally{Ib$1=!1,(zb$1!==null||Ab$1!==null)&&(Hb$1(),Fb$1())}}function Kb$1(e,o){var i=e.stateNode;if(i===null)return null;var s=Db$1(i);if(s===null)return null;i=s[o];e:switch(o){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(s=!s.disabled)||(e=e.type,s=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!s;break e;default:e=!1}if(e)return null;if(i&&typeof i!="function")throw Error(p(231,o,typeof i));return i}var Lb$1=!1;if(ia)try{var Mb$1={};Object.defineProperty(Mb$1,"passive",{get:function(){Lb$1=!0}}),window.addEventListener("test",Mb$1,Mb$1),window.removeEventListener("test",Mb$1,Mb$1)}catch{Lb$1=!1}function Nb$1(e,o,i,s,h,a,d,et,$){var c=Array.prototype.slice.call(arguments,3);try{o.apply(i,c)}catch(b){this.onError(b)}}var Ob$1=!1,Pb$1=null,Qb$1=!1,Rb$1=null,Sb$1={onError:function(e){Ob$1=!0,Pb$1=e}};function Tb$1(e,o,i,s,h,a,d,et,$){Ob$1=!1,Pb$1=null,Nb$1.apply(Sb$1,arguments)}function Ub$1(e,o,i,s,h,a,d,et,$){if(Tb$1.apply(this,arguments),Ob$1){if(Ob$1){var c=Pb$1;Ob$1=!1,Pb$1=null}else throw Error(p(198));Qb$1||(Qb$1=!0,Rb$1=c)}}function Vb$1(e){var o=e,i=e;if(e.alternate)for(;o.return;)o=o.return;else{e=o;do o=e,o.flags&4098&&(i=o.return),e=o.return;while(e)}return o.tag===3?i:null}function Wb$1(e){if(e.tag===13){var o=e.memoizedState;if(o===null&&(e=e.alternate,e!==null&&(o=e.memoizedState)),o!==null)return o.dehydrated}return null}function Xb$1(e){if(Vb$1(e)!==e)throw Error(p(188))}function Yb$1(e){var o=e.alternate;if(!o){if(o=Vb$1(e),o===null)throw Error(p(188));return o!==e?null:e}for(var i=e,s=o;;){var h=i.return;if(h===null)break;var a=h.alternate;if(a===null){if(s=h.return,s!==null){i=s;continue}break}if(h.child===a.child){for(a=h.child;a;){if(a===i)return Xb$1(h),e;if(a===s)return Xb$1(h),o;a=a.sibling}throw Error(p(188))}if(i.return!==s.return)i=h,s=a;else{for(var d=!1,et=h.child;et;){if(et===i){d=!0,i=h,s=a;break}if(et===s){d=!0,s=h,i=a;break}et=et.sibling}if(!d){for(et=a.child;et;){if(et===i){d=!0,i=a,s=h;break}if(et===s){d=!0,s=a,i=h;break}et=et.sibling}if(!d)throw Error(p(189))}}if(i.alternate!==s)throw Error(p(190))}if(i.tag!==3)throw Error(p(188));return i.stateNode.current===i?e:o}function Zb$1(e){return e=Yb$1(e),e!==null?$b$1(e):null}function $b$1(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var o=$b$1(e);if(o!==null)return o;e=e.sibling}return null}var ac$1=ca.unstable_scheduleCallback,bc$1=ca.unstable_cancelCallback,cc$1=ca.unstable_shouldYield,dc$1=ca.unstable_requestPaint,B$1=ca.unstable_now,ec$1=ca.unstable_getCurrentPriorityLevel,fc$1=ca.unstable_ImmediatePriority,gc$1=ca.unstable_UserBlockingPriority,hc$1=ca.unstable_NormalPriority,ic$1=ca.unstable_LowPriority,jc$1=ca.unstable_IdlePriority,kc$1=null,lc$1=null;function mc$1(e){if(lc$1&&typeof lc$1.onCommitFiberRoot=="function")try{lc$1.onCommitFiberRoot(kc$1,e,void 0,(e.current.flags&128)===128)}catch{}}var oc$1=Math.clz32?Math.clz32:nc$1,pc$1=Math.log,qc$1=Math.LN2;function nc$1(e){return e>>>=0,e===0?32:31-(pc$1(e)/qc$1|0)|0}var rc$1=64,sc$1=4194304;function tc$1(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function uc$1(e,o){var i=e.pendingLanes;if(i===0)return 0;var s=0,h=e.suspendedLanes,a=e.pingedLanes,d=i&268435455;if(d!==0){var et=d&~h;et!==0?s=tc$1(et):(a&=d,a!==0&&(s=tc$1(a)))}else d=i&~h,d!==0?s=tc$1(d):a!==0&&(s=tc$1(a));if(s===0)return 0;if(o!==0&&o!==s&&!(o&h)&&(h=s&-s,a=o&-o,h>=a||h===16&&(a&4194240)!==0))return o;if(s&4&&(s|=i&16),o=e.entangledLanes,o!==0)for(e=e.entanglements,o&=s;0<o;)i=31-oc$1(o),h=1<<i,s|=e[i],o&=~h;return s}function vc$1(e,o){switch(e){case 1:case 2:case 4:return o+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return o+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc$1(e,o){for(var i=e.suspendedLanes,s=e.pingedLanes,h=e.expirationTimes,a=e.pendingLanes;0<a;){var d=31-oc$1(a),et=1<<d,$=h[d];$===-1?(!(et&i)||et&s)&&(h[d]=vc$1(et,o)):$<=o&&(e.expiredLanes|=et),a&=~et}}function xc$1(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function yc$1(){var e=rc$1;return rc$1<<=1,!(rc$1&4194240)&&(rc$1=64),e}function zc$1(e){for(var o=[],i=0;31>i;i++)o.push(e);return o}function Ac$1(e,o,i){e.pendingLanes|=o,o!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,o=31-oc$1(o),e[o]=i}function Bc$1(e,o){var i=e.pendingLanes&~o;e.pendingLanes=o,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=o,e.mutableReadLanes&=o,e.entangledLanes&=o,o=e.entanglements;var s=e.eventTimes;for(e=e.expirationTimes;0<i;){var h=31-oc$1(i),a=1<<h;o[h]=0,s[h]=-1,e[h]=-1,i&=~a}}function Cc$1(e,o){var i=e.entangledLanes|=o;for(e=e.entanglements;i;){var s=31-oc$1(i),h=1<<s;h&o|e[s]&o&&(e[s]|=o),i&=~h}}var C=0;function Dc$1(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var Ec$1,Fc$1,Gc$1,Hc$1,Ic$1,Jc$1=!1,Kc$1=[],Lc$1=null,Mc$1=null,Nc$1=null,Oc$1=new Map,Pc$1=new Map,Qc$1=[],Rc$1="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc$1(e,o){switch(e){case"focusin":case"focusout":Lc$1=null;break;case"dragenter":case"dragleave":Mc$1=null;break;case"mouseover":case"mouseout":Nc$1=null;break;case"pointerover":case"pointerout":Oc$1.delete(o.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc$1.delete(o.pointerId)}}function Tc$1(e,o,i,s,h,a){return e===null||e.nativeEvent!==a?(e={blockedOn:o,domEventName:i,eventSystemFlags:s,nativeEvent:a,targetContainers:[h]},o!==null&&(o=Cb$1(o),o!==null&&Fc$1(o)),e):(e.eventSystemFlags|=s,o=e.targetContainers,h!==null&&o.indexOf(h)===-1&&o.push(h),e)}function Uc$1(e,o,i,s,h){switch(o){case"focusin":return Lc$1=Tc$1(Lc$1,e,o,i,s,h),!0;case"dragenter":return Mc$1=Tc$1(Mc$1,e,o,i,s,h),!0;case"mouseover":return Nc$1=Tc$1(Nc$1,e,o,i,s,h),!0;case"pointerover":var a=h.pointerId;return Oc$1.set(a,Tc$1(Oc$1.get(a)||null,e,o,i,s,h)),!0;case"gotpointercapture":return a=h.pointerId,Pc$1.set(a,Tc$1(Pc$1.get(a)||null,e,o,i,s,h)),!0}return!1}function Vc$1(e){var o=Wc$1(e.target);if(o!==null){var i=Vb$1(o);if(i!==null){if(o=i.tag,o===13){if(o=Wb$1(i),o!==null){e.blockedOn=o,Ic$1(e.priority,function(){Gc$1(i)});return}}else if(o===3&&i.stateNode.current.memoizedState.isDehydrated){e.blockedOn=i.tag===3?i.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Xc$1(e){if(e.blockedOn!==null)return!1;for(var o=e.targetContainers;0<o.length;){var i=Yc$1(e.domEventName,e.eventSystemFlags,o[0],e.nativeEvent);if(i===null){i=e.nativeEvent;var s=new i.constructor(i.type,i);wb$1=s,i.target.dispatchEvent(s),wb$1=null}else return o=Cb$1(i),o!==null&&Fc$1(o),e.blockedOn=i,!1;o.shift()}return!0}function Zc$1(e,o,i){Xc$1(e)&&i.delete(o)}function $c$1(){Jc$1=!1,Lc$1!==null&&Xc$1(Lc$1)&&(Lc$1=null),Mc$1!==null&&Xc$1(Mc$1)&&(Mc$1=null),Nc$1!==null&&Xc$1(Nc$1)&&(Nc$1=null),Oc$1.forEach(Zc$1),Pc$1.forEach(Zc$1)}function ad$1(e,o){e.blockedOn===o&&(e.blockedOn=null,Jc$1||(Jc$1=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c$1)))}function bd(e){function o(h){return ad$1(h,e)}if(0<Kc$1.length){ad$1(Kc$1[0],e);for(var i=1;i<Kc$1.length;i++){var s=Kc$1[i];s.blockedOn===e&&(s.blockedOn=null)}}for(Lc$1!==null&&ad$1(Lc$1,e),Mc$1!==null&&ad$1(Mc$1,e),Nc$1!==null&&ad$1(Nc$1,e),Oc$1.forEach(o),Pc$1.forEach(o),i=0;i<Qc$1.length;i++)s=Qc$1[i],s.blockedOn===e&&(s.blockedOn=null);for(;0<Qc$1.length&&(i=Qc$1[0],i.blockedOn===null);)Vc$1(i),i.blockedOn===null&&Qc$1.shift()}var cd$1=ua.ReactCurrentBatchConfig,dd=!0;function ed$1(e,o,i,s){var h=C,a=cd$1.transition;cd$1.transition=null;try{C=1,fd$1(e,o,i,s)}finally{C=h,cd$1.transition=a}}function gd(e,o,i,s){var h=C,a=cd$1.transition;cd$1.transition=null;try{C=4,fd$1(e,o,i,s)}finally{C=h,cd$1.transition=a}}function fd$1(e,o,i,s){if(dd){var h=Yc$1(e,o,i,s);if(h===null)hd(e,o,s,id$1,i),Sc$1(e,s);else if(Uc$1(h,e,o,i,s))s.stopPropagation();else if(Sc$1(e,s),o&4&&-1<Rc$1.indexOf(e)){for(;h!==null;){var a=Cb$1(h);if(a!==null&&Ec$1(a),a=Yc$1(e,o,i,s),a===null&&hd(e,o,s,id$1,i),a===h)break;h=a}h!==null&&s.stopPropagation()}else hd(e,o,s,null,i)}}var id$1=null;function Yc$1(e,o,i,s){if(id$1=null,e=xb$1(s),e=Wc$1(e),e!==null)if(o=Vb$1(e),o===null)e=null;else if(i=o.tag,i===13){if(e=Wb$1(o),e!==null)return e;e=null}else if(i===3){if(o.stateNode.current.memoizedState.isDehydrated)return o.tag===3?o.stateNode.containerInfo:null;e=null}else o!==e&&(e=null);return id$1=e,null}function jd$1(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec$1()){case fc$1:return 1;case gc$1:return 4;case hc$1:case ic$1:return 16;case jc$1:return 536870912;default:return 16}default:return 16}}var kd=null,ld$1=null,md=null;function nd$1(){if(md)return md;var e,o=ld$1,i=o.length,s,h="value"in kd?kd.value:kd.textContent,a=h.length;for(e=0;e<i&&o[e]===h[e];e++);var d=i-e;for(s=1;s<=d&&o[i-s]===h[a-s];s++);return md=h.slice(e,1<s?1-s:void 0)}function od$1(e){var o=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&o===13&&(e=13)):e=o,e===10&&(e=13),32<=e||e===13?e:0}function pd(){return!0}function qd$1(){return!1}function rd$1(e){function o(i,s,h,a,d){this._reactName=i,this._targetInst=h,this.type=s,this.nativeEvent=a,this.target=d,this.currentTarget=null;for(var et in e)e.hasOwnProperty(et)&&(i=e[et],this[et]=i?i(a):a[et]);return this.isDefaultPrevented=(a.defaultPrevented!=null?a.defaultPrevented:a.returnValue===!1)?pd:qd$1,this.isPropagationStopped=qd$1,this}return A(o.prototype,{preventDefault:function(){this.defaultPrevented=!0;var i=this.nativeEvent;i&&(i.preventDefault?i.preventDefault():typeof i.returnValue!="unknown"&&(i.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var i=this.nativeEvent;i&&(i.stopPropagation?i.stopPropagation():typeof i.cancelBubble!="unknown"&&(i.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd}),o}var sd$1={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td$1=rd$1(sd$1),ud$1=A({},sd$1,{view:0,detail:0}),vd=rd$1(ud$1),wd,xd,yd,Ad=A({},ud$1,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd$1,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==yd&&(yd&&e.type==="mousemove"?(wd=e.screenX-yd.screenX,xd=e.screenY-yd.screenY):xd=wd=0,yd=e),wd)},movementY:function(e){return"movementY"in e?e.movementY:xd}}),Bd=rd$1(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd$1(Cd),Ed=A({},ud$1,{relatedTarget:0}),Fd=rd$1(Ed),Gd=A({},sd$1,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd$1=rd$1(Gd),Id=A({},sd$1,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Jd$1=rd$1(Id),Kd$1=A({},sd$1,{data:0}),Ld=rd$1(Kd$1),Md={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(e){var o=this.nativeEvent;return o.getModifierState?o.getModifierState(e):(e=Od[e])?!!o[e]:!1}function zd$1(){return Pd}var Qd$1=A({},ud$1,{key:function(e){if(e.key){var o=Md[e.key]||e.key;if(o!=="Unidentified")return o}return e.type==="keypress"?(e=od$1(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?Nd[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd$1,charCode:function(e){return e.type==="keypress"?od$1(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?od$1(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),Rd=rd$1(Qd$1),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd$1(Sd),Ud=A({},ud$1,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd$1}),Vd=rd$1(Ud),Wd$1=A({},sd$1,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd$1=rd$1(Wd$1),Yd$1=A({},Ad,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd$1=rd$1(Yd$1),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be$1=null;ia&&"documentMode"in document&&(be$1=document.documentMode);var ce$1=ia&&"TextEvent"in window&&!be$1,de=ia&&(!ae||be$1&&8<be$1&&11>=be$1),ee$1=" ",fe$1=!1;function ge(e,o){switch(e){case"keyup":return $d.indexOf(o.keyCode)!==-1;case"keydown":return o.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he$1(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var ie=!1;function je$1(e,o){switch(e){case"compositionend":return he$1(o);case"keypress":return o.which!==32?null:(fe$1=!0,ee$1);case"textInput":return e=o.data,e===ee$1&&fe$1?null:e;default:return null}}function ke$1(e,o){if(ie)return e==="compositionend"||!ae&&ge(e,o)?(e=nd$1(),md=ld$1=kd=null,ie=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(o.ctrlKey||o.altKey||o.metaKey)||o.ctrlKey&&o.altKey){if(o.char&&1<o.char.length)return o.char;if(o.which)return String.fromCharCode(o.which)}return null;case"compositionend":return de&&o.locale!=="ko"?null:o.data;default:return null}}var le$1={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me$1(e){var o=e&&e.nodeName&&e.nodeName.toLowerCase();return o==="input"?!!le$1[e.type]:o==="textarea"}function ne(e,o,i,s){Eb$1(s),o=oe(o,"onChange"),0<o.length&&(i=new td$1("onChange","change",null,i,s),e.push({event:i,listeners:o}))}var pe=null,qe$1=null;function re(e){se(e,0)}function te(e){var o=ue$1(e);if(Wa(o))return e}function ve(e,o){if(e==="change")return o}var we=!1;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze$1=document.createElement("div");ze$1.setAttribute("oninput","return;"),ye=typeof ze$1.oninput=="function"}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae$1(){pe&&(pe.detachEvent("onpropertychange",Be$1),qe$1=pe=null)}function Be$1(e){if(e.propertyName==="value"&&te(qe$1)){var o=[];ne(o,qe$1,e,xb$1(e)),Jb$1(re,o)}}function Ce$1(e,o,i){e==="focusin"?(Ae$1(),pe=o,qe$1=i,pe.attachEvent("onpropertychange",Be$1)):e==="focusout"&&Ae$1()}function De(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return te(qe$1)}function Ee(e,o){if(e==="click")return te(o)}function Fe$1(e,o){if(e==="input"||e==="change")return te(o)}function Ge$1(e,o){return e===o&&(e!==0||1/e===1/o)||e!==e&&o!==o}var He$1=typeof Object.is=="function"?Object.is:Ge$1;function Ie$1(e,o){if(He$1(e,o))return!0;if(typeof e!="object"||e===null||typeof o!="object"||o===null)return!1;var i=Object.keys(e),s=Object.keys(o);if(i.length!==s.length)return!1;for(s=0;s<i.length;s++){var h=i[s];if(!ja.call(o,h)||!He$1(e[h],o[h]))return!1}return!0}function Je(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Ke$1(e,o){var i=Je(e);e=0;for(var s;i;){if(i.nodeType===3){if(s=e+i.textContent.length,e<=o&&s>=o)return{node:i,offset:o-e};e=s}e:{for(;i;){if(i.nextSibling){i=i.nextSibling;break e}i=i.parentNode}i=void 0}i=Je(i)}}function Le(e,o){return e&&o?e===o?!0:e&&e.nodeType===3?!1:o&&o.nodeType===3?Le(e,o.parentNode):"contains"in e?e.contains(o):e.compareDocumentPosition?!!(e.compareDocumentPosition(o)&16):!1:!1}function Me$1(){for(var e=window,o=Xa();o instanceof e.HTMLIFrameElement;){try{var i=typeof o.contentWindow.location.href=="string"}catch{i=!1}if(i)e=o.contentWindow;else break;o=Xa(e.document)}return o}function Ne(e){var o=e&&e.nodeName&&e.nodeName.toLowerCase();return o&&(o==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||o==="textarea"||e.contentEditable==="true")}function Oe$1(e){var o=Me$1(),i=e.focusedElem,s=e.selectionRange;if(o!==i&&i&&i.ownerDocument&&Le(i.ownerDocument.documentElement,i)){if(s!==null&&Ne(i)){if(o=s.start,e=s.end,e===void 0&&(e=o),"selectionStart"in i)i.selectionStart=o,i.selectionEnd=Math.min(e,i.value.length);else if(e=(o=i.ownerDocument||document)&&o.defaultView||window,e.getSelection){e=e.getSelection();var h=i.textContent.length,a=Math.min(s.start,h);s=s.end===void 0?a:Math.min(s.end,h),!e.extend&&a>s&&(h=s,s=a,a=h),h=Ke$1(i,a);var d=Ke$1(i,s);h&&d&&(e.rangeCount!==1||e.anchorNode!==h.node||e.anchorOffset!==h.offset||e.focusNode!==d.node||e.focusOffset!==d.offset)&&(o=o.createRange(),o.setStart(h.node,h.offset),e.removeAllRanges(),a>s?(e.addRange(o),e.extend(d.node,d.offset)):(o.setEnd(d.node,d.offset),e.addRange(o)))}}for(o=[],e=i;e=e.parentNode;)e.nodeType===1&&o.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof i.focus=="function"&&i.focus(),i=0;i<o.length;i++)e=o[i],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var Pe$1=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;function Ue$1(e,o,i){var s=i.window===i?i.document:i.nodeType===9?i:i.ownerDocument;Te||Qe==null||Qe!==Xa(s)||(s=Qe,"selectionStart"in s&&Ne(s)?s={start:s.selectionStart,end:s.selectionEnd}:(s=(s.ownerDocument&&s.ownerDocument.defaultView||window).getSelection(),s={anchorNode:s.anchorNode,anchorOffset:s.anchorOffset,focusNode:s.focusNode,focusOffset:s.focusOffset}),Se&&Ie$1(Se,s)||(Se=s,s=oe(Re,"onSelect"),0<s.length&&(o=new td$1("onSelect","select",null,o,i),e.push({event:o,listeners:s}),o.target=Qe)))}function Ve$1(e,o){var i={};return i[e.toLowerCase()]=o.toLowerCase(),i["Webkit"+e]="webkit"+o,i["Moz"+e]="moz"+o,i}var We$1={animationend:Ve$1("Animation","AnimationEnd"),animationiteration:Ve$1("Animation","AnimationIteration"),animationstart:Ve$1("Animation","AnimationStart"),transitionend:Ve$1("Transition","TransitionEnd")},Xe$1={},Ye={};ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We$1.animationend.animation,delete We$1.animationiteration.animation,delete We$1.animationstart.animation),"TransitionEvent"in window||delete We$1.transitionend.transition);function Ze(e){if(Xe$1[e])return Xe$1[e];if(!We$1[e])return e;var o=We$1[e],i;for(i in o)if(o.hasOwnProperty(i)&&i in Ye)return Xe$1[e]=o[i];return e}var $e$1=Ze("animationend"),af$1=Ze("animationiteration"),bf$1=Ze("animationstart"),cf$1=Ze("transitionend"),df$1=new Map,ef$1="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff$1(e,o){df$1.set(e,o),fa(o,[e])}for(var gf$1=0;gf$1<ef$1.length;gf$1++){var hf$1=ef$1[gf$1],jf$1=hf$1.toLowerCase(),kf$1=hf$1[0].toUpperCase()+hf$1.slice(1);ff$1(jf$1,"on"+kf$1)}ff$1($e$1,"onAnimationEnd");ff$1(af$1,"onAnimationIteration");ff$1(bf$1,"onAnimationStart");ff$1("dblclick","onDoubleClick");ff$1("focusin","onFocus");ff$1("focusout","onBlur");ff$1(cf$1,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf$1="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf$1=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf$1));function nf$1(e,o,i){var s=e.type||"unknown-event";e.currentTarget=i,Ub$1(s,o,void 0,e),e.currentTarget=null}function se(e,o){o=(o&4)!==0;for(var i=0;i<e.length;i++){var s=e[i],h=s.event;s=s.listeners;e:{var a=void 0;if(o)for(var d=s.length-1;0<=d;d--){var et=s[d],$=et.instance,c=et.currentTarget;if(et=et.listener,$!==a&&h.isPropagationStopped())break e;nf$1(h,et,c),a=$}else for(d=0;d<s.length;d++){if(et=s[d],$=et.instance,c=et.currentTarget,et=et.listener,$!==a&&h.isPropagationStopped())break e;nf$1(h,et,c),a=$}}}if(Qb$1)throw e=Rb$1,Qb$1=!1,Rb$1=null,e}function D$1(e,o){var i=o[of$1];i===void 0&&(i=o[of$1]=new Set);var s=e+"__bubble";i.has(s)||(pf$1(o,e,2,!1),i.add(s))}function qf$1(e,o,i){var s=0;o&&(s|=4),pf$1(i,e,s,o)}var rf$1="_reactListening"+Math.random().toString(36).slice(2);function sf$1(e){if(!e[rf$1]){e[rf$1]=!0,da.forEach(function(i){i!=="selectionchange"&&(mf$1.has(i)||qf$1(i,!1,e),qf$1(i,!0,e))});var o=e.nodeType===9?e:e.ownerDocument;o===null||o[rf$1]||(o[rf$1]=!0,qf$1("selectionchange",!1,o))}}function pf$1(e,o,i,s){switch(jd$1(o)){case 1:var h=ed$1;break;case 4:h=gd;break;default:h=fd$1}i=h.bind(null,o,i,e),h=void 0,!Lb$1||o!=="touchstart"&&o!=="touchmove"&&o!=="wheel"||(h=!0),s?h!==void 0?e.addEventListener(o,i,{capture:!0,passive:h}):e.addEventListener(o,i,!0):h!==void 0?e.addEventListener(o,i,{passive:h}):e.addEventListener(o,i,!1)}function hd(e,o,i,s,h){var a=s;if(!(o&1)&&!(o&2)&&s!==null)e:for(;;){if(s===null)return;var d=s.tag;if(d===3||d===4){var et=s.stateNode.containerInfo;if(et===h||et.nodeType===8&&et.parentNode===h)break;if(d===4)for(d=s.return;d!==null;){var $=d.tag;if(($===3||$===4)&&($=d.stateNode.containerInfo,$===h||$.nodeType===8&&$.parentNode===h))return;d=d.return}for(;et!==null;){if(d=Wc$1(et),d===null)return;if($=d.tag,$===5||$===6){s=a=d;continue e}et=et.parentNode}}s=s.return}Jb$1(function(){var c=a,b=xb$1(i),g=[];e:{var nt=df$1.get(e);if(nt!==void 0){var at=td$1,Ot=e;switch(e){case"keypress":if(od$1(i)===0)break e;case"keydown":case"keyup":at=Rd;break;case"focusin":Ot="focus",at=Fd;break;case"focusout":Ot="blur",at=Fd;break;case"beforeblur":case"afterblur":at=Fd;break;case"click":if(i.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":at=Bd;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":at=Dd;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":at=Vd;break;case $e$1:case af$1:case bf$1:at=Hd$1;break;case cf$1:at=Xd$1;break;case"scroll":at=vd;break;case"wheel":at=Zd$1;break;case"copy":case"cut":case"paste":at=Jd$1;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":at=Td}var At=(o&4)!==0,Ct=!At&&e==="scroll",St=At?nt!==null?nt+"Capture":null:nt;At=[];for(var xt=c,Dt;xt!==null;){Dt=xt;var Qt=Dt.stateNode;if(Dt.tag===5&&Qt!==null&&(Dt=Qt,St!==null&&(Qt=Kb$1(xt,St),Qt!=null&&At.push(tf$1(xt,Qt,Dt)))),Ct)break;xt=xt.return}0<At.length&&(nt=new at(nt,Ot,null,i,b),g.push({event:nt,listeners:At}))}}if(!(o&7)){e:{if(nt=e==="mouseover"||e==="pointerover",at=e==="mouseout"||e==="pointerout",nt&&i!==wb$1&&(Ot=i.relatedTarget||i.fromElement)&&(Wc$1(Ot)||Ot[uf$1]))break e;if((at||nt)&&(nt=b.window===b?b:(nt=b.ownerDocument)?nt.defaultView||nt.parentWindow:window,at?(Ot=i.relatedTarget||i.toElement,at=c,Ot=Ot?Wc$1(Ot):null,Ot!==null&&(Ct=Vb$1(Ot),Ot!==Ct||Ot.tag!==5&&Ot.tag!==6)&&(Ot=null)):(at=null,Ot=c),at!==Ot)){if(At=Bd,Qt="onMouseLeave",St="onMouseEnter",xt="mouse",(e==="pointerout"||e==="pointerover")&&(At=Td,Qt="onPointerLeave",St="onPointerEnter",xt="pointer"),Ct=at==null?nt:ue$1(at),Dt=Ot==null?nt:ue$1(Ot),nt=new At(Qt,xt+"leave",at,i,b),nt.target=Ct,nt.relatedTarget=Dt,Qt=null,Wc$1(b)===c&&(At=new At(St,xt+"enter",Ot,i,b),At.target=Dt,At.relatedTarget=Ct,Qt=At),Ct=Qt,at&&Ot)t:{for(At=at,St=Ot,xt=0,Dt=At;Dt;Dt=vf$1(Dt))xt++;for(Dt=0,Qt=St;Qt;Qt=vf$1(Qt))Dt++;for(;0<xt-Dt;)At=vf$1(At),xt--;for(;0<Dt-xt;)St=vf$1(St),Dt--;for(;xt--;){if(At===St||St!==null&&At===St.alternate)break t;At=vf$1(At),St=vf$1(St)}At=null}else At=null;at!==null&&wf$1(g,nt,at,At,!1),Ot!==null&&Ct!==null&&wf$1(g,Ct,Ot,At,!0)}}e:{if(nt=c?ue$1(c):window,at=nt.nodeName&&nt.nodeName.toLowerCase(),at==="select"||at==="input"&&nt.type==="file")var Zt=ve;else if(me$1(nt))if(we)Zt=Fe$1;else{Zt=De;var gr=Ce$1}else(at=nt.nodeName)&&at.toLowerCase()==="input"&&(nt.type==="checkbox"||nt.type==="radio")&&(Zt=Ee);if(Zt&&(Zt=Zt(e,c))){ne(g,Zt,i,b);break e}gr&&gr(e,nt,c),e==="focusout"&&(gr=nt._wrapperState)&&gr.controlled&&nt.type==="number"&&cb$1(nt,"number",nt.value)}switch(gr=c?ue$1(c):window,e){case"focusin":(me$1(gr)||gr.contentEditable==="true")&&(Qe=gr,Re=c,Se=null);break;case"focusout":Se=Re=Qe=null;break;case"mousedown":Te=!0;break;case"contextmenu":case"mouseup":case"dragend":Te=!1,Ue$1(g,i,b);break;case"selectionchange":if(Pe$1)break;case"keydown":case"keyup":Ue$1(g,i,b)}var vr;if(ae)e:{switch(e){case"compositionstart":var Er="onCompositionStart";break e;case"compositionend":Er="onCompositionEnd";break e;case"compositionupdate":Er="onCompositionUpdate";break e}Er=void 0}else ie?ge(e,i)&&(Er="onCompositionEnd"):e==="keydown"&&i.keyCode===229&&(Er="onCompositionStart");Er&&(de&&i.locale!=="ko"&&(ie||Er!=="onCompositionStart"?Er==="onCompositionEnd"&&ie&&(vr=nd$1()):(kd=b,ld$1="value"in kd?kd.value:kd.textContent,ie=!0)),gr=oe(c,Er),0<gr.length&&(Er=new Ld(Er,e,null,i,b),g.push({event:Er,listeners:gr}),vr?Er.data=vr:(vr=he$1(i),vr!==null&&(Er.data=vr)))),(vr=ce$1?je$1(e,i):ke$1(e,i))&&(c=oe(c,"onBeforeInput"),0<c.length&&(b=new Ld("onBeforeInput","beforeinput",null,i,b),g.push({event:b,listeners:c}),b.data=vr))}se(g,o)})}function tf$1(e,o,i){return{instance:e,listener:o,currentTarget:i}}function oe(e,o){for(var i=o+"Capture",s=[];e!==null;){var h=e,a=h.stateNode;h.tag===5&&a!==null&&(h=a,a=Kb$1(e,i),a!=null&&s.unshift(tf$1(e,a,h)),a=Kb$1(e,o),a!=null&&s.push(tf$1(e,a,h))),e=e.return}return s}function vf$1(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function wf$1(e,o,i,s,h){for(var a=o._reactName,d=[];i!==null&&i!==s;){var et=i,$=et.alternate,c=et.stateNode;if($!==null&&$===s)break;et.tag===5&&c!==null&&(et=c,h?($=Kb$1(i,a),$!=null&&d.unshift(tf$1(i,$,et))):h||($=Kb$1(i,a),$!=null&&d.push(tf$1(i,$,et)))),i=i.return}d.length!==0&&e.push({event:o,listeners:d})}var xf$1=/\r\n?/g,yf$1=/\u0000|\uFFFD/g;function zf$1(e){return(typeof e=="string"?e:""+e).replace(xf$1,`
`).replace(yf$1,"")}function Af$1(e,o,i){if(o=zf$1(o),zf$1(e)!==o&&i)throw Error(p(425))}function Bf$1(){}var Cf$1=null,Df$1=null;function Ef$1(e,o){return e==="textarea"||e==="noscript"||typeof o.children=="string"||typeof o.children=="number"||typeof o.dangerouslySetInnerHTML=="object"&&o.dangerouslySetInnerHTML!==null&&o.dangerouslySetInnerHTML.__html!=null}var Ff$1=typeof setTimeout=="function"?setTimeout:void 0,Gf$1=typeof clearTimeout=="function"?clearTimeout:void 0,Hf$1=typeof Promise=="function"?Promise:void 0,Jf$1=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf$1<"u"?function(e){return Hf$1.resolve(null).then(e).catch(If$1)}:Ff$1;function If$1(e){setTimeout(function(){throw e})}function Kf$1(e,o){var i=o,s=0;do{var h=i.nextSibling;if(e.removeChild(i),h&&h.nodeType===8)if(i=h.data,i==="/$"){if(s===0){e.removeChild(h),bd(o);return}s--}else i!=="$"&&i!=="$?"&&i!=="$!"||s++;i=h}while(i);bd(o)}function Lf$1(e){for(;e!=null;e=e.nextSibling){var o=e.nodeType;if(o===1||o===3)break;if(o===8){if(o=e.data,o==="$"||o==="$!"||o==="$?")break;if(o==="/$")return null}}return e}function Mf$1(e){e=e.previousSibling;for(var o=0;e;){if(e.nodeType===8){var i=e.data;if(i==="$"||i==="$!"||i==="$?"){if(o===0)return e;o--}else i==="/$"&&o++}e=e.previousSibling}return null}var Nf$1=Math.random().toString(36).slice(2),Of$1="__reactFiber$"+Nf$1,Pf$1="__reactProps$"+Nf$1,uf$1="__reactContainer$"+Nf$1,of$1="__reactEvents$"+Nf$1,Qf$1="__reactListeners$"+Nf$1,Rf$1="__reactHandles$"+Nf$1;function Wc$1(e){var o=e[Of$1];if(o)return o;for(var i=e.parentNode;i;){if(o=i[uf$1]||i[Of$1]){if(i=o.alternate,o.child!==null||i!==null&&i.child!==null)for(e=Mf$1(e);e!==null;){if(i=e[Of$1])return i;e=Mf$1(e)}return o}e=i,i=e.parentNode}return null}function Cb$1(e){return e=e[Of$1]||e[uf$1],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function ue$1(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(p(33))}function Db$1(e){return e[Pf$1]||null}var Sf$1=[],Tf$1=-1;function Uf$1(e){return{current:e}}function E(e){0>Tf$1||(e.current=Sf$1[Tf$1],Sf$1[Tf$1]=null,Tf$1--)}function G$1(e,o){Tf$1++,Sf$1[Tf$1]=e.current,e.current=o}var Vf$1={},H$1=Uf$1(Vf$1),Wf$1=Uf$1(!1),Xf$1=Vf$1;function Yf$1(e,o){var i=e.type.contextTypes;if(!i)return Vf$1;var s=e.stateNode;if(s&&s.__reactInternalMemoizedUnmaskedChildContext===o)return s.__reactInternalMemoizedMaskedChildContext;var h={},a;for(a in i)h[a]=o[a];return s&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=o,e.__reactInternalMemoizedMaskedChildContext=h),h}function Zf$1(e){return e=e.childContextTypes,e!=null}function $f$1(){E(Wf$1),E(H$1)}function ag$1(e,o,i){if(H$1.current!==Vf$1)throw Error(p(168));G$1(H$1,o),G$1(Wf$1,i)}function bg$1(e,o,i){var s=e.stateNode;if(o=o.childContextTypes,typeof s.getChildContext!="function")return i;s=s.getChildContext();for(var h in s)if(!(h in o))throw Error(p(108,Ra(e)||"Unknown",h));return A({},i,s)}function cg(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Vf$1,Xf$1=H$1.current,G$1(H$1,e),G$1(Wf$1,Wf$1.current),!0}function dg$1(e,o,i){var s=e.stateNode;if(!s)throw Error(p(169));i?(e=bg$1(e,o,Xf$1),s.__reactInternalMemoizedMergedChildContext=e,E(Wf$1),E(H$1),G$1(H$1,e)):E(Wf$1),G$1(Wf$1,i)}var eg$1=null,fg$1=!1,gg$1=!1;function hg$1(e){eg$1===null?eg$1=[e]:eg$1.push(e)}function ig$1(e){fg$1=!0,hg$1(e)}function jg(){if(!gg$1&&eg$1!==null){gg$1=!0;var e=0,o=C;try{var i=eg$1;for(C=1;e<i.length;e++){var s=i[e];do s=s(!0);while(s!==null)}eg$1=null,fg$1=!1}catch(h){throw eg$1!==null&&(eg$1=eg$1.slice(e+1)),ac$1(fc$1,jg),h}finally{C=o,gg$1=!1}}return null}var kg$1=[],lg$1=0,mg$1=null,ng$1=0,og$1=[],pg=0,qg=null,rg$1=1,sg$1="";function tg$1(e,o){kg$1[lg$1++]=ng$1,kg$1[lg$1++]=mg$1,mg$1=e,ng$1=o}function ug$1(e,o,i){og$1[pg++]=rg$1,og$1[pg++]=sg$1,og$1[pg++]=qg,qg=e;var s=rg$1;e=sg$1;var h=32-oc$1(s)-1;s&=~(1<<h),i+=1;var a=32-oc$1(o)+h;if(30<a){var d=h-h%5;a=(s&(1<<d)-1).toString(32),s>>=d,h-=d,rg$1=1<<32-oc$1(o)+h|i<<h|s,sg$1=a+e}else rg$1=1<<a|i<<h|s,sg$1=e}function vg$1(e){e.return!==null&&(tg$1(e,1),ug$1(e,1,0))}function wg$1(e){for(;e===mg$1;)mg$1=kg$1[--lg$1],kg$1[lg$1]=null,ng$1=kg$1[--lg$1],kg$1[lg$1]=null;for(;e===qg;)qg=og$1[--pg],og$1[pg]=null,sg$1=og$1[--pg],og$1[pg]=null,rg$1=og$1[--pg],og$1[pg]=null}var xg$1=null,yg$1=null,I=!1,zg=null;function Ag$1(e,o){var i=Bg$1(5,null,null,0);i.elementType="DELETED",i.stateNode=o,i.return=e,o=e.deletions,o===null?(e.deletions=[i],e.flags|=16):o.push(i)}function Cg(e,o){switch(e.tag){case 5:var i=e.type;return o=o.nodeType!==1||i.toLowerCase()!==o.nodeName.toLowerCase()?null:o,o!==null?(e.stateNode=o,xg$1=e,yg$1=Lf$1(o.firstChild),!0):!1;case 6:return o=e.pendingProps===""||o.nodeType!==3?null:o,o!==null?(e.stateNode=o,xg$1=e,yg$1=null,!0):!1;case 13:return o=o.nodeType!==8?null:o,o!==null?(i=qg!==null?{id:rg$1,overflow:sg$1}:null,e.memoizedState={dehydrated:o,treeContext:i,retryLane:1073741824},i=Bg$1(18,null,null,0),i.stateNode=o,i.return=e,e.child=i,xg$1=e,yg$1=null,!0):!1;default:return!1}}function Dg$1(e){return(e.mode&1)!==0&&(e.flags&128)===0}function Eg$1(e){if(I){var o=yg$1;if(o){var i=o;if(!Cg(e,o)){if(Dg$1(e))throw Error(p(418));o=Lf$1(i.nextSibling);var s=xg$1;o&&Cg(e,o)?Ag$1(s,i):(e.flags=e.flags&-4097|2,I=!1,xg$1=e)}}else{if(Dg$1(e))throw Error(p(418));e.flags=e.flags&-4097|2,I=!1,xg$1=e}}}function Fg$1(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;xg$1=e}function Gg$1(e){if(e!==xg$1)return!1;if(!I)return Fg$1(e),I=!0,!1;var o;if((o=e.tag!==3)&&!(o=e.tag!==5)&&(o=e.type,o=o!=="head"&&o!=="body"&&!Ef$1(e.type,e.memoizedProps)),o&&(o=yg$1)){if(Dg$1(e))throw Hg(),Error(p(418));for(;o;)Ag$1(e,o),o=Lf$1(o.nextSibling)}if(Fg$1(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(p(317));e:{for(e=e.nextSibling,o=0;e;){if(e.nodeType===8){var i=e.data;if(i==="/$"){if(o===0){yg$1=Lf$1(e.nextSibling);break e}o--}else i!=="$"&&i!=="$!"&&i!=="$?"||o++}e=e.nextSibling}yg$1=null}}else yg$1=xg$1?Lf$1(e.stateNode.nextSibling):null;return!0}function Hg(){for(var e=yg$1;e;)e=Lf$1(e.nextSibling)}function Ig$1(){yg$1=xg$1=null,I=!1}function Jg(e){zg===null?zg=[e]:zg.push(e)}var Kg=ua.ReactCurrentBatchConfig;function Lg$1(e,o,i){if(e=i.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(i._owner){if(i=i._owner,i){if(i.tag!==1)throw Error(p(309));var s=i.stateNode}if(!s)throw Error(p(147,e));var h=s,a=""+e;return o!==null&&o.ref!==null&&typeof o.ref=="function"&&o.ref._stringRef===a?o.ref:(o=function(d){var et=h.refs;d===null?delete et[a]:et[a]=d},o._stringRef=a,o)}if(typeof e!="string")throw Error(p(284));if(!i._owner)throw Error(p(290,e))}return e}function Mg$1(e,o){throw e=Object.prototype.toString.call(o),Error(p(31,e==="[object Object]"?"object with keys {"+Object.keys(o).join(", ")+"}":e))}function Ng$1(e){var o=e._init;return o(e._payload)}function Og$1(e){function o(St,xt){if(e){var Dt=St.deletions;Dt===null?(St.deletions=[xt],St.flags|=16):Dt.push(xt)}}function i(St,xt){if(!e)return null;for(;xt!==null;)o(St,xt),xt=xt.sibling;return null}function s(St,xt){for(St=new Map;xt!==null;)xt.key!==null?St.set(xt.key,xt):St.set(xt.index,xt),xt=xt.sibling;return St}function h(St,xt){return St=Pg$1(St,xt),St.index=0,St.sibling=null,St}function a(St,xt,Dt){return St.index=Dt,e?(Dt=St.alternate,Dt!==null?(Dt=Dt.index,Dt<xt?(St.flags|=2,xt):Dt):(St.flags|=2,xt)):(St.flags|=1048576,xt)}function d(St){return e&&St.alternate===null&&(St.flags|=2),St}function et(St,xt,Dt,Qt){return xt===null||xt.tag!==6?(xt=Qg(Dt,St.mode,Qt),xt.return=St,xt):(xt=h(xt,Dt),xt.return=St,xt)}function $(St,xt,Dt,Qt){var Zt=Dt.type;return Zt===ya?b(St,xt,Dt.props.children,Qt,Dt.key):xt!==null&&(xt.elementType===Zt||typeof Zt=="object"&&Zt!==null&&Zt.$$typeof===Ha&&Ng$1(Zt)===xt.type)?(Qt=h(xt,Dt.props),Qt.ref=Lg$1(St,xt,Dt),Qt.return=St,Qt):(Qt=Rg$1(Dt.type,Dt.key,Dt.props,null,St.mode,Qt),Qt.ref=Lg$1(St,xt,Dt),Qt.return=St,Qt)}function c(St,xt,Dt,Qt){return xt===null||xt.tag!==4||xt.stateNode.containerInfo!==Dt.containerInfo||xt.stateNode.implementation!==Dt.implementation?(xt=Sg$1(Dt,St.mode,Qt),xt.return=St,xt):(xt=h(xt,Dt.children||[]),xt.return=St,xt)}function b(St,xt,Dt,Qt,Zt){return xt===null||xt.tag!==7?(xt=Tg$1(Dt,St.mode,Qt,Zt),xt.return=St,xt):(xt=h(xt,Dt),xt.return=St,xt)}function g(St,xt,Dt){if(typeof xt=="string"&&xt!==""||typeof xt=="number")return xt=Qg(""+xt,St.mode,Dt),xt.return=St,xt;if(typeof xt=="object"&&xt!==null){switch(xt.$$typeof){case va:return Dt=Rg$1(xt.type,xt.key,xt.props,null,St.mode,Dt),Dt.ref=Lg$1(St,null,xt),Dt.return=St,Dt;case wa:return xt=Sg$1(xt,St.mode,Dt),xt.return=St,xt;case Ha:var Qt=xt._init;return g(St,Qt(xt._payload),Dt)}if(eb$1(xt)||Ka(xt))return xt=Tg$1(xt,St.mode,Dt,null),xt.return=St,xt;Mg$1(St,xt)}return null}function nt(St,xt,Dt,Qt){var Zt=xt!==null?xt.key:null;if(typeof Dt=="string"&&Dt!==""||typeof Dt=="number")return Zt!==null?null:et(St,xt,""+Dt,Qt);if(typeof Dt=="object"&&Dt!==null){switch(Dt.$$typeof){case va:return Dt.key===Zt?$(St,xt,Dt,Qt):null;case wa:return Dt.key===Zt?c(St,xt,Dt,Qt):null;case Ha:return Zt=Dt._init,nt(St,xt,Zt(Dt._payload),Qt)}if(eb$1(Dt)||Ka(Dt))return Zt!==null?null:b(St,xt,Dt,Qt,null);Mg$1(St,Dt)}return null}function at(St,xt,Dt,Qt,Zt){if(typeof Qt=="string"&&Qt!==""||typeof Qt=="number")return St=St.get(Dt)||null,et(xt,St,""+Qt,Zt);if(typeof Qt=="object"&&Qt!==null){switch(Qt.$$typeof){case va:return St=St.get(Qt.key===null?Dt:Qt.key)||null,$(xt,St,Qt,Zt);case wa:return St=St.get(Qt.key===null?Dt:Qt.key)||null,c(xt,St,Qt,Zt);case Ha:var gr=Qt._init;return at(St,xt,Dt,gr(Qt._payload),Zt)}if(eb$1(Qt)||Ka(Qt))return St=St.get(Dt)||null,b(xt,St,Qt,Zt,null);Mg$1(xt,Qt)}return null}function Ot(St,xt,Dt,Qt){for(var Zt=null,gr=null,vr=xt,Er=xt=0,wo=null;vr!==null&&Er<Dt.length;Er++){vr.index>Er?(wo=vr,vr=null):wo=vr.sibling;var Do=nt(St,vr,Dt[Er],Qt);if(Do===null){vr===null&&(vr=wo);break}e&&vr&&Do.alternate===null&&o(St,vr),xt=a(Do,xt,Er),gr===null?Zt=Do:gr.sibling=Do,gr=Do,vr=wo}if(Er===Dt.length)return i(St,vr),I&&tg$1(St,Er),Zt;if(vr===null){for(;Er<Dt.length;Er++)vr=g(St,Dt[Er],Qt),vr!==null&&(xt=a(vr,xt,Er),gr===null?Zt=vr:gr.sibling=vr,gr=vr);return I&&tg$1(St,Er),Zt}for(vr=s(St,vr);Er<Dt.length;Er++)wo=at(vr,St,Er,Dt[Er],Qt),wo!==null&&(e&&wo.alternate!==null&&vr.delete(wo.key===null?Er:wo.key),xt=a(wo,xt,Er),gr===null?Zt=wo:gr.sibling=wo,gr=wo);return e&&vr.forEach(function(Js){return o(St,Js)}),I&&tg$1(St,Er),Zt}function At(St,xt,Dt,Qt){var Zt=Ka(Dt);if(typeof Zt!="function")throw Error(p(150));if(Dt=Zt.call(Dt),Dt==null)throw Error(p(151));for(var gr=Zt=null,vr=xt,Er=xt=0,wo=null,Do=Dt.next();vr!==null&&!Do.done;Er++,Do=Dt.next()){vr.index>Er?(wo=vr,vr=null):wo=vr.sibling;var Js=nt(St,vr,Do.value,Qt);if(Js===null){vr===null&&(vr=wo);break}e&&vr&&Js.alternate===null&&o(St,vr),xt=a(Js,xt,Er),gr===null?Zt=Js:gr.sibling=Js,gr=Js,vr=wo}if(Do.done)return i(St,vr),I&&tg$1(St,Er),Zt;if(vr===null){for(;!Do.done;Er++,Do=Dt.next())Do=g(St,Do.value,Qt),Do!==null&&(xt=a(Do,xt,Er),gr===null?Zt=Do:gr.sibling=Do,gr=Do);return I&&tg$1(St,Er),Zt}for(vr=s(St,vr);!Do.done;Er++,Do=Dt.next())Do=at(vr,St,Er,Do.value,Qt),Do!==null&&(e&&Do.alternate!==null&&vr.delete(Do.key===null?Er:Do.key),xt=a(Do,xt,Er),gr===null?Zt=Do:gr.sibling=Do,gr=Do);return e&&vr.forEach(function(In){return o(St,In)}),I&&tg$1(St,Er),Zt}function Ct(St,xt,Dt,Qt){if(typeof Dt=="object"&&Dt!==null&&Dt.type===ya&&Dt.key===null&&(Dt=Dt.props.children),typeof Dt=="object"&&Dt!==null){switch(Dt.$$typeof){case va:e:{for(var Zt=Dt.key,gr=xt;gr!==null;){if(gr.key===Zt){if(Zt=Dt.type,Zt===ya){if(gr.tag===7){i(St,gr.sibling),xt=h(gr,Dt.props.children),xt.return=St,St=xt;break e}}else if(gr.elementType===Zt||typeof Zt=="object"&&Zt!==null&&Zt.$$typeof===Ha&&Ng$1(Zt)===gr.type){i(St,gr.sibling),xt=h(gr,Dt.props),xt.ref=Lg$1(St,gr,Dt),xt.return=St,St=xt;break e}i(St,gr);break}else o(St,gr);gr=gr.sibling}Dt.type===ya?(xt=Tg$1(Dt.props.children,St.mode,Qt,Dt.key),xt.return=St,St=xt):(Qt=Rg$1(Dt.type,Dt.key,Dt.props,null,St.mode,Qt),Qt.ref=Lg$1(St,xt,Dt),Qt.return=St,St=Qt)}return d(St);case wa:e:{for(gr=Dt.key;xt!==null;){if(xt.key===gr)if(xt.tag===4&&xt.stateNode.containerInfo===Dt.containerInfo&&xt.stateNode.implementation===Dt.implementation){i(St,xt.sibling),xt=h(xt,Dt.children||[]),xt.return=St,St=xt;break e}else{i(St,xt);break}else o(St,xt);xt=xt.sibling}xt=Sg$1(Dt,St.mode,Qt),xt.return=St,St=xt}return d(St);case Ha:return gr=Dt._init,Ct(St,xt,gr(Dt._payload),Qt)}if(eb$1(Dt))return Ot(St,xt,Dt,Qt);if(Ka(Dt))return At(St,xt,Dt,Qt);Mg$1(St,Dt)}return typeof Dt=="string"&&Dt!==""||typeof Dt=="number"?(Dt=""+Dt,xt!==null&&xt.tag===6?(i(St,xt.sibling),xt=h(xt,Dt),xt.return=St,St=xt):(i(St,xt),xt=Qg(Dt,St.mode,Qt),xt.return=St,St=xt),d(St)):i(St,xt)}return Ct}var Ug=Og$1(!0),Vg=Og$1(!1),Wg=Uf$1(null),Xg=null,Yg=null,Zg=null;function $g$1(){Zg=Yg=Xg=null}function ah(e){var o=Wg.current;E(Wg),e._currentValue=o}function bh$1(e,o,i){for(;e!==null;){var s=e.alternate;if((e.childLanes&o)!==o?(e.childLanes|=o,s!==null&&(s.childLanes|=o)):s!==null&&(s.childLanes&o)!==o&&(s.childLanes|=o),e===i)break;e=e.return}}function ch(e,o){Xg=e,Zg=Yg=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&o&&(dh$1=!0),e.firstContext=null)}function eh(e){var o=e._currentValue;if(Zg!==e)if(e={context:e,memoizedValue:o,next:null},Yg===null){if(Xg===null)throw Error(p(308));Yg=e,Xg.dependencies={lanes:0,firstContext:e}}else Yg=Yg.next=e;return o}var fh=null;function gh$1(e){fh===null?fh=[e]:fh.push(e)}function hh$1(e,o,i,s){var h=o.interleaved;return h===null?(i.next=i,gh$1(o)):(i.next=h.next,h.next=i),o.interleaved=i,ih(e,s)}function ih(e,o){e.lanes|=o;var i=e.alternate;for(i!==null&&(i.lanes|=o),i=e,e=e.return;e!==null;)e.childLanes|=o,i=e.alternate,i!==null&&(i.childLanes|=o),i=e,e=e.return;return i.tag===3?i.stateNode:null}var jh$1=!1;function kh$1(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lh(e,o){e=e.updateQueue,o.updateQueue===e&&(o.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function mh$1(e,o){return{eventTime:e,lane:o,tag:0,payload:null,callback:null,next:null}}function nh(e,o,i){var s=e.updateQueue;if(s===null)return null;if(s=s.shared,K&2){var h=s.pending;return h===null?o.next=o:(o.next=h.next,h.next=o),s.pending=o,ih(e,i)}return h=s.interleaved,h===null?(o.next=o,gh$1(s)):(o.next=h.next,h.next=o),s.interleaved=o,ih(e,i)}function oh(e,o,i){if(o=o.updateQueue,o!==null&&(o=o.shared,(i&4194240)!==0)){var s=o.lanes;s&=e.pendingLanes,i|=s,o.lanes=i,Cc$1(e,i)}}function ph$1(e,o){var i=e.updateQueue,s=e.alternate;if(s!==null&&(s=s.updateQueue,i===s)){var h=null,a=null;if(i=i.firstBaseUpdate,i!==null){do{var d={eventTime:i.eventTime,lane:i.lane,tag:i.tag,payload:i.payload,callback:i.callback,next:null};a===null?h=a=d:a=a.next=d,i=i.next}while(i!==null);a===null?h=a=o:a=a.next=o}else h=a=o;i={baseState:s.baseState,firstBaseUpdate:h,lastBaseUpdate:a,shared:s.shared,effects:s.effects},e.updateQueue=i;return}e=i.lastBaseUpdate,e===null?i.firstBaseUpdate=o:e.next=o,i.lastBaseUpdate=o}function qh(e,o,i,s){var h=e.updateQueue;jh$1=!1;var a=h.firstBaseUpdate,d=h.lastBaseUpdate,et=h.shared.pending;if(et!==null){h.shared.pending=null;var $=et,c=$.next;$.next=null,d===null?a=c:d.next=c,d=$;var b=e.alternate;b!==null&&(b=b.updateQueue,et=b.lastBaseUpdate,et!==d&&(et===null?b.firstBaseUpdate=c:et.next=c,b.lastBaseUpdate=$))}if(a!==null){var g=h.baseState;d=0,b=c=$=null,et=a;do{var nt=et.lane,at=et.eventTime;if((s&nt)===nt){b!==null&&(b=b.next={eventTime:at,lane:0,tag:et.tag,payload:et.payload,callback:et.callback,next:null});e:{var Ot=e,At=et;switch(nt=o,at=i,At.tag){case 1:if(Ot=At.payload,typeof Ot=="function"){g=Ot.call(at,g,nt);break e}g=Ot;break e;case 3:Ot.flags=Ot.flags&-65537|128;case 0:if(Ot=At.payload,nt=typeof Ot=="function"?Ot.call(at,g,nt):Ot,nt==null)break e;g=A({},g,nt);break e;case 2:jh$1=!0}}et.callback!==null&&et.lane!==0&&(e.flags|=64,nt=h.effects,nt===null?h.effects=[et]:nt.push(et))}else at={eventTime:at,lane:nt,tag:et.tag,payload:et.payload,callback:et.callback,next:null},b===null?(c=b=at,$=g):b=b.next=at,d|=nt;if(et=et.next,et===null){if(et=h.shared.pending,et===null)break;nt=et,et=nt.next,nt.next=null,h.lastBaseUpdate=nt,h.shared.pending=null}}while(!0);if(b===null&&($=g),h.baseState=$,h.firstBaseUpdate=c,h.lastBaseUpdate=b,o=h.shared.interleaved,o!==null){h=o;do d|=h.lane,h=h.next;while(h!==o)}else a===null&&(h.shared.lanes=0);rh$1|=d,e.lanes=d,e.memoizedState=g}}function sh(e,o,i){if(e=o.effects,o.effects=null,e!==null)for(o=0;o<e.length;o++){var s=e[o],h=s.callback;if(h!==null){if(s.callback=null,s=i,typeof h!="function")throw Error(p(191,h));h.call(s)}}}var th$1={},uh=Uf$1(th$1),vh$1=Uf$1(th$1),wh$1=Uf$1(th$1);function xh$1(e){if(e===th$1)throw Error(p(174));return e}function yh$1(e,o){switch(G$1(wh$1,o),G$1(vh$1,e),G$1(uh,th$1),e=o.nodeType,e){case 9:case 11:o=(o=o.documentElement)?o.namespaceURI:lb$1(null,"");break;default:e=e===8?o.parentNode:o,o=e.namespaceURI||null,e=e.tagName,o=lb$1(o,e)}E(uh),G$1(uh,o)}function zh$1(){E(uh),E(vh$1),E(wh$1)}function Ah(e){xh$1(wh$1.current);var o=xh$1(uh.current),i=lb$1(o,e.type);o!==i&&(G$1(vh$1,e),G$1(uh,i))}function Bh$1(e){vh$1.current===e&&(E(uh),E(vh$1))}var L=Uf$1(0);function Ch$1(e){for(var o=e;o!==null;){if(o.tag===13){var i=o.memoizedState;if(i!==null&&(i=i.dehydrated,i===null||i.data==="$?"||i.data==="$!"))return o}else if(o.tag===19&&o.memoizedProps.revealOrder!==void 0){if(o.flags&128)return o}else if(o.child!==null){o.child.return=o,o=o.child;continue}if(o===e)break;for(;o.sibling===null;){if(o.return===null||o.return===e)return null;o=o.return}o.sibling.return=o.return,o=o.sibling}return null}var Dh$1=[];function Eh$1(){for(var e=0;e<Dh$1.length;e++)Dh$1[e]._workInProgressVersionPrimary=null;Dh$1.length=0}var Fh$1=ua.ReactCurrentDispatcher,Gh$1=ua.ReactCurrentBatchConfig,Hh$1=0,M=null,N=null,O$1=null,Ih$1=!1,Jh$1=!1,Kh$1=0,Lh=0;function P(){throw Error(p(321))}function Mh$1(e,o){if(o===null)return!1;for(var i=0;i<o.length&&i<e.length;i++)if(!He$1(e[i],o[i]))return!1;return!0}function Nh$1(e,o,i,s,h,a){if(Hh$1=a,M=o,o.memoizedState=null,o.updateQueue=null,o.lanes=0,Fh$1.current=e===null||e.memoizedState===null?Oh$1:Ph$1,e=i(s,h),Jh$1){a=0;do{if(Jh$1=!1,Kh$1=0,25<=a)throw Error(p(301));a+=1,O$1=N=null,o.updateQueue=null,Fh$1.current=Qh$1,e=i(s,h)}while(Jh$1)}if(Fh$1.current=Rh$1,o=N!==null&&N.next!==null,Hh$1=0,O$1=N=M=null,Ih$1=!1,o)throw Error(p(300));return e}function Sh$1(){var e=Kh$1!==0;return Kh$1=0,e}function Th$1(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return O$1===null?M.memoizedState=O$1=e:O$1=O$1.next=e,O$1}function Uh$1(){if(N===null){var e=M.alternate;e=e!==null?e.memoizedState:null}else e=N.next;var o=O$1===null?M.memoizedState:O$1.next;if(o!==null)O$1=o,N=e;else{if(e===null)throw Error(p(310));N=e,e={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null},O$1===null?M.memoizedState=O$1=e:O$1=O$1.next=e}return O$1}function Vh$1(e,o){return typeof o=="function"?o(e):o}function Wh$1(e){var o=Uh$1(),i=o.queue;if(i===null)throw Error(p(311));i.lastRenderedReducer=e;var s=N,h=s.baseQueue,a=i.pending;if(a!==null){if(h!==null){var d=h.next;h.next=a.next,a.next=d}s.baseQueue=h=a,i.pending=null}if(h!==null){a=h.next,s=s.baseState;var et=d=null,$=null,c=a;do{var b=c.lane;if((Hh$1&b)===b)$!==null&&($=$.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),s=c.hasEagerState?c.eagerState:e(s,c.action);else{var g={lane:b,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};$===null?(et=$=g,d=s):$=$.next=g,M.lanes|=b,rh$1|=b}c=c.next}while(c!==null&&c!==a);$===null?d=s:$.next=et,He$1(s,o.memoizedState)||(dh$1=!0),o.memoizedState=s,o.baseState=d,o.baseQueue=$,i.lastRenderedState=s}if(e=i.interleaved,e!==null){h=e;do a=h.lane,M.lanes|=a,rh$1|=a,h=h.next;while(h!==e)}else h===null&&(i.lanes=0);return[o.memoizedState,i.dispatch]}function Xh$1(e){var o=Uh$1(),i=o.queue;if(i===null)throw Error(p(311));i.lastRenderedReducer=e;var s=i.dispatch,h=i.pending,a=o.memoizedState;if(h!==null){i.pending=null;var d=h=h.next;do a=e(a,d.action),d=d.next;while(d!==h);He$1(a,o.memoizedState)||(dh$1=!0),o.memoizedState=a,o.baseQueue===null&&(o.baseState=a),i.lastRenderedState=a}return[a,s]}function Yh$1(){}function Zh$1(e,o){var i=M,s=Uh$1(),h=o(),a=!He$1(s.memoizedState,h);if(a&&(s.memoizedState=h,dh$1=!0),s=s.queue,$h$1(ai$1.bind(null,i,s,e),[e]),s.getSnapshot!==o||a||O$1!==null&&O$1.memoizedState.tag&1){if(i.flags|=2048,bi$1(9,ci$1.bind(null,i,s,h,o),void 0,null),Q===null)throw Error(p(349));Hh$1&30||di$1(i,o,h)}return h}function di$1(e,o,i){e.flags|=16384,e={getSnapshot:o,value:i},o=M.updateQueue,o===null?(o={lastEffect:null,stores:null},M.updateQueue=o,o.stores=[e]):(i=o.stores,i===null?o.stores=[e]:i.push(e))}function ci$1(e,o,i,s){o.value=i,o.getSnapshot=s,ei$1(o)&&fi$1(e)}function ai$1(e,o,i){return i(function(){ei$1(o)&&fi$1(e)})}function ei$1(e){var o=e.getSnapshot;e=e.value;try{var i=o();return!He$1(e,i)}catch{return!0}}function fi$1(e){var o=ih(e,1);o!==null&&gi$1(o,e,1,-1)}function hi$1(e){var o=Th$1();return typeof e=="function"&&(e=e()),o.memoizedState=o.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh$1,lastRenderedState:e},o.queue=e,e=e.dispatch=ii$1.bind(null,M,e),[o.memoizedState,e]}function bi$1(e,o,i,s){return e={tag:e,create:o,destroy:i,deps:s,next:null},o=M.updateQueue,o===null?(o={lastEffect:null,stores:null},M.updateQueue=o,o.lastEffect=e.next=e):(i=o.lastEffect,i===null?o.lastEffect=e.next=e:(s=i.next,i.next=e,e.next=s,o.lastEffect=e)),e}function ji$1(){return Uh$1().memoizedState}function ki$1(e,o,i,s){var h=Th$1();M.flags|=e,h.memoizedState=bi$1(1|o,i,void 0,s===void 0?null:s)}function li$1(e,o,i,s){var h=Uh$1();s=s===void 0?null:s;var a=void 0;if(N!==null){var d=N.memoizedState;if(a=d.destroy,s!==null&&Mh$1(s,d.deps)){h.memoizedState=bi$1(o,i,a,s);return}}M.flags|=e,h.memoizedState=bi$1(1|o,i,a,s)}function mi$1(e,o){return ki$1(8390656,8,e,o)}function $h$1(e,o){return li$1(2048,8,e,o)}function ni$1(e,o){return li$1(4,2,e,o)}function oi$1(e,o){return li$1(4,4,e,o)}function pi$1(e,o){if(typeof o=="function")return e=e(),o(e),function(){o(null)};if(o!=null)return e=e(),o.current=e,function(){o.current=null}}function qi$1(e,o,i){return i=i!=null?i.concat([e]):null,li$1(4,4,pi$1.bind(null,o,e),i)}function ri(){}function si$1(e,o){var i=Uh$1();o=o===void 0?null:o;var s=i.memoizedState;return s!==null&&o!==null&&Mh$1(o,s[1])?s[0]:(i.memoizedState=[e,o],e)}function ti(e,o){var i=Uh$1();o=o===void 0?null:o;var s=i.memoizedState;return s!==null&&o!==null&&Mh$1(o,s[1])?s[0]:(e=e(),i.memoizedState=[e,o],e)}function ui$1(e,o,i){return Hh$1&21?(He$1(i,o)||(i=yc$1(),M.lanes|=i,rh$1|=i,e.baseState=!0),o):(e.baseState&&(e.baseState=!1,dh$1=!0),e.memoizedState=i)}function vi$1(e,o){var i=C;C=i!==0&&4>i?i:4,e(!0);var s=Gh$1.transition;Gh$1.transition={};try{e(!1),o()}finally{C=i,Gh$1.transition=s}}function wi$1(){return Uh$1().memoizedState}function xi$1(e,o,i){var s=yi$1(e);if(i={lane:s,action:i,hasEagerState:!1,eagerState:null,next:null},zi$1(e))Ai$1(o,i);else if(i=hh$1(e,o,i,s),i!==null){var h=R();gi$1(i,e,s,h),Bi$1(i,o,s)}}function ii$1(e,o,i){var s=yi$1(e),h={lane:s,action:i,hasEagerState:!1,eagerState:null,next:null};if(zi$1(e))Ai$1(o,h);else{var a=e.alternate;if(e.lanes===0&&(a===null||a.lanes===0)&&(a=o.lastRenderedReducer,a!==null))try{var d=o.lastRenderedState,et=a(d,i);if(h.hasEagerState=!0,h.eagerState=et,He$1(et,d)){var $=o.interleaved;$===null?(h.next=h,gh$1(o)):(h.next=$.next,$.next=h),o.interleaved=h;return}}catch{}finally{}i=hh$1(e,o,h,s),i!==null&&(h=R(),gi$1(i,e,s,h),Bi$1(i,o,s))}}function zi$1(e){var o=e.alternate;return e===M||o!==null&&o===M}function Ai$1(e,o){Jh$1=Ih$1=!0;var i=e.pending;i===null?o.next=o:(o.next=i.next,i.next=o),e.pending=o}function Bi$1(e,o,i){if(i&4194240){var s=o.lanes;s&=e.pendingLanes,i|=s,o.lanes=i,Cc$1(e,i)}}var Rh$1={readContext:eh,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useInsertionEffect:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useDeferredValue:P,useTransition:P,useMutableSource:P,useSyncExternalStore:P,useId:P,unstable_isNewReconciler:!1},Oh$1={readContext:eh,useCallback:function(e,o){return Th$1().memoizedState=[e,o===void 0?null:o],e},useContext:eh,useEffect:mi$1,useImperativeHandle:function(e,o,i){return i=i!=null?i.concat([e]):null,ki$1(4194308,4,pi$1.bind(null,o,e),i)},useLayoutEffect:function(e,o){return ki$1(4194308,4,e,o)},useInsertionEffect:function(e,o){return ki$1(4,2,e,o)},useMemo:function(e,o){var i=Th$1();return o=o===void 0?null:o,e=e(),i.memoizedState=[e,o],e},useReducer:function(e,o,i){var s=Th$1();return o=i!==void 0?i(o):o,s.memoizedState=s.baseState=o,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:o},s.queue=e,e=e.dispatch=xi$1.bind(null,M,e),[s.memoizedState,e]},useRef:function(e){var o=Th$1();return e={current:e},o.memoizedState=e},useState:hi$1,useDebugValue:ri,useDeferredValue:function(e){return Th$1().memoizedState=e},useTransition:function(){var e=hi$1(!1),o=e[0];return e=vi$1.bind(null,e[1]),Th$1().memoizedState=e,[o,e]},useMutableSource:function(){},useSyncExternalStore:function(e,o,i){var s=M,h=Th$1();if(I){if(i===void 0)throw Error(p(407));i=i()}else{if(i=o(),Q===null)throw Error(p(349));Hh$1&30||di$1(s,o,i)}h.memoizedState=i;var a={value:i,getSnapshot:o};return h.queue=a,mi$1(ai$1.bind(null,s,a,e),[e]),s.flags|=2048,bi$1(9,ci$1.bind(null,s,a,i,o),void 0,null),i},useId:function(){var e=Th$1(),o=Q.identifierPrefix;if(I){var i=sg$1,s=rg$1;i=(s&~(1<<32-oc$1(s)-1)).toString(32)+i,o=":"+o+"R"+i,i=Kh$1++,0<i&&(o+="H"+i.toString(32)),o+=":"}else i=Lh++,o=":"+o+"r"+i.toString(32)+":";return e.memoizedState=o},unstable_isNewReconciler:!1},Ph$1={readContext:eh,useCallback:si$1,useContext:eh,useEffect:$h$1,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti,useReducer:Wh$1,useRef:ji$1,useState:function(){return Wh$1(Vh$1)},useDebugValue:ri,useDeferredValue:function(e){var o=Uh$1();return ui$1(o,N.memoizedState,e)},useTransition:function(){var e=Wh$1(Vh$1)[0],o=Uh$1().memoizedState;return[e,o]},useMutableSource:Yh$1,useSyncExternalStore:Zh$1,useId:wi$1,unstable_isNewReconciler:!1},Qh$1={readContext:eh,useCallback:si$1,useContext:eh,useEffect:$h$1,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti,useReducer:Xh$1,useRef:ji$1,useState:function(){return Xh$1(Vh$1)},useDebugValue:ri,useDeferredValue:function(e){var o=Uh$1();return N===null?o.memoizedState=e:ui$1(o,N.memoizedState,e)},useTransition:function(){var e=Xh$1(Vh$1)[0],o=Uh$1().memoizedState;return[e,o]},useMutableSource:Yh$1,useSyncExternalStore:Zh$1,useId:wi$1,unstable_isNewReconciler:!1};function Ci$1(e,o){if(e&&e.defaultProps){o=A({},o),e=e.defaultProps;for(var i in e)o[i]===void 0&&(o[i]=e[i]);return o}return o}function Di$1(e,o,i,s){o=e.memoizedState,i=i(s,o),i=i==null?o:A({},o,i),e.memoizedState=i,e.lanes===0&&(e.updateQueue.baseState=i)}var Ei$1={isMounted:function(e){return(e=e._reactInternals)?Vb$1(e)===e:!1},enqueueSetState:function(e,o,i){e=e._reactInternals;var s=R(),h=yi$1(e),a=mh$1(s,h);a.payload=o,i!=null&&(a.callback=i),o=nh(e,a,h),o!==null&&(gi$1(o,e,h,s),oh(o,e,h))},enqueueReplaceState:function(e,o,i){e=e._reactInternals;var s=R(),h=yi$1(e),a=mh$1(s,h);a.tag=1,a.payload=o,i!=null&&(a.callback=i),o=nh(e,a,h),o!==null&&(gi$1(o,e,h,s),oh(o,e,h))},enqueueForceUpdate:function(e,o){e=e._reactInternals;var i=R(),s=yi$1(e),h=mh$1(i,s);h.tag=2,o!=null&&(h.callback=o),o=nh(e,h,s),o!==null&&(gi$1(o,e,s,i),oh(o,e,s))}};function Fi$1(e,o,i,s,h,a,d){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(s,a,d):o.prototype&&o.prototype.isPureReactComponent?!Ie$1(i,s)||!Ie$1(h,a):!0}function Gi$1(e,o,i){var s=!1,h=Vf$1,a=o.contextType;return typeof a=="object"&&a!==null?a=eh(a):(h=Zf$1(o)?Xf$1:H$1.current,s=o.contextTypes,a=(s=s!=null)?Yf$1(e,h):Vf$1),o=new o(i,a),e.memoizedState=o.state!==null&&o.state!==void 0?o.state:null,o.updater=Ei$1,e.stateNode=o,o._reactInternals=e,s&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=h,e.__reactInternalMemoizedMaskedChildContext=a),o}function Hi$1(e,o,i,s){e=o.state,typeof o.componentWillReceiveProps=="function"&&o.componentWillReceiveProps(i,s),typeof o.UNSAFE_componentWillReceiveProps=="function"&&o.UNSAFE_componentWillReceiveProps(i,s),o.state!==e&&Ei$1.enqueueReplaceState(o,o.state,null)}function Ii$1(e,o,i,s){var h=e.stateNode;h.props=i,h.state=e.memoizedState,h.refs={},kh$1(e);var a=o.contextType;typeof a=="object"&&a!==null?h.context=eh(a):(a=Zf$1(o)?Xf$1:H$1.current,h.context=Yf$1(e,a)),h.state=e.memoizedState,a=o.getDerivedStateFromProps,typeof a=="function"&&(Di$1(e,o,a,i),h.state=e.memoizedState),typeof o.getDerivedStateFromProps=="function"||typeof h.getSnapshotBeforeUpdate=="function"||typeof h.UNSAFE_componentWillMount!="function"&&typeof h.componentWillMount!="function"||(o=h.state,typeof h.componentWillMount=="function"&&h.componentWillMount(),typeof h.UNSAFE_componentWillMount=="function"&&h.UNSAFE_componentWillMount(),o!==h.state&&Ei$1.enqueueReplaceState(h,h.state,null),qh(e,i,h,s),h.state=e.memoizedState),typeof h.componentDidMount=="function"&&(e.flags|=4194308)}function Ji$1(e,o){try{var i="",s=o;do i+=Pa(s),s=s.return;while(s);var h=i}catch(a){h=`
Error generating stack: `+a.message+`
`+a.stack}return{value:e,source:o,stack:h,digest:null}}function Ki$1(e,o,i){return{value:e,source:null,stack:i??null,digest:o??null}}function Li$1(e,o){try{console.error(o.value)}catch(i){setTimeout(function(){throw i})}}var Mi$1=typeof WeakMap=="function"?WeakMap:Map;function Ni$1(e,o,i){i=mh$1(-1,i),i.tag=3,i.payload={element:null};var s=o.value;return i.callback=function(){Oi$1||(Oi$1=!0,Pi$1=s),Li$1(e,o)},i}function Qi$1(e,o,i){i=mh$1(-1,i),i.tag=3;var s=e.type.getDerivedStateFromError;if(typeof s=="function"){var h=o.value;i.payload=function(){return s(h)},i.callback=function(){Li$1(e,o)}}var a=e.stateNode;return a!==null&&typeof a.componentDidCatch=="function"&&(i.callback=function(){Li$1(e,o),typeof s!="function"&&(Ri$1===null?Ri$1=new Set([this]):Ri$1.add(this));var d=o.stack;this.componentDidCatch(o.value,{componentStack:d!==null?d:""})}),i}function Si$1(e,o,i){var s=e.pingCache;if(s===null){s=e.pingCache=new Mi$1;var h=new Set;s.set(o,h)}else h=s.get(o),h===void 0&&(h=new Set,s.set(o,h));h.has(i)||(h.add(i),e=Ti$1.bind(null,e,o,i),o.then(e,e))}function Ui$1(e){do{var o;if((o=e.tag===13)&&(o=e.memoizedState,o=o!==null?o.dehydrated!==null:!0),o)return e;e=e.return}while(e!==null);return null}function Vi$1(e,o,i,s,h){return e.mode&1?(e.flags|=65536,e.lanes=h,e):(e===o?e.flags|=65536:(e.flags|=128,i.flags|=131072,i.flags&=-52805,i.tag===1&&(i.alternate===null?i.tag=17:(o=mh$1(-1,1),o.tag=2,nh(i,o,1))),i.lanes|=1),e)}var Wi$1=ua.ReactCurrentOwner,dh$1=!1;function Xi$1(e,o,i,s){o.child=e===null?Vg(o,null,i,s):Ug(o,e.child,i,s)}function Yi$1(e,o,i,s,h){i=i.render;var a=o.ref;return ch(o,h),s=Nh$1(e,o,i,s,a,h),i=Sh$1(),e!==null&&!dh$1?(o.updateQueue=e.updateQueue,o.flags&=-2053,e.lanes&=~h,Zi$1(e,o,h)):(I&&i&&vg$1(o),o.flags|=1,Xi$1(e,o,s,h),o.child)}function $i$1(e,o,i,s,h){if(e===null){var a=i.type;return typeof a=="function"&&!aj(a)&&a.defaultProps===void 0&&i.compare===null&&i.defaultProps===void 0?(o.tag=15,o.type=a,bj(e,o,a,s,h)):(e=Rg$1(i.type,null,s,o,o.mode,h),e.ref=o.ref,e.return=o,o.child=e)}if(a=e.child,!(e.lanes&h)){var d=a.memoizedProps;if(i=i.compare,i=i!==null?i:Ie$1,i(d,s)&&e.ref===o.ref)return Zi$1(e,o,h)}return o.flags|=1,e=Pg$1(a,s),e.ref=o.ref,e.return=o,o.child=e}function bj(e,o,i,s,h){if(e!==null){var a=e.memoizedProps;if(Ie$1(a,s)&&e.ref===o.ref)if(dh$1=!1,o.pendingProps=s=a,(e.lanes&h)!==0)e.flags&131072&&(dh$1=!0);else return o.lanes=e.lanes,Zi$1(e,o,h)}return cj(e,o,i,s,h)}function dj(e,o,i){var s=o.pendingProps,h=s.children,a=e!==null?e.memoizedState:null;if(s.mode==="hidden")if(!(o.mode&1))o.memoizedState={baseLanes:0,cachePool:null,transitions:null},G$1(ej,fj),fj|=i;else{if(!(i&1073741824))return e=a!==null?a.baseLanes|i:i,o.lanes=o.childLanes=1073741824,o.memoizedState={baseLanes:e,cachePool:null,transitions:null},o.updateQueue=null,G$1(ej,fj),fj|=e,null;o.memoizedState={baseLanes:0,cachePool:null,transitions:null},s=a!==null?a.baseLanes:i,G$1(ej,fj),fj|=s}else a!==null?(s=a.baseLanes|i,o.memoizedState=null):s=i,G$1(ej,fj),fj|=s;return Xi$1(e,o,h,i),o.child}function gj(e,o){var i=o.ref;(e===null&&i!==null||e!==null&&e.ref!==i)&&(o.flags|=512,o.flags|=2097152)}function cj(e,o,i,s,h){var a=Zf$1(i)?Xf$1:H$1.current;return a=Yf$1(o,a),ch(o,h),i=Nh$1(e,o,i,s,a,h),s=Sh$1(),e!==null&&!dh$1?(o.updateQueue=e.updateQueue,o.flags&=-2053,e.lanes&=~h,Zi$1(e,o,h)):(I&&s&&vg$1(o),o.flags|=1,Xi$1(e,o,i,h),o.child)}function hj(e,o,i,s,h){if(Zf$1(i)){var a=!0;cg(o)}else a=!1;if(ch(o,h),o.stateNode===null)ij(e,o),Gi$1(o,i,s),Ii$1(o,i,s,h),s=!0;else if(e===null){var d=o.stateNode,et=o.memoizedProps;d.props=et;var $=d.context,c=i.contextType;typeof c=="object"&&c!==null?c=eh(c):(c=Zf$1(i)?Xf$1:H$1.current,c=Yf$1(o,c));var b=i.getDerivedStateFromProps,g=typeof b=="function"||typeof d.getSnapshotBeforeUpdate=="function";g||typeof d.UNSAFE_componentWillReceiveProps!="function"&&typeof d.componentWillReceiveProps!="function"||(et!==s||$!==c)&&Hi$1(o,d,s,c),jh$1=!1;var nt=o.memoizedState;d.state=nt,qh(o,s,d,h),$=o.memoizedState,et!==s||nt!==$||Wf$1.current||jh$1?(typeof b=="function"&&(Di$1(o,i,b,s),$=o.memoizedState),(et=jh$1||Fi$1(o,i,et,s,nt,$,c))?(g||typeof d.UNSAFE_componentWillMount!="function"&&typeof d.componentWillMount!="function"||(typeof d.componentWillMount=="function"&&d.componentWillMount(),typeof d.UNSAFE_componentWillMount=="function"&&d.UNSAFE_componentWillMount()),typeof d.componentDidMount=="function"&&(o.flags|=4194308)):(typeof d.componentDidMount=="function"&&(o.flags|=4194308),o.memoizedProps=s,o.memoizedState=$),d.props=s,d.state=$,d.context=c,s=et):(typeof d.componentDidMount=="function"&&(o.flags|=4194308),s=!1)}else{d=o.stateNode,lh(e,o),et=o.memoizedProps,c=o.type===o.elementType?et:Ci$1(o.type,et),d.props=c,g=o.pendingProps,nt=d.context,$=i.contextType,typeof $=="object"&&$!==null?$=eh($):($=Zf$1(i)?Xf$1:H$1.current,$=Yf$1(o,$));var at=i.getDerivedStateFromProps;(b=typeof at=="function"||typeof d.getSnapshotBeforeUpdate=="function")||typeof d.UNSAFE_componentWillReceiveProps!="function"&&typeof d.componentWillReceiveProps!="function"||(et!==g||nt!==$)&&Hi$1(o,d,s,$),jh$1=!1,nt=o.memoizedState,d.state=nt,qh(o,s,d,h);var Ot=o.memoizedState;et!==g||nt!==Ot||Wf$1.current||jh$1?(typeof at=="function"&&(Di$1(o,i,at,s),Ot=o.memoizedState),(c=jh$1||Fi$1(o,i,c,s,nt,Ot,$)||!1)?(b||typeof d.UNSAFE_componentWillUpdate!="function"&&typeof d.componentWillUpdate!="function"||(typeof d.componentWillUpdate=="function"&&d.componentWillUpdate(s,Ot,$),typeof d.UNSAFE_componentWillUpdate=="function"&&d.UNSAFE_componentWillUpdate(s,Ot,$)),typeof d.componentDidUpdate=="function"&&(o.flags|=4),typeof d.getSnapshotBeforeUpdate=="function"&&(o.flags|=1024)):(typeof d.componentDidUpdate!="function"||et===e.memoizedProps&&nt===e.memoizedState||(o.flags|=4),typeof d.getSnapshotBeforeUpdate!="function"||et===e.memoizedProps&&nt===e.memoizedState||(o.flags|=1024),o.memoizedProps=s,o.memoizedState=Ot),d.props=s,d.state=Ot,d.context=$,s=c):(typeof d.componentDidUpdate!="function"||et===e.memoizedProps&&nt===e.memoizedState||(o.flags|=4),typeof d.getSnapshotBeforeUpdate!="function"||et===e.memoizedProps&&nt===e.memoizedState||(o.flags|=1024),s=!1)}return jj(e,o,i,s,a,h)}function jj(e,o,i,s,h,a){gj(e,o);var d=(o.flags&128)!==0;if(!s&&!d)return h&&dg$1(o,i,!1),Zi$1(e,o,a);s=o.stateNode,Wi$1.current=o;var et=d&&typeof i.getDerivedStateFromError!="function"?null:s.render();return o.flags|=1,e!==null&&d?(o.child=Ug(o,e.child,null,a),o.child=Ug(o,null,et,a)):Xi$1(e,o,et,a),o.memoizedState=s.state,h&&dg$1(o,i,!0),o.child}function kj(e){var o=e.stateNode;o.pendingContext?ag$1(e,o.pendingContext,o.pendingContext!==o.context):o.context&&ag$1(e,o.context,!1),yh$1(e,o.containerInfo)}function lj(e,o,i,s,h){return Ig$1(),Jg(h),o.flags|=256,Xi$1(e,o,i,s),o.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(e){return{baseLanes:e,cachePool:null,transitions:null}}function oj(e,o,i){var s=o.pendingProps,h=L.current,a=!1,d=(o.flags&128)!==0,et;if((et=d)||(et=e!==null&&e.memoizedState===null?!1:(h&2)!==0),et?(a=!0,o.flags&=-129):(e===null||e.memoizedState!==null)&&(h|=1),G$1(L,h&1),e===null)return Eg$1(o),e=o.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(o.mode&1?e.data==="$!"?o.lanes=8:o.lanes=1073741824:o.lanes=1,null):(d=s.children,e=s.fallback,a?(s=o.mode,a=o.child,d={mode:"hidden",children:d},!(s&1)&&a!==null?(a.childLanes=0,a.pendingProps=d):a=pj(d,s,0,null),e=Tg$1(e,s,i,null),a.return=o,e.return=o,a.sibling=e,o.child=a,o.child.memoizedState=nj(i),o.memoizedState=mj,e):qj(o,d));if(h=e.memoizedState,h!==null&&(et=h.dehydrated,et!==null))return rj(e,o,d,s,et,h,i);if(a){a=s.fallback,d=o.mode,h=e.child,et=h.sibling;var $={mode:"hidden",children:s.children};return!(d&1)&&o.child!==h?(s=o.child,s.childLanes=0,s.pendingProps=$,o.deletions=null):(s=Pg$1(h,$),s.subtreeFlags=h.subtreeFlags&14680064),et!==null?a=Pg$1(et,a):(a=Tg$1(a,d,i,null),a.flags|=2),a.return=o,s.return=o,s.sibling=a,o.child=s,s=a,a=o.child,d=e.child.memoizedState,d=d===null?nj(i):{baseLanes:d.baseLanes|i,cachePool:null,transitions:d.transitions},a.memoizedState=d,a.childLanes=e.childLanes&~i,o.memoizedState=mj,s}return a=e.child,e=a.sibling,s=Pg$1(a,{mode:"visible",children:s.children}),!(o.mode&1)&&(s.lanes=i),s.return=o,s.sibling=null,e!==null&&(i=o.deletions,i===null?(o.deletions=[e],o.flags|=16):i.push(e)),o.child=s,o.memoizedState=null,s}function qj(e,o){return o=pj({mode:"visible",children:o},e.mode,0,null),o.return=e,e.child=o}function sj(e,o,i,s){return s!==null&&Jg(s),Ug(o,e.child,null,i),e=qj(o,o.pendingProps.children),e.flags|=2,o.memoizedState=null,e}function rj(e,o,i,s,h,a,d){if(i)return o.flags&256?(o.flags&=-257,s=Ki$1(Error(p(422))),sj(e,o,d,s)):o.memoizedState!==null?(o.child=e.child,o.flags|=128,null):(a=s.fallback,h=o.mode,s=pj({mode:"visible",children:s.children},h,0,null),a=Tg$1(a,h,d,null),a.flags|=2,s.return=o,a.return=o,s.sibling=a,o.child=s,o.mode&1&&Ug(o,e.child,null,d),o.child.memoizedState=nj(d),o.memoizedState=mj,a);if(!(o.mode&1))return sj(e,o,d,null);if(h.data==="$!"){if(s=h.nextSibling&&h.nextSibling.dataset,s)var et=s.dgst;return s=et,a=Error(p(419)),s=Ki$1(a,s,void 0),sj(e,o,d,s)}if(et=(d&e.childLanes)!==0,dh$1||et){if(s=Q,s!==null){switch(d&-d){case 4:h=2;break;case 16:h=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:h=32;break;case 536870912:h=268435456;break;default:h=0}h=h&(s.suspendedLanes|d)?0:h,h!==0&&h!==a.retryLane&&(a.retryLane=h,ih(e,h),gi$1(s,e,h,-1))}return tj(),s=Ki$1(Error(p(421))),sj(e,o,d,s)}return h.data==="$?"?(o.flags|=128,o.child=e.child,o=uj.bind(null,e),h._reactRetry=o,null):(e=a.treeContext,yg$1=Lf$1(h.nextSibling),xg$1=o,I=!0,zg=null,e!==null&&(og$1[pg++]=rg$1,og$1[pg++]=sg$1,og$1[pg++]=qg,rg$1=e.id,sg$1=e.overflow,qg=o),o=qj(o,s.children),o.flags|=4096,o)}function vj(e,o,i){e.lanes|=o;var s=e.alternate;s!==null&&(s.lanes|=o),bh$1(e.return,o,i)}function wj(e,o,i,s,h){var a=e.memoizedState;a===null?e.memoizedState={isBackwards:o,rendering:null,renderingStartTime:0,last:s,tail:i,tailMode:h}:(a.isBackwards=o,a.rendering=null,a.renderingStartTime=0,a.last=s,a.tail=i,a.tailMode=h)}function xj(e,o,i){var s=o.pendingProps,h=s.revealOrder,a=s.tail;if(Xi$1(e,o,s.children,i),s=L.current,s&2)s=s&1|2,o.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=o.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&vj(e,i,o);else if(e.tag===19)vj(e,i,o);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===o)break e;for(;e.sibling===null;){if(e.return===null||e.return===o)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}s&=1}if(G$1(L,s),!(o.mode&1))o.memoizedState=null;else switch(h){case"forwards":for(i=o.child,h=null;i!==null;)e=i.alternate,e!==null&&Ch$1(e)===null&&(h=i),i=i.sibling;i=h,i===null?(h=o.child,o.child=null):(h=i.sibling,i.sibling=null),wj(o,!1,h,i,a);break;case"backwards":for(i=null,h=o.child,o.child=null;h!==null;){if(e=h.alternate,e!==null&&Ch$1(e)===null){o.child=h;break}e=h.sibling,h.sibling=i,i=h,h=e}wj(o,!0,i,null,a);break;case"together":wj(o,!1,null,null,void 0);break;default:o.memoizedState=null}return o.child}function ij(e,o){!(o.mode&1)&&e!==null&&(e.alternate=null,o.alternate=null,o.flags|=2)}function Zi$1(e,o,i){if(e!==null&&(o.dependencies=e.dependencies),rh$1|=o.lanes,!(i&o.childLanes))return null;if(e!==null&&o.child!==e.child)throw Error(p(153));if(o.child!==null){for(e=o.child,i=Pg$1(e,e.pendingProps),o.child=i,i.return=o;e.sibling!==null;)e=e.sibling,i=i.sibling=Pg$1(e,e.pendingProps),i.return=o;i.sibling=null}return o.child}function yj(e,o,i){switch(o.tag){case 3:kj(o),Ig$1();break;case 5:Ah(o);break;case 1:Zf$1(o.type)&&cg(o);break;case 4:yh$1(o,o.stateNode.containerInfo);break;case 10:var s=o.type._context,h=o.memoizedProps.value;G$1(Wg,s._currentValue),s._currentValue=h;break;case 13:if(s=o.memoizedState,s!==null)return s.dehydrated!==null?(G$1(L,L.current&1),o.flags|=128,null):i&o.child.childLanes?oj(e,o,i):(G$1(L,L.current&1),e=Zi$1(e,o,i),e!==null?e.sibling:null);G$1(L,L.current&1);break;case 19:if(s=(i&o.childLanes)!==0,e.flags&128){if(s)return xj(e,o,i);o.flags|=128}if(h=o.memoizedState,h!==null&&(h.rendering=null,h.tail=null,h.lastEffect=null),G$1(L,L.current),s)break;return null;case 22:case 23:return o.lanes=0,dj(e,o,i)}return Zi$1(e,o,i)}var zj,Aj,Bj,Cj;zj=function(e,o){for(var i=o.child;i!==null;){if(i.tag===5||i.tag===6)e.appendChild(i.stateNode);else if(i.tag!==4&&i.child!==null){i.child.return=i,i=i.child;continue}if(i===o)break;for(;i.sibling===null;){if(i.return===null||i.return===o)return;i=i.return}i.sibling.return=i.return,i=i.sibling}};Aj=function(){};Bj=function(e,o,i,s){var h=e.memoizedProps;if(h!==s){e=o.stateNode,xh$1(uh.current);var a=null;switch(i){case"input":h=Ya(e,h),s=Ya(e,s),a=[];break;case"select":h=A({},h,{value:void 0}),s=A({},s,{value:void 0}),a=[];break;case"textarea":h=gb$1(e,h),s=gb$1(e,s),a=[];break;default:typeof h.onClick!="function"&&typeof s.onClick=="function"&&(e.onclick=Bf$1)}ub$1(i,s);var d;i=null;for(c in h)if(!s.hasOwnProperty(c)&&h.hasOwnProperty(c)&&h[c]!=null)if(c==="style"){var et=h[c];for(d in et)et.hasOwnProperty(d)&&(i||(i={}),i[d]="")}else c!=="dangerouslySetInnerHTML"&&c!=="children"&&c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(ea.hasOwnProperty(c)?a||(a=[]):(a=a||[]).push(c,null));for(c in s){var $=s[c];if(et=h?.[c],s.hasOwnProperty(c)&&$!==et&&($!=null||et!=null))if(c==="style")if(et){for(d in et)!et.hasOwnProperty(d)||$&&$.hasOwnProperty(d)||(i||(i={}),i[d]="");for(d in $)$.hasOwnProperty(d)&&et[d]!==$[d]&&(i||(i={}),i[d]=$[d])}else i||(a||(a=[]),a.push(c,i)),i=$;else c==="dangerouslySetInnerHTML"?($=$?$.__html:void 0,et=et?et.__html:void 0,$!=null&&et!==$&&(a=a||[]).push(c,$)):c==="children"?typeof $!="string"&&typeof $!="number"||(a=a||[]).push(c,""+$):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&(ea.hasOwnProperty(c)?($!=null&&c==="onScroll"&&D$1("scroll",e),a||et===$||(a=[])):(a=a||[]).push(c,$))}i&&(a=a||[]).push("style",i);var c=a;(o.updateQueue=c)&&(o.flags|=4)}};Cj=function(e,o,i,s){i!==s&&(o.flags|=4)};function Dj(e,o){if(!I)switch(e.tailMode){case"hidden":o=e.tail;for(var i=null;o!==null;)o.alternate!==null&&(i=o),o=o.sibling;i===null?e.tail=null:i.sibling=null;break;case"collapsed":i=e.tail;for(var s=null;i!==null;)i.alternate!==null&&(s=i),i=i.sibling;s===null?o||e.tail===null?e.tail=null:e.tail.sibling=null:s.sibling=null}}function S(e){var o=e.alternate!==null&&e.alternate.child===e.child,i=0,s=0;if(o)for(var h=e.child;h!==null;)i|=h.lanes|h.childLanes,s|=h.subtreeFlags&14680064,s|=h.flags&14680064,h.return=e,h=h.sibling;else for(h=e.child;h!==null;)i|=h.lanes|h.childLanes,s|=h.subtreeFlags,s|=h.flags,h.return=e,h=h.sibling;return e.subtreeFlags|=s,e.childLanes=i,o}function Ej(e,o,i){var s=o.pendingProps;switch(wg$1(o),o.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(o),null;case 1:return Zf$1(o.type)&&$f$1(),S(o),null;case 3:return s=o.stateNode,zh$1(),E(Wf$1),E(H$1),Eh$1(),s.pendingContext&&(s.context=s.pendingContext,s.pendingContext=null),(e===null||e.child===null)&&(Gg$1(o)?o.flags|=4:e===null||e.memoizedState.isDehydrated&&!(o.flags&256)||(o.flags|=1024,zg!==null&&(Fj(zg),zg=null))),Aj(e,o),S(o),null;case 5:Bh$1(o);var h=xh$1(wh$1.current);if(i=o.type,e!==null&&o.stateNode!=null)Bj(e,o,i,s,h),e.ref!==o.ref&&(o.flags|=512,o.flags|=2097152);else{if(!s){if(o.stateNode===null)throw Error(p(166));return S(o),null}if(e=xh$1(uh.current),Gg$1(o)){s=o.stateNode,i=o.type;var a=o.memoizedProps;switch(s[Of$1]=o,s[Pf$1]=a,e=(o.mode&1)!==0,i){case"dialog":D$1("cancel",s),D$1("close",s);break;case"iframe":case"object":case"embed":D$1("load",s);break;case"video":case"audio":for(h=0;h<lf$1.length;h++)D$1(lf$1[h],s);break;case"source":D$1("error",s);break;case"img":case"image":case"link":D$1("error",s),D$1("load",s);break;case"details":D$1("toggle",s);break;case"input":Za$1(s,a),D$1("invalid",s);break;case"select":s._wrapperState={wasMultiple:!!a.multiple},D$1("invalid",s);break;case"textarea":hb$1(s,a),D$1("invalid",s)}ub$1(i,a),h=null;for(var d in a)if(a.hasOwnProperty(d)){var et=a[d];d==="children"?typeof et=="string"?s.textContent!==et&&(a.suppressHydrationWarning!==!0&&Af$1(s.textContent,et,e),h=["children",et]):typeof et=="number"&&s.textContent!==""+et&&(a.suppressHydrationWarning!==!0&&Af$1(s.textContent,et,e),h=["children",""+et]):ea.hasOwnProperty(d)&&et!=null&&d==="onScroll"&&D$1("scroll",s)}switch(i){case"input":Va(s),db$2(s,a,!0);break;case"textarea":Va(s),jb$1(s);break;case"select":case"option":break;default:typeof a.onClick=="function"&&(s.onclick=Bf$1)}s=h,o.updateQueue=s,s!==null&&(o.flags|=4)}else{d=h.nodeType===9?h:h.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=kb$1(i)),e==="http://www.w3.org/1999/xhtml"?i==="script"?(e=d.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof s.is=="string"?e=d.createElement(i,{is:s.is}):(e=d.createElement(i),i==="select"&&(d=e,s.multiple?d.multiple=!0:s.size&&(d.size=s.size))):e=d.createElementNS(e,i),e[Of$1]=o,e[Pf$1]=s,zj(e,o,!1,!1),o.stateNode=e;e:{switch(d=vb$1(i,s),i){case"dialog":D$1("cancel",e),D$1("close",e),h=s;break;case"iframe":case"object":case"embed":D$1("load",e),h=s;break;case"video":case"audio":for(h=0;h<lf$1.length;h++)D$1(lf$1[h],e);h=s;break;case"source":D$1("error",e),h=s;break;case"img":case"image":case"link":D$1("error",e),D$1("load",e),h=s;break;case"details":D$1("toggle",e),h=s;break;case"input":Za$1(e,s),h=Ya(e,s),D$1("invalid",e);break;case"option":h=s;break;case"select":e._wrapperState={wasMultiple:!!s.multiple},h=A({},s,{value:void 0}),D$1("invalid",e);break;case"textarea":hb$1(e,s),h=gb$1(e,s),D$1("invalid",e);break;default:h=s}ub$1(i,h),et=h;for(a in et)if(et.hasOwnProperty(a)){var $=et[a];a==="style"?sb$1(e,$):a==="dangerouslySetInnerHTML"?($=$?$.__html:void 0,$!=null&&nb$1(e,$)):a==="children"?typeof $=="string"?(i!=="textarea"||$!=="")&&ob$1(e,$):typeof $=="number"&&ob$1(e,""+$):a!=="suppressContentEditableWarning"&&a!=="suppressHydrationWarning"&&a!=="autoFocus"&&(ea.hasOwnProperty(a)?$!=null&&a==="onScroll"&&D$1("scroll",e):$!=null&&ta(e,a,$,d))}switch(i){case"input":Va(e),db$2(e,s,!1);break;case"textarea":Va(e),jb$1(e);break;case"option":s.value!=null&&e.setAttribute("value",""+Sa(s.value));break;case"select":e.multiple=!!s.multiple,a=s.value,a!=null?fb$1(e,!!s.multiple,a,!1):s.defaultValue!=null&&fb$1(e,!!s.multiple,s.defaultValue,!0);break;default:typeof h.onClick=="function"&&(e.onclick=Bf$1)}switch(i){case"button":case"input":case"select":case"textarea":s=!!s.autoFocus;break e;case"img":s=!0;break e;default:s=!1}}s&&(o.flags|=4)}o.ref!==null&&(o.flags|=512,o.flags|=2097152)}return S(o),null;case 6:if(e&&o.stateNode!=null)Cj(e,o,e.memoizedProps,s);else{if(typeof s!="string"&&o.stateNode===null)throw Error(p(166));if(i=xh$1(wh$1.current),xh$1(uh.current),Gg$1(o)){if(s=o.stateNode,i=o.memoizedProps,s[Of$1]=o,(a=s.nodeValue!==i)&&(e=xg$1,e!==null))switch(e.tag){case 3:Af$1(s.nodeValue,i,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&Af$1(s.nodeValue,i,(e.mode&1)!==0)}a&&(o.flags|=4)}else s=(i.nodeType===9?i:i.ownerDocument).createTextNode(s),s[Of$1]=o,o.stateNode=s}return S(o),null;case 13:if(E(L),s=o.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(I&&yg$1!==null&&o.mode&1&&!(o.flags&128))Hg(),Ig$1(),o.flags|=98560,a=!1;else if(a=Gg$1(o),s!==null&&s.dehydrated!==null){if(e===null){if(!a)throw Error(p(318));if(a=o.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(p(317));a[Of$1]=o}else Ig$1(),!(o.flags&128)&&(o.memoizedState=null),o.flags|=4;S(o),a=!1}else zg!==null&&(Fj(zg),zg=null),a=!0;if(!a)return o.flags&65536?o:null}return o.flags&128?(o.lanes=i,o):(s=s!==null,s!==(e!==null&&e.memoizedState!==null)&&s&&(o.child.flags|=8192,o.mode&1&&(e===null||L.current&1?T$1===0&&(T$1=3):tj())),o.updateQueue!==null&&(o.flags|=4),S(o),null);case 4:return zh$1(),Aj(e,o),e===null&&sf$1(o.stateNode.containerInfo),S(o),null;case 10:return ah(o.type._context),S(o),null;case 17:return Zf$1(o.type)&&$f$1(),S(o),null;case 19:if(E(L),a=o.memoizedState,a===null)return S(o),null;if(s=(o.flags&128)!==0,d=a.rendering,d===null)if(s)Dj(a,!1);else{if(T$1!==0||e!==null&&e.flags&128)for(e=o.child;e!==null;){if(d=Ch$1(e),d!==null){for(o.flags|=128,Dj(a,!1),s=d.updateQueue,s!==null&&(o.updateQueue=s,o.flags|=4),o.subtreeFlags=0,s=i,i=o.child;i!==null;)a=i,e=s,a.flags&=14680066,d=a.alternate,d===null?(a.childLanes=0,a.lanes=e,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=d.childLanes,a.lanes=d.lanes,a.child=d.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=d.memoizedProps,a.memoizedState=d.memoizedState,a.updateQueue=d.updateQueue,a.type=d.type,e=d.dependencies,a.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),i=i.sibling;return G$1(L,L.current&1|2),o.child}e=e.sibling}a.tail!==null&&B$1()>Gj&&(o.flags|=128,s=!0,Dj(a,!1),o.lanes=4194304)}else{if(!s)if(e=Ch$1(d),e!==null){if(o.flags|=128,s=!0,i=e.updateQueue,i!==null&&(o.updateQueue=i,o.flags|=4),Dj(a,!0),a.tail===null&&a.tailMode==="hidden"&&!d.alternate&&!I)return S(o),null}else 2*B$1()-a.renderingStartTime>Gj&&i!==1073741824&&(o.flags|=128,s=!0,Dj(a,!1),o.lanes=4194304);a.isBackwards?(d.sibling=o.child,o.child=d):(i=a.last,i!==null?i.sibling=d:o.child=d,a.last=d)}return a.tail!==null?(o=a.tail,a.rendering=o,a.tail=o.sibling,a.renderingStartTime=B$1(),o.sibling=null,i=L.current,G$1(L,s?i&1|2:i&1),o):(S(o),null);case 22:case 23:return Hj(),s=o.memoizedState!==null,e!==null&&e.memoizedState!==null!==s&&(o.flags|=8192),s&&o.mode&1?fj&1073741824&&(S(o),o.subtreeFlags&6&&(o.flags|=8192)):S(o),null;case 24:return null;case 25:return null}throw Error(p(156,o.tag))}function Ij(e,o){switch(wg$1(o),o.tag){case 1:return Zf$1(o.type)&&$f$1(),e=o.flags,e&65536?(o.flags=e&-65537|128,o):null;case 3:return zh$1(),E(Wf$1),E(H$1),Eh$1(),e=o.flags,e&65536&&!(e&128)?(o.flags=e&-65537|128,o):null;case 5:return Bh$1(o),null;case 13:if(E(L),e=o.memoizedState,e!==null&&e.dehydrated!==null){if(o.alternate===null)throw Error(p(340));Ig$1()}return e=o.flags,e&65536?(o.flags=e&-65537|128,o):null;case 19:return E(L),null;case 4:return zh$1(),null;case 10:return ah(o.type._context),null;case 22:case 23:return Hj(),null;case 24:return null;default:return null}}var Jj=!1,U=!1,Kj=typeof WeakSet=="function"?WeakSet:Set,V=null;function Lj(e,o){var i=e.ref;if(i!==null)if(typeof i=="function")try{i(null)}catch(s){W$1(e,o,s)}else i.current=null}function Mj(e,o,i){try{i()}catch(s){W$1(e,o,s)}}var Nj=!1;function Oj(e,o){if(Cf$1=dd,e=Me$1(),Ne(e)){if("selectionStart"in e)var i={start:e.selectionStart,end:e.selectionEnd};else e:{i=(i=e.ownerDocument)&&i.defaultView||window;var s=i.getSelection&&i.getSelection();if(s&&s.rangeCount!==0){i=s.anchorNode;var h=s.anchorOffset,a=s.focusNode;s=s.focusOffset;try{i.nodeType,a.nodeType}catch{i=null;break e}var d=0,et=-1,$=-1,c=0,b=0,g=e,nt=null;t:for(;;){for(var at;g!==i||h!==0&&g.nodeType!==3||(et=d+h),g!==a||s!==0&&g.nodeType!==3||($=d+s),g.nodeType===3&&(d+=g.nodeValue.length),(at=g.firstChild)!==null;)nt=g,g=at;for(;;){if(g===e)break t;if(nt===i&&++c===h&&(et=d),nt===a&&++b===s&&($=d),(at=g.nextSibling)!==null)break;g=nt,nt=g.parentNode}g=at}i=et===-1||$===-1?null:{start:et,end:$}}else i=null}i=i||{start:0,end:0}}else i=null;for(Df$1={focusedElem:e,selectionRange:i},dd=!1,V=o;V!==null;)if(o=V,e=o.child,(o.subtreeFlags&1028)!==0&&e!==null)e.return=o,V=e;else for(;V!==null;){o=V;try{var Ot=o.alternate;if(o.flags&1024)switch(o.tag){case 0:case 11:case 15:break;case 1:if(Ot!==null){var At=Ot.memoizedProps,Ct=Ot.memoizedState,St=o.stateNode,xt=St.getSnapshotBeforeUpdate(o.elementType===o.type?At:Ci$1(o.type,At),Ct);St.__reactInternalSnapshotBeforeUpdate=xt}break;case 3:var Dt=o.stateNode.containerInfo;Dt.nodeType===1?Dt.textContent="":Dt.nodeType===9&&Dt.documentElement&&Dt.removeChild(Dt.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163))}}catch(Qt){W$1(o,o.return,Qt)}if(e=o.sibling,e!==null){e.return=o.return,V=e;break}V=o.return}return Ot=Nj,Nj=!1,Ot}function Pj(e,o,i){var s=o.updateQueue;if(s=s!==null?s.lastEffect:null,s!==null){var h=s=s.next;do{if((h.tag&e)===e){var a=h.destroy;h.destroy=void 0,a!==void 0&&Mj(o,i,a)}h=h.next}while(h!==s)}}function Qj(e,o){if(o=o.updateQueue,o=o!==null?o.lastEffect:null,o!==null){var i=o=o.next;do{if((i.tag&e)===e){var s=i.create;i.destroy=s()}i=i.next}while(i!==o)}}function Rj(e){var o=e.ref;if(o!==null){var i=e.stateNode;switch(e.tag){case 5:e=i;break;default:e=i}typeof o=="function"?o(e):o.current=e}}function Sj(e){var o=e.alternate;o!==null&&(e.alternate=null,Sj(o)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(o=e.stateNode,o!==null&&(delete o[Of$1],delete o[Pf$1],delete o[of$1],delete o[Qf$1],delete o[Rf$1])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function Tj(e){return e.tag===5||e.tag===3||e.tag===4}function Uj(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||Tj(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function Vj(e,o,i){var s=e.tag;if(s===5||s===6)e=e.stateNode,o?i.nodeType===8?i.parentNode.insertBefore(e,o):i.insertBefore(e,o):(i.nodeType===8?(o=i.parentNode,o.insertBefore(e,i)):(o=i,o.appendChild(e)),i=i._reactRootContainer,i!=null||o.onclick!==null||(o.onclick=Bf$1));else if(s!==4&&(e=e.child,e!==null))for(Vj(e,o,i),e=e.sibling;e!==null;)Vj(e,o,i),e=e.sibling}function Wj(e,o,i){var s=e.tag;if(s===5||s===6)e=e.stateNode,o?i.insertBefore(e,o):i.appendChild(e);else if(s!==4&&(e=e.child,e!==null))for(Wj(e,o,i),e=e.sibling;e!==null;)Wj(e,o,i),e=e.sibling}var X=null,Xj=!1;function Yj(e,o,i){for(i=i.child;i!==null;)Zj(e,o,i),i=i.sibling}function Zj(e,o,i){if(lc$1&&typeof lc$1.onCommitFiberUnmount=="function")try{lc$1.onCommitFiberUnmount(kc$1,i)}catch{}switch(i.tag){case 5:U||Lj(i,o);case 6:var s=X,h=Xj;X=null,Yj(e,o,i),X=s,Xj=h,X!==null&&(Xj?(e=X,i=i.stateNode,e.nodeType===8?e.parentNode.removeChild(i):e.removeChild(i)):X.removeChild(i.stateNode));break;case 18:X!==null&&(Xj?(e=X,i=i.stateNode,e.nodeType===8?Kf$1(e.parentNode,i):e.nodeType===1&&Kf$1(e,i),bd(e)):Kf$1(X,i.stateNode));break;case 4:s=X,h=Xj,X=i.stateNode.containerInfo,Xj=!0,Yj(e,o,i),X=s,Xj=h;break;case 0:case 11:case 14:case 15:if(!U&&(s=i.updateQueue,s!==null&&(s=s.lastEffect,s!==null))){h=s=s.next;do{var a=h,d=a.destroy;a=a.tag,d!==void 0&&(a&2||a&4)&&Mj(i,o,d),h=h.next}while(h!==s)}Yj(e,o,i);break;case 1:if(!U&&(Lj(i,o),s=i.stateNode,typeof s.componentWillUnmount=="function"))try{s.props=i.memoizedProps,s.state=i.memoizedState,s.componentWillUnmount()}catch(et){W$1(i,o,et)}Yj(e,o,i);break;case 21:Yj(e,o,i);break;case 22:i.mode&1?(U=(s=U)||i.memoizedState!==null,Yj(e,o,i),U=s):Yj(e,o,i);break;default:Yj(e,o,i)}}function ak(e){var o=e.updateQueue;if(o!==null){e.updateQueue=null;var i=e.stateNode;i===null&&(i=e.stateNode=new Kj),o.forEach(function(s){var h=bk.bind(null,e,s);i.has(s)||(i.add(s),s.then(h,h))})}}function ck(e,o){var i=o.deletions;if(i!==null)for(var s=0;s<i.length;s++){var h=i[s];try{var a=e,d=o,et=d;e:for(;et!==null;){switch(et.tag){case 5:X=et.stateNode,Xj=!1;break e;case 3:X=et.stateNode.containerInfo,Xj=!0;break e;case 4:X=et.stateNode.containerInfo,Xj=!0;break e}et=et.return}if(X===null)throw Error(p(160));Zj(a,d,h),X=null,Xj=!1;var $=h.alternate;$!==null&&($.return=null),h.return=null}catch(c){W$1(h,o,c)}}if(o.subtreeFlags&12854)for(o=o.child;o!==null;)dk(o,e),o=o.sibling}function dk(e,o){var i=e.alternate,s=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ck(o,e),ek(e),s&4){try{Pj(3,e,e.return),Qj(3,e)}catch(At){W$1(e,e.return,At)}try{Pj(5,e,e.return)}catch(At){W$1(e,e.return,At)}}break;case 1:ck(o,e),ek(e),s&512&&i!==null&&Lj(i,i.return);break;case 5:if(ck(o,e),ek(e),s&512&&i!==null&&Lj(i,i.return),e.flags&32){var h=e.stateNode;try{ob$1(h,"")}catch(At){W$1(e,e.return,At)}}if(s&4&&(h=e.stateNode,h!=null)){var a=e.memoizedProps,d=i!==null?i.memoizedProps:a,et=e.type,$=e.updateQueue;if(e.updateQueue=null,$!==null)try{et==="input"&&a.type==="radio"&&a.name!=null&&ab$1(h,a),vb$1(et,d);var c=vb$1(et,a);for(d=0;d<$.length;d+=2){var b=$[d],g=$[d+1];b==="style"?sb$1(h,g):b==="dangerouslySetInnerHTML"?nb$1(h,g):b==="children"?ob$1(h,g):ta(h,b,g,c)}switch(et){case"input":bb$1(h,a);break;case"textarea":ib$1(h,a);break;case"select":var nt=h._wrapperState.wasMultiple;h._wrapperState.wasMultiple=!!a.multiple;var at=a.value;at!=null?fb$1(h,!!a.multiple,at,!1):nt!==!!a.multiple&&(a.defaultValue!=null?fb$1(h,!!a.multiple,a.defaultValue,!0):fb$1(h,!!a.multiple,a.multiple?[]:"",!1))}h[Pf$1]=a}catch(At){W$1(e,e.return,At)}}break;case 6:if(ck(o,e),ek(e),s&4){if(e.stateNode===null)throw Error(p(162));h=e.stateNode,a=e.memoizedProps;try{h.nodeValue=a}catch(At){W$1(e,e.return,At)}}break;case 3:if(ck(o,e),ek(e),s&4&&i!==null&&i.memoizedState.isDehydrated)try{bd(o.containerInfo)}catch(At){W$1(e,e.return,At)}break;case 4:ck(o,e),ek(e);break;case 13:ck(o,e),ek(e),h=e.child,h.flags&8192&&(a=h.memoizedState!==null,h.stateNode.isHidden=a,!a||h.alternate!==null&&h.alternate.memoizedState!==null||(fk=B$1())),s&4&&ak(e);break;case 22:if(b=i!==null&&i.memoizedState!==null,e.mode&1?(U=(c=U)||b,ck(o,e),U=c):ck(o,e),ek(e),s&8192){if(c=e.memoizedState!==null,(e.stateNode.isHidden=c)&&!b&&e.mode&1)for(V=e,b=e.child;b!==null;){for(g=V=b;V!==null;){switch(nt=V,at=nt.child,nt.tag){case 0:case 11:case 14:case 15:Pj(4,nt,nt.return);break;case 1:Lj(nt,nt.return);var Ot=nt.stateNode;if(typeof Ot.componentWillUnmount=="function"){s=nt,i=nt.return;try{o=s,Ot.props=o.memoizedProps,Ot.state=o.memoizedState,Ot.componentWillUnmount()}catch(At){W$1(s,i,At)}}break;case 5:Lj(nt,nt.return);break;case 22:if(nt.memoizedState!==null){gk(g);continue}}at!==null?(at.return=nt,V=at):gk(g)}b=b.sibling}e:for(b=null,g=e;;){if(g.tag===5){if(b===null){b=g;try{h=g.stateNode,c?(a=h.style,typeof a.setProperty=="function"?a.setProperty("display","none","important"):a.display="none"):(et=g.stateNode,$=g.memoizedProps.style,d=$!=null&&$.hasOwnProperty("display")?$.display:null,et.style.display=rb$1("display",d))}catch(At){W$1(e,e.return,At)}}}else if(g.tag===6){if(b===null)try{g.stateNode.nodeValue=c?"":g.memoizedProps}catch(At){W$1(e,e.return,At)}}else if((g.tag!==22&&g.tag!==23||g.memoizedState===null||g===e)&&g.child!==null){g.child.return=g,g=g.child;continue}if(g===e)break e;for(;g.sibling===null;){if(g.return===null||g.return===e)break e;b===g&&(b=null),g=g.return}b===g&&(b=null),g.sibling.return=g.return,g=g.sibling}}break;case 19:ck(o,e),ek(e),s&4&&ak(e);break;case 21:break;default:ck(o,e),ek(e)}}function ek(e){var o=e.flags;if(o&2){try{e:{for(var i=e.return;i!==null;){if(Tj(i)){var s=i;break e}i=i.return}throw Error(p(160))}switch(s.tag){case 5:var h=s.stateNode;s.flags&32&&(ob$1(h,""),s.flags&=-33);var a=Uj(e);Wj(e,a,h);break;case 3:case 4:var d=s.stateNode.containerInfo,et=Uj(e);Vj(e,et,d);break;default:throw Error(p(161))}}catch($){W$1(e,e.return,$)}e.flags&=-3}o&4096&&(e.flags&=-4097)}function hk(e,o,i){V=e,ik(e)}function ik(e,o,i){for(var s=(e.mode&1)!==0;V!==null;){var h=V,a=h.child;if(h.tag===22&&s){var d=h.memoizedState!==null||Jj;if(!d){var et=h.alternate,$=et!==null&&et.memoizedState!==null||U;et=Jj;var c=U;if(Jj=d,(U=$)&&!c)for(V=h;V!==null;)d=V,$=d.child,d.tag===22&&d.memoizedState!==null?jk(h):$!==null?($.return=d,V=$):jk(h);for(;a!==null;)V=a,ik(a),a=a.sibling;V=h,Jj=et,U=c}kk(e)}else h.subtreeFlags&8772&&a!==null?(a.return=h,V=a):kk(e)}}function kk(e){for(;V!==null;){var o=V;if(o.flags&8772){var i=o.alternate;try{if(o.flags&8772)switch(o.tag){case 0:case 11:case 15:U||Qj(5,o);break;case 1:var s=o.stateNode;if(o.flags&4&&!U)if(i===null)s.componentDidMount();else{var h=o.elementType===o.type?i.memoizedProps:Ci$1(o.type,i.memoizedProps);s.componentDidUpdate(h,i.memoizedState,s.__reactInternalSnapshotBeforeUpdate)}var a=o.updateQueue;a!==null&&sh(o,a,s);break;case 3:var d=o.updateQueue;if(d!==null){if(i=null,o.child!==null)switch(o.child.tag){case 5:i=o.child.stateNode;break;case 1:i=o.child.stateNode}sh(o,d,i)}break;case 5:var et=o.stateNode;if(i===null&&o.flags&4){i=et;var $=o.memoizedProps;switch(o.type){case"button":case"input":case"select":case"textarea":$.autoFocus&&i.focus();break;case"img":$.src&&(i.src=$.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(o.memoizedState===null){var c=o.alternate;if(c!==null){var b=c.memoizedState;if(b!==null){var g=b.dehydrated;g!==null&&bd(g)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p(163))}U||o.flags&512&&Rj(o)}catch(nt){W$1(o,o.return,nt)}}if(o===e){V=null;break}if(i=o.sibling,i!==null){i.return=o.return,V=i;break}V=o.return}}function gk(e){for(;V!==null;){var o=V;if(o===e){V=null;break}var i=o.sibling;if(i!==null){i.return=o.return,V=i;break}V=o.return}}function jk(e){for(;V!==null;){var o=V;try{switch(o.tag){case 0:case 11:case 15:var i=o.return;try{Qj(4,o)}catch($){W$1(o,i,$)}break;case 1:var s=o.stateNode;if(typeof s.componentDidMount=="function"){var h=o.return;try{s.componentDidMount()}catch($){W$1(o,h,$)}}var a=o.return;try{Rj(o)}catch($){W$1(o,a,$)}break;case 5:var d=o.return;try{Rj(o)}catch($){W$1(o,d,$)}}}catch($){W$1(o,o.return,$)}if(o===e){V=null;break}var et=o.sibling;if(et!==null){et.return=o.return,V=et;break}V=o.return}}var lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K=0,Q=null,Y$1=null,Z=0,fj=0,ej=Uf$1(0),T$1=0,pk=null,rh$1=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=1/0,uk=null,Oi$1=!1,Pi$1=null,Ri$1=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R(){return K&6?B$1():Ak!==-1?Ak:Ak=B$1()}function yi$1(e){return e.mode&1?K&2&&Z!==0?Z&-Z:Kg.transition!==null?(Bk===0&&(Bk=yc$1()),Bk):(e=C,e!==0||(e=window.event,e=e===void 0?16:jd$1(e.type)),e):1}function gi$1(e,o,i,s){if(50<yk)throw yk=0,zk=null,Error(p(185));Ac$1(e,i,s),(!(K&2)||e!==Q)&&(e===Q&&(!(K&2)&&(qk|=i),T$1===4&&Ck(e,Z)),Dk(e,s),i===1&&K===0&&!(o.mode&1)&&(Gj=B$1()+500,fg$1&&jg()))}function Dk(e,o){var i=e.callbackNode;wc$1(e,o);var s=uc$1(e,e===Q?Z:0);if(s===0)i!==null&&bc$1(i),e.callbackNode=null,e.callbackPriority=0;else if(o=s&-s,e.callbackPriority!==o){if(i!=null&&bc$1(i),o===1)e.tag===0?ig$1(Ek.bind(null,e)):hg$1(Ek.bind(null,e)),Jf$1(function(){!(K&6)&&jg()}),i=null;else{switch(Dc$1(s)){case 1:i=fc$1;break;case 4:i=gc$1;break;case 16:i=hc$1;break;case 536870912:i=jc$1;break;default:i=hc$1}i=Fk(i,Gk.bind(null,e))}e.callbackPriority=o,e.callbackNode=i}}function Gk(e,o){if(Ak=-1,Bk=0,K&6)throw Error(p(327));var i=e.callbackNode;if(Hk()&&e.callbackNode!==i)return null;var s=uc$1(e,e===Q?Z:0);if(s===0)return null;if(s&30||s&e.expiredLanes||o)o=Ik(e,s);else{o=s;var h=K;K|=2;var a=Jk();(Q!==e||Z!==o)&&(uk=null,Gj=B$1()+500,Kk(e,o));do try{Lk();break}catch(et){Mk(e,et)}while(!0);$g$1(),mk.current=a,K=h,Y$1!==null?o=0:(Q=null,Z=0,o=T$1)}if(o!==0){if(o===2&&(h=xc$1(e),h!==0&&(s=h,o=Nk(e,h))),o===1)throw i=pk,Kk(e,0),Ck(e,s),Dk(e,B$1()),i;if(o===6)Ck(e,s);else{if(h=e.current.alternate,!(s&30)&&!Ok(h)&&(o=Ik(e,s),o===2&&(a=xc$1(e),a!==0&&(s=a,o=Nk(e,a))),o===1))throw i=pk,Kk(e,0),Ck(e,s),Dk(e,B$1()),i;switch(e.finishedWork=h,e.finishedLanes=s,o){case 0:case 1:throw Error(p(345));case 2:Pk(e,tk,uk);break;case 3:if(Ck(e,s),(s&130023424)===s&&(o=fk+500-B$1(),10<o)){if(uc$1(e,0)!==0)break;if(h=e.suspendedLanes,(h&s)!==s){R(),e.pingedLanes|=e.suspendedLanes&h;break}e.timeoutHandle=Ff$1(Pk.bind(null,e,tk,uk),o);break}Pk(e,tk,uk);break;case 4:if(Ck(e,s),(s&4194240)===s)break;for(o=e.eventTimes,h=-1;0<s;){var d=31-oc$1(s);a=1<<d,d=o[d],d>h&&(h=d),s&=~a}if(s=h,s=B$1()-s,s=(120>s?120:480>s?480:1080>s?1080:1920>s?1920:3e3>s?3e3:4320>s?4320:1960*lk(s/1960))-s,10<s){e.timeoutHandle=Ff$1(Pk.bind(null,e,tk,uk),s);break}Pk(e,tk,uk);break;case 5:Pk(e,tk,uk);break;default:throw Error(p(329))}}}return Dk(e,B$1()),e.callbackNode===i?Gk.bind(null,e):null}function Nk(e,o){var i=sk;return e.current.memoizedState.isDehydrated&&(Kk(e,o).flags|=256),e=Ik(e,o),e!==2&&(o=tk,tk=i,o!==null&&Fj(o)),e}function Fj(e){tk===null?tk=e:tk.push.apply(tk,e)}function Ok(e){for(var o=e;;){if(o.flags&16384){var i=o.updateQueue;if(i!==null&&(i=i.stores,i!==null))for(var s=0;s<i.length;s++){var h=i[s],a=h.getSnapshot;h=h.value;try{if(!He$1(a(),h))return!1}catch{return!1}}}if(i=o.child,o.subtreeFlags&16384&&i!==null)i.return=o,o=i;else{if(o===e)break;for(;o.sibling===null;){if(o.return===null||o.return===e)return!0;o=o.return}o.sibling.return=o.return,o=o.sibling}}return!0}function Ck(e,o){for(o&=~rk,o&=~qk,e.suspendedLanes|=o,e.pingedLanes&=~o,e=e.expirationTimes;0<o;){var i=31-oc$1(o),s=1<<i;e[i]=-1,o&=~s}}function Ek(e){if(K&6)throw Error(p(327));Hk();var o=uc$1(e,0);if(!(o&1))return Dk(e,B$1()),null;var i=Ik(e,o);if(e.tag!==0&&i===2){var s=xc$1(e);s!==0&&(o=s,i=Nk(e,s))}if(i===1)throw i=pk,Kk(e,0),Ck(e,o),Dk(e,B$1()),i;if(i===6)throw Error(p(345));return e.finishedWork=e.current.alternate,e.finishedLanes=o,Pk(e,tk,uk),Dk(e,B$1()),null}function Qk(e,o){var i=K;K|=1;try{return e(o)}finally{K=i,K===0&&(Gj=B$1()+500,fg$1&&jg())}}function Rk(e){wk!==null&&wk.tag===0&&!(K&6)&&Hk();var o=K;K|=1;var i=ok.transition,s=C;try{if(ok.transition=null,C=1,e)return e()}finally{C=s,ok.transition=i,K=o,!(K&6)&&jg()}}function Hj(){fj=ej.current,E(ej)}function Kk(e,o){e.finishedWork=null,e.finishedLanes=0;var i=e.timeoutHandle;if(i!==-1&&(e.timeoutHandle=-1,Gf$1(i)),Y$1!==null)for(i=Y$1.return;i!==null;){var s=i;switch(wg$1(s),s.tag){case 1:s=s.type.childContextTypes,s!=null&&$f$1();break;case 3:zh$1(),E(Wf$1),E(H$1),Eh$1();break;case 5:Bh$1(s);break;case 4:zh$1();break;case 13:E(L);break;case 19:E(L);break;case 10:ah(s.type._context);break;case 22:case 23:Hj()}i=i.return}if(Q=e,Y$1=e=Pg$1(e.current,null),Z=fj=o,T$1=0,pk=null,rk=qk=rh$1=0,tk=sk=null,fh!==null){for(o=0;o<fh.length;o++)if(i=fh[o],s=i.interleaved,s!==null){i.interleaved=null;var h=s.next,a=i.pending;if(a!==null){var d=a.next;a.next=h,s.next=d}i.pending=s}fh=null}return e}function Mk(e,o){do{var i=Y$1;try{if($g$1(),Fh$1.current=Rh$1,Ih$1){for(var s=M.memoizedState;s!==null;){var h=s.queue;h!==null&&(h.pending=null),s=s.next}Ih$1=!1}if(Hh$1=0,O$1=N=M=null,Jh$1=!1,Kh$1=0,nk.current=null,i===null||i.return===null){T$1=1,pk=o,Y$1=null;break}e:{var a=e,d=i.return,et=i,$=o;if(o=Z,et.flags|=32768,$!==null&&typeof $=="object"&&typeof $.then=="function"){var c=$,b=et,g=b.tag;if(!(b.mode&1)&&(g===0||g===11||g===15)){var nt=b.alternate;nt?(b.updateQueue=nt.updateQueue,b.memoizedState=nt.memoizedState,b.lanes=nt.lanes):(b.updateQueue=null,b.memoizedState=null)}var at=Ui$1(d);if(at!==null){at.flags&=-257,Vi$1(at,d,et,a,o),at.mode&1&&Si$1(a,c,o),o=at,$=c;var Ot=o.updateQueue;if(Ot===null){var At=new Set;At.add($),o.updateQueue=At}else Ot.add($);break e}else{if(!(o&1)){Si$1(a,c,o),tj();break e}$=Error(p(426))}}else if(I&&et.mode&1){var Ct=Ui$1(d);if(Ct!==null){!(Ct.flags&65536)&&(Ct.flags|=256),Vi$1(Ct,d,et,a,o),Jg(Ji$1($,et));break e}}a=$=Ji$1($,et),T$1!==4&&(T$1=2),sk===null?sk=[a]:sk.push(a),a=d;do{switch(a.tag){case 3:a.flags|=65536,o&=-o,a.lanes|=o;var St=Ni$1(a,$,o);ph$1(a,St);break e;case 1:et=$;var xt=a.type,Dt=a.stateNode;if(!(a.flags&128)&&(typeof xt.getDerivedStateFromError=="function"||Dt!==null&&typeof Dt.componentDidCatch=="function"&&(Ri$1===null||!Ri$1.has(Dt)))){a.flags|=65536,o&=-o,a.lanes|=o;var Qt=Qi$1(a,et,o);ph$1(a,Qt);break e}}a=a.return}while(a!==null)}Sk(i)}catch(Zt){o=Zt,Y$1===i&&i!==null&&(Y$1=i=i.return);continue}break}while(!0)}function Jk(){var e=mk.current;return mk.current=Rh$1,e===null?Rh$1:e}function tj(){(T$1===0||T$1===3||T$1===2)&&(T$1=4),Q===null||!(rh$1&268435455)&&!(qk&268435455)||Ck(Q,Z)}function Ik(e,o){var i=K;K|=2;var s=Jk();(Q!==e||Z!==o)&&(uk=null,Kk(e,o));do try{Tk();break}catch(h){Mk(e,h)}while(!0);if($g$1(),K=i,mk.current=s,Y$1!==null)throw Error(p(261));return Q=null,Z=0,T$1}function Tk(){for(;Y$1!==null;)Uk(Y$1)}function Lk(){for(;Y$1!==null&&!cc$1();)Uk(Y$1)}function Uk(e){var o=Vk(e.alternate,e,fj);e.memoizedProps=e.pendingProps,o===null?Sk(e):Y$1=o,nk.current=null}function Sk(e){var o=e;do{var i=o.alternate;if(e=o.return,o.flags&32768){if(i=Ij(i,o),i!==null){i.flags&=32767,Y$1=i;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{T$1=6,Y$1=null;return}}else if(i=Ej(i,o,fj),i!==null){Y$1=i;return}if(o=o.sibling,o!==null){Y$1=o;return}Y$1=o=e}while(o!==null);T$1===0&&(T$1=5)}function Pk(e,o,i){var s=C,h=ok.transition;try{ok.transition=null,C=1,Wk(e,o,i,s)}finally{ok.transition=h,C=s}return null}function Wk(e,o,i,s){do Hk();while(wk!==null);if(K&6)throw Error(p(327));i=e.finishedWork;var h=e.finishedLanes;if(i===null)return null;if(e.finishedWork=null,e.finishedLanes=0,i===e.current)throw Error(p(177));e.callbackNode=null,e.callbackPriority=0;var a=i.lanes|i.childLanes;if(Bc$1(e,a),e===Q&&(Y$1=Q=null,Z=0),!(i.subtreeFlags&2064)&&!(i.flags&2064)||vk||(vk=!0,Fk(hc$1,function(){return Hk(),null})),a=(i.flags&15990)!==0,i.subtreeFlags&15990||a){a=ok.transition,ok.transition=null;var d=C;C=1;var et=K;K|=4,nk.current=null,Oj(e,i),dk(i,e),Oe$1(Df$1),dd=!!Cf$1,Df$1=Cf$1=null,e.current=i,hk(i),dc$1(),K=et,C=d,ok.transition=a}else e.current=i;if(vk&&(vk=!1,wk=e,xk=h),a=e.pendingLanes,a===0&&(Ri$1=null),mc$1(i.stateNode),Dk(e,B$1()),o!==null)for(s=e.onRecoverableError,i=0;i<o.length;i++)h=o[i],s(h.value,{componentStack:h.stack,digest:h.digest});if(Oi$1)throw Oi$1=!1,e=Pi$1,Pi$1=null,e;return xk&1&&e.tag!==0&&Hk(),a=e.pendingLanes,a&1?e===zk?yk++:(yk=0,zk=e):yk=0,jg(),null}function Hk(){if(wk!==null){var e=Dc$1(xk),o=ok.transition,i=C;try{if(ok.transition=null,C=16>e?16:e,wk===null)var s=!1;else{if(e=wk,wk=null,xk=0,K&6)throw Error(p(331));var h=K;for(K|=4,V=e.current;V!==null;){var a=V,d=a.child;if(V.flags&16){var et=a.deletions;if(et!==null){for(var $=0;$<et.length;$++){var c=et[$];for(V=c;V!==null;){var b=V;switch(b.tag){case 0:case 11:case 15:Pj(8,b,a)}var g=b.child;if(g!==null)g.return=b,V=g;else for(;V!==null;){b=V;var nt=b.sibling,at=b.return;if(Sj(b),b===c){V=null;break}if(nt!==null){nt.return=at,V=nt;break}V=at}}}var Ot=a.alternate;if(Ot!==null){var At=Ot.child;if(At!==null){Ot.child=null;do{var Ct=At.sibling;At.sibling=null,At=Ct}while(At!==null)}}V=a}}if(a.subtreeFlags&2064&&d!==null)d.return=a,V=d;else e:for(;V!==null;){if(a=V,a.flags&2048)switch(a.tag){case 0:case 11:case 15:Pj(9,a,a.return)}var St=a.sibling;if(St!==null){St.return=a.return,V=St;break e}V=a.return}}var xt=e.current;for(V=xt;V!==null;){d=V;var Dt=d.child;if(d.subtreeFlags&2064&&Dt!==null)Dt.return=d,V=Dt;else e:for(d=xt;V!==null;){if(et=V,et.flags&2048)try{switch(et.tag){case 0:case 11:case 15:Qj(9,et)}}catch(Zt){W$1(et,et.return,Zt)}if(et===d){V=null;break e}var Qt=et.sibling;if(Qt!==null){Qt.return=et.return,V=Qt;break e}V=et.return}}if(K=h,jg(),lc$1&&typeof lc$1.onPostCommitFiberRoot=="function")try{lc$1.onPostCommitFiberRoot(kc$1,e)}catch{}s=!0}return s}finally{C=i,ok.transition=o}}return!1}function Xk(e,o,i){o=Ji$1(i,o),o=Ni$1(e,o,1),e=nh(e,o,1),o=R(),e!==null&&(Ac$1(e,1,o),Dk(e,o))}function W$1(e,o,i){if(e.tag===3)Xk(e,e,i);else for(;o!==null;){if(o.tag===3){Xk(o,e,i);break}else if(o.tag===1){var s=o.stateNode;if(typeof o.type.getDerivedStateFromError=="function"||typeof s.componentDidCatch=="function"&&(Ri$1===null||!Ri$1.has(s))){e=Ji$1(i,e),e=Qi$1(o,e,1),o=nh(o,e,1),e=R(),o!==null&&(Ac$1(o,1,e),Dk(o,e));break}}o=o.return}}function Ti$1(e,o,i){var s=e.pingCache;s!==null&&s.delete(o),o=R(),e.pingedLanes|=e.suspendedLanes&i,Q===e&&(Z&i)===i&&(T$1===4||T$1===3&&(Z&130023424)===Z&&500>B$1()-fk?Kk(e,0):rk|=i),Dk(e,o)}function Yk(e,o){o===0&&(e.mode&1?(o=sc$1,sc$1<<=1,!(sc$1&130023424)&&(sc$1=4194304)):o=1);var i=R();e=ih(e,o),e!==null&&(Ac$1(e,o,i),Dk(e,i))}function uj(e){var o=e.memoizedState,i=0;o!==null&&(i=o.retryLane),Yk(e,i)}function bk(e,o){var i=0;switch(e.tag){case 13:var s=e.stateNode,h=e.memoizedState;h!==null&&(i=h.retryLane);break;case 19:s=e.stateNode;break;default:throw Error(p(314))}s!==null&&s.delete(o),Yk(e,i)}var Vk;Vk=function(e,o,i){if(e!==null)if(e.memoizedProps!==o.pendingProps||Wf$1.current)dh$1=!0;else{if(!(e.lanes&i)&&!(o.flags&128))return dh$1=!1,yj(e,o,i);dh$1=!!(e.flags&131072)}else dh$1=!1,I&&o.flags&1048576&&ug$1(o,ng$1,o.index);switch(o.lanes=0,o.tag){case 2:var s=o.type;ij(e,o),e=o.pendingProps;var h=Yf$1(o,H$1.current);ch(o,i),h=Nh$1(null,o,s,e,h,i);var a=Sh$1();return o.flags|=1,typeof h=="object"&&h!==null&&typeof h.render=="function"&&h.$$typeof===void 0?(o.tag=1,o.memoizedState=null,o.updateQueue=null,Zf$1(s)?(a=!0,cg(o)):a=!1,o.memoizedState=h.state!==null&&h.state!==void 0?h.state:null,kh$1(o),h.updater=Ei$1,o.stateNode=h,h._reactInternals=o,Ii$1(o,s,e,i),o=jj(null,o,s,!0,a,i)):(o.tag=0,I&&a&&vg$1(o),Xi$1(null,o,h,i),o=o.child),o;case 16:s=o.elementType;e:{switch(ij(e,o),e=o.pendingProps,h=s._init,s=h(s._payload),o.type=s,h=o.tag=Zk(s),e=Ci$1(s,e),h){case 0:o=cj(null,o,s,e,i);break e;case 1:o=hj(null,o,s,e,i);break e;case 11:o=Yi$1(null,o,s,e,i);break e;case 14:o=$i$1(null,o,s,Ci$1(s.type,e),i);break e}throw Error(p(306,s,""))}return o;case 0:return s=o.type,h=o.pendingProps,h=o.elementType===s?h:Ci$1(s,h),cj(e,o,s,h,i);case 1:return s=o.type,h=o.pendingProps,h=o.elementType===s?h:Ci$1(s,h),hj(e,o,s,h,i);case 3:e:{if(kj(o),e===null)throw Error(p(387));s=o.pendingProps,a=o.memoizedState,h=a.element,lh(e,o),qh(o,s,null,i);var d=o.memoizedState;if(s=d.element,a.isDehydrated)if(a={element:s,isDehydrated:!1,cache:d.cache,pendingSuspenseBoundaries:d.pendingSuspenseBoundaries,transitions:d.transitions},o.updateQueue.baseState=a,o.memoizedState=a,o.flags&256){h=Ji$1(Error(p(423)),o),o=lj(e,o,s,i,h);break e}else if(s!==h){h=Ji$1(Error(p(424)),o),o=lj(e,o,s,i,h);break e}else for(yg$1=Lf$1(o.stateNode.containerInfo.firstChild),xg$1=o,I=!0,zg=null,i=Vg(o,null,s,i),o.child=i;i;)i.flags=i.flags&-3|4096,i=i.sibling;else{if(Ig$1(),s===h){o=Zi$1(e,o,i);break e}Xi$1(e,o,s,i)}o=o.child}return o;case 5:return Ah(o),e===null&&Eg$1(o),s=o.type,h=o.pendingProps,a=e!==null?e.memoizedProps:null,d=h.children,Ef$1(s,h)?d=null:a!==null&&Ef$1(s,a)&&(o.flags|=32),gj(e,o),Xi$1(e,o,d,i),o.child;case 6:return e===null&&Eg$1(o),null;case 13:return oj(e,o,i);case 4:return yh$1(o,o.stateNode.containerInfo),s=o.pendingProps,e===null?o.child=Ug(o,null,s,i):Xi$1(e,o,s,i),o.child;case 11:return s=o.type,h=o.pendingProps,h=o.elementType===s?h:Ci$1(s,h),Yi$1(e,o,s,h,i);case 7:return Xi$1(e,o,o.pendingProps,i),o.child;case 8:return Xi$1(e,o,o.pendingProps.children,i),o.child;case 12:return Xi$1(e,o,o.pendingProps.children,i),o.child;case 10:e:{if(s=o.type._context,h=o.pendingProps,a=o.memoizedProps,d=h.value,G$1(Wg,s._currentValue),s._currentValue=d,a!==null)if(He$1(a.value,d)){if(a.children===h.children&&!Wf$1.current){o=Zi$1(e,o,i);break e}}else for(a=o.child,a!==null&&(a.return=o);a!==null;){var et=a.dependencies;if(et!==null){d=a.child;for(var $=et.firstContext;$!==null;){if($.context===s){if(a.tag===1){$=mh$1(-1,i&-i),$.tag=2;var c=a.updateQueue;if(c!==null){c=c.shared;var b=c.pending;b===null?$.next=$:($.next=b.next,b.next=$),c.pending=$}}a.lanes|=i,$=a.alternate,$!==null&&($.lanes|=i),bh$1(a.return,i,o),et.lanes|=i;break}$=$.next}}else if(a.tag===10)d=a.type===o.type?null:a.child;else if(a.tag===18){if(d=a.return,d===null)throw Error(p(341));d.lanes|=i,et=d.alternate,et!==null&&(et.lanes|=i),bh$1(d,i,o),d=a.sibling}else d=a.child;if(d!==null)d.return=a;else for(d=a;d!==null;){if(d===o){d=null;break}if(a=d.sibling,a!==null){a.return=d.return,d=a;break}d=d.return}a=d}Xi$1(e,o,h.children,i),o=o.child}return o;case 9:return h=o.type,s=o.pendingProps.children,ch(o,i),h=eh(h),s=s(h),o.flags|=1,Xi$1(e,o,s,i),o.child;case 14:return s=o.type,h=Ci$1(s,o.pendingProps),h=Ci$1(s.type,h),$i$1(e,o,s,h,i);case 15:return bj(e,o,o.type,o.pendingProps,i);case 17:return s=o.type,h=o.pendingProps,h=o.elementType===s?h:Ci$1(s,h),ij(e,o),o.tag=1,Zf$1(s)?(e=!0,cg(o)):e=!1,ch(o,i),Gi$1(o,s,h),Ii$1(o,s,h,i),jj(null,o,s,!0,e,i);case 19:return xj(e,o,i);case 22:return dj(e,o,i)}throw Error(p(156,o.tag))};function Fk(e,o){return ac$1(e,o)}function $k(e,o,i,s){this.tag=e,this.key=i,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=o,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=s,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg$1(e,o,i,s){return new $k(e,o,i,s)}function aj(e){return e=e.prototype,!(!e||!e.isReactComponent)}function Zk(e){if(typeof e=="function")return aj(e)?1:0;if(e!=null){if(e=e.$$typeof,e===Da)return 11;if(e===Ga)return 14}return 2}function Pg$1(e,o){var i=e.alternate;return i===null?(i=Bg$1(e.tag,o,e.key,e.mode),i.elementType=e.elementType,i.type=e.type,i.stateNode=e.stateNode,i.alternate=e,e.alternate=i):(i.pendingProps=o,i.type=e.type,i.flags=0,i.subtreeFlags=0,i.deletions=null),i.flags=e.flags&14680064,i.childLanes=e.childLanes,i.lanes=e.lanes,i.child=e.child,i.memoizedProps=e.memoizedProps,i.memoizedState=e.memoizedState,i.updateQueue=e.updateQueue,o=e.dependencies,i.dependencies=o===null?null:{lanes:o.lanes,firstContext:o.firstContext},i.sibling=e.sibling,i.index=e.index,i.ref=e.ref,i}function Rg$1(e,o,i,s,h,a){var d=2;if(s=e,typeof e=="function")aj(e)&&(d=1);else if(typeof e=="string")d=5;else e:switch(e){case ya:return Tg$1(i.children,h,a,o);case za:d=8,h|=8;break;case Aa:return e=Bg$1(12,i,o,h|2),e.elementType=Aa,e.lanes=a,e;case Ea:return e=Bg$1(13,i,o,h),e.elementType=Ea,e.lanes=a,e;case Fa:return e=Bg$1(19,i,o,h),e.elementType=Fa,e.lanes=a,e;case Ia:return pj(i,h,a,o);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case Ba:d=10;break e;case Ca:d=9;break e;case Da:d=11;break e;case Ga:d=14;break e;case Ha:d=16,s=null;break e}throw Error(p(130,e==null?e:typeof e,""))}return o=Bg$1(d,i,o,h),o.elementType=e,o.type=s,o.lanes=a,o}function Tg$1(e,o,i,s){return e=Bg$1(7,e,s,o),e.lanes=i,e}function pj(e,o,i,s){return e=Bg$1(22,e,s,o),e.elementType=Ia,e.lanes=i,e.stateNode={isHidden:!1},e}function Qg(e,o,i){return e=Bg$1(6,e,null,o),e.lanes=i,e}function Sg$1(e,o,i){return o=Bg$1(4,e.children!==null?e.children:[],e.key,o),o.lanes=i,o.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},o}function al$1(e,o,i,s,h){this.tag=o,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc$1(0),this.expirationTimes=zc$1(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc$1(0),this.identifierPrefix=s,this.onRecoverableError=h,this.mutableSourceEagerHydrationData=null}function bl$1(e,o,i,s,h,a,d,et,$){return e=new al$1(e,o,i,et,$),o===1?(o=1,a===!0&&(o|=8)):o=0,a=Bg$1(3,null,null,o),e.current=a,a.stateNode=e,a.memoizedState={element:s,isDehydrated:i,cache:null,transitions:null,pendingSuspenseBoundaries:null},kh$1(a),e}function cl$1(e,o,i){var s=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa,key:s==null?null:""+s,children:e,containerInfo:o,implementation:i}}function dl$1(e){if(!e)return Vf$1;e=e._reactInternals;e:{if(Vb$1(e)!==e||e.tag!==1)throw Error(p(170));var o=e;do{switch(o.tag){case 3:o=o.stateNode.context;break e;case 1:if(Zf$1(o.type)){o=o.stateNode.__reactInternalMemoizedMergedChildContext;break e}}o=o.return}while(o!==null);throw Error(p(171))}if(e.tag===1){var i=e.type;if(Zf$1(i))return bg$1(e,i,o)}return o}function el$1(e,o,i,s,h,a,d,et,$){return e=bl$1(i,s,!0,e,h,a,d,et,$),e.context=dl$1(null),i=e.current,s=R(),h=yi$1(i),a=mh$1(s,h),a.callback=o??null,nh(i,a,h),e.current.lanes=h,Ac$1(e,h,s),Dk(e,s),e}function fl$1(e,o,i,s){var h=o.current,a=R(),d=yi$1(h);return i=dl$1(i),o.context===null?o.context=i:o.pendingContext=i,o=mh$1(a,d),o.payload={element:e},s=s===void 0?null:s,s!==null&&(o.callback=s),e=nh(h,o,d),e!==null&&(gi$1(e,h,d,a),oh(e,h,d)),d}function gl$1(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function hl$1(e,o){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var i=e.retryLane;e.retryLane=i!==0&&i<o?i:o}}function il$1(e,o){hl$1(e,o),(e=e.alternate)&&hl$1(e,o)}function jl$1(){return null}var kl$1=typeof reportError=="function"?reportError:function(e){console.error(e)};function ll$1(e){this._internalRoot=e}ml$1.prototype.render=ll$1.prototype.render=function(e){var o=this._internalRoot;if(o===null)throw Error(p(409));fl$1(e,o,null,null)};ml$1.prototype.unmount=ll$1.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var o=e.containerInfo;Rk(function(){fl$1(null,e,null,null)}),o[uf$1]=null}};function ml$1(e){this._internalRoot=e}ml$1.prototype.unstable_scheduleHydration=function(e){if(e){var o=Hc$1();e={blockedOn:null,target:e,priority:o};for(var i=0;i<Qc$1.length&&o!==0&&o<Qc$1[i].priority;i++);Qc$1.splice(i,0,e),i===0&&Vc$1(e)}};function nl$1(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function ol$1(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function pl$1(){}function ql$1(e,o,i,s,h){if(h){if(typeof s=="function"){var a=s;s=function(){var c=gl$1(d);a.call(c)}}var d=el$1(o,s,e,0,null,!1,!1,"",pl$1);return e._reactRootContainer=d,e[uf$1]=d.current,sf$1(e.nodeType===8?e.parentNode:e),Rk(),d}for(;h=e.lastChild;)e.removeChild(h);if(typeof s=="function"){var et=s;s=function(){var c=gl$1($);et.call(c)}}var $=bl$1(e,0,!1,null,null,!1,!1,"",pl$1);return e._reactRootContainer=$,e[uf$1]=$.current,sf$1(e.nodeType===8?e.parentNode:e),Rk(function(){fl$1(o,$,i,s)}),$}function rl$1(e,o,i,s,h){var a=i._reactRootContainer;if(a){var d=a;if(typeof h=="function"){var et=h;h=function(){var $=gl$1(d);et.call($)}}fl$1(o,d,e,h)}else d=ql$1(i,o,e,h,s);return gl$1(d)}Ec$1=function(e){switch(e.tag){case 3:var o=e.stateNode;if(o.current.memoizedState.isDehydrated){var i=tc$1(o.pendingLanes);i!==0&&(Cc$1(o,i|1),Dk(o,B$1()),!(K&6)&&(Gj=B$1()+500,jg()))}break;case 13:Rk(function(){var s=ih(e,1);if(s!==null){var h=R();gi$1(s,e,1,h)}}),il$1(e,1)}};Fc$1=function(e){if(e.tag===13){var o=ih(e,134217728);if(o!==null){var i=R();gi$1(o,e,134217728,i)}il$1(e,134217728)}};Gc$1=function(e){if(e.tag===13){var o=yi$1(e),i=ih(e,o);if(i!==null){var s=R();gi$1(i,e,o,s)}il$1(e,o)}};Hc$1=function(){return C};Ic$1=function(e,o){var i=C;try{return C=e,o()}finally{C=i}};yb$1=function(e,o,i){switch(o){case"input":if(bb$1(e,i),o=i.name,i.type==="radio"&&o!=null){for(i=e;i.parentNode;)i=i.parentNode;for(i=i.querySelectorAll("input[name="+JSON.stringify(""+o)+'][type="radio"]'),o=0;o<i.length;o++){var s=i[o];if(s!==e&&s.form===e.form){var h=Db$1(s);if(!h)throw Error(p(90));Wa(s),bb$1(s,h)}}}break;case"textarea":ib$1(e,i);break;case"select":o=i.value,o!=null&&fb$1(e,!!i.multiple,o,!1)}};Gb$1=Qk;Hb$1=Rk;var sl$1={usingClientEntryPoint:!1,Events:[Cb$1,ue$1,Db$1,Eb$1,Fb$1,Qk]},tl$1={findFiberByHostInstance:Wc$1,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ul={bundleType:tl$1.bundleType,version:tl$1.version,rendererPackageName:tl$1.rendererPackageName,rendererConfig:tl$1.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=Zb$1(e),e===null?null:e.stateNode},findFiberByHostInstance:tl$1.findFiberByHostInstance||jl$1,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vl$1=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl$1.isDisabled&&vl$1.supportsFiber)try{kc$1=vl$1.inject(ul),lc$1=vl$1}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl$1;reactDom_production_min.createPortal=function(e,o){var i=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!nl$1(o))throw Error(p(200));return cl$1(e,o,null,i)};reactDom_production_min.createRoot=function(e,o){if(!nl$1(e))throw Error(p(299));var i=!1,s="",h=kl$1;return o!=null&&(o.unstable_strictMode===!0&&(i=!0),o.identifierPrefix!==void 0&&(s=o.identifierPrefix),o.onRecoverableError!==void 0&&(h=o.onRecoverableError)),o=bl$1(e,1,!1,null,null,i,!1,s,h),e[uf$1]=o.current,sf$1(e.nodeType===8?e.parentNode:e),new ll$1(o)};reactDom_production_min.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var o=e._reactInternals;if(o===void 0)throw typeof e.render=="function"?Error(p(188)):(e=Object.keys(e).join(","),Error(p(268,e)));return e=Zb$1(o),e=e===null?null:e.stateNode,e};reactDom_production_min.flushSync=function(e){return Rk(e)};reactDom_production_min.hydrate=function(e,o,i){if(!ol$1(o))throw Error(p(200));return rl$1(null,e,o,!0,i)};reactDom_production_min.hydrateRoot=function(e,o,i){if(!nl$1(e))throw Error(p(405));var s=i!=null&&i.hydratedSources||null,h=!1,a="",d=kl$1;if(i!=null&&(i.unstable_strictMode===!0&&(h=!0),i.identifierPrefix!==void 0&&(a=i.identifierPrefix),i.onRecoverableError!==void 0&&(d=i.onRecoverableError)),o=el$1(o,null,e,1,i??null,h,!1,a,d),e[uf$1]=o.current,sf$1(e),s)for(e=0;e<s.length;e++)i=s[e],h=i._getVersion,h=h(i._source),o.mutableSourceEagerHydrationData==null?o.mutableSourceEagerHydrationData=[i,h]:o.mutableSourceEagerHydrationData.push(i,h);return new ml$1(o)};reactDom_production_min.render=function(e,o,i){if(!ol$1(o))throw Error(p(200));return rl$1(null,e,o,!1,i)};reactDom_production_min.unmountComponentAtNode=function(e){if(!ol$1(e))throw Error(p(40));return e._reactRootContainer?(Rk(function(){rl$1(null,null,e,!1,function(){e._reactRootContainer=null,e[uf$1]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(e,o,i,s){if(!ol$1(i))throw Error(p(200));if(e==null||e._reactInternals===void 0)throw Error(p(38));return rl$1(e,o,i,!1,s)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(e){console.error(e)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports,createRoot,m=reactDomExports;createRoot=m.createRoot,m.hydrateRoot;var propTypes={exports:{}},ReactPropTypesSecret$1="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",ReactPropTypesSecret_1=ReactPropTypesSecret$1,ReactPropTypesSecret=ReactPropTypesSecret_1;function emptyFunction(){}function emptyFunctionWithReset(){}emptyFunctionWithReset.resetWarningCache=emptyFunction;var factoryWithThrowingShims=function(){function e(s,h,a,d,et,$){if($!==ReactPropTypesSecret){var c=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw c.name="Invariant Violation",c}}e.isRequired=e;function o(){return e}var i={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:o,element:e,elementType:e,instanceOf:o,node:e,objectOf:o,oneOf:o,oneOfType:o,shape:o,exact:o,checkPropTypes:emptyFunctionWithReset,resetWarningCache:emptyFunction};return i.PropTypes=i,i};propTypes.exports=factoryWithThrowingShims();var propTypesExports=propTypes.exports;const PropTypes=getDefaultExportFromCjs(propTypesExports);function __awaiter(e,o,i,s){function h(a){return a instanceof i?a:new i(function(d){d(a)})}return new(i||(i=Promise))(function(a,d){function et(b){try{c(s.next(b))}catch(g){d(g)}}function $(b){try{c(s.throw(b))}catch(g){d(g)}}function c(b){b.done?a(b.value):h(b.value).then(et,$)}c((s=s.apply(e,o||[])).next())})}function __generator(e,o){var i={label:0,sent:function(){if(a[0]&1)throw a[1];return a[1]},trys:[],ops:[]},s,h,a,d=Object.create((typeof Iterator=="function"?Iterator:Object).prototype);return d.next=et(0),d.throw=et(1),d.return=et(2),typeof Symbol=="function"&&(d[Symbol.iterator]=function(){return this}),d;function et(c){return function(b){return $([c,b])}}function $(c){if(s)throw new TypeError("Generator is already executing.");for(;d&&(d=0,c[0]&&(i=0)),i;)try{if(s=1,h&&(a=c[0]&2?h.return:c[0]?h.throw||((a=h.return)&&a.call(h),0):h.next)&&!(a=a.call(h,c[1])).done)return a;switch(h=0,a&&(c=[c[0]&2,a.value]),c[0]){case 0:case 1:a=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,h=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(a=i.trys,!(a=a.length>0&&a[a.length-1])&&(c[0]===6||c[0]===2)){i=0;continue}if(c[0]===3&&(!a||c[1]>a[0]&&c[1]<a[3])){i.label=c[1];break}if(c[0]===6&&i.label<a[1]){i.label=a[1],a=c;break}if(a&&i.label<a[2]){i.label=a[2],i.ops.push(c);break}a[2]&&i.ops.pop(),i.trys.pop();continue}c=o.call(e,i)}catch(b){c=[6,b],h=0}finally{s=a=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}}function __read(e,o){var i=typeof Symbol=="function"&&e[Symbol.iterator];if(!i)return e;var s=i.call(e),h,a=[],d;try{for(;(o===void 0||o-- >0)&&!(h=s.next()).done;)a.push(h.value)}catch(et){d={error:et}}finally{try{h&&!h.done&&(i=s.return)&&i.call(s)}finally{if(d)throw d.error}}return a}function __spreadArray(e,o,i){if(i||arguments.length===2)for(var s=0,h=o.length,a;s<h;s++)(a||!(s in o))&&(a||(a=Array.prototype.slice.call(o,0,s)),a[s]=o[s]);return e.concat(a||Array.prototype.slice.call(o))}typeof SuppressedError=="function"&&SuppressedError;var COMMON_MIME_TYPES=new Map([["aac","audio/aac"],["abw","application/x-abiword"],["arc","application/x-freearc"],["avif","image/avif"],["avi","video/x-msvideo"],["azw","application/vnd.amazon.ebook"],["bin","application/octet-stream"],["bmp","image/bmp"],["bz","application/x-bzip"],["bz2","application/x-bzip2"],["cda","application/x-cdf"],["csh","application/x-csh"],["css","text/css"],["csv","text/csv"],["doc","application/msword"],["docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"],["eot","application/vnd.ms-fontobject"],["epub","application/epub+zip"],["gz","application/gzip"],["gif","image/gif"],["heic","image/heic"],["heif","image/heif"],["htm","text/html"],["html","text/html"],["ico","image/vnd.microsoft.icon"],["ics","text/calendar"],["jar","application/java-archive"],["jpeg","image/jpeg"],["jpg","image/jpeg"],["js","text/javascript"],["json","application/json"],["jsonld","application/ld+json"],["mid","audio/midi"],["midi","audio/midi"],["mjs","text/javascript"],["mp3","audio/mpeg"],["mp4","video/mp4"],["mpeg","video/mpeg"],["mpkg","application/vnd.apple.installer+xml"],["odp","application/vnd.oasis.opendocument.presentation"],["ods","application/vnd.oasis.opendocument.spreadsheet"],["odt","application/vnd.oasis.opendocument.text"],["oga","audio/ogg"],["ogv","video/ogg"],["ogx","application/ogg"],["opus","audio/opus"],["otf","font/otf"],["png","image/png"],["pdf","application/pdf"],["php","application/x-httpd-php"],["ppt","application/vnd.ms-powerpoint"],["pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation"],["rar","application/vnd.rar"],["rtf","application/rtf"],["sh","application/x-sh"],["svg","image/svg+xml"],["swf","application/x-shockwave-flash"],["tar","application/x-tar"],["tif","image/tiff"],["tiff","image/tiff"],["ts","video/mp2t"],["ttf","font/ttf"],["txt","text/plain"],["vsd","application/vnd.visio"],["wav","audio/wav"],["weba","audio/webm"],["webm","video/webm"],["webp","image/webp"],["woff","font/woff"],["woff2","font/woff2"],["xhtml","application/xhtml+xml"],["xls","application/vnd.ms-excel"],["xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],["xml","application/xml"],["xul","application/vnd.mozilla.xul+xml"],["zip","application/zip"],["7z","application/x-7z-compressed"],["mkv","video/x-matroska"],["mov","video/quicktime"],["msg","application/vnd.ms-outlook"]]);function toFileWithPath(e,o){var i=withMimeType(e);if(typeof i.path!="string"){var s=e.webkitRelativePath;Object.defineProperty(i,"path",{value:typeof o=="string"?o:typeof s=="string"&&s.length>0?s:e.name,writable:!1,configurable:!1,enumerable:!0})}return i}function withMimeType(e){var o=e.name,i=o&&o.lastIndexOf(".")!==-1;if(i&&!e.type){var s=o.split(".").pop().toLowerCase(),h=COMMON_MIME_TYPES.get(s);h&&Object.defineProperty(e,"type",{value:h,writable:!1,configurable:!1,enumerable:!0})}return e}var FILES_TO_IGNORE=[".DS_Store","Thumbs.db"];function fromEvent(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(o){return isObject(e)&&isDataTransfer(e.dataTransfer)?[2,getDataTransferFiles(e.dataTransfer,e.type)]:isChangeEvt(e)?[2,getInputFiles(e)]:Array.isArray(e)&&e.every(function(i){return"getFile"in i&&typeof i.getFile=="function"})?[2,getFsHandleFiles(e)]:[2,[]]})})}function isDataTransfer(e){return isObject(e)}function isChangeEvt(e){return isObject(e)&&isObject(e.target)}function isObject(e){return typeof e=="object"&&e!==null}function getInputFiles(e){return fromList(e.target.files).map(function(o){return toFileWithPath(o)})}function getFsHandleFiles(e){return __awaiter(this,void 0,void 0,function(){var o;return __generator(this,function(i){switch(i.label){case 0:return[4,Promise.all(e.map(function(s){return s.getFile()}))];case 1:return o=i.sent(),[2,o.map(function(s){return toFileWithPath(s)})]}})})}function getDataTransferFiles(e,o){return __awaiter(this,void 0,void 0,function(){var i,s;return __generator(this,function(h){switch(h.label){case 0:return e.items?(i=fromList(e.items).filter(function(a){return a.kind==="file"}),o!=="drop"?[2,i]:[4,Promise.all(i.map(toFilePromises))]):[3,2];case 1:return s=h.sent(),[2,noIgnoredFiles(flatten(s))];case 2:return[2,noIgnoredFiles(fromList(e.files).map(function(a){return toFileWithPath(a)}))]}})})}function noIgnoredFiles(e){return e.filter(function(o){return FILES_TO_IGNORE.indexOf(o.name)===-1})}function fromList(e){if(e===null)return[];for(var o=[],i=0;i<e.length;i++){var s=e[i];o.push(s)}return o}function toFilePromises(e){if(typeof e.webkitGetAsEntry!="function")return fromDataTransferItem(e);var o=e.webkitGetAsEntry();return o&&o.isDirectory?fromDirEntry(o):fromDataTransferItem(e)}function flatten(e){return e.reduce(function(o,i){return __spreadArray(__spreadArray([],__read(o),!1),__read(Array.isArray(i)?flatten(i):[i]),!1)},[])}function fromDataTransferItem(e){var o=e.getAsFile();if(!o)return Promise.reject("".concat(e," is not a File"));var i=toFileWithPath(o);return Promise.resolve(i)}function fromEntry(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(o){return[2,e.isDirectory?fromDirEntry(e):fromFileEntry(e)]})})}function fromDirEntry(e){var o=e.createReader();return new Promise(function(i,s){var h=[];function a(){var d=this;o.readEntries(function(et){return __awaiter(d,void 0,void 0,function(){var $,c,b;return __generator(this,function(g){switch(g.label){case 0:if(et.length)return[3,5];g.label=1;case 1:return g.trys.push([1,3,,4]),[4,Promise.all(h)];case 2:return $=g.sent(),i($),[3,4];case 3:return c=g.sent(),s(c),[3,4];case 4:return[3,6];case 5:b=Promise.all(et.map(fromEntry)),h.push(b),a(),g.label=6;case 6:return[2]}})})},function(et){s(et)})}a()})}function fromFileEntry(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(o){return[2,new Promise(function(i,s){e.file(function(h){var a=toFileWithPath(h,e.fullPath);i(a)},function(h){s(h)})})]})})}var _default=function(e,o){if(e&&o){var i=Array.isArray(o)?o:o.split(","),s=e.name||"",h=(e.type||"").toLowerCase(),a=h.replace(/\/.*$/,"");return i.some(function(d){var et=d.trim().toLowerCase();return et.charAt(0)==="."?s.toLowerCase().endsWith(et):et.endsWith("/*")?a===et.replace(/\/.*$/,""):h===et})}return!0};function _toConsumableArray$1(e){return _arrayWithoutHoles$1(e)||_iterableToArray$1(e)||_unsupportedIterableToArray$1(e)||_nonIterableSpread$1()}function _nonIterableSpread$1(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _iterableToArray$1(e){if(typeof Symbol<"u"&&e[Symbol.iterator]!=null||e["@@iterator"]!=null)return Array.from(e)}function _arrayWithoutHoles$1(e){if(Array.isArray(e))return _arrayLikeToArray$1(e)}function ownKeys$1(e,o){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);o&&(s=s.filter(function(h){return Object.getOwnPropertyDescriptor(e,h).enumerable})),i.push.apply(i,s)}return i}function _objectSpread$1(e){for(var o=1;o<arguments.length;o++){var i=arguments[o]!=null?arguments[o]:{};o%2?ownKeys$1(Object(i),!0).forEach(function(s){_defineProperty$1(e,s,i[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ownKeys$1(Object(i)).forEach(function(s){Object.defineProperty(e,s,Object.getOwnPropertyDescriptor(i,s))})}return e}function _defineProperty$1(e,o,i){return o in e?Object.defineProperty(e,o,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[o]=i,e}function _slicedToArray$1(e,o){return _arrayWithHoles$1(e)||_iterableToArrayLimit$1(e,o)||_unsupportedIterableToArray$1(e,o)||_nonIterableRest$1()}function _nonIterableRest$1(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$1(e,o){if(e){if(typeof e=="string")return _arrayLikeToArray$1(e,o);var i=Object.prototype.toString.call(e).slice(8,-1);if(i==="Object"&&e.constructor&&(i=e.constructor.name),i==="Map"||i==="Set")return Array.from(e);if(i==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return _arrayLikeToArray$1(e,o)}}function _arrayLikeToArray$1(e,o){(o==null||o>e.length)&&(o=e.length);for(var i=0,s=new Array(o);i<o;i++)s[i]=e[i];return s}function _iterableToArrayLimit$1(e,o){var i=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(i!=null){var s=[],h=!0,a=!1,d,et;try{for(i=i.call(e);!(h=(d=i.next()).done)&&(s.push(d.value),!(o&&s.length===o));h=!0);}catch($){a=!0,et=$}finally{try{!h&&i.return!=null&&i.return()}finally{if(a)throw et}}return s}}function _arrayWithHoles$1(e){if(Array.isArray(e))return e}var FILE_INVALID_TYPE="file-invalid-type",FILE_TOO_LARGE="file-too-large",FILE_TOO_SMALL="file-too-small",TOO_MANY_FILES="too-many-files",getInvalidTypeRejectionErr=function(o){o=Array.isArray(o)&&o.length===1?o[0]:o;var i=Array.isArray(o)?"one of ".concat(o.join(", ")):o;return{code:FILE_INVALID_TYPE,message:"File type must be ".concat(i)}},getTooLargeRejectionErr=function(o){return{code:FILE_TOO_LARGE,message:"File is larger than ".concat(o," ").concat(o===1?"byte":"bytes")}},getTooSmallRejectionErr=function(o){return{code:FILE_TOO_SMALL,message:"File is smaller than ".concat(o," ").concat(o===1?"byte":"bytes")}},TOO_MANY_FILES_REJECTION={code:TOO_MANY_FILES,message:"Too many files"};function fileAccepted(e,o){var i=e.type==="application/x-moz-file"||_default(e,o);return[i,i?null:getInvalidTypeRejectionErr(o)]}function fileMatchSize(e,o,i){if(isDefined(e.size))if(isDefined(o)&&isDefined(i)){if(e.size>i)return[!1,getTooLargeRejectionErr(i)];if(e.size<o)return[!1,getTooSmallRejectionErr(o)]}else{if(isDefined(o)&&e.size<o)return[!1,getTooSmallRejectionErr(o)];if(isDefined(i)&&e.size>i)return[!1,getTooLargeRejectionErr(i)]}return[!0,null]}function isDefined(e){return e!=null}function allFilesAccepted(e){var o=e.files,i=e.accept,s=e.minSize,h=e.maxSize,a=e.multiple,d=e.maxFiles,et=e.validator;return!a&&o.length>1||a&&d>=1&&o.length>d?!1:o.every(function($){var c=fileAccepted($,i),b=_slicedToArray$1(c,1),g=b[0],nt=fileMatchSize($,s,h),at=_slicedToArray$1(nt,1),Ot=at[0],At=et?et($):null;return g&&Ot&&!At})}function isPropagationStopped(e){return typeof e.isPropagationStopped=="function"?e.isPropagationStopped():typeof e.cancelBubble<"u"?e.cancelBubble:!1}function isEvtWithFiles(e){return e.dataTransfer?Array.prototype.some.call(e.dataTransfer.types,function(o){return o==="Files"||o==="application/x-moz-file"}):!!e.target&&!!e.target.files}function onDocumentDragOver(e){e.preventDefault()}function isIe(e){return e.indexOf("MSIE")!==-1||e.indexOf("Trident/")!==-1}function isEdge(e){return e.indexOf("Edge/")!==-1}function isIeOrEdge(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:window.navigator.userAgent;return isIe(e)||isEdge(e)}function composeEventHandlers(){for(var e=arguments.length,o=new Array(e),i=0;i<e;i++)o[i]=arguments[i];return function(s){for(var h=arguments.length,a=new Array(h>1?h-1:0),d=1;d<h;d++)a[d-1]=arguments[d];return o.some(function(et){return!isPropagationStopped(s)&&et&&et.apply(void 0,[s].concat(a)),isPropagationStopped(s)})}}function canUseFileSystemAccessAPI(){return"showOpenFilePicker"in window}function pickerOptionsFromAccept(e){if(isDefined(e)){var o=Object.entries(e).filter(function(i){var s=_slicedToArray$1(i,2),h=s[0],a=s[1],d=!0;return isMIMEType(h)||(console.warn('Skipped "'.concat(h,'" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')),d=!1),(!Array.isArray(a)||!a.every(isExt))&&(console.warn('Skipped "'.concat(h,'" because an invalid file extension was provided.')),d=!1),d}).reduce(function(i,s){var h=_slicedToArray$1(s,2),a=h[0],d=h[1];return _objectSpread$1(_objectSpread$1({},i),{},_defineProperty$1({},a,d))},{});return[{description:"Files",accept:o}]}return e}function acceptPropAsAcceptAttr(e){if(isDefined(e))return Object.entries(e).reduce(function(o,i){var s=_slicedToArray$1(i,2),h=s[0],a=s[1];return[].concat(_toConsumableArray$1(o),[h],_toConsumableArray$1(a))},[]).filter(function(o){return isMIMEType(o)||isExt(o)}).join(",")}function isAbort(e){return e instanceof DOMException&&(e.name==="AbortError"||e.code===e.ABORT_ERR)}function isSecurityError(e){return e instanceof DOMException&&(e.name==="SecurityError"||e.code===e.SECURITY_ERR)}function isMIMEType(e){return e==="audio/*"||e==="video/*"||e==="image/*"||e==="text/*"||/\w+\/[-+.\w]+/g.test(e)}function isExt(e){return/^.*\.[\w]+$/.test(e)}var _excluded=["children"],_excluded2=["open"],_excluded3=["refKey","role","onKeyDown","onFocus","onBlur","onClick","onDragEnter","onDragOver","onDragLeave","onDrop"],_excluded4=["refKey","onChange","onClick"];function _toConsumableArray(e){return _arrayWithoutHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _iterableToArray(e){if(typeof Symbol<"u"&&e[Symbol.iterator]!=null||e["@@iterator"]!=null)return Array.from(e)}function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}function _slicedToArray(e,o){return _arrayWithHoles(e)||_iterableToArrayLimit(e,o)||_unsupportedIterableToArray(e,o)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray(e,o){if(e){if(typeof e=="string")return _arrayLikeToArray(e,o);var i=Object.prototype.toString.call(e).slice(8,-1);if(i==="Object"&&e.constructor&&(i=e.constructor.name),i==="Map"||i==="Set")return Array.from(e);if(i==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return _arrayLikeToArray(e,o)}}function _arrayLikeToArray(e,o){(o==null||o>e.length)&&(o=e.length);for(var i=0,s=new Array(o);i<o;i++)s[i]=e[i];return s}function _iterableToArrayLimit(e,o){var i=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(i!=null){var s=[],h=!0,a=!1,d,et;try{for(i=i.call(e);!(h=(d=i.next()).done)&&(s.push(d.value),!(o&&s.length===o));h=!0);}catch($){a=!0,et=$}finally{try{!h&&i.return!=null&&i.return()}finally{if(a)throw et}}return s}}function _arrayWithHoles(e){if(Array.isArray(e))return e}function ownKeys(e,o){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);o&&(s=s.filter(function(h){return Object.getOwnPropertyDescriptor(e,h).enumerable})),i.push.apply(i,s)}return i}function _objectSpread(e){for(var o=1;o<arguments.length;o++){var i=arguments[o]!=null?arguments[o]:{};o%2?ownKeys(Object(i),!0).forEach(function(s){_defineProperty(e,s,i[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ownKeys(Object(i)).forEach(function(s){Object.defineProperty(e,s,Object.getOwnPropertyDescriptor(i,s))})}return e}function _defineProperty(e,o,i){return o in e?Object.defineProperty(e,o,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[o]=i,e}function _objectWithoutProperties(e,o){if(e==null)return{};var i=_objectWithoutPropertiesLoose(e,o),s,h;if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(h=0;h<a.length;h++)s=a[h],!(o.indexOf(s)>=0)&&Object.prototype.propertyIsEnumerable.call(e,s)&&(i[s]=e[s])}return i}function _objectWithoutPropertiesLoose(e,o){if(e==null)return{};var i={},s=Object.keys(e),h,a;for(a=0;a<s.length;a++)h=s[a],!(o.indexOf(h)>=0)&&(i[h]=e[h]);return i}var Dropzone=reactExports.forwardRef(function(e,o){var i=e.children,s=_objectWithoutProperties(e,_excluded),h=useDropzone(s),a=h.open,d=_objectWithoutProperties(h,_excluded2);return reactExports.useImperativeHandle(o,function(){return{open:a}},[a]),React.createElement(reactExports.Fragment,null,i(_objectSpread(_objectSpread({},d),{},{open:a})))});Dropzone.displayName="Dropzone";var defaultProps={disabled:!1,getFilesFromEvent:fromEvent,maxSize:1/0,minSize:0,multiple:!0,maxFiles:0,preventDropOnDocument:!0,noClick:!1,noKeyboard:!1,noDrag:!1,noDragEventsBubbling:!1,validator:null,useFsAccessApi:!0,autoFocus:!1};Dropzone.defaultProps=defaultProps;Dropzone.propTypes={children:PropTypes.func,accept:PropTypes.objectOf(PropTypes.arrayOf(PropTypes.string)),multiple:PropTypes.bool,preventDropOnDocument:PropTypes.bool,noClick:PropTypes.bool,noKeyboard:PropTypes.bool,noDrag:PropTypes.bool,noDragEventsBubbling:PropTypes.bool,minSize:PropTypes.number,maxSize:PropTypes.number,maxFiles:PropTypes.number,disabled:PropTypes.bool,getFilesFromEvent:PropTypes.func,onFileDialogCancel:PropTypes.func,onFileDialogOpen:PropTypes.func,useFsAccessApi:PropTypes.bool,autoFocus:PropTypes.bool,onDragEnter:PropTypes.func,onDragLeave:PropTypes.func,onDragOver:PropTypes.func,onDrop:PropTypes.func,onDropAccepted:PropTypes.func,onDropRejected:PropTypes.func,onError:PropTypes.func,validator:PropTypes.func};var initialState={isFocused:!1,isFileDialogActive:!1,isDragActive:!1,isDragAccept:!1,isDragReject:!1,acceptedFiles:[],fileRejections:[]};function useDropzone(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},o=_objectSpread(_objectSpread({},defaultProps),e),i=o.accept,s=o.disabled,h=o.getFilesFromEvent,a=o.maxSize,d=o.minSize,et=o.multiple,$=o.maxFiles,c=o.onDragEnter,b=o.onDragLeave,g=o.onDragOver,nt=o.onDrop,at=o.onDropAccepted,Ot=o.onDropRejected,At=o.onFileDialogCancel,Ct=o.onFileDialogOpen,St=o.useFsAccessApi,xt=o.autoFocus,Dt=o.preventDropOnDocument,Qt=o.noClick,Zt=o.noKeyboard,gr=o.noDrag,vr=o.noDragEventsBubbling,Er=o.onError,wo=o.validator,Do=reactExports.useMemo(function(){return acceptPropAsAcceptAttr(i)},[i]),Js=reactExports.useMemo(function(){return pickerOptionsFromAccept(i)},[i]),In=reactExports.useMemo(function(){return typeof Ct=="function"?Ct:noop},[Ct]),Wo=reactExports.useMemo(function(){return typeof At=="function"?At:noop},[At]),Ir=reactExports.useRef(null),Yo=reactExports.useRef(null),Bu=reactExports.useReducer(reducer,initialState),Ho=_slicedToArray(Bu,2),tn=Ho[0],To=Ho[1],Qo=tn.isFocused,Jr=tn.isFileDialogActive,Lo=reactExports.useRef(typeof window<"u"&&window.isSecureContext&&St&&canUseFileSystemAccessAPI()),Du=function(){!Lo.current&&Jr&&setTimeout(function(){if(Yo.current){var qs=Yo.current.files;qs.length||(To({type:"closeDialog"}),Wo())}},300)};reactExports.useEffect(function(){return window.addEventListener("focus",Du,!1),function(){window.removeEventListener("focus",Du,!1)}},[Yo,Jr,Wo,Lo]);var _u=reactExports.useRef([]),du=function(qs){Ir.current&&Ir.current.contains(qs.target)||(qs.preventDefault(),_u.current=[])};reactExports.useEffect(function(){return Dt&&(document.addEventListener("dragover",onDocumentDragOver,!1),document.addEventListener("drop",du,!1)),function(){Dt&&(document.removeEventListener("dragover",onDocumentDragOver),document.removeEventListener("drop",du))}},[Ir,Dt]),reactExports.useEffect(function(){return!s&&xt&&Ir.current&&Ir.current.focus(),function(){}},[Ir,xt,s]);var wu=reactExports.useCallback(function(Mo){Er?Er(Mo):console.error(Mo)},[Er]),r_=reactExports.useCallback(function(Mo){Mo.preventDefault(),Mo.persist(),Lr(Mo),_u.current=[].concat(_toConsumableArray(_u.current),[Mo.target]),isEvtWithFiles(Mo)&&Promise.resolve(h(Mo)).then(function(qs){if(!(isPropagationStopped(Mo)&&!vr)){var au=qs.length,i_=au>0&&allFilesAccepted({files:qs,accept:Do,minSize:d,maxSize:a,multiple:et,maxFiles:$,validator:wo}),$u=au>0&&!i_;To({isDragAccept:i_,isDragReject:$u,isDragActive:!0,type:"setDraggedFiles"}),c&&c(Mo)}}).catch(function(qs){return wu(qs)})},[h,c,wu,vr,Do,d,a,et,$,wo]),d_=reactExports.useCallback(function(Mo){Mo.preventDefault(),Mo.persist(),Lr(Mo);var qs=isEvtWithFiles(Mo);if(qs&&Mo.dataTransfer)try{Mo.dataTransfer.dropEffect="copy"}catch{}return qs&&g&&g(Mo),!1},[g,vr]),na=reactExports.useCallback(function(Mo){Mo.preventDefault(),Mo.persist(),Lr(Mo);var qs=_u.current.filter(function(i_){return Ir.current&&Ir.current.contains(i_)}),au=qs.indexOf(Mo.target);au!==-1&&qs.splice(au,1),_u.current=qs,!(qs.length>0)&&(To({type:"setDraggedFiles",isDragActive:!1,isDragAccept:!1,isDragReject:!1}),isEvtWithFiles(Mo)&&b&&b(Mo))},[Ir,b,vr]),Ko=reactExports.useCallback(function(Mo,qs){var au=[],i_=[];Mo.forEach(function($u){var m_=fileAccepted($u,Do),L_=_slicedToArray(m_,2),Z_=L_[0],Ty=L_[1],ey=fileMatchSize($u,d,a),yy=_slicedToArray(ey,2),O_=yy[0],fy=yy[1],g_=wo?wo($u):null;if(Z_&&O_&&!g_)au.push($u);else{var jo=[Ty,fy];g_&&(jo=jo.concat(g_)),i_.push({file:$u,errors:jo.filter(function(Xs){return Xs})})}}),(!et&&au.length>1||et&&$>=1&&au.length>$)&&(au.forEach(function($u){i_.push({file:$u,errors:[TOO_MANY_FILES_REJECTION]})}),au.splice(0)),To({acceptedFiles:au,fileRejections:i_,type:"setFiles"}),nt&&nt(au,i_,qs),i_.length>0&&Ot&&Ot(i_,qs),au.length>0&&at&&at(au,qs)},[To,et,Do,d,a,$,nt,at,Ot,wo]),vu=reactExports.useCallback(function(Mo){Mo.preventDefault(),Mo.persist(),Lr(Mo),_u.current=[],isEvtWithFiles(Mo)&&Promise.resolve(h(Mo)).then(function(qs){isPropagationStopped(Mo)&&!vr||Ko(qs,Mo)}).catch(function(qs){return wu(qs)}),To({type:"reset"})},[h,Ko,wu,vr]),Cu=reactExports.useCallback(function(){if(Lo.current){To({type:"openDialog"}),In();var Mo={multiple:et,types:Js};window.showOpenFilePicker(Mo).then(function(qs){return h(qs)}).then(function(qs){Ko(qs,null),To({type:"closeDialog"})}).catch(function(qs){isAbort(qs)?(Wo(qs),To({type:"closeDialog"})):isSecurityError(qs)?(Lo.current=!1,Yo.current?(Yo.current.value=null,Yo.current.click()):wu(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))):wu(qs)});return}Yo.current&&(To({type:"openDialog"}),In(),Yo.current.value=null,Yo.current.click())},[To,In,Wo,St,Ko,wu,Js,et]),e_=reactExports.useCallback(function(Mo){!Ir.current||!Ir.current.isEqualNode(Mo.target)||(Mo.key===" "||Mo.key==="Enter"||Mo.keyCode===32||Mo.keyCode===13)&&(Mo.preventDefault(),Cu())},[Ir,Cu]),ar=reactExports.useCallback(function(){To({type:"focus"})},[]),Qs=reactExports.useCallback(function(){To({type:"blur"})},[]),_a=reactExports.useCallback(function(){Qt||(isIeOrEdge()?setTimeout(Cu,0):Cu())},[Qt,Cu]),$o=function(qs){return s?null:qs},Eo=function(qs){return Zt?null:$o(qs)},js=function(qs){return gr?null:$o(qs)},Lr=function(qs){vr&&qs.stopPropagation()},rn=reactExports.useMemo(function(){return function(){var Mo=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},qs=Mo.refKey,au=qs===void 0?"ref":qs,i_=Mo.role,$u=Mo.onKeyDown,m_=Mo.onFocus,L_=Mo.onBlur,Z_=Mo.onClick,Ty=Mo.onDragEnter,ey=Mo.onDragOver,yy=Mo.onDragLeave,O_=Mo.onDrop,fy=_objectWithoutProperties(Mo,_excluded3);return _objectSpread(_objectSpread(_defineProperty({onKeyDown:Eo(composeEventHandlers($u,e_)),onFocus:Eo(composeEventHandlers(m_,ar)),onBlur:Eo(composeEventHandlers(L_,Qs)),onClick:$o(composeEventHandlers(Z_,_a)),onDragEnter:js(composeEventHandlers(Ty,r_)),onDragOver:js(composeEventHandlers(ey,d_)),onDragLeave:js(composeEventHandlers(yy,na)),onDrop:js(composeEventHandlers(O_,vu)),role:typeof i_=="string"&&i_!==""?i_:"presentation"},au,Ir),!s&&!Zt?{tabIndex:0}:{}),fy)}},[Ir,e_,ar,Qs,_a,r_,d_,na,vu,Zt,gr,s]),Kr=reactExports.useCallback(function(Mo){Mo.stopPropagation()},[]),Oo=reactExports.useMemo(function(){return function(){var Mo=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},qs=Mo.refKey,au=qs===void 0?"ref":qs,i_=Mo.onChange,$u=Mo.onClick,m_=_objectWithoutProperties(Mo,_excluded4),L_=_defineProperty({accept:Do,multiple:et,type:"file",style:{display:"none"},onChange:$o(composeEventHandlers(i_,vu)),onClick:$o(composeEventHandlers($u,Kr)),tabIndex:-1},au,Yo);return _objectSpread(_objectSpread({},L_),m_)}},[Yo,i,et,vu,s]);return _objectSpread(_objectSpread({},tn),{},{isFocused:Qo&&!s,getRootProps:rn,getInputProps:Oo,rootRef:Ir,inputRef:Yo,open:$o(Cu)})}function reducer(e,o){switch(o.type){case"focus":return _objectSpread(_objectSpread({},e),{},{isFocused:!0});case"blur":return _objectSpread(_objectSpread({},e),{},{isFocused:!1});case"openDialog":return _objectSpread(_objectSpread({},initialState),{},{isFileDialogActive:!0});case"closeDialog":return _objectSpread(_objectSpread({},e),{},{isFileDialogActive:!1});case"setDraggedFiles":return _objectSpread(_objectSpread({},e),{},{isDragActive:o.isDragActive,isDragAccept:o.isDragAccept,isDragReject:o.isDragReject});case"setFiles":return _objectSpread(_objectSpread({},e),{},{acceptedFiles:o.acceptedFiles,fileRejections:o.fileRejections});case"reset":return _objectSpread({},initialState);default:return e}}function noop(){}var define_process_env_default={},__webpack_modules__={"./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":(e,o,i)=>{e.exports=i.p+"ort-wasm-simd-threaded.jsep.wasm"},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,o,i)=>{i.r(o),i.d(o,{Environment:()=>Qs,Interpreter:()=>_a,Template:()=>js,parse:()=>Qo,tokenize:()=>g});var s=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),h=Object.freeze({set:s.Set,for:s.For,in:s.In,is:s.Is,if:s.If,else:s.Else,endif:s.EndIf,elif:s.ElseIf,endfor:s.EndFor,and:s.And,or:s.Or,not:s.Not,"not in":s.NotIn,macro:s.Macro,endmacro:s.EndMacro,true:s.BooleanLiteral,false:s.BooleanLiteral,True:s.BooleanLiteral,False:s.BooleanLiteral}),a=class{constructor(Lr,rn){this.value=Lr,this.type=rn}};function d(Lr){return/\w/.test(Lr)}function et(Lr){return/[0-9]/.test(Lr)}var $=[["{%",s.OpenStatement],["%}",s.CloseStatement],["{{",s.OpenExpression],["}}",s.CloseExpression],["(",s.OpenParen],[")",s.CloseParen],["{",s.OpenCurlyBracket],["}",s.CloseCurlyBracket],["[",s.OpenSquareBracket],["]",s.CloseSquareBracket],[",",s.Comma],[".",s.Dot],[":",s.Colon],["|",s.Pipe],["<=",s.ComparisonBinaryOperator],[">=",s.ComparisonBinaryOperator],["==",s.ComparisonBinaryOperator],["!=",s.ComparisonBinaryOperator],["<",s.ComparisonBinaryOperator],[">",s.ComparisonBinaryOperator],["+",s.AdditiveBinaryOperator],["-",s.AdditiveBinaryOperator],["*",s.MultiplicativeBinaryOperator],["/",s.MultiplicativeBinaryOperator],["%",s.MultiplicativeBinaryOperator],["=",s.Equals]],c=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function b(Lr,rn={}){return Lr.endsWith(`
`)&&(Lr=Lr.slice(0,-1)),Lr=Lr.replace(/{#.*?#}/gs,"{##}"),rn.lstrip_blocks&&(Lr=Lr.replace(/^[ \t]*({[#%])/gm,"$1")),rn.trim_blocks&&(Lr=Lr.replace(/([#%]})\n/g,"$1")),Lr.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function g(Lr,rn={}){const Kr=[],Oo=b(Lr,rn);let Mo=0;const qs=au=>{let i_="";for(;au(Oo[Mo]);){if(Oo[Mo]==="\\"){if(++Mo,Mo>=Oo.length)throw new SyntaxError("Unexpected end of input");const $u=Oo[Mo++],m_=c.get($u);if(m_===void 0)throw new SyntaxError(`Unexpected escaped character: ${$u}`);i_+=m_;continue}if(i_+=Oo[Mo++],Mo>=Oo.length)throw new SyntaxError("Unexpected end of input")}return i_};e:for(;Mo<Oo.length;){const au=Kr.at(-1)?.type;if(au===void 0||au===s.CloseStatement||au===s.CloseExpression){let $u="";for(;Mo<Oo.length&&!(Oo[Mo]==="{"&&(Oo[Mo+1]==="%"||Oo[Mo+1]==="{"));)$u+=Oo[Mo++];if($u.length>0){Kr.push(new a($u,s.Text));continue}}qs($u=>/\s/.test($u));const i_=Oo[Mo];if(i_==="-"||i_==="+"){const $u=Kr.at(-1)?.type;if($u===s.Text||$u===void 0)throw new SyntaxError(`Unexpected character: ${i_}`);switch($u){case s.Identifier:case s.NumericLiteral:case s.BooleanLiteral:case s.StringLiteral:case s.CloseParen:case s.CloseSquareBracket:break;default:{++Mo;const m_=qs(et);Kr.push(new a(`${i_}${m_}`,m_.length>0?s.NumericLiteral:s.UnaryOperator));continue}}}for(const[$u,m_]of $)if(Oo.slice(Mo,Mo+$u.length)===$u){Kr.push(new a($u,m_)),Mo+=$u.length;continue e}if(i_==="'"||i_==='"'){++Mo;const $u=qs(m_=>m_!==i_);Kr.push(new a($u,s.StringLiteral)),++Mo;continue}if(et(i_)){const $u=qs(et);Kr.push(new a($u,s.NumericLiteral));continue}if(d(i_)){const $u=qs(d),m_=Object.hasOwn(h,$u)?h[$u]:s.Identifier;m_===s.In&&Kr.at(-1)?.type===s.Not?(Kr.pop(),Kr.push(new a("not in",s.NotIn))):Kr.push(new a($u,m_));continue}throw new SyntaxError(`Unexpected character: ${i_}`)}return Kr}var nt=class{type="Statement"},at=class extends nt{constructor(Lr){super(),this.body=Lr}type="Program"},Ot=class extends nt{constructor(Lr,rn,Kr){super(),this.test=Lr,this.body=rn,this.alternate=Kr}type="If"},At=class extends nt{constructor(Lr,rn,Kr,Oo){super(),this.loopvar=Lr,this.iterable=rn,this.body=Kr,this.defaultBlock=Oo}type="For"},Ct=class extends nt{constructor(Lr,rn){super(),this.assignee=Lr,this.value=rn}type="Set"},St=class extends nt{constructor(Lr,rn,Kr){super(),this.name=Lr,this.args=rn,this.body=Kr}type="Macro"},xt=class extends nt{type="Expression"},Dt=class extends xt{constructor(Lr,rn,Kr){super(),this.object=Lr,this.property=rn,this.computed=Kr}type="MemberExpression"},Qt=class extends xt{constructor(Lr,rn){super(),this.callee=Lr,this.args=rn}type="CallExpression"},Zt=class extends xt{constructor(Lr){super(),this.value=Lr}type="Identifier"},gr=class extends xt{constructor(Lr){super(),this.value=Lr}type="Literal"},vr=class extends gr{type="NumericLiteral"},Er=class extends gr{type="StringLiteral"},wo=class extends gr{type="BooleanLiteral"},Do=class extends gr{type="ArrayLiteral"},Js=class extends gr{type="TupleLiteral"},In=class extends gr{type="ObjectLiteral"},Wo=class extends xt{constructor(Lr,rn,Kr){super(),this.operator=Lr,this.left=rn,this.right=Kr}type="BinaryExpression"},Ir=class extends xt{constructor(Lr,rn){super(),this.operand=Lr,this.filter=rn}type="FilterExpression"},Yo=class extends xt{constructor(Lr,rn){super(),this.iterable=Lr,this.test=rn}type="SelectExpression"},Bu=class extends xt{constructor(Lr,rn,Kr){super(),this.operand=Lr,this.negate=rn,this.test=Kr}type="TestExpression"},Ho=class extends xt{constructor(Lr,rn){super(),this.operator=Lr,this.argument=rn}type="UnaryExpression"},tn=class extends xt{constructor(Lr=void 0,rn=void 0,Kr=void 0){super(),this.start=Lr,this.stop=rn,this.step=Kr}type="SliceExpression"},To=class extends xt{constructor(Lr,rn){super(),this.key=Lr,this.value=rn}type="KeywordArgumentExpression"};function Qo(Lr){const rn=new at([]);let Kr=0;function Oo(pu,T_){const E_=Lr[Kr++];if(!E_||E_.type!==pu)throw new Error(`Parser Error: ${T_}. ${E_.type} !== ${pu}.`);return E_}function Mo(){switch(Lr[Kr].type){case s.Text:return i_();case s.OpenStatement:return $u();case s.OpenExpression:return m_();default:throw new SyntaxError(`Unexpected token type: ${Lr[Kr].type}`)}}function qs(...pu){return Kr+pu.length<=Lr.length&&pu.some((T_,E_)=>T_!==Lr[Kr+E_].type)}function au(...pu){return Kr+pu.length<=Lr.length&&pu.every((T_,E_)=>T_===Lr[Kr+E_].type)}function i_(){return new Er(Oo(s.Text,"Expected text token").value)}function $u(){Oo(s.OpenStatement,"Expected opening statement token");let pu;switch(Lr[Kr].type){case s.Set:++Kr,pu=L_(),Oo(s.CloseStatement,"Expected closing statement token");break;case s.If:++Kr,pu=Z_(),Oo(s.OpenStatement,"Expected {% token"),Oo(s.EndIf,"Expected endif token"),Oo(s.CloseStatement,"Expected %} token");break;case s.Macro:++Kr,pu=Ty(),Oo(s.OpenStatement,"Expected {% token"),Oo(s.EndMacro,"Expected endmacro token"),Oo(s.CloseStatement,"Expected %} token");break;case s.For:++Kr,pu=yy(),Oo(s.OpenStatement,"Expected {% token"),Oo(s.EndFor,"Expected endfor token"),Oo(s.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${Lr[Kr].type}`)}return pu}function m_(){Oo(s.OpenExpression,"Expected opening expression token");const pu=O_();return Oo(s.CloseExpression,"Expected closing expression token"),pu}function L_(){const pu=O_();if(au(s.Equals)){++Kr;const T_=L_();return new Ct(pu,T_)}return pu}function Z_(){const pu=O_();Oo(s.CloseStatement,"Expected closing statement token");const T_=[],E_=[];for(;!(Lr[Kr]?.type===s.OpenStatement&&(Lr[Kr+1]?.type===s.ElseIf||Lr[Kr+1]?.type===s.Else||Lr[Kr+1]?.type===s.EndIf));)T_.push(Mo());if(Lr[Kr]?.type===s.OpenStatement&&Lr[Kr+1]?.type!==s.EndIf)if(++Kr,au(s.ElseIf))Oo(s.ElseIf,"Expected elseif token"),E_.push(Z_());else for(Oo(s.Else,"Expected else token"),Oo(s.CloseStatement,"Expected closing statement token");!(Lr[Kr]?.type===s.OpenStatement&&Lr[Kr+1]?.type===s.EndIf);)E_.push(Mo());return new Ot(pu,T_,E_)}function Ty(){const pu=j_();if(pu.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const T_=k_();Oo(s.CloseStatement,"Expected closing statement token");const E_=[];for(;qs(s.OpenStatement,s.EndMacro);)E_.push(Mo());return new St(pu,T_,E_)}function ey(pu=!1){const T_=pu?j_:O_,E_=[T_()],iy=au(s.Comma);for(;iy&&(++Kr,E_.push(T_()),!!au(s.Comma)););return iy?new Js(E_):E_[0]}function yy(){const pu=ey(!0);if(!(pu instanceof Zt||pu instanceof Js))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${pu.type} instead`);Oo(s.In,"Expected `in` keyword following loop variable");const T_=O_();Oo(s.CloseStatement,"Expected closing statement token");const E_=[];for(;qs(s.OpenStatement,s.EndFor)&&qs(s.OpenStatement,s.Else);)E_.push(Mo());const iy=[];if(au(s.OpenStatement,s.Else))for(++Kr,++Kr,Oo(s.CloseStatement,"Expected closing statement token");qs(s.OpenStatement,s.EndFor);)iy.push(Mo());return new At(pu,T_,E_,iy)}function O_(){return fy()}function fy(){const pu=g_();if(au(s.If)){++Kr;const T_=g_();if(au(s.Else)){++Kr;const E_=g_();return new Ot(T_,[pu],[E_])}else return new Yo(pu,T_)}return pu}function g_(){let pu=jo();for(;au(s.Or);){const T_=Lr[Kr];++Kr;const E_=jo();pu=new Wo(T_,pu,E_)}return pu}function jo(){let pu=Xs();for(;au(s.And);){const T_=Lr[Kr];++Kr;const E_=Xs();pu=new Wo(T_,pu,E_)}return pu}function Xs(){let pu;for(;au(s.Not);){const T_=Lr[Kr];++Kr;const E_=Xs();pu=new Ho(T_,E_)}return pu??_d()}function _d(){let pu=w_();for(;au(s.ComparisonBinaryOperator)||au(s.In)||au(s.NotIn);){const T_=Lr[Kr];++Kr;const E_=w_();pu=new Wo(T_,pu,E_)}return pu}function w_(){let pu=N_();for(;au(s.AdditiveBinaryOperator);){const T_=Lr[Kr];++Kr;const E_=N_();pu=new Wo(T_,pu,E_)}return pu}function mu(){const pu=P_();return au(s.OpenParen)?y_(pu):pu}function y_(pu){let T_=new Qt(pu,k_());return au(s.OpenParen)&&(T_=y_(T_)),T_}function k_(){Oo(s.OpenParen,"Expected opening parenthesis for arguments list");const pu=S_();return Oo(s.CloseParen,"Expected closing parenthesis for arguments list"),pu}function S_(){const pu=[];for(;!au(s.CloseParen);){let T_=O_();if(au(s.Equals)){if(++Kr,!(T_ instanceof Zt))throw new SyntaxError("Expected identifier for keyword argument");const E_=O_();T_=new To(T_,E_)}pu.push(T_),au(s.Comma)&&++Kr}return pu}function B_(){const pu=[];let T_=!1;for(;!au(s.CloseSquareBracket);)au(s.Colon)?(pu.push(void 0),++Kr,T_=!0):(pu.push(O_()),au(s.Colon)&&(++Kr,T_=!0));if(pu.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(T_){if(pu.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new tn(...pu)}return pu[0]}function P_(){let pu=j_();for(;au(s.Dot)||au(s.OpenSquareBracket);){const T_=Lr[Kr];++Kr;let E_;const iy=T_.type!==s.Dot;if(iy)E_=B_(),Oo(s.CloseSquareBracket,"Expected closing square bracket");else if(E_=j_(),E_.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");pu=new Dt(pu,E_,iy)}return pu}function N_(){let pu=q_();for(;au(s.MultiplicativeBinaryOperator);){const T_=Lr[Kr];++Kr;const E_=q_();pu=new Wo(T_,pu,E_)}return pu}function q_(){let pu=H_();for(;au(s.Is);){++Kr;const T_=au(s.Not);T_&&++Kr;let E_=j_();if(E_ instanceof wo&&(E_=new Zt(E_.value.toString())),!(E_ instanceof Zt))throw new SyntaxError("Expected identifier for the test");pu=new Bu(pu,T_,E_)}return pu}function H_(){let pu=mu();for(;au(s.Pipe);){++Kr;let T_=j_();if(!(T_ instanceof Zt))throw new SyntaxError("Expected identifier for the filter");au(s.OpenParen)&&(T_=y_(T_)),pu=new Ir(pu,T_)}return pu}function j_(){const pu=Lr[Kr];switch(pu.type){case s.NumericLiteral:return++Kr,new vr(Number(pu.value));case s.StringLiteral:return++Kr,new Er(pu.value);case s.BooleanLiteral:return++Kr,new wo(pu.value.toLowerCase()==="true");case s.Identifier:return++Kr,new Zt(pu.value);case s.OpenParen:{++Kr;const T_=ey();if(Lr[Kr].type!==s.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${Lr[Kr].type} instead`);return++Kr,T_}case s.OpenSquareBracket:{++Kr;const T_=[];for(;!au(s.CloseSquareBracket);)T_.push(O_()),au(s.Comma)&&++Kr;return++Kr,new Do(T_)}case s.OpenCurlyBracket:{++Kr;const T_=new Map;for(;!au(s.CloseCurlyBracket);){const E_=O_();Oo(s.Colon,"Expected colon between key and value in object literal");const iy=O_();T_.set(E_,iy),au(s.Comma)&&++Kr}return++Kr,new In(T_)}default:throw new SyntaxError(`Unexpected token: ${pu.type}`)}}for(;Kr<Lr.length;)rn.body.push(Mo());return rn}function Jr(Lr,rn,Kr=1){rn===void 0&&(rn=Lr,Lr=0);const Oo=[];for(let Mo=Lr;Mo<rn;Mo+=Kr)Oo.push(Mo);return Oo}function Lo(Lr,rn,Kr,Oo=1){const Mo=Math.sign(Oo);Mo>=0?(rn=(rn??=0)<0?Math.max(Lr.length+rn,0):Math.min(rn,Lr.length),Kr=(Kr??=Lr.length)<0?Math.max(Lr.length+Kr,0):Math.min(Kr,Lr.length)):(rn=(rn??=Lr.length-1)<0?Math.max(Lr.length+rn,-1):Math.min(rn,Lr.length-1),Kr=(Kr??=-1)<-1?Math.max(Lr.length+Kr,-1):Math.min(Kr,Lr.length-1));const qs=[];for(let au=rn;Mo*au<Mo*Kr;au+=Oo)qs.push(Lr[au]);return qs}function Du(Lr){return Lr.replace(/\b\w/g,rn=>rn.toUpperCase())}var _u=class{type="RuntimeValue";value;builtins=new Map;constructor(Lr=void 0){this.value=Lr}__bool__(){return new r_(!!this.value)}},du=class extends _u{type="NumericValue"},wu=class extends _u{type="StringValue";builtins=new Map([["upper",new Cu(()=>new wu(this.value.toUpperCase()))],["lower",new Cu(()=>new wu(this.value.toLowerCase()))],["strip",new Cu(()=>new wu(this.value.trim()))],["title",new Cu(()=>new wu(Du(this.value)))],["length",new du(this.value.length)]])},r_=class extends _u{type="BooleanValue"},d_=class extends _u{type="ObjectValue";__bool__(){return new r_(this.value.size>0)}builtins=new Map([["get",new Cu(([Lr,rn])=>{if(!(Lr instanceof wu))throw new Error(`Object key must be a string: got ${Lr.type}`);return this.value.get(Lr.value)??rn??new e_})],["items",new Cu(()=>new Ko(Array.from(this.value.entries()).map(([Lr,rn])=>new Ko([new wu(Lr),rn]))))]])},na=class extends d_{type="KeywordArgumentsValue"},Ko=class extends _u{type="ArrayValue";builtins=new Map([["length",new du(this.value.length)]]);__bool__(){return new r_(this.value.length>0)}},vu=class extends Ko{type="TupleValue"},Cu=class extends _u{type="FunctionValue"},e_=class extends _u{type="NullValue"},ar=class extends _u{type="UndefinedValue"},Qs=class{constructor(Lr){this.parent=Lr}variables=new Map([["namespace",new Cu(Lr=>{if(Lr.length===0)return new d_(new Map);if(Lr.length!==1||!(Lr[0]instanceof d_))throw new Error("`namespace` expects either zero arguments or a single object argument");return Lr[0]})]]);tests=new Map([["boolean",Lr=>Lr.type==="BooleanValue"],["callable",Lr=>Lr instanceof Cu],["odd",Lr=>{if(Lr.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${Lr.type}`);return Lr.value%2!==0}],["even",Lr=>{if(Lr.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${Lr.type}`);return Lr.value%2===0}],["false",Lr=>Lr.type==="BooleanValue"&&!Lr.value],["true",Lr=>Lr.type==="BooleanValue"&&Lr.value],["string",Lr=>Lr.type==="StringValue"],["number",Lr=>Lr.type==="NumericValue"],["integer",Lr=>Lr.type==="NumericValue"&&Number.isInteger(Lr.value)],["iterable",Lr=>Lr instanceof Ko||Lr instanceof wu],["lower",Lr=>{const rn=Lr.value;return Lr.type==="StringValue"&&rn===rn.toLowerCase()}],["upper",Lr=>{const rn=Lr.value;return Lr.type==="StringValue"&&rn===rn.toUpperCase()}],["none",Lr=>Lr.type==="NullValue"],["defined",Lr=>Lr.type!=="UndefinedValue"],["undefined",Lr=>Lr.type==="UndefinedValue"],["equalto",(Lr,rn)=>Lr.value===rn.value],["eq",(Lr,rn)=>Lr.value===rn.value]]);set(Lr,rn){return this.declareVariable(Lr,$o(rn))}declareVariable(Lr,rn){if(this.variables.has(Lr))throw new SyntaxError(`Variable already declared: ${Lr}`);return this.variables.set(Lr,rn),rn}setVariable(Lr,rn){return this.variables.set(Lr,rn),rn}resolve(Lr){if(this.variables.has(Lr))return this;if(this.parent)return this.parent.resolve(Lr);throw new Error(`Unknown variable: ${Lr}`)}lookupVariable(Lr){try{return this.resolve(Lr).variables.get(Lr)??new ar}catch{return new ar}}},_a=class{global;constructor(Lr){this.global=Lr??new Qs}run(Lr){return this.evaluate(Lr,this.global)}evaluateBinaryExpression(Lr,rn){const Kr=this.evaluate(Lr.left,rn);switch(Lr.operator.value){case"and":return Kr.__bool__().value?this.evaluate(Lr.right,rn):Kr;case"or":return Kr.__bool__().value?Kr:this.evaluate(Lr.right,rn)}const Oo=this.evaluate(Lr.right,rn);switch(Lr.operator.value){case"==":return new r_(Kr.value==Oo.value);case"!=":return new r_(Kr.value!=Oo.value)}if(Kr instanceof ar||Oo instanceof ar)throw new Error("Cannot perform operation on undefined values");if(Kr instanceof e_||Oo instanceof e_)throw new Error("Cannot perform operation on null values");if(Kr instanceof du&&Oo instanceof du)switch(Lr.operator.value){case"+":return new du(Kr.value+Oo.value);case"-":return new du(Kr.value-Oo.value);case"*":return new du(Kr.value*Oo.value);case"/":return new du(Kr.value/Oo.value);case"%":return new du(Kr.value%Oo.value);case"<":return new r_(Kr.value<Oo.value);case">":return new r_(Kr.value>Oo.value);case">=":return new r_(Kr.value>=Oo.value);case"<=":return new r_(Kr.value<=Oo.value)}else if(Kr instanceof Ko&&Oo instanceof Ko)switch(Lr.operator.value){case"+":return new Ko(Kr.value.concat(Oo.value))}else if(Oo instanceof Ko){const Mo=Oo.value.find(qs=>qs.value===Kr.value)!==void 0;switch(Lr.operator.value){case"in":return new r_(Mo);case"not in":return new r_(!Mo)}}if(Kr instanceof wu||Oo instanceof wu)switch(Lr.operator.value){case"+":return new wu(Kr.value.toString()+Oo.value.toString())}if(Kr instanceof wu&&Oo instanceof wu)switch(Lr.operator.value){case"in":return new r_(Oo.value.includes(Kr.value));case"not in":return new r_(!Oo.value.includes(Kr.value))}if(Kr instanceof wu&&Oo instanceof d_)switch(Lr.operator.value){case"in":return new r_(Oo.value.has(Kr.value));case"not in":return new r_(!Oo.value.has(Kr.value))}throw new SyntaxError(`Unknown operator "${Lr.operator.value}" between ${Kr.type} and ${Oo.type}`)}evaluateArguments(Lr,rn){const Kr=[],Oo=new Map;for(const Mo of Lr)if(Mo.type==="KeywordArgumentExpression"){const qs=Mo;Oo.set(qs.key.value,this.evaluate(qs.value,rn))}else{if(Oo.size>0)throw new Error("Positional arguments must come before keyword arguments");Kr.push(this.evaluate(Mo,rn))}return[Kr,Oo]}evaluateFilterExpression(Lr,rn){const Kr=this.evaluate(Lr.operand,rn);if(Lr.filter.type==="Identifier"){const Oo=Lr.filter;if(Oo.value==="tojson")return new wu(Eo(Kr));if(Kr instanceof Ko)switch(Oo.value){case"list":return Kr;case"first":return Kr.value[0];case"last":return Kr.value[Kr.value.length-1];case"length":return new du(Kr.value.length);case"reverse":return new Ko(Kr.value.reverse());case"sort":return new Ko(Kr.value.sort((Mo,qs)=>{if(Mo.type!==qs.type)throw new Error(`Cannot compare different types: ${Mo.type} and ${qs.type}`);switch(Mo.type){case"NumericValue":return Mo.value-qs.value;case"StringValue":return Mo.value.localeCompare(qs.value);default:throw new Error(`Cannot compare type: ${Mo.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${Oo.value}`)}else if(Kr instanceof wu)switch(Oo.value){case"length":return new du(Kr.value.length);case"upper":return new wu(Kr.value.toUpperCase());case"lower":return new wu(Kr.value.toLowerCase());case"title":return new wu(Du(Kr.value));case"capitalize":return new wu(Kr.value.charAt(0).toUpperCase()+Kr.value.slice(1));case"trim":return new wu(Kr.value.trim());case"indent":return new wu(Kr.value.split(`
`).map((Mo,qs)=>qs===0||Mo.length===0?Mo:"    "+Mo).join(`
`));case"string":return Kr;default:throw new Error(`Unknown StringValue filter: ${Oo.value}`)}else if(Kr instanceof du)switch(Oo.value){case"abs":return new du(Math.abs(Kr.value));default:throw new Error(`Unknown NumericValue filter: ${Oo.value}`)}else if(Kr instanceof d_)switch(Oo.value){case"items":return new Ko(Array.from(Kr.value.entries()).map(([Mo,qs])=>new Ko([new wu(Mo),qs])));case"length":return new du(Kr.value.size);default:throw new Error(`Unknown ObjectValue filter: ${Oo.value}`)}throw new Error(`Cannot apply filter "${Oo.value}" to type: ${Kr.type}`)}else if(Lr.filter.type==="CallExpression"){const Oo=Lr.filter;if(Oo.callee.type!=="Identifier")throw new Error(`Unknown filter: ${Oo.callee.type}`);const Mo=Oo.callee.value;if(Mo==="tojson"){const[,qs]=this.evaluateArguments(Oo.args,rn),au=qs.get("indent")??new e_;if(!(au instanceof du||au instanceof e_))throw new Error("If set, indent must be a number");return new wu(Eo(Kr,au.value))}if(Kr instanceof Ko){switch(Mo){case"selectattr":{if(Kr.value.some(L_=>!(L_ instanceof d_)))throw new Error("`selectattr` can only be applied to array of objects");if(Oo.args.some(L_=>L_.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[qs,au,i_]=Oo.args.map(L_=>this.evaluate(L_,rn));let $u;if(au){const L_=rn.tests.get(au.value);if(!L_)throw new Error(`Unknown test: ${au.value}`);$u=L_}else $u=(...L_)=>L_[0].__bool__().value;const m_=Kr.value.filter(L_=>{const Z_=L_.value.get(qs.value);return Z_?$u(Z_,i_):!1});return new Ko(m_)}case"map":{const[,qs]=this.evaluateArguments(Oo.args,rn);if(qs.has("attribute")){const au=qs.get("attribute");if(!(au instanceof wu))throw new Error("attribute must be a string");const i_=qs.get("default"),$u=Kr.value.map(m_=>{if(!(m_ instanceof d_))throw new Error("items in map must be an object");return m_.value.get(au.value)??i_??new ar});return new Ko($u)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${Mo}`)}else if(Kr instanceof wu){switch(Mo){case"indent":{const[qs,au]=this.evaluateArguments(Oo.args,rn),i_=qs.at(0)??au.get("width")??new du(4);if(!(i_ instanceof du))throw new Error("width must be a number");const $u=qs.at(1)??au.get("first")??new r_(!1),m_=qs.at(2)??au.get("blank")??new r_(!1),L_=Kr.value.split(`
`),Z_=" ".repeat(i_.value),Ty=L_.map((ey,yy)=>!$u.value&&yy===0||!m_.value&&ey.length===0?ey:Z_+ey);return new wu(Ty.join(`
`))}}throw new Error(`Unknown StringValue filter: ${Mo}`)}else throw new Error(`Cannot apply filter "${Mo}" to type: ${Kr.type}`)}throw new Error(`Unknown filter: ${Lr.filter.type}`)}evaluateTestExpression(Lr,rn){const Kr=this.evaluate(Lr.operand,rn),Oo=rn.tests.get(Lr.test.value);if(!Oo)throw new Error(`Unknown test: ${Lr.test.value}`);const Mo=Oo(Kr);return new r_(Lr.negate?!Mo:Mo)}evaluateUnaryExpression(Lr,rn){const Kr=this.evaluate(Lr.argument,rn);switch(Lr.operator.value){case"not":return new r_(!Kr.value);default:throw new SyntaxError(`Unknown operator: ${Lr.operator.value}`)}}evalProgram(Lr,rn){return this.evaluateBlock(Lr.body,rn)}evaluateBlock(Lr,rn){let Kr="";for(const Oo of Lr){const Mo=this.evaluate(Oo,rn);Mo.type!=="NullValue"&&Mo.type!=="UndefinedValue"&&(Kr+=Mo.value)}return new wu(Kr)}evaluateIdentifier(Lr,rn){return rn.lookupVariable(Lr.value)}evaluateCallExpression(Lr,rn){const[Kr,Oo]=this.evaluateArguments(Lr.args,rn);Oo.size>0&&Kr.push(new na(Oo));const Mo=this.evaluate(Lr.callee,rn);if(Mo.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${Mo.type}`);return Mo.value(Kr,rn)}evaluateSliceExpression(Lr,rn,Kr){if(!(Lr instanceof Ko||Lr instanceof wu))throw new Error("Slice object must be an array or string");const Oo=this.evaluate(rn.start,Kr),Mo=this.evaluate(rn.stop,Kr),qs=this.evaluate(rn.step,Kr);if(!(Oo instanceof du||Oo instanceof ar))throw new Error("Slice start must be numeric or undefined");if(!(Mo instanceof du||Mo instanceof ar))throw new Error("Slice stop must be numeric or undefined");if(!(qs instanceof du||qs instanceof ar))throw new Error("Slice step must be numeric or undefined");return Lr instanceof Ko?new Ko(Lo(Lr.value,Oo.value,Mo.value,qs.value)):new wu(Lo(Array.from(Lr.value),Oo.value,Mo.value,qs.value).join(""))}evaluateMemberExpression(Lr,rn){const Kr=this.evaluate(Lr.object,rn);let Oo;if(Lr.computed){if(Lr.property.type==="SliceExpression")return this.evaluateSliceExpression(Kr,Lr.property,rn);Oo=this.evaluate(Lr.property,rn)}else Oo=new wu(Lr.property.value);let Mo;if(Kr instanceof d_){if(!(Oo instanceof wu))throw new Error(`Cannot access property with non-string: got ${Oo.type}`);Mo=Kr.value.get(Oo.value)??Kr.builtins.get(Oo.value)}else if(Kr instanceof Ko||Kr instanceof wu)if(Oo instanceof du)Mo=Kr.value.at(Oo.value),Kr instanceof wu&&(Mo=new wu(Kr.value.at(Oo.value)));else if(Oo instanceof wu)Mo=Kr.builtins.get(Oo.value);else throw new Error(`Cannot access property with non-string/non-number: got ${Oo.type}`);else{if(!(Oo instanceof wu))throw new Error(`Cannot access property with non-string: got ${Oo.type}`);Mo=Kr.builtins.get(Oo.value)}return Mo instanceof _u?Mo:new ar}evaluateSet(Lr,rn){const Kr=this.evaluate(Lr.value,rn);if(Lr.assignee.type==="Identifier"){const Oo=Lr.assignee.value;rn.setVariable(Oo,Kr)}else if(Lr.assignee.type==="MemberExpression"){const Oo=Lr.assignee,Mo=this.evaluate(Oo.object,rn);if(!(Mo instanceof d_))throw new Error("Cannot assign to member of non-object");if(Oo.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");Mo.value.set(Oo.property.value,Kr)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(Lr.assignee)}`);return new e_}evaluateIf(Lr,rn){const Kr=this.evaluate(Lr.test,rn);return this.evaluateBlock(Kr.__bool__().value?Lr.body:Lr.alternate,rn)}evaluateFor(Lr,rn){const Kr=new Qs(rn);let Oo,Mo;if(Lr.iterable.type==="SelectExpression"){const m_=Lr.iterable;Mo=this.evaluate(m_.iterable,Kr),Oo=m_.test}else Mo=this.evaluate(Lr.iterable,Kr);if(!(Mo instanceof Ko))throw new Error(`Expected iterable type in for loop: got ${Mo.type}`);const qs=[],au=[];for(let m_=0;m_<Mo.value.length;++m_){const L_=new Qs(Kr),Z_=Mo.value[m_];let Ty;if(Lr.loopvar.type==="Identifier")Ty=ey=>ey.setVariable(Lr.loopvar.value,Z_);else if(Lr.loopvar.type==="TupleLiteral"){const ey=Lr.loopvar;if(Z_.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${Z_.type}`);const yy=Z_;if(ey.value.length!==yy.value.length)throw new Error(`Too ${ey.value.length>yy.value.length?"few":"many"} items to unpack`);Ty=O_=>{for(let fy=0;fy<ey.value.length;++fy){if(ey.value[fy].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${ey.value[fy].type}`);O_.setVariable(ey.value[fy].value,yy.value[fy])}}}else throw new Error(`Invalid loop variable(s): ${Lr.loopvar.type}`);Oo&&(Ty(L_),!this.evaluate(Oo,L_).__bool__().value)||(qs.push(Z_),au.push(Ty))}let i_="",$u=!0;for(let m_=0;m_<qs.length;++m_){const L_=new Map([["index",new du(m_+1)],["index0",new du(m_)],["revindex",new du(qs.length-m_)],["revindex0",new du(qs.length-m_-1)],["first",new r_(m_===0)],["last",new r_(m_===qs.length-1)],["length",new du(qs.length)],["previtem",m_>0?qs[m_-1]:new ar],["nextitem",m_<qs.length-1?qs[m_+1]:new ar]]);Kr.setVariable("loop",new d_(L_)),au[m_](Kr);const Z_=this.evaluateBlock(Lr.body,Kr);i_+=Z_.value,$u=!1}if($u){const m_=this.evaluateBlock(Lr.defaultBlock,Kr);i_+=m_.value}return new wu(i_)}evaluateMacro(Lr,rn){return rn.setVariable(Lr.name.value,new Cu((Kr,Oo)=>{const Mo=new Qs(Oo);Kr=Kr.slice();let qs;Kr.at(-1)?.type==="KeywordArgumentsValue"&&(qs=Kr.pop());for(let au=0;au<Lr.args.length;++au){const i_=Lr.args[au],$u=Kr[au];if(i_.type==="Identifier"){const m_=i_;if(!$u)throw new Error(`Missing positional argument: ${m_.value}`);Mo.setVariable(m_.value,$u)}else if(i_.type==="KeywordArgumentExpression"){const m_=i_,L_=$u??qs?.value.get(m_.key.value)??this.evaluate(m_.value,Mo);Mo.setVariable(m_.key.value,L_)}else throw new Error(`Unknown argument type: ${i_.type}`)}return this.evaluateBlock(Lr.body,Mo)})),new e_}evaluate(Lr,rn){if(Lr===void 0)return new ar;switch(Lr.type){case"Program":return this.evalProgram(Lr,rn);case"Set":return this.evaluateSet(Lr,rn);case"If":return this.evaluateIf(Lr,rn);case"For":return this.evaluateFor(Lr,rn);case"Macro":return this.evaluateMacro(Lr,rn);case"NumericLiteral":return new du(Number(Lr.value));case"StringLiteral":return new wu(Lr.value);case"BooleanLiteral":return new r_(Lr.value);case"ArrayLiteral":return new Ko(Lr.value.map(Kr=>this.evaluate(Kr,rn)));case"TupleLiteral":return new vu(Lr.value.map(Kr=>this.evaluate(Kr,rn)));case"ObjectLiteral":{const Kr=new Map;for(const[Oo,Mo]of Lr.value){const qs=this.evaluate(Oo,rn);if(!(qs instanceof wu))throw new Error(`Object keys must be strings: got ${qs.type}`);Kr.set(qs.value,this.evaluate(Mo,rn))}return new d_(Kr)}case"Identifier":return this.evaluateIdentifier(Lr,rn);case"CallExpression":return this.evaluateCallExpression(Lr,rn);case"MemberExpression":return this.evaluateMemberExpression(Lr,rn);case"UnaryExpression":return this.evaluateUnaryExpression(Lr,rn);case"BinaryExpression":return this.evaluateBinaryExpression(Lr,rn);case"FilterExpression":return this.evaluateFilterExpression(Lr,rn);case"TestExpression":return this.evaluateTestExpression(Lr,rn);default:throw new SyntaxError(`Unknown node type: ${Lr.type}`)}}};function $o(Lr){switch(typeof Lr){case"number":return new du(Lr);case"string":return new wu(Lr);case"boolean":return new r_(Lr);case"undefined":return new ar;case"object":return Lr===null?new e_:Array.isArray(Lr)?new Ko(Lr.map($o)):new d_(new Map(Object.entries(Lr).map(([rn,Kr])=>[rn,$o(Kr)])));case"function":return new Cu((rn,Kr)=>{const Oo=Lr(...rn.map(Mo=>Mo.value))??null;return $o(Oo)});default:throw new Error(`Cannot convert to runtime value: ${Lr}`)}}function Eo(Lr,rn,Kr){const Oo=Kr??0;switch(Lr.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(Lr.value);case"ArrayValue":case"ObjectValue":{const Mo=rn?" ".repeat(rn):"",qs=`
`+Mo.repeat(Oo),au=qs+Mo;if(Lr.type==="ArrayValue"){const i_=Lr.value.map($u=>Eo($u,rn,Oo+1));return rn?`[${au}${i_.join(`,${au}`)}${qs}]`:`[${i_.join(", ")}]`}else{const i_=Array.from(Lr.value.entries()).map(([$u,m_])=>{const L_=`"${$u}": ${Eo(m_,rn,Oo+1)}`;return rn?`${au}${L_}`:L_});return rn?`{${i_.join(",")}${qs}}`:`{${i_.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${Lr.type}`)}}var js=class{parsed;constructor(Lr){const rn=g(Lr,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Qo(rn)}render(Lr){const rn=new Qs;rn.set("false",!1),rn.set("true",!0),rn.set("raise_exception",Mo=>{throw new Error(Mo)}),rn.set("range",Jr);for(const[Mo,qs]of Object.entries(Lr))rn.set(Mo,qs);return new _a(rn).run(this.parsed).value}}},"./node_modules/onnxruntime-common/dist/esm/backend-impl.js":(e,o,i)=>{i.r(o),i.d(o,{registerBackend:()=>a,resolveBackendAndExecutionProviders:()=>et});const s=new Map,h=[],a=($,c,b)=>{if(c&&typeof c.init=="function"&&typeof c.createInferenceSessionHandler=="function"){const g=s.get($);if(g===void 0)s.set($,{backend:c,priority:b});else{if(g.priority>b)return;if(g.priority===b&&g.backend!==c)throw new Error(`cannot register backend "${$}" using priority ${b}`)}if(b>=0){const nt=h.indexOf($);nt!==-1&&h.splice(nt,1);for(let at=0;at<h.length;at++)if(s.get(h[at]).priority<=b){h.splice(at,0,$);return}h.push($)}return}throw new TypeError("not a valid backend")},d=async $=>{const c=s.get($);if(!c)return"backend not found.";if(c.initialized)return c.backend;if(c.aborted)return c.error;{const b=!!c.initPromise;try{return b||(c.initPromise=c.backend.init($)),await c.initPromise,c.initialized=!0,c.backend}catch(g){return b||(c.error=`${g}`,c.aborted=!0),c.error}finally{delete c.initPromise}}},et=async $=>{const c=$.executionProviders||[],b=c.map(Ct=>typeof Ct=="string"?Ct:Ct.name),g=b.length===0?h:b;let nt;const at=[],Ot=new Set;for(const Ct of g){const St=await d(Ct);typeof St=="string"?at.push({name:Ct,err:St}):(nt||(nt=St),nt===St&&Ot.add(Ct))}if(!nt)throw new Error(`no available backend found. ERR: ${at.map(Ct=>`[${Ct.name}] ${Ct.err}`).join(", ")}`);for(const{name:Ct,err:St}of at)b.includes(Ct)&&console.warn(`removing requested execution provider "${Ct}" from session options because it is not available: ${St}`);const At=c.filter(Ct=>Ot.has(typeof Ct=="string"?Ct:Ct.name));return[nt,new Proxy($,{get:(Ct,St)=>St==="executionProviders"?At:Reflect.get(Ct,St)})]}},"./node_modules/onnxruntime-common/dist/esm/backend.js":(e,o,i)=>{i.r(o),i.d(o,{registerBackend:()=>s.registerBackend});var s=i("./node_modules/onnxruntime-common/dist/esm/backend-impl.js")},"./node_modules/onnxruntime-common/dist/esm/env-impl.js":(e,o,i)=>{i.r(o),i.d(o,{env:()=>a});var s=i("./node_modules/onnxruntime-common/dist/esm/version.js");let h="warning";const a={wasm:{},webgl:{},webgpu:{},versions:{common:s.version},set logLevel(d){if(d!==void 0){if(typeof d!="string"||["verbose","info","warning","error","fatal"].indexOf(d)===-1)throw new Error(`Unsupported logging level: ${d}`);h=d}},get logLevel(){return h}};Object.defineProperty(a,"logLevel",{enumerable:!0})},"./node_modules/onnxruntime-common/dist/esm/env.js":(e,o,i)=>{i.r(o),i.d(o,{env:()=>h});var s=i("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const h=s.env},"./node_modules/onnxruntime-common/dist/esm/index.js":(e,o,i)=>{i.r(o),i.d(o,{InferenceSession:()=>a.InferenceSession,TRACE:()=>et.TRACE,TRACE_FUNC_BEGIN:()=>et.TRACE_FUNC_BEGIN,TRACE_FUNC_END:()=>et.TRACE_FUNC_END,Tensor:()=>d.Tensor,TrainingSession:()=>$.TrainingSession,env:()=>h.env,registerBackend:()=>s.registerBackend});var s=i("./node_modules/onnxruntime-common/dist/esm/backend.js"),h=i("./node_modules/onnxruntime-common/dist/esm/env.js"),a=i("./node_modules/onnxruntime-common/dist/esm/inference-session.js"),d=i("./node_modules/onnxruntime-common/dist/esm/tensor.js");i("./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"),i("./node_modules/onnxruntime-common/dist/esm/tensor-factory.js");var et=i("./node_modules/onnxruntime-common/dist/esm/trace.js");i("./node_modules/onnxruntime-common/dist/esm/onnx-model.js"),i("./node_modules/onnxruntime-common/dist/esm/onnx-value.js");var $=i("./node_modules/onnxruntime-common/dist/esm/training-session.js")},"./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js":(e,o,i)=>{i.r(o),i.d(o,{InferenceSession:()=>d});var s=i("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),h=i("./node_modules/onnxruntime-common/dist/esm/tensor.js"),a=i("./node_modules/onnxruntime-common/dist/esm/trace.js");class d{constructor($){this.handler=$}async run($,c,b){(0,a.TRACE_FUNC_BEGIN)();const g={};let nt={};if(typeof $!="object"||$===null||$ instanceof h.Tensor||Array.isArray($))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let at=!0;if(typeof c=="object"){if(c===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(c instanceof h.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(c)){if(c.length===0)throw new TypeError("'fetches' cannot be an empty array.");at=!1;for(const Ct of c){if(typeof Ct!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(Ct)===-1)throw new RangeError(`'fetches' contains invalid output name: ${Ct}.`);g[Ct]=null}if(typeof b=="object"&&b!==null)nt=b;else if(typeof b<"u")throw new TypeError("'options' must be an object.")}else{let Ct=!1;const St=Object.getOwnPropertyNames(c);for(const xt of this.outputNames)if(St.indexOf(xt)!==-1){const Dt=c[xt];(Dt===null||Dt instanceof h.Tensor)&&(Ct=!0,at=!1,g[xt]=Dt)}if(Ct){if(typeof b=="object"&&b!==null)nt=b;else if(typeof b<"u")throw new TypeError("'options' must be an object.")}else nt=c}}else if(typeof c<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const Ct of this.inputNames)if(typeof $[Ct]>"u")throw new Error(`input '${Ct}' is missing in 'feeds'.`);if(at)for(const Ct of this.outputNames)g[Ct]=null;const Ot=await this.handler.run($,g,nt),At={};for(const Ct in Ot)if(Object.hasOwnProperty.call(Ot,Ct)){const St=Ot[Ct];St instanceof h.Tensor?At[Ct]=St:At[Ct]=new h.Tensor(St.type,St.data,St.dims)}return(0,a.TRACE_FUNC_END)(),At}async release(){return this.handler.dispose()}static async create($,c,b,g){(0,a.TRACE_FUNC_BEGIN)();let nt,at={};if(typeof $=="string"){if(nt=$,typeof c=="object"&&c!==null)at=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else if($ instanceof Uint8Array){if(nt=$,typeof c=="object"&&c!==null)at=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else if($ instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&$ instanceof SharedArrayBuffer){const St=$;let xt=0,Dt=$.byteLength;if(typeof c=="object"&&c!==null)at=c;else if(typeof c=="number"){if(xt=c,!Number.isSafeInteger(xt))throw new RangeError("'byteOffset' must be an integer.");if(xt<0||xt>=St.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${St.byteLength}).`);if(Dt=$.byteLength-xt,typeof b=="number"){if(Dt=b,!Number.isSafeInteger(Dt))throw new RangeError("'byteLength' must be an integer.");if(Dt<=0||xt+Dt>St.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${St.byteLength-xt}].`);if(typeof g=="object"&&g!==null)at=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else if(typeof b<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof c<"u")throw new TypeError("'options' must be an object.");nt=new Uint8Array(St,xt,Dt)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[Ot,At]=await(0,s.resolveBackendAndExecutionProviders)(at),Ct=await Ot.createInferenceSessionHandler(nt,At);return(0,a.TRACE_FUNC_END)(),new d(Ct)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}},"./node_modules/onnxruntime-common/dist/esm/inference-session.js":(e,o,i)=>{i.r(o),i.d(o,{InferenceSession:()=>h});var s=i("./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js");const h=s.InferenceSession},"./node_modules/onnxruntime-common/dist/esm/onnx-model.js":(e,o,i)=>{i.r(o)},"./node_modules/onnxruntime-common/dist/esm/onnx-value.js":(e,o,i)=>{i.r(o)},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js":(e,o,i)=>{i.r(o),i.d(o,{tensorToDataURL:()=>s,tensorToImageData:()=>h});const s=(a,d)=>{const et=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);et.width=a.dims[3],et.height=a.dims[2];const $=et.getContext("2d");if($!=null){let c,b;d?.tensorLayout!==void 0&&d.tensorLayout==="NHWC"?(c=a.dims[2],b=a.dims[3]):(c=a.dims[3],b=a.dims[2]);const g=d?.format!==void 0?d.format:"RGB",nt=d?.norm;let at,Ot;nt===void 0||nt.mean===void 0?at=[255,255,255,255]:typeof nt.mean=="number"?at=[nt.mean,nt.mean,nt.mean,nt.mean]:(at=[nt.mean[0],nt.mean[1],nt.mean[2],0],nt.mean[3]!==void 0&&(at[3]=nt.mean[3])),nt===void 0||nt.bias===void 0?Ot=[0,0,0,0]:typeof nt.bias=="number"?Ot=[nt.bias,nt.bias,nt.bias,nt.bias]:(Ot=[nt.bias[0],nt.bias[1],nt.bias[2],0],nt.bias[3]!==void 0&&(Ot[3]=nt.bias[3]));const At=b*c;let Ct=0,St=At,xt=At*2,Dt=-1;g==="RGBA"?(Ct=0,St=At,xt=At*2,Dt=At*3):g==="RGB"?(Ct=0,St=At,xt=At*2):g==="RBG"&&(Ct=0,xt=At,St=At*2);for(let Qt=0;Qt<b;Qt++)for(let Zt=0;Zt<c;Zt++){const gr=(a.data[Ct++]-Ot[0])*at[0],vr=(a.data[St++]-Ot[1])*at[1],Er=(a.data[xt++]-Ot[2])*at[2],wo=Dt===-1?255:(a.data[Dt++]-Ot[3])*at[3];$.fillStyle="rgba("+gr+","+vr+","+Er+","+wo+")",$.fillRect(Zt,Qt,1,1)}if("toDataURL"in et)return et.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},h=(a,d)=>{const et=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let $;if(et!=null){let c,b,g;d?.tensorLayout!==void 0&&d.tensorLayout==="NHWC"?(c=a.dims[2],b=a.dims[1],g=a.dims[3]):(c=a.dims[3],b=a.dims[2],g=a.dims[1]);const nt=d!==void 0&&d.format!==void 0?d.format:"RGB",at=d?.norm;let Ot,At;at===void 0||at.mean===void 0?Ot=[255,255,255,255]:typeof at.mean=="number"?Ot=[at.mean,at.mean,at.mean,at.mean]:(Ot=[at.mean[0],at.mean[1],at.mean[2],255],at.mean[3]!==void 0&&(Ot[3]=at.mean[3])),at===void 0||at.bias===void 0?At=[0,0,0,0]:typeof at.bias=="number"?At=[at.bias,at.bias,at.bias,at.bias]:(At=[at.bias[0],at.bias[1],at.bias[2],0],at.bias[3]!==void 0&&(At[3]=at.bias[3]));const Ct=b*c;if(d!==void 0&&(d.format!==void 0&&g===4&&d.format!=="RGBA"||g===3&&d.format!=="RGB"&&d.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const St=4;let xt=0,Dt=1,Qt=2,Zt=3,gr=0,vr=Ct,Er=Ct*2,wo=-1;nt==="RGBA"?(gr=0,vr=Ct,Er=Ct*2,wo=Ct*3):nt==="RGB"?(gr=0,vr=Ct,Er=Ct*2):nt==="RBG"&&(gr=0,Er=Ct,vr=Ct*2),$=et.createImageData(c,b);for(let Do=0;Do<b*c;xt+=St,Dt+=St,Qt+=St,Zt+=St,Do++)$.data[xt]=(a.data[gr++]-At[0])*Ot[0],$.data[Dt]=(a.data[vr++]-At[1])*Ot[1],$.data[Qt]=(a.data[Er++]-At[2])*Ot[2],$.data[Zt]=wo===-1?255:(a.data[wo++]-At[3])*Ot[3]}else throw new Error("Can not access image data");return $}},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js":(e,o,i)=>{i.r(o)},"./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js":(e,o,i)=>{i.r(o),i.d(o,{bufferToTensor:()=>h,tensorFromGpuBuffer:()=>et,tensorFromImage:()=>a,tensorFromPinnedBuffer:()=>$,tensorFromTexture:()=>d});var s=i("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const h=(c,b)=>{if(c===void 0)throw new Error("Image buffer must be defined");if(b.height===void 0||b.width===void 0)throw new Error("Image height and width must be defined");if(b.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:g,width:nt}=b,at=b.norm??{mean:255,bias:0};let Ot,At;typeof at.mean=="number"?Ot=[at.mean,at.mean,at.mean,at.mean]:Ot=[at.mean[0],at.mean[1],at.mean[2],at.mean[3]??255],typeof at.bias=="number"?At=[at.bias,at.bias,at.bias,at.bias]:At=[at.bias[0],at.bias[1],at.bias[2],at.bias[3]??0];const Ct=b.format!==void 0?b.format:"RGBA",St=b.tensorFormat!==void 0&&b.tensorFormat!==void 0?b.tensorFormat:"RGB",xt=g*nt,Dt=St==="RGBA"?new Float32Array(xt*4):new Float32Array(xt*3);let Qt=4,Zt=0,gr=1,vr=2,Er=3,wo=0,Do=xt,Js=xt*2,In=-1;Ct==="RGB"&&(Qt=3,Zt=0,gr=1,vr=2,Er=-1),St==="RGBA"?In=xt*3:St==="RBG"?(wo=0,Js=xt,Do=xt*2):St==="BGR"&&(Js=0,Do=xt,wo=xt*2);for(let Ir=0;Ir<xt;Ir++,Zt+=Qt,vr+=Qt,gr+=Qt,Er+=Qt)Dt[wo++]=(c[Zt]+At[0])/Ot[0],Dt[Do++]=(c[gr]+At[1])/Ot[1],Dt[Js++]=(c[vr]+At[2])/Ot[2],In!==-1&&Er!==-1&&(Dt[In++]=(c[Er]+At[3])/Ot[3]);return St==="RGBA"?new s.Tensor("float32",Dt,[1,4,g,nt]):new s.Tensor("float32",Dt,[1,3,g,nt])},a=async(c,b)=>{const g=typeof HTMLImageElement<"u"&&c instanceof HTMLImageElement,nt=typeof ImageData<"u"&&c instanceof ImageData,at=typeof ImageBitmap<"u"&&c instanceof ImageBitmap,Ot=typeof c=="string";let At,Ct=b??{};const St=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},xt=Dt=>Dt instanceof HTMLCanvasElement||Dt instanceof OffscreenCanvas?Dt.getContext("2d"):null;if(g){const Dt=St();Dt.width=c.width,Dt.height=c.height;const Qt=xt(Dt);if(Qt!=null){let Zt=c.height,gr=c.width;if(b!==void 0&&b.resizedHeight!==void 0&&b.resizedWidth!==void 0&&(Zt=b.resizedHeight,gr=b.resizedWidth),b!==void 0){if(Ct=b,b.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");Ct.tensorFormat="RGBA",Ct.height=Zt,Ct.width=gr}else Ct.tensorFormat="RGBA",Ct.height=Zt,Ct.width=gr;Qt.drawImage(c,0,0),At=Qt.getImageData(0,0,gr,Zt).data}else throw new Error("Can not access image data")}else if(nt){let Dt,Qt;if(b!==void 0&&b.resizedWidth!==void 0&&b.resizedHeight!==void 0?(Dt=b.resizedHeight,Qt=b.resizedWidth):(Dt=c.height,Qt=c.width),b!==void 0&&(Ct=b),Ct.format="RGBA",Ct.height=Dt,Ct.width=Qt,b!==void 0){const Zt=St();Zt.width=Qt,Zt.height=Dt;const gr=xt(Zt);if(gr!=null)gr.putImageData(c,0,0),At=gr.getImageData(0,0,Qt,Dt).data;else throw new Error("Can not access image data")}else At=c.data}else if(at){if(b===void 0)throw new Error("Please provide image config with format for Imagebitmap");const Dt=St();Dt.width=c.width,Dt.height=c.height;const Qt=xt(Dt);if(Qt!=null){const Zt=c.height,gr=c.width;return Qt.drawImage(c,0,0,gr,Zt),At=Qt.getImageData(0,0,gr,Zt).data,Ct.height=Zt,Ct.width=gr,h(At,Ct)}else throw new Error("Can not access image data")}else{if(Ot)return new Promise((Dt,Qt)=>{const Zt=St(),gr=xt(Zt);if(!c||!gr)return Qt();const vr=new Image;vr.crossOrigin="Anonymous",vr.src=c,vr.onload=()=>{Zt.width=vr.width,Zt.height=vr.height,gr.drawImage(vr,0,0,Zt.width,Zt.height);const Er=gr.getImageData(0,0,Zt.width,Zt.height);Ct.height=Zt.height,Ct.width=Zt.width,Dt(h(Er.data,Ct))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(At!==void 0)return h(At,Ct);throw new Error("Input data provided is not supported - aborted tensor creation")},d=(c,b)=>{const{width:g,height:nt,download:at,dispose:Ot}=b,At=[1,nt,g,4];return new s.Tensor({location:"texture",type:"float32",texture:c,dims:At,download:at,dispose:Ot})},et=(c,b)=>{const{dataType:g,dims:nt,download:at,dispose:Ot}=b;return new s.Tensor({location:"gpu-buffer",type:g??"float32",gpuBuffer:c,dims:nt,download:at,dispose:Ot})},$=(c,b,g)=>new s.Tensor({location:"cpu-pinned",type:c,data:b,dims:g??[b.length]})},"./node_modules/onnxruntime-common/dist/esm/tensor-factory.js":(e,o,i)=>{i.r(o)},"./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js":(e,o,i)=>{i.r(o),i.d(o,{NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP:()=>h,NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP:()=>s,checkTypedArray:()=>d});const s=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),h=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let a=!1;const d=()=>{if(!a){a=!0;const et=typeof BigInt64Array<"u"&&BigInt64Array.from,$=typeof BigUint64Array<"u"&&BigUint64Array.from,c=typeof Float16Array<"u"&&Float16Array.from;et&&(s.set("int64",BigInt64Array),h.set(BigInt64Array,"int64")),$&&(s.set("uint64",BigUint64Array),h.set(BigUint64Array,"uint64")),c?(s.set("float16",Float16Array),h.set(Float16Array,"float16")):s.set("float16",Uint16Array)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-impl.js":(e,o,i)=>{i.r(o),i.d(o,{Tensor:()=>et});var s=i("./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"),h=i("./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"),a=i("./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"),d=i("./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js");class et{constructor(c,b,g){(0,a.checkTypedArray)();let nt,at;if(typeof c=="object"&&"location"in c)switch(this.dataLocation=c.location,nt=c.type,at=c.dims,c.location){case"cpu-pinned":{const At=a.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(nt);if(!At)throw new TypeError(`unsupported type "${nt}" to create tensor from pinned buffer`);if(!(c.data instanceof At))throw new TypeError(`buffer should be of type ${At.name}`);this.cpuData=c.data;break}case"texture":{if(nt!=="float32")throw new TypeError(`unsupported type "${nt}" to create tensor from texture`);this.gpuTextureData=c.texture,this.downloader=c.download,this.disposer=c.dispose;break}case"gpu-buffer":{if(nt!=="float32"&&nt!=="float16"&&nt!=="int32"&&nt!=="int64"&&nt!=="uint32"&&nt!=="uint8"&&nt!=="bool")throw new TypeError(`unsupported type "${nt}" to create tensor from gpu buffer`);this.gpuBufferData=c.gpuBuffer,this.downloader=c.download,this.disposer=c.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let At,Ct;if(typeof c=="string")if(nt=c,Ct=g,c==="string"){if(!Array.isArray(b))throw new TypeError("A string tensor's data must be a string array.");At=b}else{const St=a.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(c);if(St===void 0)throw new TypeError(`Unsupported tensor type: ${c}.`);if(Array.isArray(b)){if(c==="float16"&&St===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");c==="uint64"||c==="int64"?At=St.from(b,BigInt):At=St.from(b)}else if(b instanceof St)At=b;else throw new TypeError(`A ${nt} tensor's data must be type of ${St}`)}else if(Ct=b,Array.isArray(c)){if(c.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const St=typeof c[0];if(St==="string")nt="string",At=c;else if(St==="boolean")nt="bool",At=Uint8Array.from(c);else throw new TypeError(`Invalid element type of data array: ${St}.`)}else{const St=a.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(c.constructor);if(St===void 0)throw new TypeError(`Unsupported type for tensor data: ${c.constructor}.`);nt=St,At=c}if(Ct===void 0)Ct=[At.length];else if(!Array.isArray(Ct))throw new TypeError("A tensor's dims must be a number array");at=Ct,this.cpuData=At,this.dataLocation="cpu"}const Ot=(0,d.calculateSize)(at);if(this.cpuData&&Ot!==this.cpuData.length)throw new Error(`Tensor's size(${Ot}) does not match data length(${this.cpuData.length}).`);this.type=nt,this.dims=at,this.size=Ot}static async fromImage(c,b){return(0,h.tensorFromImage)(c,b)}static fromTexture(c,b){return(0,h.tensorFromTexture)(c,b)}static fromGpuBuffer(c,b){return(0,h.tensorFromGpuBuffer)(c,b)}static fromPinnedBuffer(c,b,g){return(0,h.tensorFromPinnedBuffer)(c,b,g)}toDataURL(c){return(0,s.tensorToDataURL)(this,c)}toImageData(c){return(0,s.tensorToImageData)(this,c)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(c){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const b=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=b,c&&this.disposer&&(this.disposer(),this.disposer=void 0),b}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(c){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return(0,d.tensorReshape)(this,c)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js":(e,o,i)=>{i.r(o),i.d(o,{calculateSize:()=>h,tensorReshape:()=>a});var s=i("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const h=d=>{let et=1;for(let $=0;$<d.length;$++){const c=d[$];if(typeof c!="number"||!Number.isSafeInteger(c))throw new TypeError(`dims[${$}] must be an integer, got: ${c}`);if(c<0)throw new RangeError(`dims[${$}] must be a non-negative integer, got: ${c}`);et*=c}return et},a=(d,et)=>{switch(d.location){case"cpu":return new s.Tensor(d.type,d.data,et);case"cpu-pinned":return new s.Tensor({location:"cpu-pinned",data:d.data,type:d.type,dims:et});case"texture":return new s.Tensor({location:"texture",texture:d.texture,type:d.type,dims:et});case"gpu-buffer":return new s.Tensor({location:"gpu-buffer",gpuBuffer:d.gpuBuffer,type:d.type,dims:et});default:throw new Error(`tensorReshape: tensor location ${d.location} is not supported`)}}},"./node_modules/onnxruntime-common/dist/esm/tensor.js":(e,o,i)=>{i.r(o),i.d(o,{Tensor:()=>h});var s=i("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const h=s.Tensor},"./node_modules/onnxruntime-common/dist/esm/trace.js":(e,o,i)=>{i.r(o),i.d(o,{TRACE:()=>h,TRACE_FUNC_BEGIN:()=>d,TRACE_FUNC_END:()=>et});var s=i("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const h=($,c)=>{(typeof s.env.trace>"u"?!s.env.wasm.trace:!s.env.trace)||console.timeStamp(`${$}::ORT::${c}`)},a=($,c)=>{const b=new Error().stack?.split(/\r\n|\r|\n/g)||[];let g=!1;for(let nt=0;nt<b.length;nt++){if(g&&!b[nt].includes("TRACE_FUNC")){let at=`FUNC_${$}::${b[nt].trim().split(" ")[1]}`;c&&(at+=`::${c}`),h("CPU",at);return}b[nt].includes("TRACE_FUNC")&&(g=!0)}},d=$=>{(typeof s.env.trace>"u"?!s.env.wasm.trace:!s.env.trace)||a("BEGIN",$)},et=$=>{(typeof s.env.trace>"u"?!s.env.wasm.trace:!s.env.trace)||a("END",$)}},"./node_modules/onnxruntime-common/dist/esm/training-session-impl.js":(e,o,i)=>{i.r(o),i.d(o,{TrainingSession:()=>d});var s=i("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),h=i("./node_modules/onnxruntime-common/dist/esm/tensor.js");const a="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";class d{constructor($,c,b){this.handler=$,this.hasOptimizerModel=c,this.hasEvalModel=b}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create($,c){const b=$.evalModel||"",g=$.optimizerModel||"",nt=c||{},[at,Ot]=await(0,s.resolveBackendAndExecutionProviders)(nt);if(at.createTrainingSessionHandler){const At=await at.createTrainingSessionHandler($.checkpointState,$.trainModel,b,g,Ot);return new d(At,!!$.optimizerModel,!!$.evalModel)}else throw new Error(a)}typeNarrowingForRunStep($,c,b,g,nt){const at={};let Ot={};if(typeof b!="object"||b===null||b instanceof h.Tensor||Array.isArray(b))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let At=!0;if(typeof g=="object"){if(g===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(g instanceof h.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(g)){if(g.length===0)throw new TypeError("'fetches' cannot be an empty array.");At=!1;for(const Ct of g){if(typeof Ct!="string")throw new TypeError("'fetches' must be a string array or an object.");if(c.indexOf(Ct)===-1)throw new RangeError(`'fetches' contains invalid output name: ${Ct}.`);at[Ct]=null}if(typeof nt=="object"&&nt!==null)Ot=nt;else if(typeof nt<"u")throw new TypeError("'options' must be an object.")}else{let Ct=!1;const St=Object.getOwnPropertyNames(g);for(const xt of c)if(St.indexOf(xt)!==-1){const Dt=g[xt];(Dt===null||Dt instanceof h.Tensor)&&(Ct=!0,At=!1,at[xt]=Dt)}if(Ct){if(typeof nt=="object"&&nt!==null)Ot=nt;else if(typeof nt<"u")throw new TypeError("'options' must be an object.")}else Ot=g}}else if(typeof g<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const Ct of $)if(typeof b[Ct]>"u")throw new Error(`input '${Ct}' is missing in 'feeds'.`);if(At)for(const Ct of c)at[Ct]=null;return[at,Ot]}convertHandlerReturnTypeToMapOfTensors($){const c={};for(const b in $)if(Object.hasOwnProperty.call($,b)){const g=$[b];g instanceof h.Tensor?c[b]=g:c[b]=new h.Tensor(g.type,g.data,g.dims)}return c}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep($,c,b){const[g,nt]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,$,c,b),at=await this.handler.runTrainStep($,g,nt);return this.convertHandlerReturnTypeToMapOfTensors(at)}async runOptimizerStep($){if(this.hasOptimizerModel)await this.handler.runOptimizerStep($||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep($,c,b){if(this.hasEvalModel){const[g,nt]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,$,c,b),at=await this.handler.runEvalStep($,g,nt);return this.convertHandlerReturnTypeToMapOfTensors(at)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize($=!0){return this.handler.getParametersSize($)}async loadParametersBuffer($,c=!0){const b=await this.getParametersSize(c);if($.length!==4*b)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer($,c)}async getContiguousParameters($=!0){return this.handler.getContiguousParameters($)}async release(){return this.handler.dispose()}}},"./node_modules/onnxruntime-common/dist/esm/training-session.js":(e,o,i)=>{i.r(o),i.d(o,{TrainingSession:()=>h});var s=i("./node_modules/onnxruntime-common/dist/esm/training-session-impl.js");const h=s.TrainingSession},"./node_modules/onnxruntime-common/dist/esm/version.js":(e,o,i)=>{i.r(o),i.d(o,{version:()=>s});const s="1.19.2"},"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs":(e,o,i)=>{i.r(o),i.d(o,{InferenceSession:()=>Eo,TRACE:()=>vu,TRACE_FUNC_BEGIN:()=>e_,TRACE_FUNC_END:()=>ar,Tensor:()=>na,TrainingSession:()=>i_,default:()=>rS,env:()=>Er,registerBackend:()=>Ot});/*!
 * ONNX Runtime Web v1.20.0-dev.20240908-de7a02beef
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var s=Object.defineProperty,h=Object.getOwnPropertyDescriptor,a=Object.getOwnPropertyNames,d=Object.prototype.hasOwnProperty,et=(_=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(_,{get:(_e,it)=>(typeof require<"u"?require:_e)[it]}):_)(function(_){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+_+'" is not supported')}),$=(_,_e)=>()=>(_&&(_e=_(_=0)),_e),c=(_,_e)=>{for(var it in _e)s(_,it,{get:_e[it],enumerable:!0})},b=(_,_e,it,ut)=>{if(_e&&typeof _e=="object"||typeof _e=="function")for(let ct of a(_e))!d.call(_,ct)&&ct!==it&&s(_,ct,{get:()=>_e[ct],enumerable:!(ut=h(_e,ct))||ut.enumerable});return _},g=_=>b(s({},"__esModule",{value:!0}),_),nt,at,Ot,At,Ct,St=$(()=>{nt=new Map,at=[],Ot=(_,_e,it)=>{if(_e&&typeof _e.init=="function"&&typeof _e.createInferenceSessionHandler=="function"){let ut=nt.get(_);if(ut===void 0)nt.set(_,{backend:_e,priority:it});else{if(ut.priority>it)return;if(ut.priority===it&&ut.backend!==_e)throw new Error(`cannot register backend "${_}" using priority ${it}`)}if(it>=0){let ct=at.indexOf(_);ct!==-1&&at.splice(ct,1);for(let pt=0;pt<at.length;pt++)if(nt.get(at[pt]).priority<=it){at.splice(pt,0,_);return}at.push(_)}return}throw new TypeError("not a valid backend")},At=async _=>{let _e=nt.get(_);if(!_e)return"backend not found.";if(_e.initialized)return _e.backend;if(_e.aborted)return _e.error;{let it=!!_e.initPromise;try{return it||(_e.initPromise=_e.backend.init(_)),await _e.initPromise,_e.initialized=!0,_e.backend}catch(ut){return it||(_e.error=`${ut}`,_e.aborted=!0),_e.error}finally{delete _e.initPromise}}},Ct=async _=>{let _e=_.executionProviders||[],it=_e.map(Gt=>typeof Gt=="string"?Gt:Gt.name),ut=it.length===0?at:it,ct,pt=[],ft=new Set;for(let Gt of ut){let er=await At(Gt);typeof er=="string"?pt.push({name:Gt,err:er}):(ct||(ct=er),ct===er&&ft.add(Gt))}if(!ct)throw new Error(`no available backend found. ERR: ${pt.map(Gt=>`[${Gt.name}] ${Gt.err}`).join(", ")}`);for(let{name:Gt,err:er}of pt)it.includes(Gt)&&console.warn(`removing requested execution provider "${Gt}" from session options because it is not available: ${er}`);let Bt=_e.filter(Gt=>ft.has(typeof Gt=="string"?Gt:Gt.name));return[ct,new Proxy(_,{get:(Gt,er)=>er==="executionProviders"?Bt:Reflect.get(Gt,er)})]}}),xt=$(()=>{St()}),Dt,Qt=$(()=>{Dt="1.20.0-dev.20240827-5d54dc1462"}),Zt,gr,vr=$(()=>{Qt(),Zt="warning",gr={wasm:{},webgl:{},webgpu:{},versions:{common:Dt},set logLevel(_){if(_!==void 0){if(typeof _!="string"||["verbose","info","warning","error","fatal"].indexOf(_)===-1)throw new Error(`Unsupported logging level: ${_}`);Zt=_}},get logLevel(){return Zt}},Object.defineProperty(gr,"logLevel",{enumerable:!0})}),Er,wo=$(()=>{vr(),Er=gr}),Do,Js,In=$(()=>{Do=(_,_e)=>{let it=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);it.width=_.dims[3],it.height=_.dims[2];let ut=it.getContext("2d");if(ut!=null){let ct,pt;_e?.tensorLayout!==void 0&&_e.tensorLayout==="NHWC"?(ct=_.dims[2],pt=_.dims[3]):(ct=_.dims[3],pt=_.dims[2]);let ft=_e?.format!==void 0?_e.format:"RGB",Bt=_e?.norm,Gt,er;Bt===void 0||Bt.mean===void 0?Gt=[255,255,255,255]:typeof Bt.mean=="number"?Gt=[Bt.mean,Bt.mean,Bt.mean,Bt.mean]:(Gt=[Bt.mean[0],Bt.mean[1],Bt.mean[2],0],Bt.mean[3]!==void 0&&(Gt[3]=Bt.mean[3])),Bt===void 0||Bt.bias===void 0?er=[0,0,0,0]:typeof Bt.bias=="number"?er=[Bt.bias,Bt.bias,Bt.bias,Bt.bias]:(er=[Bt.bias[0],Bt.bias[1],Bt.bias[2],0],Bt.bias[3]!==void 0&&(er[3]=Bt.bias[3]));let Yr=pt*ct,It=0,en=Yr,wn=Yr*2,_o=-1;ft==="RGBA"?(It=0,en=Yr,wn=Yr*2,_o=Yr*3):ft==="RGB"?(It=0,en=Yr,wn=Yr*2):ft==="RBG"&&(It=0,wn=Yr,en=Yr*2);for(let vn=0;vn<pt;vn++)for(let Ws=0;Ws<ct;Ws++){let Jo=(_.data[It++]-er[0])*Gt[0],So=(_.data[en++]-er[1])*Gt[1],xa=(_.data[wn++]-er[2])*Gt[2],$a=_o===-1?255:(_.data[_o++]-er[3])*Gt[3];ut.fillStyle="rgba("+Jo+","+So+","+xa+","+$a+")",ut.fillRect(Ws,vn,1,1)}if("toDataURL"in it)return it.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Js=(_,_e)=>{let it=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),ut;if(it!=null){let ct,pt,ft;_e?.tensorLayout!==void 0&&_e.tensorLayout==="NHWC"?(ct=_.dims[2],pt=_.dims[1],ft=_.dims[3]):(ct=_.dims[3],pt=_.dims[2],ft=_.dims[1]);let Bt=_e!==void 0&&_e.format!==void 0?_e.format:"RGB",Gt=_e?.norm,er,Yr;Gt===void 0||Gt.mean===void 0?er=[255,255,255,255]:typeof Gt.mean=="number"?er=[Gt.mean,Gt.mean,Gt.mean,Gt.mean]:(er=[Gt.mean[0],Gt.mean[1],Gt.mean[2],255],Gt.mean[3]!==void 0&&(er[3]=Gt.mean[3])),Gt===void 0||Gt.bias===void 0?Yr=[0,0,0,0]:typeof Gt.bias=="number"?Yr=[Gt.bias,Gt.bias,Gt.bias,Gt.bias]:(Yr=[Gt.bias[0],Gt.bias[1],Gt.bias[2],0],Gt.bias[3]!==void 0&&(Yr[3]=Gt.bias[3]));let It=pt*ct;if(_e!==void 0&&(_e.format!==void 0&&ft===4&&_e.format!=="RGBA"||ft===3&&_e.format!=="RGB"&&_e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let en=4,wn=0,_o=1,vn=2,Ws=3,Jo=0,So=It,xa=It*2,$a=-1;Bt==="RGBA"?(Jo=0,So=It,xa=It*2,$a=It*3):Bt==="RGB"?(Jo=0,So=It,xa=It*2):Bt==="RBG"&&(Jo=0,xa=It,So=It*2),ut=it.createImageData(ct,pt);for(let gu=0;gu<pt*ct;wn+=en,_o+=en,vn+=en,Ws+=en,gu++)ut.data[wn]=(_.data[Jo++]-Yr[0])*er[0],ut.data[_o]=(_.data[So++]-Yr[1])*er[1],ut.data[vn]=(_.data[xa++]-Yr[2])*er[2],ut.data[Ws]=$a===-1?255:(_.data[$a++]-Yr[3])*er[3]}else throw new Error("Can not access image data");return ut}}),Wo,Ir,Yo,Bu,Ho,tn=$(()=>{d_(),Wo=(_,_e)=>{if(_===void 0)throw new Error("Image buffer must be defined");if(_e.height===void 0||_e.width===void 0)throw new Error("Image height and width must be defined");if(_e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:it,width:ut}=_e,ct=_e.norm??{mean:255,bias:0},pt,ft;typeof ct.mean=="number"?pt=[ct.mean,ct.mean,ct.mean,ct.mean]:pt=[ct.mean[0],ct.mean[1],ct.mean[2],ct.mean[3]??255],typeof ct.bias=="number"?ft=[ct.bias,ct.bias,ct.bias,ct.bias]:ft=[ct.bias[0],ct.bias[1],ct.bias[2],ct.bias[3]??0];let Bt=_e.format!==void 0?_e.format:"RGBA",Gt=_e.tensorFormat!==void 0&&_e.tensorFormat!==void 0?_e.tensorFormat:"RGB",er=it*ut,Yr=Gt==="RGBA"?new Float32Array(er*4):new Float32Array(er*3),It=4,en=0,wn=1,_o=2,vn=3,Ws=0,Jo=er,So=er*2,xa=-1;Bt==="RGB"&&(It=3,en=0,wn=1,_o=2,vn=-1),Gt==="RGBA"?xa=er*3:Gt==="RBG"?(Ws=0,So=er,Jo=er*2):Gt==="BGR"&&(So=0,Jo=er,Ws=er*2);for(let $a=0;$a<er;$a++,en+=It,_o+=It,wn+=It,vn+=It)Yr[Ws++]=(_[en]+ft[0])/pt[0],Yr[Jo++]=(_[wn]+ft[1])/pt[1],Yr[So++]=(_[_o]+ft[2])/pt[2],xa!==-1&&vn!==-1&&(Yr[xa++]=(_[vn]+ft[3])/pt[3]);return Gt==="RGBA"?new r_("float32",Yr,[1,4,it,ut]):new r_("float32",Yr,[1,3,it,ut])},Ir=async(_,_e)=>{let it=typeof HTMLImageElement<"u"&&_ instanceof HTMLImageElement,ut=typeof ImageData<"u"&&_ instanceof ImageData,ct=typeof ImageBitmap<"u"&&_ instanceof ImageBitmap,pt=typeof _=="string",ft,Bt=_e??{},Gt=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},er=Yr=>Yr instanceof HTMLCanvasElement||Yr instanceof OffscreenCanvas?Yr.getContext("2d"):null;if(it){let Yr=Gt();Yr.width=_.width,Yr.height=_.height;let It=er(Yr);if(It!=null){let en=_.height,wn=_.width;if(_e!==void 0&&_e.resizedHeight!==void 0&&_e.resizedWidth!==void 0&&(en=_e.resizedHeight,wn=_e.resizedWidth),_e!==void 0){if(Bt=_e,_e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");Bt.tensorFormat="RGBA",Bt.height=en,Bt.width=wn}else Bt.tensorFormat="RGBA",Bt.height=en,Bt.width=wn;It.drawImage(_,0,0),ft=It.getImageData(0,0,wn,en).data}else throw new Error("Can not access image data")}else if(ut){let Yr,It;if(_e!==void 0&&_e.resizedWidth!==void 0&&_e.resizedHeight!==void 0?(Yr=_e.resizedHeight,It=_e.resizedWidth):(Yr=_.height,It=_.width),_e!==void 0&&(Bt=_e),Bt.format="RGBA",Bt.height=Yr,Bt.width=It,_e!==void 0){let en=Gt();en.width=It,en.height=Yr;let wn=er(en);if(wn!=null)wn.putImageData(_,0,0),ft=wn.getImageData(0,0,It,Yr).data;else throw new Error("Can not access image data")}else ft=_.data}else if(ct){if(_e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let Yr=Gt();Yr.width=_.width,Yr.height=_.height;let It=er(Yr);if(It!=null){let en=_.height,wn=_.width;return It.drawImage(_,0,0,wn,en),ft=It.getImageData(0,0,wn,en).data,Bt.height=en,Bt.width=wn,Wo(ft,Bt)}else throw new Error("Can not access image data")}else{if(pt)return new Promise((Yr,It)=>{let en=Gt(),wn=er(en);if(!_||!wn)return It();let _o=new Image;_o.crossOrigin="Anonymous",_o.src=_,_o.onload=()=>{en.width=_o.width,en.height=_o.height,wn.drawImage(_o,0,0,en.width,en.height);let vn=wn.getImageData(0,0,en.width,en.height);Bt.height=en.height,Bt.width=en.width,Yr(Wo(vn.data,Bt))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(ft!==void 0)return Wo(ft,Bt);throw new Error("Input data provided is not supported - aborted tensor creation")},Yo=(_,_e)=>{let{width:it,height:ut,download:ct,dispose:pt}=_e,ft=[1,ut,it,4];return new r_({location:"texture",type:"float32",texture:_,dims:ft,download:ct,dispose:pt})},Bu=(_,_e)=>{let{dataType:it,dims:ut,download:ct,dispose:pt}=_e;return new r_({location:"gpu-buffer",type:it??"float32",gpuBuffer:_,dims:ut,download:ct,dispose:pt})},Ho=(_,_e,it)=>new r_({location:"cpu-pinned",type:_,data:_e,dims:it??[_e.length]})}),To,Qo,Jr,Lo,Du=$(()=>{To=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Qo=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Jr=!1,Lo=()=>{if(!Jr){Jr=!0;let _=typeof BigInt64Array<"u"&&BigInt64Array.from,_e=typeof BigUint64Array<"u"&&BigUint64Array.from,it=typeof Float16Array<"u"&&Float16Array.from;_&&(To.set("int64",BigInt64Array),Qo.set(BigInt64Array,"int64")),_e&&(To.set("uint64",BigUint64Array),Qo.set(BigUint64Array,"uint64")),it?(To.set("float16",Float16Array),Qo.set(Float16Array,"float16")):To.set("float16",Uint16Array)}}}),_u,du,wu=$(()=>{d_(),_u=_=>{let _e=1;for(let it=0;it<_.length;it++){let ut=_[it];if(typeof ut!="number"||!Number.isSafeInteger(ut))throw new TypeError(`dims[${it}] must be an integer, got: ${ut}`);if(ut<0)throw new RangeError(`dims[${it}] must be a non-negative integer, got: ${ut}`);_e*=ut}return _e},du=(_,_e)=>{switch(_.location){case"cpu":return new r_(_.type,_.data,_e);case"cpu-pinned":return new r_({location:"cpu-pinned",data:_.data,type:_.type,dims:_e});case"texture":return new r_({location:"texture",texture:_.texture,type:_.type,dims:_e});case"gpu-buffer":return new r_({location:"gpu-buffer",gpuBuffer:_.gpuBuffer,type:_.type,dims:_e});default:throw new Error(`tensorReshape: tensor location ${_.location} is not supported`)}}}),r_,d_=$(()=>{In(),tn(),Du(),wu(),r_=class{constructor(_,_e,it){Lo();let ut,ct;if(typeof _=="object"&&"location"in _)switch(this.dataLocation=_.location,ut=_.type,ct=_.dims,_.location){case"cpu-pinned":{let ft=To.get(ut);if(!ft)throw new TypeError(`unsupported type "${ut}" to create tensor from pinned buffer`);if(!(_.data instanceof ft))throw new TypeError(`buffer should be of type ${ft.name}`);this.cpuData=_.data;break}case"texture":{if(ut!=="float32")throw new TypeError(`unsupported type "${ut}" to create tensor from texture`);this.gpuTextureData=_.texture,this.downloader=_.download,this.disposer=_.dispose;break}case"gpu-buffer":{if(ut!=="float32"&&ut!=="float16"&&ut!=="int32"&&ut!=="int64"&&ut!=="uint32"&&ut!=="uint8"&&ut!=="bool"&&ut!=="uint4"&&ut!=="int4")throw new TypeError(`unsupported type "${ut}" to create tensor from gpu buffer`);this.gpuBufferData=_.gpuBuffer,this.downloader=_.download,this.disposer=_.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let ft,Bt;if(typeof _=="string")if(ut=_,Bt=it,_==="string"){if(!Array.isArray(_e))throw new TypeError("A string tensor's data must be a string array.");ft=_e}else{let Gt=To.get(_);if(Gt===void 0)throw new TypeError(`Unsupported tensor type: ${_}.`);if(Array.isArray(_e)){if(_==="float16"&&Gt===Uint16Array||_==="uint4"||_==="int4")throw new TypeError(`Creating a ${_} tensor from number array is not supported. Please use ${Gt.name} as data.`);_==="uint64"||_==="int64"?ft=Gt.from(_e,BigInt):ft=Gt.from(_e)}else if(_e instanceof Gt)ft=_e;else throw new TypeError(`A ${ut} tensor's data must be type of ${Gt}`)}else if(Bt=_e,Array.isArray(_)){if(_.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let Gt=typeof _[0];if(Gt==="string")ut="string",ft=_;else if(Gt==="boolean")ut="bool",ft=Uint8Array.from(_);else throw new TypeError(`Invalid element type of data array: ${Gt}.`)}else{let Gt=Qo.get(_.constructor);if(Gt===void 0)throw new TypeError(`Unsupported type for tensor data: ${_.constructor}.`);ut=Gt,ft=_}if(Bt===void 0)Bt=[ft.length];else if(!Array.isArray(Bt))throw new TypeError("A tensor's dims must be a number array");ct=Bt,this.cpuData=ft,this.dataLocation="cpu"}let pt=_u(ct);if(this.cpuData&&pt!==this.cpuData.length&&!((ut==="uint4"||ut==="int4")&&Math.ceil(pt/2)===this.cpuData.length))throw new Error(`Tensor's size(${pt}) does not match data length(${this.cpuData.length}).`);this.type=ut,this.dims=ct,this.size=pt}static async fromImage(_,_e){return Ir(_,_e)}static fromTexture(_,_e){return Yo(_,_e)}static fromGpuBuffer(_,_e){return Bu(_,_e)}static fromPinnedBuffer(_,_e,it){return Ho(_,_e,it)}toDataURL(_){return Do(this,_)}toImageData(_){return Js(this,_)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(_){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let _e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=_e,_&&this.disposer&&(this.disposer(),this.disposer=void 0),_e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(_){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return du(this,_)}}}),na,Ko=$(()=>{d_(),na=r_}),vu,Cu,e_,ar,Qs=$(()=>{vr(),vu=(_,_e)=>{(typeof gr.trace>"u"?!gr.wasm.trace:!gr.trace)||console.timeStamp(`${_}::ORT::${_e}`)},Cu=(_,_e)=>{let it=new Error().stack?.split(/\r\n|\r|\n/g)||[],ut=!1;for(let ct=0;ct<it.length;ct++){if(ut&&!it[ct].includes("TRACE_FUNC")){let pt=`FUNC_${_}::${it[ct].trim().split(" ")[1]}`;_e&&(pt+=`::${_e}`),vu("CPU",pt);return}it[ct].includes("TRACE_FUNC")&&(ut=!0)}},e_=_=>{(typeof gr.trace>"u"?!gr.wasm.trace:!gr.trace)||Cu("BEGIN",_)},ar=_=>{(typeof gr.trace>"u"?!gr.wasm.trace:!gr.trace)||Cu("END",_)}}),_a,$o=$(()=>{St(),Ko(),Qs(),_a=class RP{constructor(_e){this.handler=_e}async run(_e,it,ut){e_();let ct={},pt={};if(typeof _e!="object"||_e===null||_e instanceof na||Array.isArray(_e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let ft=!0;if(typeof it=="object"){if(it===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(it instanceof na)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(it)){if(it.length===0)throw new TypeError("'fetches' cannot be an empty array.");ft=!1;for(let er of it){if(typeof er!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(er)===-1)throw new RangeError(`'fetches' contains invalid output name: ${er}.`);ct[er]=null}if(typeof ut=="object"&&ut!==null)pt=ut;else if(typeof ut<"u")throw new TypeError("'options' must be an object.")}else{let er=!1,Yr=Object.getOwnPropertyNames(it);for(let It of this.outputNames)if(Yr.indexOf(It)!==-1){let en=it[It];(en===null||en instanceof na)&&(er=!0,ft=!1,ct[It]=en)}if(er){if(typeof ut=="object"&&ut!==null)pt=ut;else if(typeof ut<"u")throw new TypeError("'options' must be an object.")}else pt=it}}else if(typeof it<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let er of this.inputNames)if(typeof _e[er]>"u")throw new Error(`input '${er}' is missing in 'feeds'.`);if(ft)for(let er of this.outputNames)ct[er]=null;let Bt=await this.handler.run(_e,ct,pt),Gt={};for(let er in Bt)if(Object.hasOwnProperty.call(Bt,er)){let Yr=Bt[er];Yr instanceof na?Gt[er]=Yr:Gt[er]=new na(Yr.type,Yr.data,Yr.dims)}return ar(),Gt}async release(){return this.handler.dispose()}static async create(_e,it,ut,ct){e_();let pt,ft={};if(typeof _e=="string"){if(pt=_e,typeof it=="object"&&it!==null)ft=it;else if(typeof it<"u")throw new TypeError("'options' must be an object.")}else if(_e instanceof Uint8Array){if(pt=_e,typeof it=="object"&&it!==null)ft=it;else if(typeof it<"u")throw new TypeError("'options' must be an object.")}else if(_e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&_e instanceof SharedArrayBuffer){let Yr=_e,It=0,en=_e.byteLength;if(typeof it=="object"&&it!==null)ft=it;else if(typeof it=="number"){if(It=it,!Number.isSafeInteger(It))throw new RangeError("'byteOffset' must be an integer.");if(It<0||It>=Yr.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${Yr.byteLength}).`);if(en=_e.byteLength-It,typeof ut=="number"){if(en=ut,!Number.isSafeInteger(en))throw new RangeError("'byteLength' must be an integer.");if(en<=0||It+en>Yr.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${Yr.byteLength-It}].`);if(typeof ct=="object"&&ct!==null)ft=ct;else if(typeof ct<"u")throw new TypeError("'options' must be an object.")}else if(typeof ut<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof it<"u")throw new TypeError("'options' must be an object.");pt=new Uint8Array(Yr,It,en)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[Bt,Gt]=await Ct(ft),er=await Bt.createInferenceSessionHandler(pt,Gt);return ar(),new RP(er)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Eo,js=$(()=>{$o(),Eo=_a}),Lr=$(()=>{}),rn=$(()=>{}),Kr=$(()=>{}),Oo=$(()=>{}),Mo,qs,au=$(()=>{St(),Ko(),Mo="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",qs=class LP{constructor(_e,it,ut){this.handler=_e,this.hasOptimizerModel=it,this.hasEvalModel=ut}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(_e,it){let ut=_e.evalModel||"",ct=_e.optimizerModel||"",pt=it||{},[ft,Bt]=await Ct(pt);if(ft.createTrainingSessionHandler){let Gt=await ft.createTrainingSessionHandler(_e.checkpointState,_e.trainModel,ut,ct,Bt);return new LP(Gt,!!_e.optimizerModel,!!_e.evalModel)}else throw new Error(Mo)}typeNarrowingForRunStep(_e,it,ut,ct,pt){let ft={},Bt={};if(typeof ut!="object"||ut===null||ut instanceof na||Array.isArray(ut))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let Gt=!0;if(typeof ct=="object"){if(ct===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(ct instanceof na)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(ct)){if(ct.length===0)throw new TypeError("'fetches' cannot be an empty array.");Gt=!1;for(let er of ct){if(typeof er!="string")throw new TypeError("'fetches' must be a string array or an object.");if(it.indexOf(er)===-1)throw new RangeError(`'fetches' contains invalid output name: ${er}.`);ft[er]=null}if(typeof pt=="object"&&pt!==null)Bt=pt;else if(typeof pt<"u")throw new TypeError("'options' must be an object.")}else{let er=!1,Yr=Object.getOwnPropertyNames(ct);for(let It of it)if(Yr.indexOf(It)!==-1){let en=ct[It];(en===null||en instanceof na)&&(er=!0,Gt=!1,ft[It]=en)}if(er){if(typeof pt=="object"&&pt!==null)Bt=pt;else if(typeof pt<"u")throw new TypeError("'options' must be an object.")}else Bt=ct}}else if(typeof ct<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let er of _e)if(typeof ut[er]>"u")throw new Error(`input '${er}' is missing in 'feeds'.`);if(Gt)for(let er of it)ft[er]=null;return[ft,Bt]}convertHandlerReturnTypeToMapOfTensors(_e){let it={};for(let ut in _e)if(Object.hasOwnProperty.call(_e,ut)){let ct=_e[ut];ct instanceof na?it[ut]=ct:it[ut]=new na(ct.type,ct.data,ct.dims)}return it}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(_e,it,ut){let[ct,pt]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,_e,it,ut),ft=await this.handler.runTrainStep(_e,ct,pt);return this.convertHandlerReturnTypeToMapOfTensors(ft)}async runOptimizerStep(_e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(_e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(_e,it,ut){if(this.hasEvalModel){let[ct,pt]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,_e,it,ut),ft=await this.handler.runEvalStep(_e,ct,pt);return this.convertHandlerReturnTypeToMapOfTensors(ft)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(_e=!0){return this.handler.getParametersSize(_e)}async loadParametersBuffer(_e,it=!0){let ut=await this.getParametersSize(it);if(_e.length!==4*ut)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(_e,it)}async getContiguousParameters(_e=!0){return this.handler.getContiguousParameters(_e)}async release(){return this.handler.dispose()}}}),i_,$u=$(()=>{au(),i_=qs}),m_={};c(m_,{InferenceSession:()=>Eo,TRACE:()=>vu,TRACE_FUNC_BEGIN:()=>e_,TRACE_FUNC_END:()=>ar,Tensor:()=>na,TrainingSession:()=>i_,env:()=>Er,registerBackend:()=>Ot});var L_=$(()=>{xt(),wo(),js(),Ko(),Lr(),rn(),Qs(),Kr(),Oo(),$u()}),Z_=$(()=>{}),Ty={};c(Ty,{default:()=>O_});var ey,yy,O_,fy=$(()=>{tM(),Ay(),H_(),ey="ort-wasm-proxy-worker",yy=globalThis.self?.name===ey,yy&&(self.onmessage=_=>{let{type:_e,in:it}=_.data;try{switch(_e){case"init-wasm":Zy(it.wasm).then(()=>{L2(it).then(()=>{postMessage({type:_e})},ut=>{postMessage({type:_e,err:ut})})},ut=>{postMessage({type:_e,err:ut})});break;case"init-ep":{let{epName:ut,env:ct}=it;B2(ct,ut).then(()=>{postMessage({type:_e})},pt=>{postMessage({type:_e,err:pt})});break}case"copy-from":{let{buffer:ut}=it,ct=f2(ut);postMessage({type:_e,out:ct});break}case"create":{let{model:ut,options:ct}=it;j2(ut,ct).then(pt=>{postMessage({type:_e,out:pt})},pt=>{postMessage({type:_e,err:pt})});break}case"release":z2(it),postMessage({type:_e});break;case"run":{let{sessionId:ut,inputIndices:ct,inputs:pt,outputIndices:ft,options:Bt}=it;U2(ut,ct,pt,ft,new Array(ft.length).fill(null),Bt).then(Gt=>{Gt.some(er=>er[3]!=="cpu")?postMessage({type:_e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:_e,out:Gt},V2([...pt,...Gt]))},Gt=>{postMessage({type:_e,err:Gt})});break}case"end-profiling":W2(it),postMessage({type:_e});break;default:}}catch(ut){postMessage({type:_e,err:ut})}}),O_=yy?null:_=>new Worker(_??mu,{type:"module",name:ey})}),g_={};c(g_,{default:()=>_d});var jo,Xs,_d,w_=$(()=>{Xs=(jo=import.meta.url,async function(_={}){function _e(){return Uy.buffer!=d0.buffer&&vw(),d0}function it(){return Uy.buffer!=d0.buffer&&vw(),gy}function ut(){return Uy.buffer!=d0.buffer&&vw(),Vy}function ct(){return Uy.buffer!=d0.buffer&&vw(),x_}function pt(){return Uy.buffer!=d0.buffer&&vw(),G_}function ft(){return Uy.buffer!=d0.buffer&&vw(),By}function Bt(){return Uy.buffer!=d0.buffer&&vw(),b0}function Gt(){return Uy.buffer!=d0.buffer&&vw(),Jw}var er,Yr,It=Object.assign({},_),en=new Promise((Et,_r)=>{er=Et,Yr=_r}),wn=typeof window=="object",_o=typeof importScripts=="function",vn=_o&&self.name=="em-pthread";It.mountExternalData=(Et,_r)=>{Et.startsWith("./")&&(Et=Et.substring(2)),(It.Fb||(It.Fb=new Map)).set(Et,_r)},It.unmountExternalData=()=>{delete It.Fb};var Ws=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let Jo=()=>{let Et=(Qr,Tn,Ao)=>(...nu)=>{let f_=f1,M_=Tn?.();nu=Qr(...nu);let Y_=Tn?.();return M_!==Y_&&(Qr=Y_,Ao(M_),Tn=Ao=null),f1!=f_?new Promise((Im,cy)=>{l$={resolve:Im,reject:cy}}):nu},_r=Qr=>async(...Tn)=>{try{if(It.Eb)throw Error("Session already started");let Ao=It.Eb={cc:Tn[0],errors:[]},nu=await Qr(...Tn);if(It.Eb!==Ao)throw Error("Session mismatch");It.Mb?.flush();let f_=Ao.errors;if(0<f_.length){let M_=await Promise.all(f_);if(M_=M_.filter(Y_=>Y_),0<M_.length)throw Error(M_.join(`
`))}return nu}finally{It.Eb=null}};It._OrtCreateSession=Et(It._OrtCreateSession,()=>It._OrtCreateSession,Qr=>It._OrtCreateSession=Qr),It._OrtRun=_r(Et(It._OrtRun,()=>It._OrtRun,Qr=>It._OrtRun=Qr)),It._OrtRunWithBinding=_r(Et(It._OrtRunWithBinding,()=>It._OrtRunWithBinding,Qr=>It._OrtRunWithBinding=Qr)),It._OrtBindInput=Et(It._OrtBindInput,()=>It._OrtBindInput,Qr=>It._OrtBindInput=Qr),Jo=void 0};It.jsepInit=(Et,_r)=>{if(Jo?.(),Et==="webgpu"){[It.Mb,It.Tb,It.Xb,It.Nb,It.Wb,It.jb,It.Yb,It.$b,It.Ub,It.Vb,It.Zb]=_r;let Qr=It.Mb;It.jsepRegisterBuffer=(Tn,Ao,nu,f_)=>Qr.registerBuffer(Tn,Ao,nu,f_),It.jsepGetBuffer=Tn=>Qr.getBuffer(Tn),It.jsepCreateDownloader=(Tn,Ao,nu)=>Qr.createDownloader(Tn,Ao,nu),It.jsepOnReleaseSession=Tn=>{Qr.onReleaseSession(Tn)},It.jsepOnRunStart=Tn=>Qr.onRunStart(Tn),It.ac=(Tn,Ao)=>{Qr.upload(Tn,Ao)}}};var So,xa,$a=Object.assign({},It),gu="./this.program",u_=(Et,_r)=>{throw _r},c_="";(wn||_o)&&(_o?c_=self.location.href:typeof document<"u"&&document.currentScript&&(c_=document.currentScript.src),jo&&(c_=jo),c_=c_.startsWith("blob:")?"":c_.substr(0,c_.replace(/[?#].*/,"").lastIndexOf("/")+1),_o&&(xa=Et=>{var _r=new XMLHttpRequest;return _r.open("GET",Et,!1),_r.responseType="arraybuffer",_r.send(null),new Uint8Array(_r.response)}),So=(Et,_r,Qr)=>{var Tn=new XMLHttpRequest;Tn.open("GET",Et,!0),Tn.responseType="arraybuffer",Tn.onload=()=>{Tn.status==200||Tn.status==0&&Tn.response?_r(Tn.response):Qr()},Tn.onerror=Qr,Tn.send(null)});var R_,ny=console.log.bind(console),ty=console.error.bind(console),Ly=ny,ky=ty;if(Object.assign(It,$a),$a=null,vn){let Et=function(_r){try{var Qr=_r.data,Tn=Qr.cmd;if(Tn==="load"){let Ao=[];self.onmessage=nu=>Ao.push(nu),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let nu of Ao)Et(nu);self.onmessage=Et};for(let nu of Qr.handlers)It[nu]&&!It[nu].proxy||(It[nu]=(...f_)=>{postMessage({Lb:"callHandler",lc:nu,args:f_})},nu=="print"&&(Ly=It[nu]),nu=="printErr"&&(ky=It[nu]));Uy=Qr.wasmMemory,vw(),Wy(Qr.wasmModule)}else if(Tn==="run"){p$(Qr.pthread_ptr,0,0,1,0,0),i$(Qr.pthread_ptr),iS(),PM(),t0||(EP(),t0=!0);try{sS(Qr.start_routine,Qr.arg)}catch(Ao){if(Ao!="unwind")throw Ao}}else Tn==="cancel"?bx()&&M2(-1):Qr.target!=="setimmediate"&&(Tn==="checkMailbox"?t0&&g2():Tn&&(ky(`worker: received unknown command ${Tn}`),ky(Qr)))}catch(Ao){throw $P(),Ao}};var Wy,t0=!1;ky=function(..._r){_r=_r.join(" "),console.error(_r)},self.alert=function(..._r){postMessage({Lb:"alert",text:_r.join(" "),nc:bx()})},It.instantiateWasm=(_r,Qr)=>new Promise(Tn=>{Wy=Ao=>{Ao=new WebAssembly.Instance(Ao,xM()),Qr(Ao),Tn()}}),self.onunhandledrejection=_r=>{throw _r.reason||_r},self.onmessage=Et}It.wasmBinary&&(R_=It.wasmBinary);var Uy,dy,r0,d0,gy,Vy,x_,G_,By,b0,w0,Bw,Jw,Aw=!1;function vw(){var Et=Uy.buffer;It.HEAP8=d0=new Int8Array(Et),It.HEAP16=Vy=new Int16Array(Et),It.HEAPU8=gy=new Uint8Array(Et),It.HEAPU16=x_=new Uint16Array(Et),It.HEAP32=G_=new Int32Array(Et),It.HEAPU32=By=new Uint32Array(Et),It.HEAPF32=b0=new Float32Array(Et),It.HEAPF64=Jw=new Float64Array(Et),It.HEAP64=w0=new BigInt64Array(Et),It.HEAPU64=Bw=new BigUint64Array(Et)}if(!vn){if(!((Uy=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof Ws))throw ky("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");vw()}var hw=[],lw=[],V1=[],K1=0,bv=null;function gM(){if(--K1==0&&bv){var Et=bv;bv=null,Et()}}function mx(Et){throw ky(Et="Aborted("+Et+")"),Aw=!0,r0=1,Et=new WebAssembly.RuntimeError(Et+". Build with -sASSERTIONS for more info."),Yr(Et),Et}var H2,yM=Et=>Et.startsWith("data:application/octet-stream;base64,"),bM=Et=>Et.startsWith("file://");function wM(Et){if(Et==H2&&R_)return new Uint8Array(R_);if(xa)return xa(Et);throw"both async and sync fetching of the wasm failed"}function vM(Et,_r,Qr){return function(Tn){if(!R_&&(wn||_o)){if(typeof fetch=="function"&&!bM(Tn))return fetch(Tn,{credentials:"same-origin"}).then(Ao=>{if(!Ao.ok)throw`failed to load wasm binary file at '${Tn}'`;return Ao.arrayBuffer()}).catch(()=>wM(Tn));if(So)return new Promise((Ao,nu)=>{So(Tn,f_=>Ao(new Uint8Array(f_)),nu)})}return Promise.resolve().then(()=>wM(Tn))}(Et).then(Tn=>WebAssembly.instantiate(Tn,_r)).then(Qr,Tn=>{ky(`failed to asynchronously prepare wasm: ${Tn}`),mx(Tn)})}function xM(){return{a:{M:oS,za:nS,b:lS,$:AM,z:DM,pa:FM,X:LM,Z:BM,qa:jM,na:zM,ga:NM,ma:UM,J:WM,Y:VM,V:KM,oa:GM,W:HM,va:uS,D:cS,P:dS,O:fS,C:_S,s:mS,p:gS,E:yS,y:$S,Q:MS,ta:PS,ja:kS,T:SS,aa:OS,F:AS,ia:i$,sa:CS,u:IS,B:RS,o:LS,m:jS,c:n$,n:zS,k:WS,Aa:VS,r:KS,g:GS,v:HS,l:qS,f:XS,i:YS,j:QS,h:ZS,e:JS,da:eO,ea:tO,fa:rO,ba:aP,ca:lP,S:nO,d:oO,N:iO,G:sO,K:aO,w:lO,ra:uO,U:cO,t:cP,x:dO,L:pO,R:fO,ya:hO,xa:_O,ka:fP,la:hP,_:Z2,A:_P,I:mP,ha:gP,H:yP,a:Uy,wa:Q2,ua:vP,q:yO}}}var q2={859316:(Et,_r,Qr,Tn,Ao)=>{if(It===void 0||!It.Fb)return 1;if((Et=ew(Et>>>0)).startsWith("./")&&(Et=Et.substring(2)),!(Et=It.Fb.get(Et)))return 2;if(Tn>>>=0,(_r>>>=0)+(Qr>>>=0)>Et.byteLength)return 3;try{let nu=Et.subarray(_r,_r+Qr);switch(Ao){case 0:it().set(nu,Tn>>>0);break;case 1:It.ac(Tn,nu);break;default:return 4}return 0}catch{return 4}},859999:()=>{It.Ub()},860030:()=>{It.Vb()},860059:()=>{It.Zb()},860084:Et=>It.Tb(Et),860117:Et=>It.Xb(Et),860149:(Et,_r,Qr)=>{It.Nb(Et,_r,Qr,!0)},860188:(Et,_r,Qr)=>{It.Nb(Et,_r,Qr)},860221:()=>typeof wasmOffsetConverter<"u",860278:Et=>{It.jb("Abs",Et,void 0)},860329:Et=>{It.jb("Neg",Et,void 0)},860380:Et=>{It.jb("Floor",Et,void 0)},860433:Et=>{It.jb("Ceil",Et,void 0)},860485:Et=>{It.jb("Reciprocal",Et,void 0)},860543:Et=>{It.jb("Sqrt",Et,void 0)},860595:Et=>{It.jb("Exp",Et,void 0)},860646:Et=>{It.jb("Erf",Et,void 0)},860697:Et=>{It.jb("Sigmoid",Et,void 0)},860752:(Et,_r,Qr)=>{It.jb("HardSigmoid",Et,{alpha:_r,beta:Qr})},860831:Et=>{It.jb("Log",Et,void 0)},860882:Et=>{It.jb("Sin",Et,void 0)},860933:Et=>{It.jb("Cos",Et,void 0)},860984:Et=>{It.jb("Tan",Et,void 0)},861035:Et=>{It.jb("Asin",Et,void 0)},861087:Et=>{It.jb("Acos",Et,void 0)},861139:Et=>{It.jb("Atan",Et,void 0)},861191:Et=>{It.jb("Sinh",Et,void 0)},861243:Et=>{It.jb("Cosh",Et,void 0)},861295:Et=>{It.jb("Asinh",Et,void 0)},861348:Et=>{It.jb("Acosh",Et,void 0)},861401:Et=>{It.jb("Atanh",Et,void 0)},861454:Et=>{It.jb("Tanh",Et,void 0)},861506:Et=>{It.jb("Not",Et,void 0)},861557:(Et,_r,Qr)=>{It.jb("Clip",Et,{min:_r,max:Qr})},861626:Et=>{It.jb("Clip",Et,void 0)},861678:(Et,_r)=>{It.jb("Elu",Et,{alpha:_r})},861736:Et=>{It.jb("Gelu",Et,void 0)},861788:Et=>{It.jb("Relu",Et,void 0)},861840:(Et,_r)=>{It.jb("LeakyRelu",Et,{alpha:_r})},861904:(Et,_r)=>{It.jb("ThresholdedRelu",Et,{alpha:_r})},861974:(Et,_r)=>{It.jb("Cast",Et,{to:_r})},862032:Et=>{It.jb("Add",Et,void 0)},862083:Et=>{It.jb("Sub",Et,void 0)},862134:Et=>{It.jb("Mul",Et,void 0)},862185:Et=>{It.jb("Div",Et,void 0)},862236:Et=>{It.jb("Pow",Et,void 0)},862287:Et=>{It.jb("Equal",Et,void 0)},862340:Et=>{It.jb("Greater",Et,void 0)},862395:Et=>{It.jb("GreaterOrEqual",Et,void 0)},862457:Et=>{It.jb("Less",Et,void 0)},862509:Et=>{It.jb("LessOrEqual",Et,void 0)},862568:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceMean",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},862727:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceMax",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},862885:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceMin",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},863043:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceProd",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},863202:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceSum",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},863360:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceL1",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},863517:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceL2",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},863674:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceLogSum",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},863835:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceSumSquare",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},863999:(Et,_r,Qr,Tn,Ao)=>{It.jb("ReduceLogSumExp",Et,{keepDims:!!_r,noopWithEmptyAxes:!!Qr,axes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},864163:Et=>{It.jb("Where",Et,void 0)},864216:(Et,_r,Qr)=>{It.jb("Transpose",Et,{perm:_r?Array.from(pt().subarray(_r>>>0,Qr>>>0)):[]})},864324:(Et,_r,Qr,Tn)=>{It.jb("DepthToSpace",Et,{blocksize:_r,mode:ew(Qr),format:Tn?"NHWC":"NCHW"})},864457:(Et,_r,Qr,Tn)=>{It.jb("DepthToSpace",Et,{blocksize:_r,mode:ew(Qr),format:Tn?"NHWC":"NCHW"})},864590:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_,qy)=>{It.jb("ConvTranspose",Et,{format:Y_?"NHWC":"NCHW",autoPad:_r,dilations:[Qr],group:Tn,kernelShape:[Ao],pads:[nu,f_],strides:[M_],wIsConst:()=>!!_e()[Im>>>0],outputPadding:cy?Array.from(pt().subarray(cy>>>0,Xy>>>0)):[],outputShape:u0?Array.from(pt().subarray(u0>>>0,s_>>>0)):[],activation:ew(qy)})},864991:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_)=>{It.jb("ConvTranspose",Et,{format:M_?"NHWC":"NCHW",autoPad:_r,dilations:Array.from(pt().subarray(Qr>>>0,2+(Qr>>>0)>>>0)),group:Tn,kernelShape:Array.from(pt().subarray(Ao>>>0,2+(Ao>>>0)>>>0)),pads:Array.from(pt().subarray(nu>>>0,4+(nu>>>0)>>>0)),strides:Array.from(pt().subarray(f_>>>0,2+(f_>>>0)>>>0)),wIsConst:()=>!!_e()[Y_>>>0],outputPadding:Im?Array.from(pt().subarray(Im>>>0,cy>>>0)):[],outputShape:Xy?Array.from(pt().subarray(Xy>>>0,u0>>>0)):[],activation:ew(s_)})},865556:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_,qy)=>{It.jb("ConvTranspose",Et,{format:Y_?"NHWC":"NCHW",autoPad:_r,dilations:[Qr],group:Tn,kernelShape:[Ao],pads:[nu,f_],strides:[M_],wIsConst:()=>!!_e()[Im>>>0],outputPadding:cy?Array.from(pt().subarray(cy>>>0,Xy>>>0)):[],outputShape:u0?Array.from(pt().subarray(u0>>>0,s_>>>0)):[],activation:ew(qy)})},865957:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_)=>{It.jb("ConvTranspose",Et,{format:M_?"NHWC":"NCHW",autoPad:_r,dilations:Array.from(pt().subarray(Qr>>>0,2+(Qr>>>0)>>>0)),group:Tn,kernelShape:Array.from(pt().subarray(Ao>>>0,2+(Ao>>>0)>>>0)),pads:Array.from(pt().subarray(nu>>>0,4+(nu>>>0)>>>0)),strides:Array.from(pt().subarray(f_>>>0,2+(f_>>>0)>>>0)),wIsConst:()=>!!_e()[Y_>>>0],outputPadding:Im?Array.from(pt().subarray(Im>>>0,cy>>>0)):[],outputShape:Xy?Array.from(pt().subarray(Xy>>>0,u0>>>0)):[],activation:ew(s_)})},866522:(Et,_r)=>{It.jb("GlobalAveragePool",Et,{format:_r?"NHWC":"NCHW"})},866613:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_)=>{It.jb("AveragePool",Et,{format:s_?"NHWC":"NCHW",auto_pad:_r,ceil_mode:Qr,count_include_pad:Tn,storage_order:Ao,dilations:nu?Array.from(pt().subarray(nu>>>0,f_>>>0)):[],kernel_shape:M_?Array.from(pt().subarray(M_>>>0,Y_>>>0)):[],pads:Im?Array.from(pt().subarray(Im>>>0,cy>>>0)):[],strides:Xy?Array.from(pt().subarray(Xy>>>0,u0>>>0)):[]})},867028:(Et,_r)=>{It.jb("GlobalAveragePool",Et,{format:_r?"NHWC":"NCHW"})},867119:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_)=>{It.jb("AveragePool",Et,{format:s_?"NHWC":"NCHW",auto_pad:_r,ceil_mode:Qr,count_include_pad:Tn,storage_order:Ao,dilations:nu?Array.from(pt().subarray(nu>>>0,f_>>>0)):[],kernel_shape:M_?Array.from(pt().subarray(M_>>>0,Y_>>>0)):[],pads:Im?Array.from(pt().subarray(Im>>>0,cy>>>0)):[],strides:Xy?Array.from(pt().subarray(Xy>>>0,u0>>>0)):[]})},867534:(Et,_r)=>{It.jb("GlobalMaxPool",Et,{format:_r?"NHWC":"NCHW"})},867621:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_)=>{It.jb("MaxPool",Et,{format:s_?"NHWC":"NCHW",auto_pad:_r,ceil_mode:Qr,count_include_pad:Tn,storage_order:Ao,dilations:nu?Array.from(pt().subarray(nu>>>0,f_>>>0)):[],kernel_shape:M_?Array.from(pt().subarray(M_>>>0,Y_>>>0)):[],pads:Im?Array.from(pt().subarray(Im>>>0,cy>>>0)):[],strides:Xy?Array.from(pt().subarray(Xy>>>0,u0>>>0)):[]})},868032:(Et,_r)=>{It.jb("GlobalMaxPool",Et,{format:_r?"NHWC":"NCHW"})},868119:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_)=>{It.jb("MaxPool",Et,{format:s_?"NHWC":"NCHW",auto_pad:_r,ceil_mode:Qr,count_include_pad:Tn,storage_order:Ao,dilations:nu?Array.from(pt().subarray(nu>>>0,f_>>>0)):[],kernel_shape:M_?Array.from(pt().subarray(M_>>>0,Y_>>>0)):[],pads:Im?Array.from(pt().subarray(Im>>>0,cy>>>0)):[],strides:Xy?Array.from(pt().subarray(Xy>>>0,u0>>>0)):[]})},868530:(Et,_r,Qr,Tn,Ao)=>{It.jb("Gemm",Et,{alpha:_r,beta:Qr,transA:Tn,transB:Ao})},868634:Et=>{It.jb("MatMul",Et,void 0)},868688:(Et,_r,Qr,Tn)=>{It.jb("ArgMax",Et,{keepDims:!!_r,selectLastIndex:!!Qr,axis:Tn})},868796:(Et,_r,Qr,Tn)=>{It.jb("ArgMin",Et,{keepDims:!!_r,selectLastIndex:!!Qr,axis:Tn})},868904:(Et,_r)=>{It.jb("Softmax",Et,{axis:_r})},868967:(Et,_r)=>{It.jb("Concat",Et,{axis:_r})},869027:(Et,_r,Qr,Tn,Ao)=>{It.jb("Split",Et,{axis:_r,numOutputs:Qr,splitSizes:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},869167:Et=>{It.jb("Expand",Et,void 0)},869221:(Et,_r)=>{It.jb("Gather",Et,{axis:Number(_r)})},869292:(Et,_r)=>{It.jb("GatherElements",Et,{axis:Number(_r)})},869371:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy)=>{It.jb("Resize",Et,{antialias:_r,axes:Qr?Array.from(pt().subarray(Qr>>>0,Tn>>>0)):[],coordinateTransformMode:ew(Ao),cubicCoeffA:nu,excludeOutside:f_,extrapolationValue:M_,keepAspectRatioPolicy:ew(Y_),mode:ew(Im),nearestMode:ew(cy)})},869717:(Et,_r,Qr,Tn,Ao,nu,f_)=>{It.jb("Slice",Et,{starts:_r?Array.from(pt().subarray(_r>>>0,Qr>>>0)):[],ends:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[],axes:nu?Array.from(pt().subarray(nu>>>0,f_>>>0)):[]})},869933:Et=>{It.jb("Tile",Et,void 0)},869985:(Et,_r,Qr)=>{It.jb("InstanceNormalization",Et,{epsilon:_r,format:Qr?"NHWC":"NCHW"})},870099:(Et,_r,Qr)=>{It.jb("InstanceNormalization",Et,{epsilon:_r,format:Qr?"NHWC":"NCHW"})},870213:Et=>{It.jb("Range",Et,void 0)},870266:(Et,_r)=>{It.jb("Einsum",Et,{equation:ew(_r)})},870347:(Et,_r,Qr,Tn,Ao)=>{It.jb("Pad",Et,{mode:_r,value:Qr,pads:Tn?Array.from(pt().subarray(Tn>>>0,Ao>>>0)):[]})},870474:(Et,_r,Qr,Tn,Ao,nu)=>{It.jb("BatchNormalization",Et,{epsilon:_r,momentum:Qr,spatial:!!Ao,trainingMode:!!Tn,format:nu?"NHWC":"NCHW"})},870643:(Et,_r,Qr,Tn,Ao,nu)=>{It.jb("BatchNormalization",Et,{epsilon:_r,momentum:Qr,spatial:!!Ao,trainingMode:!!Tn,format:nu?"NHWC":"NCHW"})},870812:(Et,_r,Qr)=>{It.jb("CumSum",Et,{exclusive:Number(_r),reverse:Number(Qr)})},870909:(Et,_r,Qr)=>{It.jb("DequantizeLinear",Et,{axis:_r,blockSize:Qr})},870999:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_)=>{It.jb("Attention",Et,{numHeads:_r,isUnidirectional:Qr,maskFilterValue:Tn,scale:Ao,doRotary:nu,qkvHiddenSizes:f_?Array.from(pt().subarray(Number(M_)>>>0,Number(M_)+f_>>>0)):[],pastPresentShareBuffer:!!Y_})},871271:Et=>{It.jb("BiasAdd",Et,void 0)},871326:Et=>{It.jb("BiasSplitGelu",Et,void 0)},871387:Et=>{It.jb("FastGelu",Et,void 0)},871443:(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im,cy,Xy,u0,s_,qy,O0)=>{It.jb("Conv",Et,{format:Xy?"NHWC":"NCHW",auto_pad:_r,dilations:Qr?Array.from(pt().subarray(Qr>>>0,Tn>>>0)):[],group:Ao,kernel_shape:nu?Array.from(pt().subarray(nu>>>0,f_>>>0)):[],pads:M_?Array.from(pt().subarray(M_>>>0,Y_>>>0)):[],strides:Im?Array.from(pt().subarray(Im>>>0,cy>>>0)):[],w_is_const:()=>!!_e()[u0>>>0],activation:ew(s_),activation_params:qy?Array.from(Bt().subarray(qy>>>0,O0>>>0)):[]})},871939:Et=>{It.jb("Gelu",Et,void 0)},871991:(Et,_r,Qr,Tn)=>{It.jb("GroupQueryAttention",Et,{numHeads:_r,kvNumHeads:Qr,scale:Tn})},872104:(Et,_r,Qr,Tn)=>{It.jb("LayerNormalization",Et,{axis:_r,epsilon:Qr,simplified:!!Tn})},872215:(Et,_r,Qr,Tn)=>{It.jb("LayerNormalization",Et,{axis:_r,epsilon:Qr,simplified:!!Tn})},872326:(Et,_r,Qr,Tn,Ao,nu)=>{It.jb("MatMulNBits",Et,{k:_r,n:Qr,accuracyLevel:Tn,bits:Ao,blockSize:nu})},872453:(Et,_r,Qr,Tn,Ao,nu)=>{It.jb("MultiHeadAttention",Et,{numHeads:_r,isUnidirectional:Qr,maskFilterValue:Tn,scale:Ao,doRotary:nu})},872612:(Et,_r)=>{It.jb("QuickGelu",Et,{alpha:_r})},872676:(Et,_r,Qr,Tn,Ao)=>{It.jb("RotaryEmbedding",Et,{interleaved:!!_r,numHeads:Qr,rotaryEmbeddingDim:Tn,scale:Ao})},872815:(Et,_r,Qr)=>{It.jb("SkipLayerNormalization",Et,{epsilon:_r,simplified:!!Qr})},872917:(Et,_r,Qr)=>{It.jb("SkipLayerNormalization",Et,{epsilon:_r,simplified:!!Qr})},873019:(Et,_r,Qr,Tn)=>{It.jb("GatherBlockQuantized",Et,{gatherAxis:_r,quantizeAxis:Qr,blockSize:Tn})},873140:Et=>{It.Yb(Et)},873174:(Et,_r)=>It.$b(Et,_r,It.Eb.cc,It.Eb.errors)};function nS(Et,_r,Qr){return rP(async()=>{await It.Wb(Et,_r,Qr)})}function oS(){return typeof wasmOffsetConverter<"u"}function X2(Et){this.name="ExitStatus",this.message=`Program terminated with exit(${Et})`,this.status=Et}var Y2=Et=>{Et.terminate(),Et.onmessage=()=>{}},TM=Et=>{G1.length==0&&(SM(),kM(G1[0]));var _r=G1.pop();if(!_r)return 6;vv.push(_r),d1[Et.Ab]=_r,_r.Ab=Et.Ab;var Qr={cmd:"run",start_routine:Et.dc,arg:Et.Pb,pthread_ptr:Et.Ab};return _r.postMessage(Qr,Et.jc),0},wv=0,$0=(Et,_r,...Qr)=>{for(var Tn=2*Qr.length,Ao=_$(),nu=h$(8*Tn),f_=nu>>>3,M_=0;M_<Qr.length;M_++){var Y_=Qr[M_];typeof Y_=="bigint"?(w0[f_+2*M_]=1n,w0[f_+2*M_+1]=Y_):(w0[f_+2*M_]=0n,Gt()[f_+2*M_+1>>>0]=Y_)}return Et=MP(Et,0,Tn,nu,_r),P2(Ao),Et};function Q2(Et){if(vn)return $0(0,1,Et);if(r0=Et,!(0<wv)){for(var _r of vv)Y2(_r);for(_r of G1)Y2(_r);G1=[],vv=[],d1=[],Aw=!0}u_(Et,new X2(Et))}function EM(Et){if(vn)return $0(1,0,Et);Z2(Et)}var Z2=Et=>{if(r0=Et,vn)throw EM(Et),"unwind";Q2(Et)},G1=[],vv=[],$M=[],d1={},MM=Et=>{var _r=Et.Ab;delete d1[_r],G1.push(Et),vv.splice(vv.indexOf(Et),1),Et.Ab=0,f$(_r)};function PM(){$M.forEach(Et=>Et())}var kM=Et=>new Promise(_r=>{Et.onmessage=Ao=>{var nu=(Ao=Ao.data).cmd;if(Ao.targetThread&&Ao.targetThread!=bx()){var f_=d1[Ao.targetThread];f_?f_.postMessage(Ao,Ao.transferList):ky(`Internal error! Worker sent a message "${nu}" to target pthread ${Ao.targetThread}, but that thread no longer exists!`)}else nu==="checkMailbox"?g2():nu==="spawnThread"?TM(Ao):nu==="cleanupThread"?MM(d1[Ao.thread]):nu==="killThread"?(Ao=Ao.thread,nu=d1[Ao],delete d1[Ao],Y2(nu),f$(Ao),vv.splice(vv.indexOf(nu),1),nu.Ab=0):nu==="cancelThread"?d1[Ao.thread].postMessage({cmd:"cancel"}):nu==="loaded"?(Et.loaded=!0,_r(Et)):nu==="alert"?alert(`Thread ${Ao.threadId}: ${Ao.text}`):Ao.target==="setimmediate"?Et.postMessage(Ao):nu==="callHandler"?It[Ao.handler](...Ao.args):nu&&ky(`worker sent an unknown command ${nu}`)},Et.onerror=Ao=>{throw ky(`worker sent an error! ${Ao.filename}:${Ao.lineno}: ${Ao.message}`),Ao};var Qr,Tn=[];for(Qr of[])It.hasOwnProperty(Qr)&&Tn.push(Qr);Et.postMessage({cmd:"load",handlers:Tn,wasmMemory:Uy,wasmModule:dy})});function SM(){var Et=new Worker(new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});G1.push(Et)}var m2=Et=>{for(;0<Et.length;)Et.shift()(It)},iS=()=>{var Et=bx(),_r=ft()[Et+52>>>2>>>0];Et=ft()[Et+56>>>2>>>0],kP(_r,_r-Et),P2(_r)},sS=(Et,_r)=>{wv=0,Et=SP(Et,_r),0<wv?r0=Et:M2(Et)};class aS{constructor(_r){this.Ib=_r-24}}function lS(Et,_r,Qr){var Tn=new aS(Et>>>=0);throw _r>>>=0,Qr>>>=0,ft()[Tn.Ib+16>>>2>>>0]=0,ft()[Tn.Ib+4>>>2>>>0]=_r,ft()[Tn.Ib+8>>>2>>>0]=Qr,Et}function OM(Et,_r,Qr,Tn){return vn?$0(2,1,Et,_r,Qr,Tn):AM(Et,_r,Qr,Tn)}function AM(Et,_r,Qr,Tn){if(Et>>>=0,_r>>>=0,Qr>>>=0,Tn>>>=0,Ws===void 0)return ky("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Ao=[];return vn&&Ao.length===0?OM(Et,_r,Qr,Tn):(Et={dc:Qr,Ab:Et,Pb:Tn,jc:Ao},vn?(Et.Lb="spawnThread",postMessage(Et,Ao),0):TM(Et))}var CM=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,IM=(Et,_r,Qr)=>{var Tn=(_r>>>=0)+Qr;for(Qr=_r;Et[Qr]&&!(Qr>=Tn);)++Qr;if(16<Qr-_r&&Et.buffer&&CM)return CM.decode(Et.buffer instanceof Ws?Et.slice(_r,Qr):Et.subarray(_r,Qr));for(Tn="";_r<Qr;){var Ao=Et[_r++];if(128&Ao){var nu=63&Et[_r++];if((224&Ao)==192)Tn+=String.fromCharCode((31&Ao)<<6|nu);else{var f_=63&Et[_r++];65536>(Ao=(240&Ao)==224?(15&Ao)<<12|nu<<6|f_:(7&Ao)<<18|nu<<12|f_<<6|63&Et[_r++])?Tn+=String.fromCharCode(Ao):(Ao-=65536,Tn+=String.fromCharCode(55296|Ao>>10,56320|1023&Ao))}}else Tn+=String.fromCharCode(Ao)}return Tn},ew=(Et,_r)=>(Et>>>=0)?IM(it(),Et,_r):"";function DM(Et,_r,Qr){return vn?$0(3,1,Et,_r,Qr):0}function FM(Et,_r){if(vn)return $0(4,1,Et,_r)}var J2=Et=>{for(var _r=0,Qr=0;Qr<Et.length;++Qr){var Tn=Et.charCodeAt(Qr);127>=Tn?_r++:2047>=Tn?_r+=2:55296<=Tn&&57343>=Tn?(_r+=4,++Qr):_r+=3}return _r},RM=(Et,_r,Qr,Tn)=>{if(!(0<Tn))return 0;var Ao=Qr>>>=0;Tn=Qr+Tn-1;for(var nu=0;nu<Et.length;++nu){var f_=Et.charCodeAt(nu);if(55296<=f_&&57343>=f_&&(f_=65536+((1023&f_)<<10)|1023&Et.charCodeAt(++nu)),127>=f_){if(Qr>=Tn)break;_r[Qr++>>>0]=f_}else{if(2047>=f_){if(Qr+1>=Tn)break;_r[Qr++>>>0]=192|f_>>6}else{if(65535>=f_){if(Qr+2>=Tn)break;_r[Qr++>>>0]=224|f_>>12}else{if(Qr+3>=Tn)break;_r[Qr++>>>0]=240|f_>>18,_r[Qr++>>>0]=128|f_>>12&63}_r[Qr++>>>0]=128|f_>>6&63}_r[Qr++>>>0]=128|63&f_}}return _r[Qr>>>0]=0,Qr-Ao},gx=(Et,_r,Qr)=>RM(Et,it(),_r,Qr);function LM(Et,_r){if(vn)return $0(5,1,Et,_r)}function BM(Et,_r,Qr){if(vn)return $0(6,1,Et,_r,Qr)}function jM(Et,_r,Qr){return vn?$0(7,1,Et,_r,Qr):0}function zM(Et,_r){if(vn)return $0(8,1,Et,_r)}function NM(Et,_r,Qr){if(vn)return $0(9,1,Et,_r,Qr)}function UM(Et,_r,Qr,Tn){if(vn)return $0(10,1,Et,_r,Qr,Tn)}function WM(Et,_r,Qr,Tn){if(vn)return $0(11,1,Et,_r,Qr,Tn)}function VM(Et,_r,Qr,Tn){if(vn)return $0(12,1,Et,_r,Qr,Tn)}function KM(Et){if(vn)return $0(13,1,Et)}function GM(Et,_r){if(vn)return $0(14,1,Et,_r)}function HM(Et,_r,Qr){if(vn)return $0(15,1,Et,_r,Qr)}var qM,H1,uS=()=>{mx("")},p1=Et=>{for(var _r="";it()[Et>>>0];)_r+=qM[it()[Et++>>>0]];return _r},e$={},t$={};function E1(Et,_r,Qr={}){if(!("argPackAdvance"in _r))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(Tn,Ao,nu={}){var f_=Ao.name;if(!Tn)throw new H1(`type "${f_}" must have a positive integer typeid pointer`);if(t$.hasOwnProperty(Tn)){if(nu.Rb)return;throw new H1(`Cannot register type '${f_}' twice`)}t$[Tn]=Ao,e$.hasOwnProperty(Tn)&&(Ao=e$[Tn],delete e$[Tn],Ao.forEach(M_=>M_()))}(Et,_r,Qr)}var XM=(Et,_r,Qr)=>{switch(_r){case 1:return Qr?Tn=>_e()[Tn>>>0]:Tn=>it()[Tn>>>0];case 2:return Qr?Tn=>ut()[Tn>>>1>>>0]:Tn=>ct()[Tn>>>1>>>0];case 4:return Qr?Tn=>pt()[Tn>>>2>>>0]:Tn=>ft()[Tn>>>2>>>0];case 8:return Qr?Tn=>w0[Tn>>>3]:Tn=>Bw[Tn>>>3];default:throw new TypeError(`invalid integer width (${_r}): ${Et}`)}};function cS(Et,_r,Qr){Qr>>>=0,E1(Et>>>=0,{name:_r=p1(_r>>>0),fromWireType:Tn=>Tn,toWireType:function(Tn,Ao){if(typeof Ao!="bigint"&&typeof Ao!="number")throw Ao=Ao===null?"null":(Tn=typeof Ao)=="object"||Tn==="array"||Tn==="function"?Ao.toString():""+Ao,new TypeError(`Cannot convert "${Ao}" to ${this.name}`);return typeof Ao=="number"&&(Ao=BigInt(Ao)),Ao},argPackAdvance:q1,readValueFromPointer:XM(_r,Qr,_r.indexOf("u")==-1),Db:null})}var q1=8;function dS(Et,_r,Qr,Tn){E1(Et>>>=0,{name:_r=p1(_r>>>0),fromWireType:function(Ao){return!!Ao},toWireType:function(Ao,nu){return nu?Qr:Tn},argPackAdvance:q1,readValueFromPointer:function(Ao){return this.fromWireType(it()[Ao>>>0])},Db:null})}var r$=[],$1=[];function n$(Et){9<(Et>>>=0)&&--$1[Et+1]==0&&($1[Et]=void 0,r$.push(Et))}var jw=Et=>{if(!Et)throw new H1("Cannot use deleted val. handle = "+Et);return $1[Et]},zw=Et=>{switch(Et){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let _r=r$.pop()||$1.length;return $1[_r]=Et,$1[_r+1]=1,_r}};function o$(Et){return this.fromWireType(ft()[Et>>>2>>>0])}var pS={name:"emscripten::val",fromWireType:Et=>{var _r=jw(Et);return n$(Et),_r},toWireType:(Et,_r)=>zw(_r),argPackAdvance:q1,readValueFromPointer:o$,Db:null};function fS(Et){return E1(Et>>>0,pS)}var hS=(Et,_r)=>{switch(_r){case 4:return function(Qr){return this.fromWireType(Bt()[Qr>>>2>>>0])};case 8:return function(Qr){return this.fromWireType(Gt()[Qr>>>3>>>0])};default:throw new TypeError(`invalid float width (${_r}): ${Et}`)}};function _S(Et,_r,Qr){Qr>>>=0,E1(Et>>>=0,{name:_r=p1(_r>>>0),fromWireType:Tn=>Tn,toWireType:(Tn,Ao)=>Ao,argPackAdvance:q1,readValueFromPointer:hS(_r,Qr),Db:null})}function mS(Et,_r,Qr,Tn,Ao){if(Et>>>=0,Qr>>>=0,_r=p1(_r>>>0),Ao===-1&&(Ao=4294967295),Ao=M_=>M_,Tn===0){var nu=32-8*Qr;Ao=M_=>M_<<nu>>>nu}var f_=_r.includes("unsigned")?function(M_,Y_){return Y_>>>0}:function(M_,Y_){return Y_};E1(Et,{name:_r,fromWireType:Ao,toWireType:f_,argPackAdvance:q1,readValueFromPointer:XM(_r,Qr,Tn!==0),Db:null})}function gS(Et,_r,Qr){function Tn(nu){var f_=ft()[nu>>>2>>>0];return nu=ft()[nu+4>>>2>>>0],new Ao(_e().buffer,nu,f_)}var Ao=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][_r];E1(Et>>>=0,{name:Qr=p1(Qr>>>0),fromWireType:Tn,argPackAdvance:q1,readValueFromPointer:Tn},{Rb:!0})}function yS(Et,_r){Et>>>=0;var Qr=(_r=p1(_r>>>0))==="std::string";E1(Et,{name:_r,fromWireType:function(Tn){var Ao=ft()[Tn>>>2>>>0],nu=Tn+4;if(Qr)for(var f_=nu,M_=0;M_<=Ao;++M_){var Y_=nu+M_;if(M_==Ao||it()[Y_>>>0]==0){if(f_=ew(f_,Y_-f_),Im===void 0)var Im=f_;else Im+="\0",Im+=f_;f_=Y_+1}}else{for(Im=Array(Ao),M_=0;M_<Ao;++M_)Im[M_]=String.fromCharCode(it()[nu+M_>>>0]);Im=Im.join("")}return h1(Tn),Im},toWireType:function(Tn,Ao){Ao instanceof ArrayBuffer&&(Ao=new Uint8Array(Ao));var nu=typeof Ao=="string";if(!(nu||Ao instanceof Uint8Array||Ao instanceof Uint8ClampedArray||Ao instanceof Int8Array))throw new H1("Cannot pass non-string to std::string");var f_=Qr&&nu?J2(Ao):Ao.length,M_=$2(4+f_+1),Y_=M_+4;if(ft()[M_>>>2>>>0]=f_,Qr&&nu)gx(Ao,Y_,f_+1);else if(nu)for(nu=0;nu<f_;++nu){var Im=Ao.charCodeAt(nu);if(255<Im)throw h1(Y_),new H1("String has UTF-16 code units that do not fit in 8 bits");it()[Y_+nu>>>0]=Im}else for(nu=0;nu<f_;++nu)it()[Y_+nu>>>0]=Ao[nu];return Tn!==null&&Tn.push(h1,M_),M_},argPackAdvance:q1,readValueFromPointer:o$,Db(Tn){h1(Tn)}})}var YM=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,bS=(Et,_r)=>{for(var Qr=Et>>1,Tn=Qr+_r/2;!(Qr>=Tn)&&ct()[Qr>>>0];)++Qr;if(32<(Qr<<=1)-Et&&YM)return YM.decode(it().slice(Et,Qr));for(Qr="",Tn=0;!(Tn>=_r/2);++Tn){var Ao=ut()[Et+2*Tn>>>1>>>0];if(Ao==0)break;Qr+=String.fromCharCode(Ao)}return Qr},wS=(Et,_r,Qr)=>{if(Qr??=2147483647,2>Qr)return 0;var Tn=_r;Qr=(Qr-=2)<2*Et.length?Qr/2:Et.length;for(var Ao=0;Ao<Qr;++Ao){var nu=Et.charCodeAt(Ao);ut()[_r>>>1>>>0]=nu,_r+=2}return ut()[_r>>>1>>>0]=0,_r-Tn},vS=Et=>2*Et.length,xS=(Et,_r)=>{for(var Qr=0,Tn="";!(Qr>=_r/4);){var Ao=pt()[Et+4*Qr>>>2>>>0];if(Ao==0)break;++Qr,65536<=Ao?(Ao-=65536,Tn+=String.fromCharCode(55296|Ao>>10,56320|1023&Ao)):Tn+=String.fromCharCode(Ao)}return Tn},TS=(Et,_r,Qr)=>{if(_r>>>=0,Qr??=2147483647,4>Qr)return 0;var Tn=_r;Qr=Tn+Qr-4;for(var Ao=0;Ao<Et.length;++Ao){var nu=Et.charCodeAt(Ao);if(55296<=nu&&57343>=nu&&(nu=65536+((1023&nu)<<10)|1023&Et.charCodeAt(++Ao)),pt()[_r>>>2>>>0]=nu,(_r+=4)+4>Qr)break}return pt()[_r>>>2>>>0]=0,_r-Tn},ES=Et=>{for(var _r=0,Qr=0;Qr<Et.length;++Qr){var Tn=Et.charCodeAt(Qr);55296<=Tn&&57343>=Tn&&++Qr,_r+=4}return _r};function $S(Et,_r,Qr){if(Et>>>=0,_r>>>=0,Qr=p1(Qr>>>=0),_r===2)var Tn=bS,Ao=wS,nu=vS,f_=M_=>ct()[M_>>>1>>>0];else _r===4&&(Tn=xS,Ao=TS,nu=ES,f_=M_=>ft()[M_>>>2>>>0]);E1(Et,{name:Qr,fromWireType:M_=>{for(var Y_,Im=ft()[M_>>>2>>>0],cy=M_+4,Xy=0;Xy<=Im;++Xy){var u0=M_+4+Xy*_r;Xy!=Im&&f_(u0)!=0||(cy=Tn(cy,u0-cy),Y_===void 0?Y_=cy:(Y_+="\0",Y_+=cy),cy=u0+_r)}return h1(M_),Y_},toWireType:(M_,Y_)=>{if(typeof Y_!="string")throw new H1(`Cannot pass non-string to C++ string type ${Qr}`);var Im=nu(Y_),cy=$2(4+Im+_r);return ft()[cy>>>2>>>0]=Im/_r,Ao(Y_,cy+4,Im+_r),M_!==null&&M_.push(h1,cy),cy},argPackAdvance:q1,readValueFromPointer:o$,Db(M_){h1(M_)}})}function MS(Et,_r){E1(Et>>>=0,{Sb:!0,name:_r=p1(_r>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var PS=()=>1;function kS(Et){p$(Et>>>0,!_o,1,!wn,131072,!1),PM()}var QM=Et=>{if(!Aw)try{if(Et(),!(0<wv))try{vn?M2(r0):Z2(r0)}catch(_r){_r instanceof X2||_r=="unwind"||u_(1,_r)}}catch(_r){_r instanceof X2||_r=="unwind"||u_(1,_r)}};function i$(Et){Et>>>=0,typeof Atomics.kc=="function"&&(Atomics.kc(pt(),Et>>>2,Et).value.then(g2),Et+=128,Atomics.store(pt(),Et>>>2,1))}var g2=()=>{var Et=bx();Et&&(i$(Et),QM(PP))};function SS(Et,_r){(Et>>>=0)==_r>>>0?setTimeout(g2):vn?postMessage({targetThread:Et,cmd:"checkMailbox"}):(Et=d1[Et])&&Et.postMessage({cmd:"checkMailbox"})}var s$=[];function OS(Et,_r,Qr,Tn,Ao){for(_r>>>=0,Tn/=2,s$.length=Tn,Qr=Ao>>>0>>>3,Ao=0;Ao<Tn;Ao++)s$[Ao]=w0[Qr+2*Ao]?w0[Qr+2*Ao+1]:Gt()[Qr+2*Ao+1>>>0];return(_r?q2[_r]:bO[Et])(...s$)}function AS(Et){Et>>>=0,vn?postMessage({cmd:"cleanupThread",thread:Et}):MM(d1[Et])}function CS(Et){}var a$=(Et,_r)=>{var Qr=t$[Et];if(Qr===void 0)throw Et=TP(Et),Qr=p1(Et),h1(Et),new H1(`${_r} has unknown type ${Qr}`);return Qr},ZM=(Et,_r,Qr)=>{var Tn=[];return Et=Et.toWireType(Tn,Qr),Tn.length&&(ft()[_r>>>2>>>0]=zw(Tn)),Et};function IS(Et,_r,Qr){return _r>>>=0,Qr>>>=0,Et=jw(Et>>>0),_r=a$(_r,"emval::as"),ZM(_r,Qr,Et)}var y2=Et=>{try{Et()}catch(_r){mx(_r)}},X1=0,f1=null,JM=0,b2=[],eP={},tP={},DS=0,l$=null,FS=[];function rP(Et){return function(_r){if(!Aw){if(X1===0){var Qr=!1,Tn=!1;_r((Ao=0)=>{if(!Aw&&(JM=Ao,Qr=!0,Tn)){X1=2,y2(()=>CP(f1)),typeof Browser<"u"&&Browser.Jb.Qb&&Browser.Jb.resume(),Ao=!1;try{var nu=function(){var Y_=pt()[f1+8>>>2>>>0];return Y_=uy[tP[Y_]],--wv,Y_()}()}catch(Y_){nu=Y_,Ao=!0}var f_=!1;if(!f1){var M_=l$;M_&&(l$=null,(Ao?M_.reject:M_.resolve)(nu),f_=!0)}if(Ao&&!f_)throw nu}}),Tn=!0,Qr||(X1=1,f1=function(){var Ao=$2(65548),nu=Ao+12;ft()[Ao>>>2>>>0]=nu,ft()[Ao+4>>>2>>>0]=nu+65536,nu=b2[0];var f_=eP[nu];return f_===void 0&&(f_=DS++,eP[nu]=f_,tP[f_]=nu),nu=f_,pt()[Ao+8>>>2>>>0]=nu,Ao}(),typeof Browser<"u"&&Browser.Jb.Qb&&Browser.Jb.pause(),y2(()=>OP(f1)))}else X1===2?(X1=0,y2(IP),h1(f1),f1=null,FS.forEach(QM)):mx(`invalid state: ${X1}`);return JM}}(_r=>{Et().then(_r)})}function RS(Et){return Et>>>=0,rP(()=>(Et=jw(Et)).then(zw))}var w2=[];function LS(Et,_r,Qr,Tn){return Qr>>>=0,Tn>>>=0,(Et=w2[Et>>>0])(null,_r=jw(_r>>>0),Qr,Tn)}var BS={},v2=Et=>{var _r=BS[Et];return _r===void 0?p1(Et):_r};function jS(Et,_r,Qr,Tn,Ao){return Qr>>>=0,Tn>>>=0,Ao>>>=0,(Et=w2[Et>>>0])(_r=jw(_r>>>0),_r[Qr=v2(Qr)],Tn,Ao)}var nP=()=>typeof globalThis=="object"?globalThis:Function("return this")();function zS(Et){return(Et>>>=0)==0?zw(nP()):(Et=v2(Et),zw(nP()[Et]))}var NS=Et=>{var _r=w2.length;return w2.push(Et),_r},US=(Et,_r)=>{for(var Qr=Array(Et),Tn=0;Tn<Et;++Tn)Qr[Tn]=a$(ft()[_r+4*Tn>>>2>>>0],"parameter "+Tn);return Qr},oP=(Et,_r)=>Object.defineProperty(_r,"name",{value:Et});function WS(Et,_r,Qr){var Tn=(_r=US(Et,_r>>>0)).shift();Et--;var Ao=`return function (obj, func, destructorsRef, args) {
`,nu=0,f_=[];Qr===0&&f_.push("obj");for(var M_=["retType"],Y_=[Tn],Im=0;Im<Et;++Im)f_.push("arg"+Im),M_.push("argType"+Im),Y_.push(_r[Im]),Ao+=`  var arg${Im} = argType${Im}.readValueFromPointer(args${nu?"+"+nu:""});
`,nu+=_r[Im].argPackAdvance;return Ao+=`  var rv = ${Qr===1?"new func":"func.call"}(${f_.join(", ")});
`,Tn.Sb||(M_.push("emval_returnValue"),Y_.push(ZM),Ao+=`  return emval_returnValue(retType, destructorsRef, rv);
`),M_.push(Ao+`};
`),Et=function(cy){var Xy=Function;if(!(Xy instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Xy} which is not a function`);var u0=oP(Xy.name||"unknownFunctionName",function(){});return u0.prototype=Xy.prototype,u0=new u0,(cy=Xy.apply(u0,cy))instanceof Object?cy:u0}(M_)(...Y_),Qr=`methodCaller<(${_r.map(cy=>cy.name).join(", ")}) => ${Tn.name}>`,NS(oP(Qr,Et))}function VS(Et){return Et=v2(Et>>>0),zw(It[Et])}function KS(Et,_r){return _r>>>=0,Et=jw(Et>>>0),_r=jw(_r),zw(Et[_r])}function GS(Et){9<(Et>>>=0)&&($1[Et+1]+=1)}function HS(){return zw([])}function qS(Et){Et=jw(Et>>>0);for(var _r=Array(Et.length),Qr=0;Qr<Et.length;Qr++)_r[Qr]=Et[Qr];return zw(_r)}function XS(Et){return zw(v2(Et>>>0))}function YS(){return zw({})}function QS(Et){for(var _r=jw(Et>>>=0);_r.length;){var Qr=_r.pop();_r.pop()(Qr)}n$(Et)}function ZS(Et,_r,Qr){_r>>>=0,Qr>>>=0,Et=jw(Et>>>0),_r=jw(_r),Qr=jw(Qr),Et[_r]=Qr}function JS(Et,_r){return _r>>>=0,Et=(Et=a$(Et>>>0,"_emval_take_value")).readValueFromPointer(_r),zw(Et)}function eO(Et,_r){Et=-9007199254740992>Et||9007199254740992<Et?NaN:Number(Et),_r>>>=0,Et=new Date(1e3*Et),pt()[_r>>>2>>>0]=Et.getUTCSeconds(),pt()[_r+4>>>2>>>0]=Et.getUTCMinutes(),pt()[_r+8>>>2>>>0]=Et.getUTCHours(),pt()[_r+12>>>2>>>0]=Et.getUTCDate(),pt()[_r+16>>>2>>>0]=Et.getUTCMonth(),pt()[_r+20>>>2>>>0]=Et.getUTCFullYear()-1900,pt()[_r+24>>>2>>>0]=Et.getUTCDay(),Et=(Et.getTime()-Date.UTC(Et.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,pt()[_r+28>>>2>>>0]=Et}var yx=Et=>Et%4==0&&(Et%100!=0||Et%400==0),iP=[0,31,60,91,121,152,182,213,244,274,305,335],sP=[0,31,59,90,120,151,181,212,243,273,304,334];function tO(Et,_r){Et=-9007199254740992>Et||9007199254740992<Et?NaN:Number(Et),_r>>>=0,Et=new Date(1e3*Et),pt()[_r>>>2>>>0]=Et.getSeconds(),pt()[_r+4>>>2>>>0]=Et.getMinutes(),pt()[_r+8>>>2>>>0]=Et.getHours(),pt()[_r+12>>>2>>>0]=Et.getDate(),pt()[_r+16>>>2>>>0]=Et.getMonth(),pt()[_r+20>>>2>>>0]=Et.getFullYear()-1900,pt()[_r+24>>>2>>>0]=Et.getDay();var Qr=(yx(Et.getFullYear())?iP:sP)[Et.getMonth()]+Et.getDate()-1|0;pt()[_r+28>>>2>>>0]=Qr,pt()[_r+36>>>2>>>0]=-60*Et.getTimezoneOffset(),Qr=new Date(Et.getFullYear(),6,1).getTimezoneOffset();var Tn=new Date(Et.getFullYear(),0,1).getTimezoneOffset();Et=0|(Qr!=Tn&&Et.getTimezoneOffset()==Math.min(Tn,Qr)),pt()[_r+32>>>2>>>0]=Et}function rO(Et){Et>>>=0;var _r=new Date(pt()[Et+20>>>2>>>0]+1900,pt()[Et+16>>>2>>>0],pt()[Et+12>>>2>>>0],pt()[Et+8>>>2>>>0],pt()[Et+4>>>2>>>0],pt()[Et>>>2>>>0],0),Qr=pt()[Et+32>>>2>>>0],Tn=_r.getTimezoneOffset(),Ao=new Date(_r.getFullYear(),6,1).getTimezoneOffset(),nu=new Date(_r.getFullYear(),0,1).getTimezoneOffset(),f_=Math.min(nu,Ao);return 0>Qr?pt()[Et+32>>>2>>>0]=+(Ao!=nu&&f_==Tn):0<Qr!=(f_==Tn)&&(Ao=Math.max(nu,Ao),_r.setTime(_r.getTime()+6e4*((0<Qr?f_:Ao)-Tn))),pt()[Et+24>>>2>>>0]=_r.getDay(),Qr=(yx(_r.getFullYear())?iP:sP)[_r.getMonth()]+_r.getDate()-1|0,pt()[Et+28>>>2>>>0]=Qr,pt()[Et>>>2>>>0]=_r.getSeconds(),pt()[Et+4>>>2>>>0]=_r.getMinutes(),pt()[Et+8>>>2>>>0]=_r.getHours(),pt()[Et+12>>>2>>>0]=_r.getDate(),pt()[Et+16>>>2>>>0]=_r.getMonth(),pt()[Et+20>>>2>>>0]=_r.getYear(),Et=_r.getTime(),BigInt(isNaN(Et)?-1:Et/1e3)}function aP(Et,_r,Qr,Tn,Ao,nu,f_){return vn?$0(16,1,Et,_r,Qr,Tn,Ao,nu,f_):-52}function lP(Et,_r,Qr,Tn,Ao,nu){if(vn)return $0(17,1,Et,_r,Qr,Tn,Ao,nu)}function nO(Et,_r,Qr,Tn){Et>>>=0,_r>>>=0,Qr>>>=0,Tn>>>=0;var Ao=new Date().getFullYear(),nu=new Date(Ao,0,1),f_=new Date(Ao,6,1);Ao=nu.getTimezoneOffset();var M_=f_.getTimezoneOffset(),Y_=Math.max(Ao,M_);ft()[Et>>>2>>>0]=60*Y_,pt()[_r>>>2>>>0]=+(Ao!=M_),nu=(Et=Im=>Im.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(nu),f_=Et(f_),M_<Ao?(gx(nu,Qr,17),gx(f_,Tn,17)):(gx(nu,Tn,17),gx(f_,Qr,17))}var u$=[],uP=(Et,_r)=>{u$.length=0;for(var Qr;Qr=it()[Et++>>>0];){var Tn=Qr!=105;_r+=(Tn&=Qr!=112)&&_r%8?4:0,u$.push(Qr==112?ft()[_r>>>2>>>0]:Qr==106?w0[_r>>>3]:Qr==105?pt()[_r>>>2>>>0]:Gt()[_r>>>3>>>0]),_r+=Tn?8:4}return u$};function oO(Et,_r,Qr){return Et>>>=0,_r=uP(_r>>>0,Qr>>>0),q2[Et](..._r)}function iO(Et,_r,Qr){return Et>>>=0,_r=uP(_r>>>0,Qr>>>0),q2[Et](..._r)}var sO=()=>{},aO=()=>Date.now();function lO(Et,_r){return ky(ew(Et>>>0,_r>>>0))}var cP,uO=()=>{throw wv+=1,"unwind"};function cO(){return 4294901760}cP=()=>performance.timeOrigin+performance.now();var dO=()=>navigator.hardwareConcurrency;function pO(){return mx("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function fO(Et){Et>>>=0;var _r=it().length;if(Et<=_r||4294901760<Et)return!1;for(var Qr=1;4>=Qr;Qr*=2){var Tn=_r*(1+.2/Qr);Tn=Math.min(Tn,Et+100663296);var Ao=Math;Tn=Math.max(Et,Tn);e:{Ao=(Ao.min.call(Ao,4294901760,Tn+(65536-Tn%65536)%65536)-Uy.buffer.byteLength+65535)/65536;try{Uy.grow(Ao),vw();var nu=1;break e}catch{}nu=void 0}if(nu)return!0}return!1}var x2=()=>(mx("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),hE={},dP=Et=>{Et.forEach(_r=>{x2()})};function hO(){var Et=Error().stack.toString().split(`
`);return Et[0]=="Error"&&Et.shift(),dP(Et),hE.Ob=x2(),hE.bc=Et,hE.Ob}function _O(Et,_r,Qr){if(Et>>>=0,_r>>>=0,hE.Ob==Et)var Tn=hE.bc;else(Tn=Error().stack.toString().split(`
`))[0]=="Error"&&Tn.shift(),dP(Tn);for(var Ao=3;Tn[Ao]&&x2()!=Et;)++Ao;for(Et=0;Et<Qr&&Tn[Et+Ao];++Et)pt()[_r+4*Et>>>2>>>0]=x2();return Et}var c$,d$={},pP=()=>{if(!c$){var Et,_r={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:gu};for(Et in d$)d$[Et]===void 0?delete _r[Et]:_r[Et]=d$[Et];var Qr=[];for(Et in _r)Qr.push(`${Et}=${_r[Et]}`);c$=Qr}return c$};function fP(Et,_r){if(vn)return $0(18,1,Et,_r);Et>>>=0,_r>>>=0;var Qr=0;return pP().forEach((Tn,Ao)=>{var nu=_r+Qr;for(Ao=ft()[Et+4*Ao>>>2>>>0]=nu,nu=0;nu<Tn.length;++nu)_e()[Ao++>>>0]=Tn.charCodeAt(nu);_e()[Ao>>>0]=0,Qr+=Tn.length+1}),0}function hP(Et,_r){if(vn)return $0(19,1,Et,_r);Et>>>=0,_r>>>=0;var Qr=pP();ft()[Et>>>2>>>0]=Qr.length;var Tn=0;return Qr.forEach(Ao=>Tn+=Ao.length+1),ft()[_r>>>2>>>0]=Tn,0}function _P(Et){return vn?$0(20,1,Et):52}function mP(Et,_r,Qr,Tn){return vn?$0(21,1,Et,_r,Qr,Tn):52}function gP(Et,_r,Qr,Tn){return vn?$0(22,1,Et,_r,Qr,Tn):70}var mO=[null,[],[]];function yP(Et,_r,Qr,Tn){if(vn)return $0(23,1,Et,_r,Qr,Tn);_r>>>=0,Qr>>>=0,Tn>>>=0;for(var Ao=0,nu=0;nu<Qr;nu++){var f_=ft()[_r>>>2>>>0],M_=ft()[_r+4>>>2>>>0];_r+=8;for(var Y_=0;Y_<M_;Y_++){var Im=it()[f_+Y_>>>0],cy=mO[Et];Im===0||Im===10?((Et===1?Ly:ky)(IM(cy,0)),cy.length=0):cy.push(Im)}Ao+=M_}return ft()[Tn>>>2>>>0]=Ao,0}var bP=[31,29,31,30,31,30,31,31,30,31,30,31],wP=[31,28,31,30,31,30,31,31,30,31,30,31],gO=(Et,_r)=>{_e().set(Et,_r>>>0)};function vP(Et,_r,Qr,Tn){function Ao(s_,qy,O0){for(s_=typeof s_=="number"?s_.toString():s_||"";s_.length<qy;)s_=O0[0]+s_;return s_}function nu(s_,qy){return Ao(s_,qy,"0")}function f_(s_,qy){function O0(FP){return 0>FP?-1:0<FP?1:0}var xv;return(xv=O0(s_.getFullYear()-qy.getFullYear()))===0&&(xv=O0(s_.getMonth()-qy.getMonth()))===0&&(xv=O0(s_.getDate()-qy.getDate())),xv}function M_(s_){switch(s_.getDay()){case 0:return new Date(s_.getFullYear()-1,11,29);case 1:return s_;case 2:return new Date(s_.getFullYear(),0,3);case 3:return new Date(s_.getFullYear(),0,2);case 4:return new Date(s_.getFullYear(),0,1);case 5:return new Date(s_.getFullYear()-1,11,31);case 6:return new Date(s_.getFullYear()-1,11,30)}}function Y_(s_){var qy=s_.Bb;for(s_=new Date(new Date(s_.Cb+1900,0,1).getTime());0<qy;){var O0=s_.getMonth(),xv=(yx(s_.getFullYear())?bP:wP)[O0];if(!(qy>xv-s_.getDate())){s_.setDate(s_.getDate()+qy);break}qy-=xv-s_.getDate()+1,s_.setDate(1),11>O0?s_.setMonth(O0+1):(s_.setMonth(0),s_.setFullYear(s_.getFullYear()+1))}return O0=new Date(s_.getFullYear()+1,0,4),qy=M_(new Date(s_.getFullYear(),0,4)),O0=M_(O0),0>=f_(qy,s_)?0>=f_(O0,s_)?s_.getFullYear()+1:s_.getFullYear():s_.getFullYear()-1}Et>>>=0,_r>>>=0,Qr>>>=0,Tn>>>=0;var Im=ft()[Tn+40>>>2>>>0];for(var cy in Tn={hc:pt()[Tn>>>2>>>0],fc:pt()[Tn+4>>>2>>>0],Gb:pt()[Tn+8>>>2>>>0],Kb:pt()[Tn+12>>>2>>>0],Hb:pt()[Tn+16>>>2>>>0],Cb:pt()[Tn+20>>>2>>>0],ub:pt()[Tn+24>>>2>>>0],Bb:pt()[Tn+28>>>2>>>0],oc:pt()[Tn+32>>>2>>>0],ec:pt()[Tn+36>>>2>>>0],ic:Im?ew(Im):""},Qr=ew(Qr),Im={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Qr=Qr.replace(new RegExp(cy,"g"),Im[cy]);var Xy="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),u0="January February March April May June July August September October November December".split(" ");for(cy in Im={"%a":s_=>Xy[s_.ub].substring(0,3),"%A":s_=>Xy[s_.ub],"%b":s_=>u0[s_.Hb].substring(0,3),"%B":s_=>u0[s_.Hb],"%C":s_=>nu((s_.Cb+1900)/100|0,2),"%d":s_=>nu(s_.Kb,2),"%e":s_=>Ao(s_.Kb,2," "),"%g":s_=>Y_(s_).toString().substring(2),"%G":Y_,"%H":s_=>nu(s_.Gb,2),"%I":s_=>((s_=s_.Gb)==0?s_=12:12<s_&&(s_-=12),nu(s_,2)),"%j":s_=>{for(var qy=0,O0=0;O0<=s_.Hb-1;qy+=(yx(s_.Cb+1900)?bP:wP)[O0++]);return nu(s_.Kb+qy,3)},"%m":s_=>nu(s_.Hb+1,2),"%M":s_=>nu(s_.fc,2),"%n":()=>`
`,"%p":s_=>0<=s_.Gb&&12>s_.Gb?"AM":"PM","%S":s_=>nu(s_.hc,2),"%t":()=>"	","%u":s_=>s_.ub||7,"%U":s_=>nu(Math.floor((s_.Bb+7-s_.ub)/7),2),"%V":s_=>{var qy=Math.floor((s_.Bb+7-(s_.ub+6)%7)/7);if(2>=(s_.ub+371-s_.Bb-2)%7&&qy++,qy)qy==53&&((O0=(s_.ub+371-s_.Bb)%7)==4||O0==3&&yx(s_.Cb)||(qy=1));else{qy=52;var O0=(s_.ub+7-s_.Bb-1)%7;(O0==4||O0==5&&yx(s_.Cb%400-1))&&qy++}return nu(qy,2)},"%w":s_=>s_.ub,"%W":s_=>nu(Math.floor((s_.Bb+7-(s_.ub+6)%7)/7),2),"%y":s_=>(s_.Cb+1900).toString().substring(2),"%Y":s_=>s_.Cb+1900,"%z":s_=>{var qy=0<=(s_=s_.ec);return s_=Math.abs(s_)/60,(qy?"+":"-")+("0000"+(s_/60*100+s_%60)).slice(-4)},"%Z":s_=>s_.ic,"%%":()=>"%"},Qr=Qr.replace(/%%/g,"\0\0"),Im)Qr.includes(cy)&&(Qr=Qr.replace(new RegExp(cy,"g"),Im[cy](Tn)));return cy=function(s_){var qy=Array(J2(s_)+1);return RM(s_,qy,0,qy.length),qy}(Qr=Qr.replace(/\0\0/g,"%")),cy.length>_r?0:(gO(cy,Et),cy.length-1)}function yO(Et,_r,Qr,Tn){return vP(Et>>>0,_r>>>0,Qr>>>0,Tn>>>0)}vn||function(){for(var Et=It.numThreads-1;Et--;)SM();hw.unshift(()=>{K1++,function(_r){vn?_r():Promise.all(G1.map(kM)).then(_r)}(()=>gM())})}();for(var xP=Array(256),T2=0;256>T2;++T2)xP[T2]=String.fromCharCode(T2);qM=xP,H1=It.BindingError=class extends Error{constructor(Et){super(Et),this.name="BindingError"}},It.InternalError=class extends Error{constructor(Et){super(Et),this.name="InternalError"}},$1.push(0,1,void 0,1,null,1,!0,1,!1,1),It.count_emval_handles=()=>$1.length/2-5-r$.length;var bO=[Q2,EM,OM,DM,FM,LM,BM,jM,zM,NM,UM,WM,VM,KM,GM,HM,aP,lP,fP,hP,_P,mP,gP,yP],uy=function(){function Et(Qr,Tn){return uy=Qr.exports,uy=function(){var Ao=uy,nu={};for(let[f_,M_]of Object.entries(Ao))nu[f_]=typeof M_=="function"?(...Y_)=>{b2.push(f_);try{return M_(...Y_)}finally{Aw||(b2.pop(),f1&&X1===1&&b2.length===0&&(X1=0,wv+=1,y2(AP),typeof Fibers<"u"&&Fibers.pc()))}}:M_;return nu}(),uy=function(){var Ao=uy,nu=M_=>Y_=>M_(Y_)>>>0,f_=M_=>()=>M_()>>>0;return(Ao=Object.assign({},Ao)).Ca=nu(Ao.Ca),Ao.fb=f_(Ao.fb),Ao.gb=nu(Ao.gb),Ao.emscripten_main_runtime_thread_id=f_(Ao.emscripten_main_runtime_thread_id),Ao.sb=nu(Ao.sb),Ao.tb=f_(Ao.tb),Ao}(),$M.push(uy.ib),lw.unshift(uy.Ba),dy=Tn,gM(),uy}var _r=xM();if(K1++,It.instantiateWasm)try{return It.instantiateWasm(_r,Et)}catch(Qr){ky(`Module.instantiateWasm callback failed with error: ${Qr}`),Yr(Qr)}return H2||=It.locateFile?yM("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":It.locateFile?It.locateFile("ort-wasm-simd-threaded.jsep.wasm",c_):c_+"ort-wasm-simd-threaded.jsep.wasm":new URL(i("./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm"),i.b).href,function(Qr,Tn){var Ao=H2;return R_||typeof WebAssembly.instantiateStreaming!="function"||yM(Ao)||bM(Ao)||typeof fetch!="function"?vM(Ao,Qr,Tn):fetch(Ao,{credentials:"same-origin"}).then(nu=>WebAssembly.instantiateStreaming(nu,Qr).then(Tn,function(f_){return ky(`wasm streaming compile failed: ${f_}`),ky("falling back to ArrayBuffer instantiation"),vM(Ao,Qr,Tn)}))}(_r,function(Qr){Et(Qr.instance,Qr.module)}).catch(Yr),{}}(),TP=Et=>(TP=uy.Ca)(Et),EP=()=>(EP=uy.Da)();It._OrtInit=(Et,_r)=>(It._OrtInit=uy.Ea)(Et,_r),It._OrtGetLastError=(Et,_r)=>(It._OrtGetLastError=uy.Fa)(Et,_r),It._OrtCreateSessionOptions=(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im)=>(It._OrtCreateSessionOptions=uy.Ga)(Et,_r,Qr,Tn,Ao,nu,f_,M_,Y_,Im),It._OrtAppendExecutionProvider=(Et,_r)=>(It._OrtAppendExecutionProvider=uy.Ha)(Et,_r),It._OrtAddFreeDimensionOverride=(Et,_r,Qr)=>(It._OrtAddFreeDimensionOverride=uy.Ia)(Et,_r,Qr),It._OrtAddSessionConfigEntry=(Et,_r,Qr)=>(It._OrtAddSessionConfigEntry=uy.Ja)(Et,_r,Qr),It._OrtReleaseSessionOptions=Et=>(It._OrtReleaseSessionOptions=uy.Ka)(Et),It._OrtCreateSession=(Et,_r,Qr)=>(It._OrtCreateSession=uy.La)(Et,_r,Qr),It._OrtReleaseSession=Et=>(It._OrtReleaseSession=uy.Ma)(Et),It._OrtGetInputOutputCount=(Et,_r,Qr)=>(It._OrtGetInputOutputCount=uy.Na)(Et,_r,Qr),It._OrtGetInputName=(Et,_r)=>(It._OrtGetInputName=uy.Oa)(Et,_r),It._OrtGetOutputName=(Et,_r)=>(It._OrtGetOutputName=uy.Pa)(Et,_r),It._OrtFree=Et=>(It._OrtFree=uy.Qa)(Et),It._OrtCreateTensor=(Et,_r,Qr,Tn,Ao,nu)=>(It._OrtCreateTensor=uy.Ra)(Et,_r,Qr,Tn,Ao,nu),It._OrtGetTensorData=(Et,_r,Qr,Tn,Ao)=>(It._OrtGetTensorData=uy.Sa)(Et,_r,Qr,Tn,Ao),It._OrtReleaseTensor=Et=>(It._OrtReleaseTensor=uy.Ta)(Et),It._OrtCreateRunOptions=(Et,_r,Qr,Tn)=>(It._OrtCreateRunOptions=uy.Ua)(Et,_r,Qr,Tn),It._OrtAddRunConfigEntry=(Et,_r,Qr)=>(It._OrtAddRunConfigEntry=uy.Va)(Et,_r,Qr),It._OrtReleaseRunOptions=Et=>(It._OrtReleaseRunOptions=uy.Wa)(Et),It._OrtCreateBinding=Et=>(It._OrtCreateBinding=uy.Xa)(Et),It._OrtBindInput=(Et,_r,Qr)=>(It._OrtBindInput=uy.Ya)(Et,_r,Qr),It._OrtBindOutput=(Et,_r,Qr,Tn)=>(It._OrtBindOutput=uy.Za)(Et,_r,Qr,Tn),It._OrtClearBoundOutputs=Et=>(It._OrtClearBoundOutputs=uy._a)(Et),It._OrtReleaseBinding=Et=>(It._OrtReleaseBinding=uy.$a)(Et),It._OrtRunWithBinding=(Et,_r,Qr,Tn,Ao)=>(It._OrtRunWithBinding=uy.ab)(Et,_r,Qr,Tn,Ao),It._OrtRun=(Et,_r,Qr,Tn,Ao,nu,f_,M_)=>(It._OrtRun=uy.bb)(Et,_r,Qr,Tn,Ao,nu,f_,M_),It._OrtEndProfiling=Et=>(It._OrtEndProfiling=uy.cb)(Et),It._JsepOutput=(Et,_r,Qr)=>(It._JsepOutput=uy.db)(Et,_r,Qr),It._JsepGetNodeName=Et=>(It._JsepGetNodeName=uy.eb)(Et);var E2,bx=()=>(bx=uy.fb)(),$2=It._malloc=Et=>($2=It._malloc=uy.gb)(Et),h1=It._free=Et=>(h1=It._free=uy.hb)(Et),p$=(Et,_r,Qr,Tn,Ao,nu)=>(p$=uy.kb)(Et,_r,Qr,Tn,Ao,nu),$P=()=>($P=uy.lb)(),MP=(Et,_r,Qr,Tn,Ao)=>(MP=uy.mb)(Et,_r,Qr,Tn,Ao),f$=Et=>(f$=uy.nb)(Et),M2=Et=>(M2=uy.ob)(Et),PP=()=>(PP=uy.pb)(),kP=(Et,_r)=>(kP=uy.qb)(Et,_r),P2=Et=>(P2=uy.rb)(Et),h$=Et=>(h$=uy.sb)(Et),_$=()=>(_$=uy.tb)(),SP=It.dynCall_ii=(Et,_r)=>(SP=It.dynCall_ii=uy.vb)(Et,_r),OP=Et=>(OP=uy.wb)(Et),AP=()=>(AP=uy.xb)(),CP=Et=>(CP=uy.yb)(Et),IP=()=>(IP=uy.zb)();function DP(){0<K1||(vn?(er(It),vn||m2(lw),startWorker(It)):(m2(hw),0<K1||E2||(E2=!0,It.calledRun=!0,Aw||(vn||m2(lw),er(It),vn||m2(V1)))))}return It.___start_em_js=873286,It.___stop_em_js=873508,It.stackSave=()=>_$(),It.stackRestore=Et=>P2(Et),It.stackAlloc=Et=>h$(Et),It.UTF8ToString=ew,It.stringToUTF8=gx,It.lengthBytesUTF8=J2,bv=function Et(){E2||DP(),E2||(bv=Et)},DP(),en}),_d=Xs,globalThis.self?.name==="em-pthread"&&Xs()}),mu,y_,k_,S_,B_,P_,N_,q_,H_=$(()=>{Z_(),mu=import.meta.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),y_=typeof location>"u"?void 0:location.origin,k_=(_,_e)=>{try{let it=_e??mu;return(it?new URL(_,it):new URL(_)).origin===y_}catch{return!1}},S_=async _=>{let _e=await(await fetch(_,{credentials:"same-origin"})).blob();return URL.createObjectURL(_e)},B_=(fy(),g(Ty)).default,P_=async()=>{if(!mu)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(k_(mu))return[void 0,B_()];let _=await S_(mu);return[_,B_(_)]},N_=(w_(),g(g_)).default,q_=async(_,_e,it)=>[void 0,N_]}),j_,pu,T_,E_,iy,Ry,Zy,hy,Ay=$(()=>{H_(),pu=!1,T_=!1,E_=!1,iy=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Ry=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Zy=async _=>{if(pu)return Promise.resolve();if(T_)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(E_)throw new Error("previous call to 'initializeWebAssembly()' failed.");T_=!0;let _e=_.initTimeout,it=_.numThreads;if(!Ry())throw new Error("WebAssembly SIMD is not supported in the current environment.");let ut=iy();it>1&&!ut&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+it+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),_.numThreads=it=1);let ct=_.wasmPaths,pt=typeof ct=="string"?ct:void 0,ft=ct?.mjs,Bt=ft?.href??ft,Gt=ct?.wasm,er=Gt?.href??Gt,Yr=_.wasmBinary,[It,en]=await q_(Bt,pt,it>1),wn=!1,_o=[];if(_e>0&&_o.push(new Promise(vn=>{setTimeout(()=>{wn=!0,vn()},_e)})),_o.push(new Promise((vn,Ws)=>{let Jo={numThreads:it};Yr?Jo.wasmBinary=Yr:(er||pt)&&(Jo.locateFile=(So,xa)=>er??(pt??xa)+So),en(Jo).then(So=>{T_=!1,pu=!0,j_=So,vn(),It&&URL.revokeObjectURL(It)},So=>{T_=!1,E_=!0,Ws(So)})})),await Promise.race(_o),wn)throw new Error(`WebAssembly backend initializing failed due to timeout: ${_e}ms`)},hy=()=>{if(pu&&j_)return j_;throw new Error("WebAssembly is not initialized yet.")}}),Sy,K0,n0,A0=$(()=>{Ay(),Sy=(_,_e)=>{let it=hy(),ut=it.lengthBytesUTF8(_)+1,ct=it._malloc(ut);return it.stringToUTF8(_,ct,ut),_e.push(ct),ct},K0=(_,_e,it,ut)=>{if(typeof _=="object"&&_!==null){if(it.has(_))throw new Error("Circular reference in options");it.add(_)}Object.entries(_).forEach(([ct,pt])=>{let ft=_e?_e+ct:ct;if(typeof pt=="object")K0(pt,ft+".",it,ut);else if(typeof pt=="string"||typeof pt=="number")ut(ft,pt.toString());else if(typeof pt=="boolean")ut(ft,pt?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof pt}`)})},n0=_=>{let _e=hy(),it=_e.stackSave();try{let ut=_e.stackAlloc(8);_e._OrtGetLastError(ut,ut+4);let ct=_e.HEAP32[ut/4],pt=_e.HEAPU32[ut/4+1],ft=pt?_e.UTF8ToString(pt):"";throw new Error(`${_} ERROR_CODE: ${ct}, ERROR_MESSAGE: ${ft}`)}finally{_e.stackRestore(it)}}}),G0,N0=$(()=>{Ay(),A0(),G0=_=>{let _e=hy(),it=0,ut=[],ct=_||{};try{if(_?.logSeverityLevel===void 0)ct.logSeverityLevel=2;else if(typeof _.logSeverityLevel!="number"||!Number.isInteger(_.logSeverityLevel)||_.logSeverityLevel<0||_.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${_.logSeverityLevel}`);if(_?.logVerbosityLevel===void 0)ct.logVerbosityLevel=0;else if(typeof _.logVerbosityLevel!="number"||!Number.isInteger(_.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${_.logVerbosityLevel}`);_?.terminate===void 0&&(ct.terminate=!1);let pt=0;return _?.tag!==void 0&&(pt=Sy(_.tag,ut)),it=_e._OrtCreateRunOptions(ct.logSeverityLevel,ct.logVerbosityLevel,!!ct.terminate,pt),it===0&&n0("Can't create run options."),_?.extra!==void 0&&K0(_.extra,"",new WeakSet,(ft,Bt)=>{let Gt=Sy(ft,ut),er=Sy(Bt,ut);_e._OrtAddRunConfigEntry(it,Gt,er)!==0&&n0(`Can't set a run config entry: ${ft} - ${Bt}.`)}),[it,ut]}catch(pt){throw it!==0&&_e._OrtReleaseRunOptions(it),ut.forEach(ft=>_e._free(ft)),pt}}}),xw,uw,i0,q0,M0,Cw=$(()=>{Ay(),A0(),xw=_=>{switch(_){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${_}`)}},uw=_=>{switch(_){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${_}`)}},i0=_=>{_.extra||(_.extra={}),_.extra.session||(_.extra.session={});let _e=_.extra.session;_e.use_ort_model_bytes_directly||(_e.use_ort_model_bytes_directly="1"),_.executionProviders&&_.executionProviders.some(it=>(typeof it=="string"?it:it.name)==="webgpu")&&(_.enableMemPattern=!1)},q0=(_,_e,it)=>{for(let ut of _e){let ct=typeof ut=="string"?ut:ut.name;switch(ct){case"webnn":if(ct="WEBNN",typeof ut!="string"){let ft=ut?.deviceType;if(ft){let Bt=Sy("deviceType",it),Gt=Sy(ft,it);hy()._OrtAddSessionConfigEntry(_,Bt,Gt)!==0&&n0(`Can't set a session config entry: 'deviceType' - ${ft}.`)}}break;case"webgpu":if(ct="JS",typeof ut!="string"){let ft=ut;if(ft?.preferredLayout){if(ft.preferredLayout!=="NCHW"&&ft.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${ft.preferredLayout}`);let Bt=Sy("preferredLayout",it),Gt=Sy(ft.preferredLayout,it);hy()._OrtAddSessionConfigEntry(_,Bt,Gt)!==0&&n0(`Can't set a session config entry: 'preferredLayout' - ${ft.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${ct}`)}let pt=Sy(ct,it);hy()._OrtAppendExecutionProvider(_,pt)!==0&&n0(`Can't append execution provider: ${ct}.`)}},M0=_=>{let _e=hy(),it=0,ut=[],ct=_||{};i0(ct);try{let pt=xw(ct.graphOptimizationLevel??"all"),ft=uw(ct.executionMode??"sequential"),Bt=typeof ct.logId=="string"?Sy(ct.logId,ut):0,Gt=ct.logSeverityLevel??2;if(!Number.isInteger(Gt)||Gt<0||Gt>4)throw new Error(`log serverity level is not valid: ${Gt}`);let er=ct.logVerbosityLevel??0;if(!Number.isInteger(er)||er<0||er>4)throw new Error(`log verbosity level is not valid: ${er}`);let Yr=typeof ct.optimizedModelFilePath=="string"?Sy(ct.optimizedModelFilePath,ut):0;if(it=_e._OrtCreateSessionOptions(pt,!!ct.enableCpuMemArena,!!ct.enableMemPattern,ft,!!ct.enableProfiling,0,Bt,Gt,er,Yr),it===0&&n0("Can't create session options."),ct.executionProviders&&q0(it,ct.executionProviders,ut),ct.enableGraphCapture!==void 0){if(typeof ct.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${ct.enableGraphCapture}`);let It=Sy("enableGraphCapture",ut),en=Sy(ct.enableGraphCapture.toString(),ut);_e._OrtAddSessionConfigEntry(it,It,en)!==0&&n0(`Can't set a session config entry: 'enableGraphCapture' - ${ct.enableGraphCapture}.`)}if(ct.freeDimensionOverrides)for(let[It,en]of Object.entries(ct.freeDimensionOverrides)){if(typeof It!="string")throw new Error(`free dimension override name must be a string: ${It}`);if(typeof en!="number"||!Number.isInteger(en)||en<0)throw new Error(`free dimension override value must be a non-negative integer: ${en}`);let wn=Sy(It,ut);_e._OrtAddFreeDimensionOverride(it,wn,en)!==0&&n0(`Can't set a free dimension override: ${It} - ${en}.`)}return ct.extra!==void 0&&K0(ct.extra,"",new WeakSet,(It,en)=>{let wn=Sy(It,ut),_o=Sy(en,ut);_e._OrtAddSessionConfigEntry(it,wn,_o)!==0&&n0(`Can't set a session config entry: ${It} - ${en}.`)}),[it,ut]}catch(pt){throw it!==0&&_e._OrtReleaseSessionOptions(it),ut.forEach(ft=>_e._free(ft)),pt}}}),P0,F0,X0,Y0,U0,_w,tw,ly=$(()=>{P0=_=>{switch(_){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${_}`)}},F0=_=>{switch(_){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${_}`)}},X0=(_,_e)=>{let it=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][_],ut=typeof _e=="number"?_e:_e.reduce((ct,pt)=>ct*pt,1);return it>0?Math.ceil(ut*it):void 0},Y0=_=>{switch(_){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${_}`)}},U0=_=>{switch(_){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${_}`)}},_w=_=>_==="float32"||_==="float16"||_==="int32"||_==="int64"||_==="uint32"||_==="uint8"||_==="bool"||_==="uint4"||_==="int4",tw=_=>{switch(_){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${_}`)}}}),by,Tw=$(()=>{Z_(),by=async _=>{if(typeof _=="string"){let _e=await fetch(_);if(!_e.ok)throw new Error(`failed to load external data file: ${_}`);let it=_e.headers.get("Content-Length"),ut=it?parseInt(it,10):0;if(ut<1073741824)return new Uint8Array(await _e.arrayBuffer());{if(!_e.body)throw new Error(`failed to load external data file: ${_}, no response body.`);let ct=_e.body.getReader(),pt;try{pt=new ArrayBuffer(ut)}catch(Bt){if(Bt instanceof RangeError){let Gt=Math.ceil(ut/65536);pt=new WebAssembly.Memory({initial:Gt,maximum:Gt}).buffer}else throw Bt}let ft=0;for(;;){let{done:Bt,value:Gt}=await ct.read();if(Bt)break;let er=Gt.byteLength;new Uint8Array(pt,ft,er).set(Gt),ft+=er}return new Uint8Array(pt,0,ut)}}else return _ instanceof Blob?new Uint8Array(await _.arrayBuffer()):_ instanceof Uint8Array?_:new Uint8Array(_)}}),Ew,yw,Yy,rw,nw,ow,Jy,R0=$(()=>{ly(),Ew=["V","I","W","E","F"],yw=(_,_e)=>{console.log(`[${Ew[_]},${new Date().toISOString()}]${_e}`)},nw=(_,_e)=>{Yy=_,rw=_e},ow=(_,_e)=>{let it=U0(_),ut=U0(Yy);it>=ut&&yw(it,typeof _e=="function"?_e():_e)},Jy=(..._)=>{rw&&ow(..._)}}),xu,wr=$(()=>{ly(),xu=(_,_e)=>new(Y0(_e))(_)}),Po=$(()=>{}),Zs,ba,Iu,a_,D_,b_,z_,C_,Cy,ay=$(()=>{R0(),Po(),Zs=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),ba=[],Iu=_=>Math.ceil(_/16)*16,a_=_=>{for(let _e=0;_e<ba.length;_e++){let it=ba[_e];if(_<=it)return it}return Math.ceil(_/16)*16},D_=1,b_=()=>D_++,z_=async(_,_e,it,ut)=>{let ct=Iu(it),pt=_.device.createBuffer({size:ct,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let ft=_.getCommandEncoder();_.endComputePass(),ft.copyBufferToBuffer(_e,0,pt,0,ct),_.flush(),await pt.mapAsync(GPUMapMode.READ);let Bt=pt.getMappedRange();if(ut){let Gt=ut();return Gt.set(new Uint8Array(Bt,0,it)),Gt}else return new Uint8Array(Bt.slice(0,it))}finally{pt.destroy()}},C_=class{constructor(_){this.backend=_,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[_e]of Zs)ba.push(_e),this.freeBuffers.set(_e,[]),this.freeUniformBuffers.set(_e,[])}upload(_,_e){let it=_e.buffer,ut=_e.byteOffset,ct=_e.byteLength,pt=Iu(ct),ft=this.storageCache.get(_);if(!ft)throw new Error("gpu data for uploading does not exist");if(ft.originalSize!==ct)throw new Error(`inconsistent data size. gpu data size=${ft.originalSize}, data size=${ct}`);let Bt=this.backend.device.createBuffer({mappedAtCreation:!0,size:pt,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),Gt=Bt.getMappedRange();new Uint8Array(Gt).set(new Uint8Array(it,ut,ct)),Bt.unmap();let er=this.backend.getCommandEncoder();this.backend.endComputePass(),er.copyBufferToBuffer(Bt,0,ft.gpuData.buffer,0,pt),Jy("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${_})`),this.buffersForUploadingPending.push(Bt)}memcpy(_,_e){let it=this.storageCache.get(_);if(!it)throw new Error("source gpu data for memcpy does not exist");let ut=this.storageCache.get(_e);if(!ut)throw new Error("destination gpu data for memcpy does not exist");if(it.originalSize!==ut.originalSize)throw new Error("inconsistent source and destination gpu data size");let ct=Iu(it.originalSize),pt=this.backend.getCommandEncoder();this.backend.endComputePass(),pt.copyBufferToBuffer(it.gpuData.buffer,0,ut.gpuData.buffer,0,ct)}registerExternalBuffer(_,_e,it){let ut;if(it){if(ut=this.externalBuffers.get(it),ut===void 0)throw new Error("previous buffer is not registered");if(_===it)return Jy("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${_e}) => id=${ut}, buffer is the same, skip.`),ut;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);this.externalBuffers.delete(it)}else ut=b_();return this.storageCache.set(ut,{gpuData:{id:ut,type:0,buffer:_},originalSize:_e}),this.externalBuffers.set(_,ut),Jy("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${_e}) => id=${ut}, registered.`),ut}unregisterExternalBuffer(_){let _e=this.externalBuffers.get(_);_e!==void 0&&(this.storageCache.delete(_e),this.externalBuffers.delete(_),Jy("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${_e}`))}create(_,_e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let it=a_(_),ut,ct=(_e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,pt=(_e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(ct||pt){let Bt=(ct?this.freeBuffers:this.freeUniformBuffers).get(it);Bt?Bt.length>0?ut=Bt.pop():ut=this.backend.device.createBuffer({size:it,usage:_e}):ut=this.backend.device.createBuffer({size:it,usage:_e})}else ut=this.backend.device.createBuffer({size:it,usage:_e});let ft={id:b_(),type:0,buffer:ut};return this.storageCache.set(ft.id,{gpuData:ft,originalSize:_}),Jy("verbose",()=>`[WebGPU] GpuDataManager.create(size=${_}) => id=${ft.id}`),ft}get(_){return this.storageCache.get(_)?.gpuData}release(_){let _e=this.storageCache.get(_);if(!_e)throw new Error("releasing data does not exist");return Jy("verbose",()=>`[WebGPU] GpuDataManager.release(id=${_}), gpuDataId=${_e.gpuData.id}`),this.storageCache.delete(_),this.buffersPending.push(_e.gpuData.buffer),_e.originalSize}async download(_,_e){let it=this.storageCache.get(_);if(!it)throw new Error("data does not exist");await z_(this.backend,it.gpuData.buffer,it.originalSize,_e)}refreshPendingBuffers(){for(let _ of this.buffersForUploadingPending)_.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let _ of this.buffersPending){let _e=Zs.get(_.size);if((_.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let it=this.freeBuffers.get(_.size)||[];_e===void 0||it.length>=_e?_.destroy():it.push(_)}else if((_.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let it=this.freeUniformBuffers.get(_.size)||[];_e===void 0||it.length>=_e?_.destroy():it.push(_)}else _.destroy()}this.buffersPending=[]}else{let _=this.capturedPendingBuffers.get(this.backend.currentSessionId);_||(_=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,_));for(let _e of this.buffersPending)_.push(_e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(_=>{_.forEach(_e=>{_e.destroy()})}),this.freeUniformBuffers.forEach(_=>{_.forEach(_e=>{_e.destroy()})}),this.storageCache.forEach(_=>{_.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(_=>{_.forEach(_e=>{_e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(_){let _e=this.capturedPendingBuffers.get(_);_e&&(_e.forEach(it=>{it.destroy()}),this.capturedPendingBuffers.delete(_))}},Cy=(..._)=>new C_(..._)}),wy,sy,Ey=$(()=>{wy=class{constructor(_){Object.assign(this,_)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(_=>`${this[_]}`).join(";")),this.key}},sy=_=>new wy(_)}),L0,h0,Uu,g0,Iy,_0,ry,J_=$(()=>{L0=class{static calcMatMulShape(_,_e){return _[1]!==_e[0]?void 0:[_[0],_e[1]]}},h0=class{static calcShape(_,_e,it=!1){let ut=_.length,ct=_e.length;if(ut===0)return _e;if(ct===0)return _;let pt=Math.max(_.length,_e.length),ft=new Array(pt);if(it){if(ut<2||ct<2)return;let Bt=L0.calcMatMulShape([_[ut-2],_[ut-1]],[_e[ct-2],_e[ct-1]]);if(Bt===void 0)return;[ft[pt-2],ft[pt-1]]=Bt}for(let Bt=it?3:1;Bt<=pt;Bt++){let Gt=ut-Bt<0?1:_[ut-Bt],er=ct-Bt<0?1:_e[ct-Bt];if(Gt!==er&&Gt>1&&er>1)return;let Yr=Math.max(Gt,er);if(Gt&&er)ft[pt-Bt]=Math.max(Gt,er);else{if(Yr>1)return;ft[pt-Bt]=0}}return ft}static isValidBroadcast(_,_e){let it=_.length,ut=_e.length;if(it>ut)return!1;for(let ct=1;ct<=it;ct++)if(_[it-ct]!==1&&_[it-ct]!==_e[ut-ct])return!1;return!0}},Uu=class k2{static size(_e){return k2.getSizeFromDimensionRange(_e,0,_e.length)}static convertShape(_e,it=4){let ut=_e.length;if(ut===0)return[];let ct=new Array(ut),pt=ut-1;for(;pt>=0;){if(_e[pt]%it===0){ct[pt]=_e[pt]/it;break}if(it%_e[pt]!==0)throw new Error("cannot convert shape");ct[pt]=1,it/=_e[pt],pt--}for(pt--;pt>=0;pt--)ct[pt]=_e[pt];return ct}static sizeFromDimension(_e,it){if(it<0||it>_e.length)throw new Error(`invalid dimension of ${it} for sizeFromDimension as Tensor has ${_e.length} dimensions.`);return k2.getSizeFromDimensionRange(_e,it,_e.length)}static sizeToDimension(_e,it){if(it<0||it>_e.length)throw new Error(`invalid dimension of ${it} for sizeToDimension as Tensor has ${_e.length} dimensions.`);return k2.getSizeFromDimensionRange(_e,0,it)}static getSizeFromDimensionRange(_e,it,ut){let ct=1;for(let pt=it;pt<ut;pt++){if(_e[pt]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");ct*=_e[pt]}return ct}static computeStrides(_e){let it=_e.length;if(it===0)return[];if(it===1)return[1];let ut=new Array(it);ut[it-1]=1,ut[it-2]=_e[it-1];for(let ct=it-3;ct>=0;--ct)ut[ct]=ut[ct+1]*_e[ct+1];return ut}static normalizeAxis(_e,it){if(_e<-it&&_e>=it)throw new Error("unsupported axis for this operation.");return _e<0?_e+it:_e}static normalizeAxes(_e,it){return _e.map(ut=>this.normalizeAxis(ut,it??_e.length))}static sortBasedOnPerm(_e,it){return it?it.map(ut=>_e[ut]):_e.slice().reverse()}static padShape(_e,it){let ut=_e.length;return _e.map((ct,pt)=>ct+it[pt]+it[pt+ut])}static areEqual(_e,it){return _e.length!==it.length?!1:_e.every((ut,ct)=>ut===it[ct])}},g0=class _E{static adjustPoolAttributes(_e,it,ut,ct,pt,ft){if(!_e&&ut.length!==it.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(_e)for(let Bt=0;Bt<it.length-2;Bt++)Bt>=ut.length?ut.push(it[Bt+2]):ut[Bt]=it[Bt+2];for(let Bt=0;Bt<ut.length;Bt++)if(Bt<ct.length){if(ct[Bt]<0)throw new Error("strides should be greater than or equal to 1")}else ct.push(1);for(let Bt=0;Bt<ut.length;Bt++)if(Bt<pt.length){if(pt[Bt]<0)throw new Error("dilations should be greater than or equal to 1")}else pt.push(1);for(let Bt=0;Bt<ut.length*2;Bt++)if(Bt<ft.length){if(ft[Bt]<0)throw new Error("pad should be greater than or equal to 1")}else ft.push(0);for(let Bt=0;Bt<ut.length;Bt++){if(ut[Bt]<=0)throw new Error("kernel shapes need to be greater than 0");if(ft[Bt]>=ut[Bt]||ft[Bt+ut.length]>=ut[Bt])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(_e,it,ut,ct,pt,ft,Bt){if(Bt){if(pt.length!==2*(_e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(it.length!==_e.length-2)throw new Error("length of strides should be the length of data dimensions");if(ct.length!==_e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let Gt=0;Gt<_e.length-2;Gt++)_E.adjustPadAndReturnShape(_e[Gt+(ft?1:2)],it[Gt],ut[Gt],ct[Gt],pt,Gt,Gt+_e.length-2,Bt)}}static computePoolOutputShape(_e,it,ut,ct,pt,ft,Bt){if(it.length<=0)throw new Error("input shape must be of size greater than 0");let Gt=[it[0],it[1]];return _E.computeShapeHelper(_e,it,Gt,ut,ct,pt,ft,Bt),Gt}static computeConvOutputShape(_e,it,ut,ct,pt,ft,Bt){if(_e.length<=0||it.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let Gt=[_e[0],it[0]];return _E.computeShapeHelper(!1,_e,Gt,ut,ct,pt,ft,Bt),Gt}static computeShapeHelper(_e,it,ut,ct,pt,ft,Bt,Gt){if(_e)for(let er=0;er<it.length-2;er++)ut.push(1);else for(let er=0;er<it.length-2;er++)ut.push(_E.adjustPadAndReturnShape(it[er+2],ct[er],pt[er],ft[er],Bt,er,er+it.length-2,Gt))}static adjustPadAndReturnShape(_e,it,ut,ct,pt,ft,Bt,Gt){let er=ut*(ct-1)+1;if(Gt&&Gt!=="NOTSET")switch(Gt){case"VALID":return pt[ft]=0,pt[Bt]=0,Math.floor((_e-er)/it+1);case"SAME_LOWER":case"SAME_UPPER":if(ut!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let Yr=((_e+it-1)/it-1)*it+ct-_e;return pt[ft]=Math.floor(Gt==="SAME_LOWER"?(Yr+1)/2:Yr/2),pt[Bt]=Yr-pt[ft],Math.floor((_e+Yr-ct)/it+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((_e+pt[ft]+pt[Bt]-er)/it+1)}},Iy=class{static getShapeOfGemmResult(_,_e,it,ut,ct){if(_.length!==2||it.length!==2)throw new Error("shape need to be of size 2");let pt,ft,Bt;_e?(pt=_[1],ft=_[0]):(pt=_[0],ft=_[1]);let Gt=-1;if(ut?(Bt=it[0],Gt=1):(Bt=it[1],Gt=0),it[Gt]!==ft)throw new Error("dimension mismatch");if(pt<=0||Bt<=0||ft<=0)throw new Error("invalid shape specified");if(ct&&!h0.isValidBroadcast(ct,[pt,Bt]))throw new Error("gemm: invalid bias shape for broadcast");return[pt,Bt,ft]}},_0=-34028234663852886e22,ry=34028234663852886e22}),k0,e0,jy,zy,U_,_y,Ky,s0,S0,X_,$w,v_,Xr,Xo,ru,Pu,Nu,n_=$(()=>{ly(),J_(),k0=64,e0=(_,_e)=>{if(_e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(_){case 10:return _e>1?`vec${_e}<f16>`:"f16";case 1:return _e>1?`vec${_e}<f32>`:"f32";case 6:return _e>1?`vec${_e}<i32>`:"i32";case 12:return _e>1?`vec${_e}<u32>`:"u32";case 7:if(_e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(_e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(_e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${_}`)}},jy=(_,_e=1)=>{let it=e0(_,_e);return typeof it=="string"?it:it[0]},zy=(_,_e=1)=>{let it=e0(_,_e);return typeof it=="string"?it:it[1]},U_=(..._)=>{let _e=[];return _.forEach(it=>{it.length!==0&&_e.push({type:12,data:it},{type:12,data:Uu.computeStrides(it)})}),_e},_y=_=>_%4===0?4:_%2===0?2:1,Ky=(_="f32",_e,it="0")=>!_e||_e===1?`${_}(${it})`:`vec${_e}<${_}>(${it})`,s0=(_,_e,it)=>_==="f32"?it:_e===1?`f32(${it})`:`vec${_e}<f32>(${it})`,S0=(_,_e)=>_e===4?`(${_}.x + ${_}.y + ${_}.z + ${_}.w)`:_e===2?`(${_}.x + ${_}.y)`:_e===3?`(${_}.x + ${_}.y + ${_}.z)`:_,X_=(_,_e,it,ut)=>_.startsWith("uniforms.")&&it>4?typeof _e=="string"?ut==="f16"?`${_}[(${_e}) / 8][(${_e}) % 8 / 4][(${_e}) % 8 % 4]`:`${_}[(${_e}) / 4][(${_e}) % 4]`:ut==="f16"?`${_}[${Math.floor(_e/8)}][${Math.floor(_e%8/4)}][${_e%8%4}]`:`${_}[${Math.floor(_e/4)}][${_e%4}]`:it>1?`${_}[${_e}]`:_,$w=(_,_e,it,ut,ct)=>{let pt=typeof it=="number",ft=pt?it:it.length,Bt=[...new Array(ft).keys()],Gt=ft<2?"u32":ft<=4?`vec${ft}<u32>`:`array<u32, ${ft}>`,er=e0(_e,ct),Yr=typeof er=="string"?er:er[1],It=typeof er=="string"?er:er[0],en={indices:Gt,value:Yr,storage:It,tensor:_e},wn=x_=>typeof x_=="string"?x_:`${x_}u`,_o={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},vn=pt?"uniforms.":"",Ws=`${vn}${_}_shape`,Jo=`${vn}${_}_strides`,So="";for(let x_=0;x_<ft-1;x_++)So+=`
    let dim${x_} = current / ${X_(Jo,x_,ft)};
    let rest${x_} = current % ${X_(Jo,x_,ft)};
    indices[${x_}] = dim${x_};
    current = rest${x_};
    `;So+=`indices[${ft-1}] = current;`;let xa=ft<2?"":`
  fn o2i_${_}(offset: u32) -> ${en.indices} {
    var indices: ${en.indices};
    var current = offset;
    ${So}
    return indices;
  }`,$a=x_=>(_o.offsetToIndices=!0,ft<2?x_:`o2i_${_}(${x_})`),gu=[];if(ft>=2)for(let x_=ft-1;x_>=0;x_--)gu.push(`${X_(Jo,x_,ft)} * (indices[${x_}])`);let u_=ft<2?"":`
  fn i2o_${_}(indices: ${en.indices}) -> u32 {
    return ${gu.join("+")};
  }`,c_=x_=>(_o.indicesToOffset=!0,ft<2?x_:`i2o_${_}(${x_})`),R_=(...x_)=>ft===0?"0u":`${en.indices}(${x_.map(wn).join(",")})`,ny=(x_,G_)=>ft<2?`${x_}`:`${X_(x_,G_,ft)}`,ty=(x_,G_,By)=>ft<2?`${x_}=${By};`:`${X_(x_,G_,ft)}=${By};`,Ly={},ky=(x_,G_)=>{_o.broadcastedIndicesToOffset=!0;let By=`${G_.name}broadcastedIndicesTo${_}Offset`;if(By in Ly)return`${By}(${x_})`;let b0=[];for(let w0=ft-1;w0>=0;w0--){let Bw=G_.indicesGet("outputIndices",w0+G_.rank-ft);b0.push(`${ny(Jo,w0)} * (${Bw} % ${ny(Ws,w0)})`)}return Ly[By]=`fn ${By}(outputIndices: ${G_.type.indices}) -> u32 {
             return ${b0.length>0?b0.join("+"):"0u"};
           }`,`${By}(${x_})`},Wy=(x_,G_)=>(()=>{if(en.storage===en.value)return`${_}[${x_}]=${G_};`;if(en.storage==="vec2<u32>"&&en.value==="i32")return`${_}[${x_}]=vec2<u32>(u32(${G_}), select(0u, 0xFFFFFFFFu, ${G_} < 0));`;if(en.storage==="vec2<u32>"&&en.value==="u32")return`${_}[${x_}]=vec2<u32>(u32(${G_}), 0u);`;if(en.storage==="u32"&&en.value==="vec4<bool>")return`${_}[${x_}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${G_}));`;throw new Error(`not supported combination of storage type ${en.storage} and value type ${en.value} yet`)})(),t0=x_=>(()=>{if(en.storage===en.value)return`${_}[${x_}]`;if(en.storage==="vec2<u32>"&&en.value==="i32")return`i32(${_}[${x_}].x)`;if(en.storage==="vec2<u32>"&&en.value==="u32")return`u32(${_}[${x_}].x)`;if(en.storage==="u32"&&en.value==="vec4<bool>")return`vec4<bool>(bool(${_}[${x_}] & 0xFFu), bool(${_}[${x_}] & 0xFF00u), bool(${_}[${x_}] & 0xFF0000u), bool(${_}[${x_}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${en.storage} and value type ${en.value} yet`)})(),Uy=ft<2?"":`
  fn get_${_}ByIndices(indices: ${en.indices}) -> ${Yr} {
    return ${t0(`i2o_${_}(indices)`)};
  }`,dy=ft<2?"":(()=>{let x_=Bt.map(By=>`d${By}: u32`).join(", "),G_=Bt.map(By=>`d${By}`).join(", ");return`
  fn get_${_}(${x_}) -> ${Yr} {
    return get_${_}ByIndices(${R_(G_)});
  }`})(),r0=(...x_)=>{if(x_.length!==ft)throw new Error(`indices length must be ${ft}`);let G_=x_.map(wn).join(",");return ft===0?t0("0u"):ft===1?t0(G_[0]):(_o.get=!0,_o.getByIndices=!0,_o.indicesToOffset=!0,`get_${_}(${G_})`)},d0=x_=>ft<2?t0(x_):(_o.getByIndices=!0,_o.indicesToOffset=!0,`get_${_}ByIndices(${x_})`),gy=ft<2?"":`
  fn set_${_}ByIndices(indices: ${en.indices}, value: ${Yr}) {
    ${Wy(`i2o_${_}(indices)`,"value")}
  }`,Vy=ft<2?"":(()=>{let x_=Bt.map(By=>`d${By}: u32`).join(", "),G_=Bt.map(By=>`d${By}`).join(", ");return`
  fn set_${_}(${x_}, value: ${Yr}) {
    set_${_}ByIndices(${R_(G_)}, value);
  }`})();return{impl:()=>{let x_=[],G_=!1;return _o.offsetToIndices&&(x_.push(xa),G_=!0),_o.indicesToOffset&&(x_.push(u_),G_=!0),_o.broadcastedIndicesToOffset&&(Object.values(Ly).forEach(By=>x_.push(By)),G_=!0),_o.set&&(x_.push(Vy),G_=!0),_o.setByIndices&&(x_.push(gy),G_=!0),_o.get&&(x_.push(dy),G_=!0),_o.getByIndices&&(x_.push(Uy),G_=!0),!pt&&G_&&x_.unshift(`const ${Ws} = ${en.indices}(${it.join(",")});`,`const ${Jo} = ${en.indices}(${Uu.computeStrides(it).join(",")});`),x_.join(`
`)},type:en,offsetToIndices:$a,indicesToOffset:c_,broadcastedIndicesToOffset:ky,indices:R_,indicesGet:ny,indicesSet:ty,set:(...x_)=>{if(x_.length!==ft+1)throw new Error(`indices length must be ${ft}`);let G_=x_[ft];if(typeof G_!="string")throw new Error("value must be string");let By=x_.slice(0,ft).map(wn).join(",");return ft===0?Wy("0u",G_):ft===1?Wy(By[0],G_):(_o.set=!0,_o.setByIndices=!0,_o.indicesToOffset=!0,`set_${_}(${By}, ${G_})`)},setByOffset:Wy,setByIndices:(x_,G_)=>ft<2?Wy(x_,G_):(_o.setByIndices=!0,_o.indicesToOffset=!0,`set_${_}ByIndices(${x_}, ${G_});`),get:r0,getByOffset:t0,getByIndices:d0,usage:ut,name:_,strides:Jo,shape:Ws,rank:ft}},v_=(_,_e,it,ut=1)=>$w(_,_e,it,"input",ut),Xr=(_,_e,it,ut=1)=>$w(_,_e,it,"output",ut),Xo=(_,_e,it,ut=1)=>$w(_,_e,it,"internal",ut),ru=class{constructor(_,_e){this.normalizedDispatchGroup=_,this.limits=_e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(_){return`if (global_idx >= ${typeof _=="number"?`${_}u`:_}) { return; }`}mainStart(_=k0){let _e=typeof _=="number"?_:_[0],it=typeof _=="number"?1:_[1],ut=typeof _=="number"?1:_[2];if(_e>this.limits.maxComputeWorkgroupSizeX||it>this.limits.maxComputeWorkgroupSizeY||ut>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${_e}, ${it}, ${ut}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(_e*it*ut>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${_e}, ${it}, ${ut}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let ct=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,pt=ct?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,ft=ct?`let global_idx = global_id.x;
         let local_idx = local_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${_e*it*ut}u + local_idx;`;return`@compute @workgroup_size(${_e}, ${it}, ${ut})
  fn main(${pt}) {
    ${ft}
  `}appendVariableUniforms(_){_.rank!==0&&(_.shape.startsWith("uniforms.")&&this.uniforms.push({name:_.shape.replace("uniforms.",""),type:"u32",length:_.rank}),_.strides.startsWith("uniforms.")&&this.uniforms.push({name:_.strides.replace("uniforms.",""),type:"u32",length:_.rank}))}declareVariable(_,_e){if(_.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(_),this.appendVariableUniforms(_);let it=_.usage==="input"?"read":"read_write",ut=_.type.storage;return`@group(0) @binding(${_e}) var<storage, ${it}> ${_.name}: array<${ut}>;`}declareVariables(..._){return _.map(_e=>this.declareVariable(_e,this.variableIndex++)).join(`
`)}registerInternalVariable(_){if(_.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(_),this.appendVariableUniforms(_)}registerInternalVariables(..._){return _.forEach(_e=>this.registerInternalVariable(_e)),this}registerUniform(_,_e,it=1){return this.uniforms.push({name:_,type:_e,length:it}),this}registerUniforms(_){return this.uniforms=this.uniforms.concat(_),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let _=[];for(let{name:_e,type:it,length:ut}of this.uniforms)if(ut&&ut>4)it==="f16"?_.push(`@align(16) ${_e}:array<mat2x4<${it}>, ${Math.ceil(ut/8)}>`):_.push(`${_e}:array<vec4<${it}>, ${Math.ceil(ut/4)}>`);else{let ct=ut==null||ut===1?it:`vec${ut}<${it}>`;_.push(`${_e}:${ct}`)}return`
      struct Uniforms { ${_.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(_=>_.impl()).join(`
`)+this.internalVariables.map(_=>_.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let _=_e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(_e)];return this.uniforms.map(_e=>[_(_e.type),_e.length??1])}},Pu=(_,_e)=>new ru(_,_e),Nu=(_,_e)=>{let it=_.length,ut=[];for(let ct=0;ct<it;ct++){let pt=it-1-ct,ft=_[pt]||1;(_e[_e.length-1-ct]||1)>1&&ft===1&&ut.unshift(pt)}return ut}}),oy,Qy,p0,y0,v0,B0,e1,h_,$y=$(()=>{ly(),J_(),Ey(),n_(),oy=_=>{if(!_||_.length!==1)throw new Error("Transpose requires 1 input.")},Qy=(_,_e)=>_e&&_e.length!==_?[...new Array(_).keys()].reverse():_e,p0=(_,_e)=>Uu.sortBasedOnPerm(_,Qy(_.length,_e)),y0=(_,_e,it,ut)=>{let ct=[];ct.push(`fn perm(i: ${ut.type.indices}) -> ${it.type.indices} {
    var a: ${it.type.indices};`);for(let pt=0;pt<_e;++pt)ct.push(it.indicesSet("a",_[pt],`i[${pt}]`));return ct.push("return a;}"),ct.join(`
`)},v0=(_,_e)=>{let it=[],ut=[];for(let ct=0;ct<_.length;++ct)_[ct]!==1&&it.push(_[ct]),_[_e[ct]]!==1&&ut.push(_e[ct]);return{newShape:it,newPerm:ut}},B0=(_,_e)=>{let it=_.dataType,ut=_.dims.length,ct=Qy(ut,_e),pt=p0(_.dims,ct),{newShape:ft,newPerm:Bt}=v0(_.dims,ct),Gt=Uu.areEqual(Bt,[2,3,1]),er=Uu.areEqual(Bt,[3,1,2]),Yr=ft.length===2&&Bt[0]>Bt[1]||Gt||er,It=Yr?ft:_.dims,en=pt;Yr&&(It=Gt?[ft[0],ft[1]*ft[2]]:er?[ft[0]*ft[1],ft[2]]:ft,en=[It[1],It[0]]);let wn=v_("a",it,It.length),_o=Xr("output",it,en.length),vn=16,Ws;return Yr?Ws=Jo=>`
  ${Jo.registerUniform("output_size","u32").declareVariables(wn,_o)}
  var<workgroup> tile : array<array<${_o.type.value}, ${vn+1}>, ${vn}>;
  ${Jo.mainStart([vn,vn,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${vn} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${vn}u + local_id.x;
    let input_row = workgroup_id_x * ${vn}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${wn.getByIndices(`${wn.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${vn}u + local_id.x;
    let output_row = workgroup_id_y * ${vn}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${_o.setByIndices(`${_o.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`:Ws=Jo=>`
  ${Jo.registerUniform("output_size","u32").declareVariables(wn,_o)}

  ${y0(ct,ut,wn,_o)}

  ${Jo.mainStart()}
    ${Jo.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${_o.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${_o.setByOffset("global_idx",wn.getByIndices("aIndices"))}
  }`,{name:Yr?"TransposeShared":"Transpose",shaderCache:{hint:`${_e}`,inputDependencies:["rank"]},getRunData:()=>{let Jo=Uu.size(pt);return{outputs:[{dims:pt,dataType:_.dataType}],dispatchGroup:Yr?{x:Math.ceil(en[1]/vn),y:Math.ceil(en[0]/vn)}:{x:Math.ceil(Jo/64)},programUniforms:[{type:12,data:Jo},...U_(It,en)]}},getShaderSource:Ws}},e1=(_,_e)=>{oy(_.inputs),_.compute(B0(_.inputs[0],_e.perm))},h_=_=>sy({perm:_.perm})}),c0,iw,Iw,_1,j0,Dw,Nw,M1,Uw,P1,sw,Ww,m1,Mw,t1,g1,r1,n1,k1,Q1,o1,y1=$(()=>{ly(),J_(),n_(),kw(),$y(),c0={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},iw={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Iw={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},_1={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},j0=(_,_e)=>{let it=[];for(let ut=_e-_;ut<_e;++ut)it.push(ut);return it},Dw=(_,_e)=>{let it=[],ut=_.length;for(let pt=0;pt<ut;pt++)_e.indexOf(pt)===-1&&it.push(_[pt]);let ct=_e.map(pt=>_[pt]);return[it,ct]},Nw=(_,_e)=>{let it=_.length+_e.length,ut=[],ct=0;for(let pt=0;pt<it;pt++)_e.indexOf(pt)===-1?ut.push(_[ct++]):ut.push(1);return ut},M1=(_,_e)=>{for(let it=0;it<_.length;++it)if(_[_.length-it-1]!==_e-1-it)return!1;return!0},Uw=(_,_e)=>{let it=[];if(!M1(_,_e)){for(let ut=0;ut<_e;++ut)_.indexOf(ut)===-1&&it.push(ut);_.forEach(ut=>it.push(ut))}return it},P1=(_,_e,it,ut,ct,pt,ft)=>{let Bt=it[0].dims,Gt=Uu.size(pt),er=Uu.size(ft),Yr=v_("_A",it[0].dataType,Bt),It=Xr("output",ct,pt),en=32,wn=`
          var<workgroup> aBestValues : array<f32, ${en}>;
       `;return{name:_,shaderCache:_e,getShaderSource:_o=>`
        ${_o.registerUniform("reduceSize","u32").declareVariables(Yr,It)}
        ${wn}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${_o.mainStart(en)}

          let outputIndex = global_idx / ${en};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Iw[ut]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${en}) {
           let candidate = f32(${Yr.getByOffset("offset + k")});
           bestValue = ${c0[ut]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${en}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${iw[ut]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${It.setByOffset("outputIndex",`${ut==="mean"?`${It.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${It.type.storage}(${_1[ut]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:pt,dataType:ct}],dispatchGroup:{x:Gt},programUniforms:[{type:12,data:er}]})}},sw=(_,_e,it,ut)=>{let ct=_.inputs.length===1?it:S1(_.inputs,it),pt=ct.axes;pt.length===0&&!ct.noopWithEmptyAxes&&(pt=_.inputs[0].dims.map((wn,_o)=>_o));let ft=Uu.normalizeAxes(pt,_.inputs[0].dims.length),Bt=ft,Gt=_.inputs[0],er=Uw(Bt,_.inputs[0].dims.length);er.length>0&&(Gt=_.compute(B0(_.inputs[0],er),{inputs:[0],outputs:[-1]})[0],Bt=j0(Bt.length,Gt.dims.length));let[Yr,It]=Dw(Gt.dims,Bt),en=Yr;ct.keepDims&&(en=Nw(Yr,ft)),_.compute(P1(_e,{hint:ct.cacheKey,inputDependencies:["type"]},[Gt],ut,_.inputs[0].dataType,en,It),{inputs:[Gt]})},Ww=(_,_e)=>{sw(_,"ReduceMeanShared",_e,"mean")},m1=(_,_e)=>{sw(_,"ReduceL1Shared",_e,"l1")},Mw=(_,_e)=>{sw(_,"ReduceL2Shared",_e,"l2")},t1=(_,_e)=>{sw(_,"ReduceLogSumExpShared",_e,"logSumExp")},g1=(_,_e)=>{sw(_,"ReduceMaxShared",_e,"max")},r1=(_,_e)=>{sw(_,"ReduceMinShared",_e,"min")},n1=(_,_e)=>{sw(_,"ReduceProdShared",_e,"prod")},k1=(_,_e)=>{sw(_,"ReduceSumShared",_e,"sum")},Q1=(_,_e)=>{sw(_,"ReduceSumSquareShared",_e,"sumSquare")},o1=(_,_e)=>{sw(_,"ReduceLogSumShared",_e,"logSum")}}),cw,i1,Vw,S1,Q0,Z1,O1,b1,J1,A1,s1,C1,I1,D1,ev,dw,Kw,mw,m0,Gw,Z0,tv,a1,F1,Pw,l1,kw=$(()=>{ly(),J_(),Ey(),n_(),y1(),cw=_=>{if(!_||_.length===0||_.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(_.length===2&&_[1].dims.length!==1)throw new Error("Invalid axes input dims.")},i1=_=>["","",`var value = ${_.getByIndices("input_indices")};`,""],Vw=(_,_e,it,ut,ct,pt,ft=!1,Bt=!1)=>{let Gt=[],er=it[0].dims,Yr=er.length,It=Uu.normalizeAxes(ct,Yr),en=!Bt&&It.length===0;er.forEach((vn,Ws)=>{en||It.indexOf(Ws)>=0?ft&&Gt.push(1):Gt.push(vn)});let wn=Gt.length,_o=Uu.size(Gt);return{name:_,shaderCache:_e,getShaderSource:vn=>{let Ws=[],Jo=v_("_A",it[0].dataType,Yr),So=Xr("output",pt,wn),xa=ut(Jo,So,It),$a=xa[2];for(let gu=0,u_=0;gu<Yr;gu++)en||It.indexOf(gu)>=0?(ft&&u_++,$a=`for(var j${gu}: u32 = 0; j${gu} < ${er[gu]}; j${gu}++) {
                  ${xa[2].includes("last_index")?`let last_index = j${gu};`:""}
                  ${Jo.indicesSet("input_indices",gu,`j${gu}`)}
                  ${$a}
                }`):(Ws.push(`${Jo.indicesSet("input_indices",gu,So.indicesGet("output_indices",u_))};`),u_++);return`

        ${vn.registerUniform("output_size","u32").declareVariables(Jo,So)}

        ${vn.mainStart()}
          ${vn.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${Jo.type.indices};
          let output_indices = ${So.offsetToIndices("global_idx")};

          ${Ws.join(`
`)}
          ${xa[0]}       // init ops for reduce max/min
          ${xa[1]}
          ${$a}
          ${xa[3]}
          ${xa.length===4?So.setByOffset("global_idx","value"):xa.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:Gt,dataType:pt}],dispatchGroup:{x:Math.ceil(_o/64)},programUniforms:[{type:12,data:_o},...U_(er,Gt)]})}},S1=(_,_e)=>{let it=[];return _[1].dims[0]>0&&_[1].getBigInt64Array().forEach(ut=>it.push(Number(ut))),sy({axes:it,keepDims:_e.keepDims,noopWithEmptyAxes:_e.noopWithEmptyAxes})},Q0=(_,_e,it,ut)=>{let ct=_.inputs,pt=ct.length===1?it:S1(ct,it);_.compute(Vw(_e,{hint:pt.cacheKey,inputDependencies:["rank"]},[ct[0]],pt.noopWithEmptyAxes&&pt.axes.length===0?i1:ut,pt.axes,ct[0].dataType,pt.keepDims,pt.noopWithEmptyAxes),{inputs:[0]})},Z1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceLogSum",_e,(it,ut)=>[`var value = ${ut.type.storage}(0);`,"",`value += ${it.getByIndices("input_indices")};`,"value = log(value);"])},O1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceL1",_e,(it,ut)=>[`var value = ${ut.type.storage}(0);`,"",`value += abs(${it.getByIndices("input_indices")});`,""])},b1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceL2",_e,(it,ut)=>[`var t = ${ut.type.value}(0); var value = ${ut.type.value}(0);`,"",`t = ${it.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},J1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceLogSumExp",_e,(it,ut)=>[`var value = ${ut.type.storage}(0);`,"",`value += exp(${it.getByIndices("input_indices")});`,"value = log(value);"])},A1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceMax",_e,(it,ut,ct)=>{let pt=[];for(let ft=0;ft<it.rank;ft++)(ct.indexOf(ft)>=0||ct.length===0)&&pt.push(it.indicesSet("input_indices",ft,0));return[`${pt.join(`
`)}`,`var value = ${it.getByIndices("input_indices")};`,`value = max(value, ${it.getByIndices("input_indices")});`,""]})},s1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceMean",_e,(it,ut,ct)=>{let pt=1;for(let ft=0;ft<it.rank;ft++)(ct.indexOf(ft)>=0||ct.length===0)&&(pt*=_.inputs[0].dims[ft]);return["var sum = f32(0);","",`sum += f32(${it.getByIndices("input_indices")});`,`let value = ${ut.type.value}(sum / ${pt});`]})},C1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceMin",_e,(it,ut,ct)=>{let pt=[];for(let ft=0;ft<it.rank;ft++)(ct.indexOf(ft)>=0||ct.length===0)&&pt.push(`input_indices[${ft}] = 0;`);return[`${pt.join(`
`)}`,`var value = ${it.getByIndices("input_indices")};`,`value = min(value, ${it.getByIndices("input_indices")});`,""]})},I1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceProd",_e,(it,ut)=>[`var value = ${ut.type.storage}(1);`,"",`value *= ${it.getByIndices("input_indices")};`,""])},D1=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceSum",_e,(it,ut)=>[`var value = ${ut.type.storage}(0);`,"",`value += ${it.getByIndices("input_indices")};`,""])},ev=(_,_e)=>{cw(_.inputs),Q0(_,"ReduceSumSquare",_e,(it,ut)=>[`var t = ${ut.type.value}(0); var value = ${ut.type.value}(0);`,"",`t = ${it.getByIndices("input_indices")}; value += t * t;`,""])},dw=(_,_e,it)=>{if(_e.length===0)return it;let ut=1,ct=1;for(let pt=0;pt<_e.length;pt++)_e.indexOf(pt)===-1?ut*=_[pt]:ct*=_[pt];return ct<32&&ut>1024},Kw=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?s1(_,_e):Ww(_,_e)},mw=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?O1(_,_e):m1(_,_e)},m0=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?b1(_,_e):Mw(_,_e)},Gw=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?J1(_,_e):t1(_,_e)},Z0=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?A1(_,_e):g1(_,_e)},tv=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?C1(_,_e):r1(_,_e)},a1=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?I1(_,_e):n1(_,_e)},F1=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?D1(_,_e):k1(_,_e)},Pw=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?ev(_,_e):Q1(_,_e)},l1=(_,_e)=>{dw(_.inputs[0].dims,_e.axes,_e.noopWithEmptyAxes)?Z1(_,_e):o1(_,_e)}}),gw,w1,lt,wt,zt=$(()=>{ly(),Ey(),kw(),gw=_=>{if(!_||_.length===0||_.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(_[0].dataType!==1)throw new Error("Invalid input type.")},w1=(_,_e)=>{gw(_.inputs);let it=(ut,ct,pt)=>{let ft=[];for(let Bt=0;Bt<ut.rank;Bt++)(pt.indexOf(Bt)>=0||pt.length===0)&&ft.push(`input_indices[${Bt}] = 0;`);return[`${ft.join(`
`)}`,`var value = ${ut.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${ut.getByIndices("input_indices")} ${_e.selectLastIndex>0?"<=":"<"} value) {
         value = ${ut.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",ct.setByOffset("global_idx","best_index")]};_.compute(Vw("ArgMin",{hint:_e.cacheKey,inputDependencies:["rank"]},[_.inputs[0]],it,[_e.axis],7,_e.keepDims),{inputs:[0]})},lt=(_,_e)=>{gw(_.inputs);let it=(ut,ct,pt)=>{let ft=[];for(let Bt=0;Bt<ut.rank;Bt++)(pt.indexOf(Bt)>=0||pt.length===0)&&ft.push(`input_indices[${Bt}] = 0;`);return[`${ft.join(`
`)}`,`var value = ${ut.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${ut.getByIndices("input_indices")} ${_e.selectLastIndex>0?">=":">"} value) {
         value = ${ut.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",ct.setByOffset("global_idx","best_index")]};_.compute(Vw("argMax",{hint:_e.cacheKey,inputDependencies:["rank"]},[_.inputs[0]],it,[_e.axis],7,_e.keepDims),{inputs:[0]})},wt=_=>sy(_)}),Dr,Zr,vo,qo,ga,fu,uu,Su=$(()=>{ly(),J_(),Po(),n_(),Dr=(_,_e)=>{let it=_[0],ut=_[1],ct=_[2],pt=_[3],ft=_[4],Bt=_[5];if(ft&&Bt)throw new Error("Attention cannot have both past and attention_bias");if(it.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let Gt=it.dims[0],er=it.dims[1],Yr=it.dims[2];if(ct.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(ut.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(ut.dims[0]!==Yr)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(ct.dims[0]!==ut.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let It=ct.dims[0]/3,en=It,wn=en;if(_e.qkvHiddenSizes.length>0){if(_e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let xa of _e.qkvHiddenSizes)if(xa%_e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");It=_e.qkvHiddenSizes[0],en=_e.qkvHiddenSizes[1],wn=_e.qkvHiddenSizes[2]}let _o=er;if(It!==en)throw new Error("qkv_hidden_sizes first element should be same as the second");if(ct.dims[0]!==It+en+wn)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let vn=0;if(ft){if(en!==wn)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(ft.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(ft.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(ft.dims[1]!==Gt)throw new Error('Input "past" second dimension must be batch_size');if(ft.dims[2]!==_e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(ft.dims[4]!==en/_e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');_e.pastPresentShareBuffer||(vn=ft.dims[3])}let Ws=_o+vn,Jo=-1,So=0;if(pt)throw new Error("Mask not supported");if(ft)throw new Error("past is not supported");if(Bt){if(Bt.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(Bt.dims[0]!==Gt||Bt.dims[1]!==_e.numHeads||Bt.dims[2]!==er||Bt.dims[3]!==Ws)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:Gt,sequenceLength:er,pastSequenceLength:vn,kvSequenceLength:_o,totalSequenceLength:Ws,maxSequenceLength:Jo,inputHiddenSize:Yr,hiddenSize:It,vHiddenSize:wn,headSize:Math.floor(It/_e.numHeads),vHeadSize:Math.floor(wn/_e.numHeads),numHeads:_e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:_e.maskFilterValue,maskType:So,scale:_e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Zr=(_,_e,it)=>{let ut=_y(it),ct=64,pt=it/ut;pt<ct&&(ct=32);let ft=Math.ceil(it/ut/ct),Bt=[{type:1,data:1/it},{type:12,data:pt},{type:12,data:ft}],Gt=jy(_.dataType,ut),er=zy(1,ut),Yr=["type"],It=en=>{let wn=Xr("x",_.dataType,_.dims,ut),_o=zy(_.dataType),vn=[{name:"d_inv",type:"f32"},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${ct}>;
  var<workgroup> thread_sum: array<f32, ${ct}>;
  ${en.registerUniforms(vn).declareVariables(wn)}
  ${en.mainStart([ct,1,1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${ct}) * uniforms.d_comp + local_offset;

    var thread_max_vector = ${er}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${er}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(ut){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${ut}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${ct}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${er}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${er}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(ut){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${ut}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${ct}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${wn.type.value}(${_o}(uniforms.d_inv));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${er}(x[offset + i]);
        x[offset + i] = ${wn.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${ct};${Gt};${ut}`,inputDependencies:Yr},getShaderSource:It,getRunData:()=>({outputs:[],dispatchGroup:{x:_e},programUniforms:Bt})}},vo=(_,_e,it,ut,ct,pt,ft,Bt)=>{let Gt=Bt+pt.kvSequenceLength,er=[pt.batchSize,pt.numHeads,pt.sequenceLength,Gt],Yr=pt.kvNumHeads===void 0&&_>1&&ut,It=Yr?[pt.batchSize,pt.numHeads,Gt,pt.headSize]:void 0,en=ft.scale===0?1/Math.sqrt(pt.headSize):ft.scale,wn=_y(pt.headSize),_o=pt.headSize/wn,vn=12,Ws={x:Math.ceil(Gt/vn),y:Math.ceil(pt.sequenceLength/vn),z:pt.batchSize*pt.numHeads},Jo=[{type:12,data:pt.sequenceLength},{type:12,data:_o},{type:12,data:Gt},{type:12,data:pt.numHeads},{type:1,data:en},{type:12,data:Bt},{type:12,data:pt.kvSequenceLength}],So=Yr&&ut&&Uu.size(ut.dims)>0,xa=["type","type"];So&&xa.push("type"),ct&&xa.push("type");let $a=[{dims:er,dataType:_e.dataType,gpuDataType:0}];Yr&&$a.push({dims:It,dataType:_e.dataType,gpuDataType:0});let gu=u_=>{let c_=v_("q",_e.dataType,_e.dims,wn),R_=v_("key",it.dataType,it.dims,wn),ny=[c_,R_];if(So){let t0=v_("past_key",ut.dataType,ut.dims,wn);ny.push(t0)}ct&&ny.push(v_("attention_bias",ct.dataType,ct.dims));let ty=Xr("output",_e.dataType,er),Ly=[ty];Yr&&Ly.push(Xr("present_key",_e.dataType,It,wn));let ky=zy(1,wn),Wy=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"}];return`
  const TILE_SIZE = ${vn}u;

  var<workgroup> tileQ: array<${c_.type.storage}, ${vn*vn}>;
  var<workgroup> tileK: array<${c_.type.storage}, ${vn*vn}>;
  ${u_.registerUniforms(Wy).declareVariables(...ny,...Ly)}
  ${u_.mainStart([vn,vn,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    ${So&&Yr?`
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;
    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`:`
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`}
    ${Yr?"let presentKeyOffset = headIdx * uniforms.N * uniforms.K;":""}
    var value = ${ky}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${So&&Yr?`
              if (n + local_id.y < uniforms.past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else {
                tileK[idx] =
                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];
              }`:"tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];"}
      ${Yr?"present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];":""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${ky}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(wn){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${wn}`)}})()};
        output[outputIdx] = ${ty.type.value} (sum * uniforms.alpha) + ${ct?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${wn};${ct!==void 0};${ut!==void 0};${_}`,inputDependencies:xa},getRunData:()=>({outputs:$a,dispatchGroup:Ws,programUniforms:Jo}),getShaderSource:gu}},qo=(_,_e,it,ut,ct,pt)=>{let ft=pt+ct.kvSequenceLength,Bt=ct.nReps?ct.nReps:1,Gt=ct.vHiddenSize*Bt,er=ct.kvNumHeads==null&&_>1&&ut,Yr=er?[ct.batchSize,ct.numHeads,ft,ct.headSize]:void 0,It=[ct.batchSize,ct.sequenceLength,Gt],en=12,wn={x:Math.ceil(ct.vHeadSize/en),y:Math.ceil(ct.sequenceLength/en),z:ct.batchSize*ct.numHeads},_o=[{type:12,data:ct.sequenceLength},{type:12,data:ft},{type:12,data:ct.vHeadSize},{type:12,data:ct.numHeads},{type:12,data:Gt},{type:12,data:pt},{type:12,data:ct.kvSequenceLength}],vn=er&&ut&&Uu.size(ut.dims)>0,Ws=["type","type"];vn&&Ws.push("type");let Jo=[{dims:It,dataType:_e.dataType,gpuDataType:0}];er&&Jo.push({dims:Yr,dataType:_e.dataType,gpuDataType:0});let So=xa=>{let $a=v_("probs",_e.dataType,_e.dims),gu=v_("v",it.dataType,it.dims),u_=[$a,gu];vn&&u_.push(v_("past_value",ut.dataType,ut.dims));let c_=[Xr("output",_e.dataType,It)];er&&c_.push(Xr("present_value",_e.dataType,Yr));let R_=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"}];return`
  const TILE_SIZE = ${en}u;
  var<workgroup> tileQ: array<${$a.type.value}, ${en*en}>;
  var<workgroup> tileK: array<${$a.type.value}, ${en*en}>;
  ${xa.registerUniforms(R_).declareVariables(...u_,...c_)}
  ${xa.mainStart([en,en,1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   ${vn&&er?`
    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;
    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;
      `:`
   let offsetB = headIdx * uniforms.N * uniforms.K + n;
            `}
    ${er?"let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${$a.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${vn&&er?`
        if (w + local_id.y < uniforms.past_sequence_length) {
          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else {
          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];
        }
      `:`
        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];
      `}
        ${er?"present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];":""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${ut!==void 0};${_}`,inputDependencies:Ws},getRunData:()=>({outputs:Jo,dispatchGroup:wn,programUniforms:_o}),getShaderSource:So}},ga=(_,_e,it,ut,ct,pt,ft,Bt,Gt,er,Yr)=>{let It=Math.min(_.outputCount,1+(ft?1:0)+(Bt?1:0)),en=er.kvNumHeads!==void 0||It>1?er.pastSequenceLength:0,wn=en+er.kvSequenceLength,_o=Gt&&Uu.size(Gt.dims)>0?Gt:void 0,vn=[_e,it];er.kvNumHeads===void 0&&It>1&&ft&&Uu.size(ft.dims)>0&&vn.push(ft),_o&&vn.push(_o);let Ws=_.compute(vo(It,_e,it,ft,_o,er,Yr,en),{inputs:vn,outputs:er.kvNumHeads===void 0&&It>1?[-1,1]:[-1]})[0];_.compute(Zr(Ws,er.batchSize*er.numHeads*er.sequenceLength,wn),{inputs:[Ws],outputs:[]});let Jo=[Ws,ut];er.kvNumHeads===void 0&&It>1&&Bt&&Uu.size(Bt.dims)>0&&Jo.push(Bt),_.compute(qo(It,Ws,ut,Bt,er,en),{inputs:Jo,outputs:er.kvNumHeads===void 0&&It>1?[0,2]:[0]})},fu=(_,_e)=>{let it=[_e.batchSize,_e.numHeads,_e.sequenceLength,_e.headSize],ut=_e.sequenceLength,ct=_e.inputHiddenSize,pt=_e.headSize,ft=12,Bt={x:Math.ceil(_e.headSize/ft),y:Math.ceil(_e.sequenceLength/ft),z:_e.batchSize*_e.numHeads},Gt=[_.inputs[0],_.inputs[1],_.inputs[2]],er=[{type:12,data:ut},{type:12,data:ct},{type:12,data:pt},{type:12,data:_e.numHeads},{type:12,data:_e.headSize},{type:12,data:_e.hiddenSize},{type:12,data:_e.hiddenSize+_e.hiddenSize+_e.vHiddenSize}],Yr=It=>{let en=Xr("output_q",Gt[0].dataType,it),wn=Xr("output_k",Gt[0].dataType,it),_o=Xr("output_v",Gt[0].dataType,it),vn=v_("input",Gt[0].dataType,Gt[0].dims),Ws=v_("weight",Gt[1].dataType,Gt[1].dims),Jo=v_("bias",Gt[2].dataType,Gt[2].dims),So=vn.type.storage,xa=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${ft}u;
  var<workgroup> tileInput: array<${So}, ${ft*ft}>;
  var<workgroup> tileWeightQ: array<${So}, ${ft*ft}>;
  var<workgroup> tileWeightK: array<${So}, ${ft*ft}>;
  var<workgroup> tileWeightV: array<${So}, ${ft*ft}>;
  ${It.registerUniforms(xa).declareVariables(vn,Ws,Jo,en,wn,_o)}
  ${It.mainStart([ft,ft,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${So}(0);
    var valueK = ${So}(0);
    var valueV = ${So}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return _.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:it,dataType:_.inputs[0].dataType,gpuDataType:0},{dims:it,dataType:_.inputs[0].dataType,gpuDataType:0},{dims:it,dataType:_.inputs[0].dataType,gpuDataType:0}],dispatchGroup:Bt,programUniforms:er}),getShaderSource:Yr},{inputs:Gt,outputs:[-1,-1,-1]})},uu=(_,_e)=>{let it=Dr(_.inputs,_e),[ut,ct,pt]=fu(_,it);return ga(_,ut,ct,pt,_.inputs[4],void 0,void 0,void 0,_.inputs[5],it,_e)}}),tu,Ou,hu,yu,Au=$(()=>{L_(),ly(),J_(),Ey(),n_(),tu=(_,_e)=>{if(!_||_.length!==5)throw new Error("BatchNormalization requires 5 inputs");let it=(ut,ct,pt)=>{let ft=ct.length;if(ft!==ut.length)throw new Error(`${pt}: num dimensions != ${ft}`);ct.forEach((Bt,Gt)=>{if(Bt!==ut[Gt])throw new Error(`${pt}: dim[${Gt}] do not match`)})};if(_[0].dims.length>1){let ut=_e.format==="NHWC"?_e.spatial?_[0].dims.slice(-1):_[0].dims.slice(-1).concat(_[0].dims.slice(1,_[0].dims.length-1)):_[0].dims.slice(1,_e.spatial?2:void 0);it(_[1].dims,ut,"Invalid input scale"),it(_[2].dims,ut,"Invalid input B"),it(_[3].dims,ut,"Invalid input mean"),it(_[4].dims,ut,"Invalid input var")}else it(_[1].dims,[1],"Invalid input scale"),it(_[2].dims,[1],"Invalid input B"),it(_[3].dims,[1],"Invalid input mean"),it(_[4].dims,[1],"Invalid input var")},Ou=(_,_e)=>{let{epsilon:it,spatial:ut,format:ct}=_e,pt=_[0].dims,ft=ut?_y(pt[pt.length-1]):1,Bt=ct==="NHWC"&&pt.length>1?ft:1,Gt=Uu.size(pt)/ft,er=ut,Yr=er?pt.length:pt,It=v_("x",_[0].dataType,_[0].dims,ft),en=v_("scale",_[1].dataType,_[1].dims,Bt),wn=v_("bias",_[2].dataType,_[2].dims,Bt),_o=v_("inputMean",_[3].dataType,_[3].dims,Bt),vn=v_("inputVar",_[4].dataType,_[4].dims,Bt),Ws=Xr("y",_[0].dataType,Yr,ft),Jo=()=>{let xa="";if(ut)xa=`let cOffset = ${pt.length===1?"0u":ct==="NHWC"?`outputIndices[${pt.length-1}] / ${ft}`:"outputIndices[1]"};`;else if(ct==="NCHW")xa=`
            ${Ws.indicesSet("outputIndices","0","0")}
            let cOffset = ${Ws.indicesToOffset("outputIndices")};`;else{xa=`var cIndices = ${en.type.indices}(0);
                       cIndices[0] = outputIndices[${pt.length-1}];`;for(let $a=1;$a<en.rank;$a++)xa+=`cIndices[${$a}] = outputIndices[${$a}];`;xa+=`let cOffset = ${en.indicesToOffset("cIndices")};`}return xa},So=xa=>`
  const epsilon = ${it};
  ${xa.registerUniform("outputSize","u32").declareVariables(It,en,wn,_o,vn,Ws)}
  ${xa.mainStart()}
  ${xa.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${Ws.offsetToIndices(`global_idx * ${ft}`)};
    ${Jo()}
    let scale = ${en.getByOffset("cOffset")};
    let bias = ${wn.getByOffset("cOffset")};
    let inputMean = ${_o.getByOffset("cOffset")};
    let inputVar = ${vn.getByOffset("cOffset")};
    let x = ${It.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${Ws.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${_e.epsilon}_${_e.format}_${ut}_${ft}`,inputDependencies:er?["rank","type","type","type","type"]:void 0},getShaderSource:So,getRunData:()=>({outputs:[{dims:_[0].dims,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(Gt/64)},programUniforms:er?[{type:12,data:Gt},...U_(pt)]:[{type:12,data:Gt}]})}},hu=_=>sy(_),yu=(_,_e)=>{let{inputs:it,outputCount:ut}=_,ct=hu({..._e,outputCount:ut});if(Er.webgpu.validateInputContent&&tu(it,ct),_e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");_.compute(Ou(it,ct))}}),bu,Gu,t_,o_=$(()=>{J_(),n_(),bu=_=>{if(_[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(_[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(_[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(_[0].dims[2]!==_[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Gu=_=>{let _e=_[0].dims,it=_[0].dims[2],ut=Uu.size(_e)/4,ct=_[0].dataType,pt=v_("input",ct,_e,4),ft=v_("bias",ct,[it],4),Bt=v_("residual",ct,_e,4),Gt=Xr("output",ct,_e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:_e,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(ut/64)}}),getShaderSource:er=>`
  const channels = ${it}u / 4;
  ${er.declareVariables(pt,ft,Bt,Gt)}

  ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes(ut)}
    let value = ${pt.getByOffset("global_idx")}
      + ${ft.getByOffset("global_idx % channels")} + ${Bt.getByOffset("global_idx")};
    ${Gt.setByOffset("global_idx","value")}
  }`}},t_=_=>{bu(_.inputs),_.compute(Gu(_.inputs))}}),__,p_,V_,I_,W_,K_,A_,my,vy,Dy,Fy,aw,Oy,C0,I0,Hw,x0,Sw,Fw,wx,vx,Tv,xx,Tx,rv,Ex,$x,Ev,$v,Mx,Mv,Px,kx,Sx,Pv,kv,Ox,Sv,nv,Ax,Cx,Ov,Ix,Dx,Av,Cv=$(()=>{ly(),J_(),Ey(),n_(),__=(_,_e,it,ut,ct,pt,ft)=>{let Bt=Math.ceil(_e/4),Gt="";typeof ct=="string"?Gt=`${ct}(a)`:Gt=ct("a");let er=v_("inputData",it,[Bt],4),Yr=Xr("outputData",ut,[Bt],4),It=[{name:"vec_size",type:"u32"}];return ft&&It.push(...ft),`
      ${_.registerUniforms(It).declareVariables(er,Yr)}

  ${pt??""}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${er.getByOffset("global_idx")};
    ${Yr.setByOffset("global_idx",Gt)}
  }`},p_=(_,_e,it,ut,ct,pt=_.dataType,ft,Bt)=>{let Gt=[{type:12,data:Math.ceil(Uu.size(_.dims)/4)}];return ft&&Gt.push(...ft),{name:_e,shaderCache:{hint:ct,inputDependencies:["type"]},getShaderSource:er=>__(er,Uu.size(_.dims),_.dataType,pt,it,ut,Bt),getRunData:er=>({outputs:[{dims:_.dims,dataType:pt}],dispatchGroup:{x:Math.ceil(Uu.size(er[0].dims)/64/4)},programUniforms:Gt})}},V_=_=>{_.compute(p_(_.inputs[0],"Abs","abs"))},I_=_=>{_.compute(p_(_.inputs[0],"Acos","acos"))},W_=_=>{_.compute(p_(_.inputs[0],"Acosh","acosh"))},K_=_=>{_.compute(p_(_.inputs[0],"Asin","asin"))},A_=_=>{_.compute(p_(_.inputs[0],"Asinh","asinh"))},my=_=>{_.compute(p_(_.inputs[0],"Atan","atan"))},vy=_=>{_.compute(p_(_.inputs[0],"Atanh","atanh"))},Dy=_=>sy(_),Fy=(_,_e)=>{let it;switch(_e.to){case 10:it="vec4<f16>";break;case 1:it="vec4<f32>";break;case 12:it="vec4<u32>";break;case 6:it="vec4<i32>";break;case 9:it="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${_e.to}`)}_.compute(p_(_.inputs[0],"Cast",it,void 0,_e.cacheKey,_e.to))},aw=_=>{let _e,it,ut=_.length>=2&&_[1].data!==0,ct=_.length>=3&&_[2].data!==0;switch(_[0].dataType){case 1:_e=ut?_[1].getFloat32Array()[0]:-34028234663852886e22,it=ct?_[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:_e=ut?_[1].getUint16Array()[0]:64511,it=ct?_[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return sy({min:_e,max:it})},Oy=(_,_e)=>{let it=_e||aw(_.inputs),ut=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"Clip",ct=>`clamp(${ct}, vec4<${ut}>(uniforms.min), vec4<${ut}>(uniforms.max))`,void 0,it.cacheKey,void 0,[{type:_.inputs[0].dataType,data:it.min},{type:_.inputs[0].dataType,data:it.max}],[{name:"min",type:ut},{name:"max",type:ut}]),{inputs:[0]})},C0=_=>{_.compute(p_(_.inputs[0],"Ceil","ceil"))},I0=_=>{_.compute(p_(_.inputs[0],"Cos","cos"))},Hw=_=>{_.compute(p_(_.inputs[0],"Cosh","cosh"))},x0=_=>sy(_),Sw=(_,_e)=>{let it=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"Elu",ut=>`elu_vf32(${ut})`,`
  const elu_alpha_ = ${it}(${_e.alpha});

  fn elu_f32(a: ${it}) -> ${it} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${it}>) -> vec4<${it}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,_e.cacheKey))},Fw=(_="f32")=>`
const r0: ${_} = 0.3275911;
const r1: ${_} = 0.254829592;
const r2: ${_} = -0.284496736;
const r3: ${_} = 1.421413741;
const r4: ${_} = -1.453152027;
const r5: ${_} = 1.061405429;

fn erf_vf32(v: vec4<${_}>) -> vec4<${_}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,wx=_=>{let _e=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"Erf",it=>`erf_vf32(${it})`,Fw(_e)))},vx=_=>{_.compute(p_(_.inputs[0],"Exp","exp"))},Tv=_=>{_.compute(p_(_.inputs[0],"Floor","floor"))},xx=_=>{let _e=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"Gelu",it=>`0.5 * ${it} * (1.0 + erf_vf32(${it} * 0.7071067811865475))`,Fw(_e)))},Tx=(_,_e)=>{let it=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"LeakyRelu",ut=>`select(leaky_relu_alpha_ * ${ut}, ${ut}, ${ut} >= vec4<${it}>(0.0))`,`const leaky_relu_alpha_ = ${it}(${_e.alpha});`,_e.cacheKey))},rv=_=>{_.compute(p_(_.inputs[0],"Not",_e=>`!${_e}`))},Ex=_=>{_.compute(p_(_.inputs[0],"Neg",_e=>`-${_e}`))},$x=_=>{_.compute(p_(_.inputs[0],"Reciprocal",_e=>`1.0/${_e}`))},Ev=_=>{let _e=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"Relu",it=>`select(vec4<${_e}>(0.0), ${it}, ${it} > vec4<${_e}>(0.0))`))},$v=_=>{_.compute(p_(_.inputs[0],"Sigmoid",_e=>`(1.0 / (1.0 + exp(-${_e})))`))},Mx=_=>sy(_),Mv=(_,_e)=>{let it=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"HardSigmoid",ut=>`max(vec4<${it}>(0.0), min(vec4<${it}>(1.0), ${_e.alpha} * ${ut} + vec4<${it}>(${_e.beta})))`,void 0,_e.cacheKey))},Px=_=>{_.compute(p_(_.inputs[0],"Sin","sin"))},kx=_=>{_.compute(p_(_.inputs[0],"Sinh","sinh"))},Sx=_=>{_.compute(p_(_.inputs[0],"Sqrt","sqrt"))},Pv=_=>{_.compute(p_(_.inputs[0],"Tan","tan"))},kv=_=>`sign(${_}) * (1 - exp(-2 * abs(${_}))) / (1 + exp(-2 * abs(${_})))`,Ox=_=>{_.compute(p_(_.inputs[0],"Tanh",kv))},Sv=(_="f32")=>`
const fast_gelu_a: ${_} = 0.5;
const fast_gelu_b: ${_} = 0.7978845608028654;
const fast_gelu_c: ${_} = 0.035677408136300125;

fn tanh_v(v: vec4<${_}>) -> vec4<${_}> {
  return ${kv("v")};
}
`,nv=_=>`(fast_gelu_a + fast_gelu_a * tanh_v(${_} * (fast_gelu_c * ${_} * ${_} + fast_gelu_b))) * ${_}`,Ax=_=>{let _e=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"FastGelu",nv,Sv(_e),void 0,_.inputs[0].dataType))},Cx=(_,_e)=>{let it=zy(_.inputs[0].dataType);return _.compute(p_(_.inputs[0],"ThresholdedRelu",ut=>`select(vec4<${it}>(0.0), ${ut}, ${ut} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${it}>(${_e.alpha});`,_e.cacheKey)),0},Ov=_=>{_.compute(p_(_.inputs[0],"Log","log"))},Ix=(_,_e)=>`
const alpha = vec4<${_}>(${_e});
const one = ${_}(1.0);
const zero = ${_}(0.0);

fn quick_gelu_impl(x: vec4<${_}>) -> vec4<${_}> {
  let v = x *alpha;
  var x1 : vec4<${_}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,Dx=_=>`quick_gelu_impl(${_})`,Av=(_,_e)=>{let it=zy(_.inputs[0].dataType);_.compute(p_(_.inputs[0],"QuickGelu",Dx,Ix(it,_e.alpha),_e.cacheKey,_.inputs[0].dataType))}}),Fx,Iv,Rx,wE=$(()=>{J_(),n_(),Cv(),Fx=_=>{if(_[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(_[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(_[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(_[0].dims[2]!==_[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Iv=_=>{let _e=_[0].dims.slice();_e[2]=_e[2]/2;let it=v_("input",_[0].dataType,_[0].dims,4),ut=v_("bias",_[0].dataType,[_[0].dims[2]],4),ct=Xr("output",_[0].dataType,_e,4),pt=Uu.size(_e)/4,ft=jy(_[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:_e,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(pt/64)}}),getShaderSource:Bt=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${_[0].dims[2]/4/2}u;

  ${Bt.declareVariables(it,ut,ct)}

  ${Fw(ft)}

  ${Bt.mainStart()}
    ${Bt.guardAgainstOutOfBoundsWorkgroupSizes(pt)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${ct.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Rx=_=>{Fx(_.inputs),_.compute(Iv(_.inputs))}}),Dv,Lx,bw,Fv,Bx,jx,zx,Nx,ov,Ux,Wx,Vx,Rv,vE=$(()=>{ly(),J_(),n_(),Dv=(_,_e,it,ut,ct,pt,ft,Bt,Gt,er,Yr,It)=>{let en,wn;typeof Bt=="string"?en=wn=(So,xa)=>`${Bt}((${So}),(${xa}))`:typeof Bt=="function"?en=wn=Bt:(en=Bt.scalar,wn=Bt.vector);let _o=Xr("outputData",Yr,ut.length,4),vn=v_("aData",Gt,_e.length,4),Ws=v_("bData",er,it.length,4),Jo;if(ct)if(pt){let So=Uu.size(_e)===1,xa=Uu.size(it)===1,$a=_e.length>0&&_e[_e.length-1]%4===0,gu=it.length>0&&it[it.length-1]%4===0;So||xa?Jo=_o.setByOffset("global_idx",wn(So?`${vn.type.value}(${vn.getByOffset("0")}.x)`:vn.getByOffset("global_idx"),xa?`${Ws.type.value}(${Ws.getByOffset("0")}.x)`:Ws.getByOffset("global_idx"))):Jo=`
            let outputIndices = ${_o.offsetToIndices("global_idx * 4u")};
            let offsetA = ${vn.broadcastedIndicesToOffset("outputIndices",_o)};
            let offsetB = ${Ws.broadcastedIndicesToOffset("outputIndices",_o)};
            ${_o.setByOffset("global_idx",wn(ft||$a?vn.getByOffset("offsetA / 4u"):`${vn.type.value}(${vn.getByOffset("offsetA / 4u")}[offsetA % 4u])`,ft||gu?Ws.getByOffset("offsetB / 4u"):`${Ws.type.value}(${Ws.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else Jo=_o.setByOffset("global_idx",wn(vn.getByOffset("global_idx"),Ws.getByOffset("global_idx")));else{if(!pt)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let So=(xa,$a,gu="")=>{let u_=`aData[indexA${$a}][componentA${$a}]`,c_=`bData[indexB${$a}][componentB${$a}]`;return`
            let outputIndices${$a} = ${_o.offsetToIndices(`global_idx * 4u + ${$a}u`)};
            let offsetA${$a} = ${vn.broadcastedIndicesToOffset(`outputIndices${$a}`,_o)};
            let offsetB${$a} = ${Ws.broadcastedIndicesToOffset(`outputIndices${$a}`,_o)};
            let indexA${$a} = offsetA${$a} / 4u;
            let indexB${$a} = offsetB${$a} / 4u;
            let componentA${$a} = offsetA${$a} % 4u;
            let componentB${$a} = offsetB${$a} % 4u;
            ${xa}[${$a}] = ${gu}(${en(u_,c_)});
          `};Yr===9?Jo=`
            var data = vec4<u32>(0);
            ${So("data",0,"u32")}
            ${So("data",1,"u32")}
            ${So("data",2,"u32")}
            ${So("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Jo=`
            ${So("outputData[global_idx]",0)}
            ${So("outputData[global_idx]",1)}
            ${So("outputData[global_idx]",2)}
            ${So("outputData[global_idx]",3)}
          `}return`
        ${_.registerUniform("vec_size","u32").declareVariables(vn,Ws,_o)}

        ${It??""}

        ${_.mainStart()}
        ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${Jo}
      }`},Lx=(_,_e,it,ut,ct,pt,ft=it.dataType)=>{let Bt=!Uu.areEqual(it.dims,ut.dims),Gt=it.dims,er=Uu.size(it.dims),Yr=!1,It=!1,en=[Bt];if(Bt){let wn=h0.calcShape(it.dims,ut.dims,!1);if(!wn)throw new Error("Can't perform binary op on the given tensors");Gt=wn,er=Uu.size(Gt);let _o=Uu.size(it.dims)===1,vn=Uu.size(ut.dims)===1,Ws=it.dims.length>0&&it.dims[it.dims.length-1]%4===0,Jo=ut.dims.length>0&&ut.dims[ut.dims.length-1]%4===0;en.push(_o),en.push(vn),en.push(Ws),en.push(Jo);let So=1;for(let xa=1;xa<Gt.length;xa++){let $a=it.dims[it.dims.length-xa]??1,gu=ut.dims[ut.dims.length-xa]??1;if($a===gu)So*=$a;else break}So%4===0?(It=!0,Yr=!0):(_o||vn||Ws||Jo)&&(Yr=!0)}else Yr=!0;return en.push(Yr),{name:_,shaderCache:{hint:_e+en.map(wn=>wn.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:wn=>Dv(wn,it.dims,ut.dims,Gt,Yr,Bt,It,ct,it.dataType,ut.dataType,ft,pt),getRunData:()=>({outputs:[{dims:Gt,dataType:ft}],dispatchGroup:{x:Math.ceil(er/64/4)},programUniforms:[{type:12,data:Math.ceil(Uu.size(Gt)/4)},...U_(it.dims,ut.dims,Gt)]})}},bw=(_,_e,it,ut,ct,pt)=>{_.compute(Lx(_e,ct??"",_.inputs[0],_.inputs[1],it,ut,pt))},Fv=_=>{bw(_,"Add",(_e,it)=>`${_e}+${it}`)},Bx=_=>{bw(_,"Div",(_e,it)=>`${_e}/${it}`)},jx=_=>{bw(_,"Equal",{scalar:(_e,it)=>`u32(${_e}==${it})`,vector:(_e,it)=>`vec4<u32>(${_e}==${it})`},void 0,void 0,9)},zx=_=>{bw(_,"Mul",(_e,it)=>`${_e}*${it}`)},Nx=_=>{let _e=v_("input",_.inputs[0].dataType,_.inputs[0].dims).type.value;bw(_,"Pow",{scalar:(it,ut)=>`pow_custom(${it},${ut})`,vector:(it,ut)=>`pow_vector_custom(${it},${ut})`},`
    fn pow_custom(a : ${_e}, b : ${_e}) -> ${_e} {
      if (b == ${_e}(0.0)) {
        return ${_e}(1.0);
      } else if (a < ${_e}(0.0) && f32(b) != floor(f32(b))) {
        return ${_e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${_e}(1.0), round(f32(abs(b) % ${_e}(2.0))) != 1.0) * ${_e}(${_e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${_e}>, b : vec4<${_e}>) -> vec4<${_e}> {
      // TODO: implement vectorized pow
      return vec4<${_e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},ov=_=>{bw(_,"Sub",(_e,it)=>`${_e}-${it}`)},Ux=_=>{bw(_,"Greater",{scalar:(_e,it)=>`u32(${_e}>${it})`,vector:(_e,it)=>`vec4<u32>(${_e}>${it})`},void 0,void 0,9)},Wx=_=>{bw(_,"Less",{scalar:(_e,it)=>`u32(${_e}<${it})`,vector:(_e,it)=>`vec4<u32>(${_e}<${it})`},void 0,void 0,9)},Vx=_=>{bw(_,"GreaterOrEqual",{scalar:(_e,it)=>`u32(${_e}>=${it})`,vector:(_e,it)=>`vec4<u32>(${_e}>=${it})`},void 0,void 0,9)},Rv=_=>{bw(_,"LessOrEqual",{scalar:(_e,it)=>`u32(${_e}<=${it})`,vector:(_e,it)=>`vec4<u32>(${_e}<=${it})`},void 0,void 0,9)}}),Kx,Lv,Gx,Hx,qx,Xx,Yx=$(()=>{ly(),J_(),Ey(),n_(),Kx=(_,_e)=>{if(!_||_.length<1)throw new Error("too few inputs");let it=0,ut=_[it],ct=ut.dataType,pt=ut.dims.length;_.forEach((ft,Bt)=>{if(Bt!==it){if(ft.dataType!==ct)throw new Error("input tensors should be one type");if(ft.dims.length!==pt)throw new Error("input tensors should have the same shape");ft.dims.forEach((Gt,er)=>{if(er!==_e&&Gt!==ut.dims[er])throw new Error("non concat dimensions must match")})}})},Lv=(_,_e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${_}u>(${_e});
    for (var i: u32 = 0u; i < ${_}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${_}u;
  }`,Gx=(_,_e)=>{let it=_.length,ut=[];for(let ct=0;ct<it;++ct){let pt=_e.setByOffset("global_idx",_[ct].getByIndices("indices"));it===1?ut.push(pt):ct===0?ut.push(`if (inputIndex == ${ct}u) { ${pt} }`):ct===it-1?ut.push(`else { ${pt} }`):ut.push(`else if (inputIndex == ${ct}) { ${pt} }`)}return ut.join(`
`)},Hx=(_,_e,it,ut)=>{let ct=Uu.size(it),pt=new Array(_.length),ft=new Array(_.length),Bt=0,Gt=[],er=[],Yr=[{type:12,data:ct}];for(let vn=0;vn<_.length;++vn)Bt+=_[vn].dims[_e],pt[vn]=Bt,er.push(_[vn].dims.length),ft[vn]=v_(`input${vn}`,ut,er[vn]),Gt.push("rank"),Yr.push({type:12,data:pt[vn]});for(let vn=0;vn<_.length;++vn)Yr.push(...U_(_[vn].dims));Yr.push(...U_(it));let It=Xr("output",ut,it.length),en=It.indicesGet("indices",_e),wn=Array.from(Array(pt.length).keys()).map(vn=>`uniforms.sizeInConcatAxis${vn}`).join(","),_o=vn=>`

  ${(()=>{vn.registerUniform("outputSize","u32");for(let Ws=0;Ws<_.length;Ws++)vn.registerUniform(`sizeInConcatAxis${Ws}`,"u32");return vn.declareVariables(...ft,It)})()}

  ${Lv(pt.length,wn)}

  ${vn.mainStart()}
    ${vn.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${It.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${en});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${pt.length}u>(${wn});
      ${en} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Gx(ft,It)}
  }`;return{name:"Concat",shaderCache:{hint:`${_e}`,inputDependencies:Gt},getRunData:()=>({outputs:[{dims:it,dataType:ut}],dispatchGroup:{x:Math.ceil(ct/64)},programUniforms:Yr}),getShaderSource:_o}},qx=(_,_e)=>{let it=_.inputs,ut=it[0].dims,ct=Uu.normalizeAxis(_e.axis,ut.length);Kx(it,ct);let pt=ut.slice();pt[ct]=it.reduce((Bt,Gt)=>Bt+(Gt.dims.length>ct?Gt.dims[ct]:0),0);let ft=it.filter(Bt=>Uu.size(Bt.dims)>0);_.compute(Hx(ft,ct,pt,it[0].dataType),{inputs:ft})},Xx=_=>sy({axis:_.axis})}),qw,Xw,Rw,Bv,Yw=$(()=>{ly(),J_(),qw=(_,_e,it="f32")=>{switch(_.activation){case"Relu":return`value = max(value, ${_e}(0.0));`;case"Sigmoid":return`value = (${_e}(1.0) / (${_e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${_e}(${it}(uniforms.clip_min)), ${_e}(${it}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${_e}(0.0), min(${_e}(1.0), ${it}(uniforms.alpha) * value + ${it}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${it}(uniforms.alpha) * value, value, value >= ${_e}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${_.activation}`)}},Xw=(_,_e)=>{_.activation==="Clip"?_e.push({type:1,data:_.clipMax},{type:1,data:_.clipMin}):_.activation==="HardSigmoid"?_e.push({type:1,data:_.alpha},{type:1,data:_.beta}):_.activation==="LeakyRelu"&&_e.push({type:1,data:_.alpha})},Rw=(_,_e)=>{_.activation==="Clip"?_e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):_.activation==="HardSigmoid"?_e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):_.activation==="LeakyRelu"&&_e.push({name:"alpha",type:"f32"})},Bv=_=>{let _e=_?.activation||"";if(_e==="HardSigmoid"){let[it,ut]=_?.activation_params||[.2,.5];return{activation:_e,alpha:it,beta:ut}}else if(_e==="Clip"){let[it,ut]=_?.activation_params||[_0,ry];return{activation:_e,clipMax:ut,clipMin:it}}else if(_e==="LeakyRelu"){let[it]=_?.activation_params||[.01];return{activation:_e,alpha:it}}return{activation:_e}}}),W0,jv,iv=$(()=>{W0=(_,_e)=>{switch(_){case 1:return _e;case 2:return`vec2<${_e}>`;case 3:return`vec3<${_e}>`;case 4:return`vec4<${_e}>`;default:throw new Error(`${_}-component is not supported.`)}},jv=_=>`
      ${_?"value = value + getBiasByOutputCoords(coords);":""}
      `}),sv,Qx=$(()=>{sv=_=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${_}.x), i32(${_}.y), i32(${_}.z), 1));
}
`}),Zx,Jx,av,zv,eT,R1,tT,Nv,L1=$(()=>{ly(),J_(),n_(),Yw(),iv(),Zx=(_,_e)=>_?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${_e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${_e?", batchIndices":""});
        `,Jx=(_,_e)=>_?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${_e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${_e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${_e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,av=(_,_e,it="f32",ut,ct=!1,pt=32,ft=!1,Bt=32)=>{let Gt=_e[1]*_[1],er=_e[0]*_[0],Yr=ct?Gt:pt,It=ct?pt:Gt,en=Yr/_e[0],wn=pt/_e[1];if(!((ct&&en===4&&_[1]===4||!ct&&(en===3||en===4))&&Yr%_e[0]===0&&pt%_e[1]===0&&_[0]===4))throw new Error(`If transposeA ${ct} is true, innerElementSize ${en} and workPerThread[1] ${_[1]} must be 4.
      Otherwise, innerElementSize ${en} must be 3 or 4.
  tileAWidth ${Yr} must be divisible by workgroupSize[0]${_e[0]}. tileInner ${pt} must be divisible by workgroupSize[1] ${_e[1]}. colPerThread ${_[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${en}<${it}>, ${Yr/en}>, ${It}>;
var<workgroup> mm_Bsub: array<array<vec4<${it}>, ${er/_[0]}>, ${pt}>;

const rowPerThread = ${_[1]};
const colPerThread = ${_[0]};
const innerElementSize = ${en};
const tileInner = ${pt};

@compute @workgroup_size(${_e[0]}, ${_e[1]}, ${_e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${ft?"0":"i32(globalId.z)"};
  ${ut?`let batchIndices = ${ut.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${Gt};

  let num_tiles = ${ft?`${Math.ceil(Bt/pt)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${ft?`i32(globalId.z) * ${Bt}`:"0"};

  var acc: array<vec4<${it}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${wn};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Zx(ct,ut)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${wn}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${ut?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${en===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Jx(ct,en)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},zv=(_,_e)=>_?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${_e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${_e?", batchIndices":""});
            `,eT=_=>_?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",R1=(_,_e,it="f32",ut,ct=!1,pt=32,ft=!1,Bt=32,Gt=!1)=>{let er=_[1]*_e[1],Yr=_[0]*_e[0],It=ct?er:pt,en=ct?pt:er;if(!(en%_e[1]===0&&It%_e[0]===0&&pt%_e[1]===0))throw new Error(`tileAHight ${en} must be divisible by workgroupSize[1]${_e[1]}, tileAWidth ${It} must be divisible by workgroupSize[0]${_e[0]}, tileInner ${pt} must be divisible by workgroupSize[1]${_e[1]}`);let wn=en/_e[1],_o=It/_e[0],vn=pt/_e[1],Ws=Gt?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${er};
    let globalColStart = i32(workgroupId.x) * ${Yr};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${en}; inputRow = inputRow + ${_e[1]}) {
        for (var inputCol = localCol; inputCol < ${It}; inputCol = inputCol + ${_e[0]}) {
          ${zv(ct,ut)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${pt}; inputRow = inputRow + ${_e[1]}) {
            for (var inputCol = localCol; inputCol < ${Yr}; inputCol = inputCol + ${_e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${ut?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${it}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${_e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${ct?`mm_Asub[k][localRow + innerRow * ${_e[1]}];`:`mm_Asub[localRow + innerRow * ${_e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${_e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${_e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${er};

let tileRowA = i32(localId.y) * ${wn};
let tileColA = i32(localId.x) * ${_o};
let tileRowB = i32(localId.y) * ${vn};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${wn}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${_o}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${zv(ct,ut)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${vn}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${ut?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${it}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${eT(ct)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${it}, ${It}>, ${en}>;
  var<workgroup> mm_Bsub : array<array<${it}, ${Yr}>, ${pt}>;
  const rowPerThread = ${_[1]};
  const colPerThread = ${_[0]};
  const tileInner = ${pt};

@compute @workgroup_size(${_e[0]}, ${_e[1]}, ${_e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${ft?"0":"i32(globalId.z)"};
    ${ut?`let batchIndices = ${ut.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${ft?`${Math.ceil(Bt/pt)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${ft?`i32(globalId.z) * ${Bt}`:"0"};

    var acc : array<array<${it}, colPerThread>, rowPerThread>;
    ${Ws}
  }
`},tT=(_,_e,it,ut,ct,pt=!1)=>{let[ft,Bt,Gt]=ct,[er,Yr,It,en]=ut,wn=Nu(ft,Gt),_o=Nu(Bt,Gt),vn=jy(ut[0].type.tensor),Ws=()=>{let So=Yr.rank,xa=er.rank,$a=`var aIndices: ${Yr.type.indices};`;for(let gu=So-2-1,u_=xa-1;gu>=0;gu--,u_--)$a+=`
aIndices[${gu}] = ${xa>1?`batchIndices[${u_}]`:"batchIndices"};`;return wn.forEach(gu=>{$a+=`
aIndices[${gu}] = 0;`}),$a+=`
aIndices[${So-2}] = u32(row);
                   aIndices[${So-1}] = u32(colIn);`,$a},Jo=()=>{let So=It.rank,xa=er.rank,$a=`var bIndices: ${It.type.indices};`;for(let gu=So-2-1,u_=xa-1;gu>=0;gu--,u_--)$a+=`
bIndices[${gu}] = ${xa>1?`batchIndices[${u_}]`:"batchIndices"};`;return _o.forEach(gu=>{$a+=`
bIndices[${gu}] = 0;`}),$a+=`
bIndices[${So-2}] = u32(row);
                   bIndices[${So-1}] = u32(colIn);`,$a};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${er.type.indices}) -> ${W0(_,vn)} {
      var value = ${W0(_,vn)}(0.0);
      let col = colIn * ${_};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${Ws()}
        value = ${Yr.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${er.type.indices}) -> ${W0(_,vn)} {
      var value = ${W0(_,vn)}(0.0);
      let col = colIn * ${_};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${Jo()}
        value = ${It.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${W0(_,vn)}) {
      let col = colIn * ${_};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${_e?`value = value + ${pt?"bias[colIn]":`${W0(_,vn)}(bias[row])`};`:""}
        ${it}
        ${en.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Nv=(_,_e,it,ut,ct=!1,pt)=>{let ft=_[0].dims,Bt=_[1].dims,Gt=ft.slice(0,-2),er=Bt.slice(0,-2),Yr=ut?ut.slice(0,-2):it.slice(0,-2),It=Uu.size(Yr),en=ft[ft.length-2],wn=ft[ft.length-1],_o=Bt[Bt.length-1],vn=wn%4===0&&_o%4===0,Ws=en<=8?[4,1,1]:[4,4,1],Jo=[8,8,1],So=[Math.ceil(_o/Jo[0]/Ws[0]),Math.ceil(en/Jo[1]/Ws[1]),Math.ceil(It/Jo[2]/Ws[2])],xa=vn?4:1,$a=[...Gt,en,wn/xa],gu=$a.length,u_=[...er,wn,_o/xa],c_=u_.length,R_=[It,en,_o/xa],ny=[{type:6,data:en},{type:6,data:_o},{type:6,data:wn}];Xw(_e,ny),ny.push(...U_(Yr,$a,u_));let ty=["rank","rank"],Ly=_.length>2;Ly&&(ny.push(...U_(_[2].dims)),ty.push("rank")),ny.push(...U_(R_));let ky=Wy=>{let t0=Yr.length,Uy=Xo("batchDims",_[0].dataType,t0,1),dy=jy(_[0].dataType),r0=v_("a",_[0].dataType,gu,xa),d0=v_("b",_[1].dataType,c_,xa),gy=Xr("result",_[0].dataType,R_.length,xa),Vy=[r0,d0];if(Ly){let w0=ct?xa:1;Vy.push(v_("bias",_[2].dataType,_[2].dims.length,w0))}let x_=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Rw(_e,x_);let G_=jy(gy.type.tensor),By=qw(_e,gy.type.value,G_),b0=tT(xa,Ly,By,[Uy,r0,d0,gy],[Gt,er,Yr],ct);return`
  ${Wy.registerUniforms(x_).registerInternalVariables(Uy).declareVariables(...Vy,gy)}
  ${b0}
  ${vn?av(Ws,Jo,dy,Uy):R1(Ws,Jo,dy,Uy)}
                   `};return{name:"MatMul",shaderCache:{hint:`${Ws};${_e.activation};${vn};${ct}`,inputDependencies:ty},getRunData:()=>({outputs:[{dims:pt?pt(it):it,dataType:_[0].dataType}],dispatchGroup:{x:So[0],y:So[1],z:So[2]},programUniforms:ny}),getShaderSource:ky}}}),rT,nT,u1=$(()=>{ly(),R0(),n_(),Yw(),iv(),Qx(),L1(),rT=(_,_e,it,ut,ct=!1,pt,ft=4,Bt=4,Gt=4,er="f32")=>{let Yr=ny=>{switch(ny){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${er}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${ny} is not supported.`)}},It=ny=>{switch(ny){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${ny} is not supported.`)}},en=_?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,wn=_?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,_o=_?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",vn=_?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Ws=_?"row":"col",Jo=_?"col":"row",So=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${_?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${Ws} / outWidth;
    let outCol = ${Ws} % outWidth;

    let WRow = ${Jo} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${Jo} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${Jo} % inChannels;
    var resData = ${W0(ft,er)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${_o} && xCol >= 0 && xCol < ${vn}) {
      ${en}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${Yr(ft)}
    }
    return resData;`,xa=_?_e&&ut?`
    let col = colIn * ${ft};
    ${So}`:`
    let col = colIn * ${ft};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${So}
    }
    return ${W0(ft,er)}(0.0);`:ut&&it?`
    let col = colIn * ${ft};
    ${So}`:`
    let col = colIn * ${ft};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${So}
    }
    return ${W0(ft,er)}(0.0);`,$a=`${It(Bt)}`,gu=W0(Gt,er),u_=W0(_?ft:Bt,er),c_=W0(_?Bt:ft,er),R_=qw(pt,gu,er);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${u_} {
      ${_?xa:$a}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${c_} {
      ${_?$a:xa}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${gu}) {
      let col = colIn * ${Gt};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${_?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${wn}
      ${jv(ct)}
      ${R_}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},nT=(_,_e,it,ut,ct,pt,ft,Bt,Gt)=>{let er=_e.format==="NHWC",Yr=er?_[0].dims[3]:_[0].dims[1],It=it[0],en=er?it[2]:it[3],wn=er?it[1]:it[2],_o=er?it[3]:it[1],vn=er&&(Yr%4===0||Yr%3===0)&&_o%4===0,Ws=er?_o:en*wn,Jo=er?en*wn:_o,So=[8,8,1],xa=ut<=8?[4,1,1]:[4,4,1],$a=[Math.ceil(Ws/So[0]/xa[0]),Math.ceil(Jo/So[1]/xa[1]),Math.ceil(It/So[2]/xa[2])];Jy("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${$a}`);let gu=vn?er&&Yr%4!==0?3:4:1,u_=So[1]*xa[1],c_=So[0]*xa[0],R_=Math.max(So[0]*gu,So[1]),ny=ut%u_===0,ty=ct%c_===0,Ly=pt%R_===0,ky=vn?[gu,4,4]:[1,1,1],Wy=[{type:6,data:ut},{type:6,data:ct},{type:6,data:pt},{type:6,data:[_e.pads[0],_e.pads[1]]},{type:6,data:_e.strides},{type:6,data:_e.dilations}];Xw(_e,Wy),Wy.push(...U_(_[0].dims,_[1].dims));let t0=["rank","rank"];ft&&(Wy.push(...U_(_[2].dims)),t0.push("rank")),Wy.push(...U_(it));let Uy=dy=>{let r0=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Rw(_e,r0);let d0=vn?4:1,gy=jy(_[0].dataType),Vy=`
      fn setOutputAtIndex(flatIndex : i32, value : ${vn?`vec4<${gy}>`:gy}) {
        result[flatIndex] = ${vn?`vec4<${gy}>`:gy}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${vn?`vec4<${gy}>`:gy}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${vn?"/ 4":""}, value);
      }`,x_=v_("x",_[0].dataType,_[0].dims.length,gu===3?1:gu),G_=v_("w",_[1].dataType,_[1].dims.length,d0),By=[x_,G_],b0=Xr("result",_[0].dataType,it.length,d0);if(ft){let w0=v_("bias",_[2].dataType,_[2].dims.length,d0);By.push(w0),Vy+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${vn?`vec4<${gy}>`:gy} {
          return bias[coords.${er?"w":"y"}${vn?"/ 4":""}];
        }`}return`
        ${sv("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${dy.registerUniforms(r0).declareVariables(...By,b0)}
        ${Vy}
        ${rT(er,ny,ty,Ly,ft,_e,ky[0],ky[1],ky[2],gy)}
        ${vn?av(xa,So,gy,void 0,!er,R_):R1(xa,So,gy,void 0,!er,R_,!1,void 0,Bt)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${_e.cacheKey};${gu};${vn};${ny};${ty};${Ly};${u_};${c_};${R_}`,inputDependencies:t0},getRunData:()=>({outputs:[{dims:Gt?Gt(it):it,dataType:_[0].dataType}],dispatchGroup:{x:$a[0],y:$a[1],z:$a[2]},programUniforms:Wy}),getShaderSource:Uy}}}),oT,Uv,B1,iT,lv,sT,aT,lT,xE=$(()=>{ly(),R0(),J_(),n_(),Yw(),iv(),oT=_=>{let _e=1;for(let it=0;it<_.length;it++)_e*=_[it];return _e},Uv=_=>typeof _=="number"?[_,_,_]:_,B1=(_,_e)=>_e<=1?_:_+(_-1)*(_e-1),iT=(_,_e,it,ut=1)=>{let ct=B1(_e,ut);return Math.floor((_[0]*(it-1)-it+ct)/2)},lv=(_,_e,it,ut,ct)=>{ct==null&&(ct=iT(_,_e[0],ut[0]));let pt=[0,0,0,it];for(let ft=0;ft<3;ft++)_[ft]+2*ct>=_e[ft]&&(pt[ft]=Math.trunc((_[ft]-_e[ft]+2*ct)/ut[ft]+1));return pt},sT=(_,_e,it,ut,ct,pt,ft,Bt,Gt,er)=>{let Yr,It,en,wn;if(_==="VALID"&&(_=0),typeof _=="number"){Yr={top:_,bottom:_,left:_,right:_,front:_,back:_};let _o=lv([_e,it,ut,1],[Bt,Gt,er],1,[ct,pt,ft],_);It=_o[0],en=_o[1],wn=_o[2]}else if(Array.isArray(_)){if(!_.every((vn,Ws,Jo)=>vn===Jo[0]))throw Error(`Unsupported padding parameter: ${_}`);Yr={top:_[0],bottom:_[1],left:_[2],right:_[3],front:_[4],back:_[5]};let _o=lv([_e,it,ut,1],[Bt,Gt,er],1,[ct,pt,ft],_[0]);It=_o[0],en=_o[1],wn=_o[2]}else if(_==="SAME_UPPER"){It=Math.ceil(_e/ct),en=Math.ceil(it/pt),wn=Math.ceil(ut/ft);let _o=(It-1)*ct+Bt-_e,vn=(en-1)*pt+Gt-it,Ws=(wn-1)*ft+er-ut,Jo=Math.floor(_o/2),So=_o-Jo,xa=Math.floor(vn/2),$a=vn-xa,gu=Math.floor(Ws/2),u_=Ws-gu;Yr={top:xa,bottom:$a,left:gu,right:u_,front:Jo,back:So}}else throw Error(`Unknown padding parameter: ${_}`);return{padInfo:Yr,outDepth:It,outHeight:en,outWidth:wn}},aT=(_,_e,it,ut,ct,pt=!1,ft="channelsLast")=>{let Bt,Gt,er,Yr,It;if(ft==="channelsLast")[Bt,Gt,er,Yr,It]=_;else if(ft==="channelsFirst")[Bt,It,Gt,er,Yr]=_;else throw new Error(`Unknown dataFormat ${ft}`);let[en,,wn,_o,vn]=_e,[Ws,Jo,So]=Uv(it),[xa,$a,gu]=Uv(ut),u_=B1(wn,xa),c_=B1(_o,$a),R_=B1(vn,gu),{padInfo:ny,outDepth:ty,outHeight:Ly,outWidth:ky}=sT(ct,Gt,er,Yr,Ws,Jo,So,u_,c_,R_),Wy=pt?en*It:en,t0=[0,0,0,0,0];return ft==="channelsFirst"?t0=[Bt,Wy,ty,Ly,ky]:ft==="channelsLast"&&(t0=[Bt,ty,Ly,ky,Wy]),{batchSize:Bt,dataFormat:ft,inDepth:Gt,inHeight:er,inWidth:Yr,inChannels:It,outDepth:ty,outHeight:Ly,outWidth:ky,outChannels:Wy,padInfo:ny,strideDepth:Ws,strideHeight:Jo,strideWidth:So,filterDepth:wn,filterHeight:_o,filterWidth:vn,effectiveFilterDepth:u_,effectiveFilterHeight:c_,effectiveFilterWidth:R_,dilationDepth:xa,dilationHeight:$a,dilationWidth:gu,inShape:_,outShape:t0,filterShape:_e}},lT=(_,_e,it,ut,ct,pt)=>{let ft=pt==="channelsLast";ft?_[0].dims[3]:_[0].dims[1];let Bt=[64,1,1],Gt={x:it.map((Ws,Jo)=>Jo)},er=[Math.ceil(oT(Gt.x.map(Ws=>it[Ws]))/Bt[0]),1,1];Jy("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${er}`);let Yr=1,It=Uu.size(it),en=[{type:12,data:It},{type:12,data:ut},{type:12,data:ct},{type:12,data:_e.strides},{type:12,data:_e.dilations}];Xw(_e,en),en.push(...U_(_[0].dims,_[1].dims));let wn=["rank","rank"],_o=_.length===3;_o&&(en.push(...U_(_[2].dims)),wn.push("rank")),en.push(...U_(it));let vn=Ws=>{let Jo=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:ut.length},{name:"pads",type:"u32",length:ct.length},{name:"strides",type:"u32",length:_e.strides.length},{name:"dilations",type:"u32",length:_e.dilations.length}];Rw(_e,Jo);let So=1,xa=jy(_[0].dataType),$a=v_("x",_[0].dataType,_[0].dims.length,Yr),gu=v_("W",_[1].dataType,_[1].dims.length,So),u_=[$a,gu],c_=Xr("result",_[0].dataType,it.length,So),R_="";if(_o){let Ly=v_("bias",_[2].dataType,_[2].dims.length,So);u_.push(Ly),R_+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${xa} {
          return bias[${ft?X_("coords",4,5):X_("coords",1,5)}];
        }`}let ny=W0(Yr,xa),ty=qw(_e,ny,xa);return`
            ${R_}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${$a.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${gu.getByIndices("aIndices")};
            }
          ${Ws.registerUniforms(Jo).declareVariables(...u_,c_)}
          ${Ws.mainStart()}
          ${Ws.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${c_.offsetToIndices("global_idx")};
              let batch = ${X_("coords",0,$a.rank)};
              let d2 = ${ft?X_("coords",$a.rank-1,$a.rank):X_("coords",1,$a.rank)};
              let xFRCCorner = vec3<u32>(${ft?X_("coords",1,$a.rank):X_("coords",2,$a.rank)},
              ${ft?X_("coords",2,$a.rank):X_("coords",3,$a.rank)},
              ${ft?X_("coords",3,$a.rank):X_("coords",4,$a.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${ft?X_("uniforms.x_shape",1,$a.rank):X_("uniforms.x_shape",2,$a.rank)};
              let xShapeZ = ${ft?X_("uniforms.x_shape",2,$a.rank):X_("uniforms.x_shape",3,$a.rank)};
              let xShapeW = ${ft?X_("uniforms.x_shape",3,$a.rank):X_("uniforms.x_shape",4,$a.rank)};
              let xShapeU = ${ft?X_("uniforms.x_shape",4,$a.rank):X_("uniforms.x_shape",1,$a.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${ft?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${ft?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${ft?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${ft?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${_o?"value = value + getBiasByOutputCoords(coords)":""};
              ${ty}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${_e.cacheKey};${ft};${Yr};${_o}`,inputDependencies:wn},getRunData:()=>({outputs:[{dims:it,dataType:_[0].dataType}],dispatchGroup:{x:er[0],y:er[1],z:er[2]},programUniforms:en}),getShaderSource:vn}}}),uv,uT,TE=$(()=>{ly(),J_(),n_(),Yw(),uv=(_,_e,it,ut)=>{let ct=_.length>2,pt=ct?"value += b[output_channel];":"",ft=_[0].dims,Bt=_[1].dims,Gt=_e.format==="NHWC",er=Gt?it[3]:it[1],Yr=er/_e.group,It=Gt&&Yr>=4?_y(er):1,en=Uu.size(it)/It,wn=[{type:12,data:en},{type:12,data:_e.dilations},{type:12,data:[_e.strides[0],_e.strides[1]]},{type:12,data:[_e.pads[0],_e.pads[1]]},{type:12,data:Yr}];Xw(_e,wn),wn.push(...U_(ft,[Bt[0],Bt[1],Bt[2],Bt[3]/It]));let _o=ct?["rank","rank","rank"]:["rank","rank"];wn.push(...U_([it[0],it[1],it[2],it[3]/It]));let vn=Ws=>{let Jo=Xr("output",_[0].dataType,it.length,It),So=jy(Jo.type.tensor),xa=qw(_e,Jo.type.value,So),$a=v_("x",_[0].dataType,ft.length),gu=v_("w",_[1].dataType,Bt.length,It),u_=[$a,gu];ct&&u_.push(v_("b",_[2].dataType,_[2].dims,It));let c_=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:_e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Rw(_e,c_);let R_=Gt?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${$a.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${gu.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${$a.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${gu.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${Ws.registerUniforms(c_).declareVariables(...u_,Jo)}

  ${Ws.mainStart()}
    ${Ws.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${Jo.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${Gt?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${Gt?1:2}], outputIndices[${Gt?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${It} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${Gt?2:1}];

    var value: ${Jo.type.value} = ${Jo.type.value}(0);
    ${R_}
    ${pt}
    ${xa}
    ${Jo.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${_e.cacheKey}_${It}`,inputDependencies:_o},getRunData:()=>({outputs:[{dims:ut?ut(it):it,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(en/64)},programUniforms:wn}),getShaderSource:vn}},uT=(_,_e,it,ut)=>{let ct=_.length>2,pt=_y(it[3]),ft=_y(it[2]),Bt=Uu.size(it)/pt/ft,Gt=[_[0].dims[0],_[0].dims[1],_[0].dims[2],_[0].dims[3]/pt],er=[_[1].dims[0],_[1].dims[1],_[1].dims[2],_[1].dims[3]/pt],Yr=[it[0],it[1],it[2],it[3]/pt],It=[{type:12,data:Bt},{type:6,data:[_e.strides[0],_e.strides[1]]},{type:6,data:[_e.pads[0],_e.pads[1]]}];Xw(_e,It),It.push(...U_(Gt,er,Yr));let en=(ft-1)*_e.strides[1]+er[1],wn=_o=>{let vn=Xr("output",_[0].dataType,Yr.length,pt),Ws=jy(vn.type.tensor),Jo=qw(_e,vn.type.value,Ws),So=v_("x",_[0].dataType,Gt.length,pt),xa=v_("w",_[1].dataType,er.length,pt),$a=[So,xa];ct&&$a.push(v_("b",_[2].dataType,_[2].dims,pt));let gu=ct?"value += b[output_channel];":"",u_=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Rw(_e,u_),`
  ${_o.registerUniforms(u_).declareVariables(...$a,vn)}
  ${_o.mainStart()}
    ${_o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${ft}u;
    let col = (index1 % width1) * ${ft}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${So.type.value}, ${en}>;
    var values: array<${vn.type.value}, ${ft}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${er[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${en}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${So.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${So.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${er[1]}; w_width++) {
          let w_val = ${xa.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${ft}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${ft}u; i++) {
      var value = values[i];
      ${gu}
      ${Jo}
      ${vn.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${_e.cacheKey};${pt};${ft};${en};${er[0]};${er[1]}`,inputDependencies:ct?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:ut?ut(it):it,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(Bt/64)},programUniforms:It}),getShaderSource:wn}}}),Wv,j1,cT,dT=$(()=>{ly(),J_(),L1(),n_(),Yw(),Wv=(_,_e,it,ut,ct=!1,pt)=>{let ft=_[0].dims,Bt=_[1].dims,Gt=ft[ft.length-2],er=Bt[Bt.length-1],Yr=ft[ft.length-1],It=_y(er),en=_y(Yr),wn=_y(Gt),_o=Uu.size(it)/It/wn,vn=_.length>2,Ws=ut?ut.slice(0,-2):it.slice(0,-2),Jo=[Uu.size(Ws),Gt,er],So=[{type:12,data:_o},{type:12,data:Gt},{type:12,data:er},{type:12,data:Yr}];Xw(_e,So),So.push(...U_(Ws,ft,Bt)),vn&&So.push(...U_(_[2].dims)),So.push(...U_(Jo));let xa=$a=>{let gu=Xo("batch_dims",_[0].dataType,Ws.length),u_=v_("a",_[0].dataType,ft.length,en),c_=v_("b",_[1].dataType,Bt.length,It),R_=Xr("output",_[0].dataType,Jo.length,It),ny=jy(R_.type.tensor),ty=qw(_e,R_.type.value,ny),Ly=[u_,c_],ky="";if(vn){let Vy=ct?It:1;Ly.push(v_("bias",_[2].dataType,_[2].dims.length,Vy)),ky=`${ct?`value += bias[col / ${Vy}];`:`value += ${R_.type.value}(bias[row + i]);`}`}let Wy=ft.slice(0,-2),t0=Bt.slice(0,-2),Uy=Nu(Wy,Ws),dy=Nu(t0,Ws),r0=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Rw(_e,r0);let d0=(Vy,x_)=>{let G_=Vy.rank,By=Vy.name;if(G_===2)return`var ${By}_indices = ${Vy.type.indices}(0u, 0u);`;let b0=gu.rank,w0=`var ${By}_indices: ${Vy.type.indices};`;for(let Bw=G_-2-1,Jw=b0-1;Bw>=0;Bw--,Jw--)w0+=`
${By}_indices[${Bw}] = ${b0>1?`batch_indices[${Jw}]`:"batch_indices"};`;return x_.forEach(Bw=>{w0+=`
${By}_indices[${Bw}] = 0;`}),w0+=`${By}_indices[${G_-2}] = 0u;
                     ${By}_indices[${G_-1}] = 0u;`,w0},gy=()=>{let Vy=`var a_data: ${u_.type.value};`;for(let x_=0;x_<en;x_++)Vy+=`
              let b_data${x_} = b[(b_offset + (k + ${x_}) * uniforms.N + col) / ${It}];`;for(let x_=0;x_<wn;x_++){Vy+=`a_data = a[(a_offset + (row + ${x_}) * uniforms.K + k) / ${en}];`;for(let G_=0;G_<en;G_++)Vy+=`
            values[${x_}] = fma(${c_.type.value}(a_data${en===1?"":`[${G_}]`}), b_data${G_}, values[${x_}]);
`}return Vy};return`
  ${$a.registerUniforms(r0).registerInternalVariables(gu).declareVariables(...Ly,R_)}
  ${$a.mainStart()}
    ${$a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${It})) * ${It};
    var index1 = global_idx / (uniforms.N / ${It});
    let stride1 = uniforms.M / ${wn};
    let row = (index1 % stride1) * ${wn};
    let batch = index1 / stride1;

    ${it.length===2?"":`let batch_indices = ${gu.offsetToIndices("batch")};`}
    ${d0(u_,Uy)}
    let a_offset = ${u_.indicesToOffset("a_indices")};
    ${d0(c_,dy)}
    let b_offset = ${c_.indicesToOffset("b_indices")};
    var values: array<${R_.type.value}, ${wn}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${en}) {
      ${gy()}
    }
    for (var i = 0u; i < ${wn}u; i++) {
      var value = values[i];
      ${ky}
      ${ty}
      let cur_indices = ${R_.type.indices}(batch, row + i, col);
      let offset = ${R_.indicesToOffset("cur_indices")};
      ${R_.setByOffset(`offset / ${It}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${_e.activation};${It};${en};${wn};${ct}`,inputDependencies:vn?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:pt?pt(it):it,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(_o/64)},programUniforms:So}),getShaderSource:xa}},j1=_=>{if(!_||_.length!==2)throw new Error("MatMul requires 2 inputs.");if(_[0].dims[_[0].dims.length-1]!==_[1].dims[_[1].dims.length-2])throw new Error("shared dimension does not match.")},cT=_=>{j1(_.inputs);let _e=h0.calcShape(_.inputs[0].dims,_.inputs[1].dims,!0);if(!_e)throw new Error("Can't use matmul on the given tensors");let it=_e[_e.length-1],ut=_.inputs[0].dims[_.inputs[0].dims.length-1];it<8&&ut<8?_.compute(Wv(_.inputs,{activation:""},_e)):_.compute(Nv(_.inputs,{activation:""},_e))}}),pT,cv,dv,pv,Vv,Kv,EE,fT,Gv,$E=$(()=>{J_(),u1(),xE(),L1(),TE(),Yw(),dT(),$y(),pT=(_,_e,it,ut,ct,pt)=>{let ft=_[0],Bt=_.slice(pt?1:2,pt?3:4),Gt=Bt.length,er=_e[0],Yr=_e.slice(2).map((en,wn)=>en+(en-1)*(it[wn]-1)),It=Bt.map((en,wn)=>en+ut[wn]+ut[wn+Gt]).map((en,wn)=>Math.floor((en-Yr[wn]+ct[wn])/ct[wn]));return It.splice(0,0,ft),It.splice(pt?3:1,0,er),It},cv=[2,3,1,0],dv=(_,_e)=>{if(!_||_.length!==2&&_.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(_[0].dims.length>5)throw new Error("greater than 5D is not supported");if(_[0].dims.length!==_[1].dims.length)throw new Error("filter does not have same dimension as input");let it=_[0].dims[_e.format==="NHWC"?_[0].dims.length-1:1],ut=_[1].dims[1]*_e.group;if(it!==ut)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(_.length===3&&(_[2].dims.length!==1||_[1].dims[0]!==_[2].dims[0]))throw new Error("invalid bias");let ct=_[0].dims.length-2;if(_e.dilations.length!==ct)throw new Error(`dilations should be ${ct}D`);if(_e.strides.length!==ct)throw new Error(`strides should be ${ct}D`);if(_e.pads.length!==ct*2)throw new Error(`pads should be ${ct*2}D`);if(_e.kernelShape.length!==0&&_e.kernelShape.length!==_[1].dims.length-2)throw new Error("invalid kernel shape")},pv=(_,_e)=>{let it=_.kernelShape.slice();for(let pt=2;pt<_e[1].dims.length;++pt)it[pt-2]===0&&(it[pt-2]=_e[1].dims[pt]);let ut=_.pads.slice();g0.adjustPadsBasedOnAutoPad(_e[0].dims,_.strides,_.dilations,it,ut,_.format==="NHWC",_.autoPad);let ct=Object.assign({},_);return Object.assign(ct,{kernelShape:it,pads:ut}),ct},Vv=_=>{let _e=Bv(_),it=_.format,ut=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][_.auto_pad],ct=_.dilations,pt=_.group,ft=_.kernel_shape,Bt=_.pads,Gt=_.strides,er=_.w_is_const();return{autoPad:ut,format:it,dilations:ct,group:pt,kernelShape:ft,pads:Bt,strides:Gt,wIsConst:er,..._e,cacheKey:`${_.format};${_e.activation};`}},Kv=(_,_e,it,ut)=>{let ct=it.format==="NHWC",pt=pT(_e[0].dims,_e[1].dims,it.dilations,it.pads,it.strides,ct);if(it.group!==1){let u_=[_e[0]];if(ct){let c_=_.kernelCustomData.wT??_.compute(B0(_e[1],cv),{inputs:[1],outputs:[it.wIsConst?-2:-1]})[0];it.wIsConst&&!_.kernelCustomData.wT&&(_.kernelCustomData.wT=c_),u_.push(c_)}else u_.push(_e[1]);_e.length===3&&u_.push(_e[2]),!_.adapterInfo.isArchitecture("ampere")&&ct&&_e[1].dims[0]===it.group&&_e[1].dims[1]===1&&it.dilations[0]===1&&it.dilations[1]===1?_.compute(uT(u_,it,pt,ut),{inputs:u_}):_.compute(uv(u_,it,pt,ut),{inputs:u_});return}let ft=_e.length===3,Bt=_e[0].dims[ct?1:2],Gt=_e[0].dims[ct?2:3],er=_e[0].dims[ct?3:1],Yr=_e[1].dims[2],It=_e[1].dims[3],en=pt[ct?1:2],wn=pt[ct?2:3],_o=pt[ct?3:1],vn=ct&&Yr===Bt&&It===Gt&&it.pads[0]===0&&it.pads[1]===0;if(vn||Yr===1&&It===1&&it.dilations[0]===1&&it.dilations[1]===1&&it.strides[0]===1&&it.strides[1]===1&&it.pads[0]===0&&it.pads[1]===0){let u_=pt[0],c_,R_,ny,ty=[];if(ct){let Wy=_.kernelCustomData.wT??_.compute(B0(_e[1],cv),{inputs:[1],outputs:[it.wIsConst?-2:-1]})[0];if(it.wIsConst&&!_.kernelCustomData.wT&&(_.kernelCustomData.wT=Wy),vn){let t0=Bt*Gt*er;c_=_e[0].reshape([1,u_,t0]),R_=Wy.reshape([1,t0,_o]),ny=[1,u_,_o]}else c_=_e[0].reshape([u_,Bt*Gt,er]),R_=Wy.reshape([1,er,_o]),ny=[u_,en*wn,_o];ty.push(c_),ty.push(R_)}else c_=_e[0].reshape([u_,er,Bt*Gt]),R_=_e[1].reshape([1,_o,er]),ny=[u_,_o,en*wn],ty.push(R_),ty.push(c_);ft&&ty.push(_e[2]);let Ly=ny[2],ky=ty[0].dims[ty[0].dims.length-1];Ly<8&&ky<8?_.compute(Wv(ty,it,pt,ny,ct,ut),{inputs:ty}):_.compute(Nv(ty,it,pt,ny,ct,ut),{inputs:ty});return}let Ws=!0,Jo=_.kernelCustomData.wT??_.compute(B0(_e[1],cv),{inputs:[1],outputs:[it.wIsConst?-2:-1]})[0];it.wIsConst&&!_.kernelCustomData.wT&&(_.kernelCustomData.wT=Jo);let So=[_e[0],Jo];ft&&So.push(_e[2]);let xa=ct?en*wn:_o,$a=ct?_o:en*wn,gu=Yr*It*er;_.compute(nT(So,it,pt,xa,$a,gu,ft,Ws,ut),{inputs:So})},EE=(_,_e)=>{let it=_e.format==="NHWC",ut=[_.inputs[0].reshape(it?[_.inputs[0].dims[0],1,_.inputs[0].dims[1],_.inputs[0].dims[2]]:[_.inputs[0].dims[0],_.inputs[0].dims[1],1,_.inputs[0].dims[2]]),_.inputs[1].reshape([_.inputs[1].dims[0],_.inputs[1].dims[1],1,_.inputs[1].dims[2]])];_.inputs.length===3&&ut.push(_.inputs[2]);let ct=[0,_e.pads[0],0,_e.pads[1]],pt=[1].concat(_e.strides),ft=[1].concat(_e.dilations),Bt=[1].concat(_e.kernelShape),Gt=pv({..._e,pads:ct,strides:pt,dilations:ft,kernelShape:Bt},ut);Kv(_,ut,Gt,er=>it?[er[0],er[2],er[3]]:[er[0],er[1],er[3]])},fT=(_,_e,it)=>{let ut=it.format==="NHWC"?"channelsLast":"channelsFirst",ct=pv(it,_e),pt=it.autoPad==="NOTSET"?it.pads:it.autoPad,ft=aT(_e[0].dims,_e[1].dims,it.strides,it.dilations,pt,!1,ut);_.compute(lT(_e,ct,ft.outShape,[ft.filterDepth,ft.filterHeight,ft.filterWidth],[ft.padInfo.front,ft.padInfo.top,ft.padInfo.left],ut))},Gv=(_,_e)=>{if(dv(_.inputs,_e),_.inputs[0].dims.length===3)EE(_,_e);else if(_.inputs[0].dims.length===5)fT(_,_.inputs,_e);else{let it=pv(_e,_.inputs);Kv(_,_.inputs,it)}}}),v1,hT,ME=$(()=>{ly(),R0(),n_(),Yw(),iv(),Qx(),L1(),v1=(_,_e=!1,it,ut,ct=4)=>{let pt=Ws=>{switch(Ws){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${ut}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${Ws} is not supported.`)}},ft=_?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,Bt=_?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,Gt=_?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",er=_?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Yr=_?"row":"col",It=_?"col":"row",en=`
      let inChannels = ${_?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${_?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${Yr} / outWidth;
      let outCol = ${Yr} % outWidth;

      let WRow = ${It} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${It} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${Gt}) || fract(xR) > 0.0) {
        return ${ut}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${er}) || fract(xC) > 0.0) {
        return ${ut}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${It} % inChannels;
      ${ft}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${ct}];`,wn=_?`
      let col = colIn * ${ct};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${en}
      }
      return ${ut}(0.0);`:`
      let col = colIn * ${ct};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${en}
      }
      return ${ut}(0.0);`,_o=`
      let col = colIn * ${ct};
      let inChannels = ${_?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${_?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${pt(ct)}
      }
      return ${ut}(0.0);
      `,vn=qw(it,ut);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${ut} {
    ${_?wn:_o}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${ut} {
    ${_?_o:wn}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${ut}) {
    let col = colIn * ${ct};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${_?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${Bt}
      ${jv(_e)}
      ${vn}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${ct}] = value;
    }
  }`},hT=(_,_e,it,ut,ct,pt,ft,Bt)=>{let Gt=_e.format==="NHWC",er=Gt?_[0].dims[3]:_[0].dims[1],Yr=it[0],It=Gt?it[2]:it[3],en=Gt?it[1]:it[2],wn=Gt?it[3]:it[1],_o=Gt&&er%4===0&&er%3&&wn%4===0,vn=Gt?wn:It*en,Ws=Gt?It*en:wn,Jo=[8,8,1],So=ut<=8?[4,1,1]:[4,4,1],xa=[Math.ceil(vn/Jo[0]/So[0]),Math.ceil(Ws/Jo[1]/So[1]),Math.ceil(Yr/Jo[2]/So[2])];Jy("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${xa}`);let $a=_o?4:1,gu=Math.max(Jo[0]*$a,Jo[1]),u_=_o?4:1,c_=[_e.kernelShape[Gt?1:2],_e.kernelShape[Gt?2:3]],R_=[c_[0]+(_e.dilations[0]<=1?0:(c_[0]-1)*(_e.dilations[0]-1)),c_[1]+(_e.dilations[1]<=1?0:(c_[1]-1)*(_e.dilations[1]-1))],ny=[R_[0]-1-Math.floor((_e.pads[0]+_e.pads[2])/2),R_[1]-1-Math.floor((_e.pads[1]+_e.pads[3])/2)],ty=[{type:6,data:ut},{type:6,data:ct},{type:6,data:pt},{type:6,data:_e.strides},{type:6,data:_e.dilations},{type:6,data:c_},{type:6,data:ny}];Xw(_e,ty),ty.push(...U_(_[0].dims,_[1].dims));let Ly=["rank","rank"];ft&&(ty.push(...U_(_[2].dims)),Ly.push("rank")),ty.push(...U_(it));let ky=Wy=>{let t0=v_("x",_[0].dataType,_[0].dims.length,u_),Uy=v_("w",_[1].dataType,_[1].dims.length,1),dy=Xr("result",_[0].dataType,it.length,u_),r0=[t0,Uy],d0="";if(ft){let x_=v_("bias",_[2].dataType,_[2].dims.length,u_);r0.push(x_),d0+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${x_.type.value} {
            return bias[coords.${Gt?"w":"y"}${_o?"/ 4":""}];
          }`}let gy=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:c_.length},{name:"pads",type:"i32",length:ny.length}];Rw(_e,gy);let Vy=jy(_[0].dataType,1);if(Vy!=="f16"&&Vy!=="f32")throw new Error(`elemType ${Vy} is not supported.`);return`
        ${sv("uniforms.result_strides")}
        ${Wy.registerUniforms(gy).declareVariables(...r0,dy)};
        ${d0}
        ${v1(Gt,ft,_e,t0.type.value,$a)}
        ${_o?av(So,Jo,Vy,void 0,!Gt,gu):R1(So,Jo,Vy,void 0,!Gt,gu,!1,void 0,Bt)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${_e.cacheKey};${So};${Jo};${_o}`,inputDependencies:Ly},getRunData:()=>({outputs:[{dims:it,dataType:_[0].dataType}],dispatchGroup:{x:xa[0],y:xa[1],z:xa[2]},programUniforms:ty}),getShaderSource:ky}}}),_T,Hv,PE=$(()=>{ly(),R0(),J_(),n_(),_T=(_,_e,it,ut,ct,pt=!1,ft,Bt,Gt=!1)=>{let er=Gt?1:2,Yr=Gt?2:3,It=Gt?3:1,en=pt?2:1,wn=`
  fn setOutputAtIndex(flatIndex : u32, value : ${pt?`vec4<${ft}>`:ft}) {
    result[flatIndex] = ${pt?`vec4<${ft}>`:ft}(value);
  }`;ut&&(wn+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${pt?`vec4<${ft}>`:ft} {
      return bias[coords.${Gt?"w":"y"}${pt?"/ 4":""}];
    }`);let _o=pt?4:1,vn=v_("W",_e[1].dataType,_e[1].dims.length,_o),Ws=v_("Dy",_e[0].dataType,_e[0].dims.length,_o),Jo=[Ws,vn];ut&&Jo.push(v_("bias",_e[2].dataType,[it[It]].length,_o));let So=Xr("result",_e[0].dataType,it.length,_o),xa=`{
        let batch: u32 = ${ct?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${ct?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${ct?"global_id.y":"workgroup_id.y"} * ${en};
        let d1: u32 = ${ct?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${ft}>, ${en}>;
        for (var i = 0; i < ${en}; i++) {
          dotProd[i] = vec4<${ft}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${ft}(dyCorner.x) + ${ft}(wR)) / ${ft}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${ft}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${ft}(dyCorner.y) + ${ft}(wC)) / ${ft}(uniforms.strides.y);
            let dyC2 = (${ft}(dyCorner.y) + 1.0 + ${ft}(wC)) / ${ft}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${ft}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${ft}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Ws.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${ft}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Ws.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${ft}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${It}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Ws.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${ft}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${vn.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Ws.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${ft}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${en}; i = i + 1) {
          let value = dotProd[i] + ${ut?"bias[c+i]":`vec4<${ft}>(0.0)`};
          ${So.set("batch","r","c + i","d1","value")};
        }
      }`,$a=`
          let outputIndices = ${So.offsetToIndices("global_idx")};
          let batch = ${So.indicesGet("outputIndices",0)};
          let d1 = ${So.indicesGet("outputIndices",It)};
          let r = ${So.indicesGet("outputIndices",er)};
          let c = ${So.indicesGet("outputIndices",Yr)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${ft}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${ft}(dyRCorner) + ${ft}(wR)) / ${ft}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${ft}(uniforms.Dy_shape[${er}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${ft}(dyCCorner) + ${ft}(wC)) / ${ft}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${ft}(uniforms.Dy_shape[${Yr}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${Gt?Ws.get("batch","idyR","idyC","inputChannel"):Ws.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${vn.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${ut?"bias[d1]":`${ft}(0.0)`};
          ${So.setByOffset("global_idx","value")};
        `;return`
  ${_.registerUniforms(Bt).declareVariables(...Jo,So)}
  ${wn}

    ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${pt?xa:$a}}`},Hv=(_,_e,it)=>{let ut=_.length>2,ct=_e.outputShape,pt=Uu.size(ct),ft=[Math.ceil(pt/64),1,1];Jy("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${ft}`);let Bt=_e.format==="NHWC",Gt=["rank","rank"],er=[_e.strides[0],_e.strides[1]],Yr=[_e.kernelShape[Bt?1:2],_e.kernelShape[Bt?2:3]],It=[_e.dilations[0],_e.dilations[1]],en=[Yr[0]+(_e.dilations[0]<=1?0:(_e.kernelShape[Bt?1:2]-1)*(_e.dilations[0]-1)),Yr[1]+(_e.dilations[1]<=1?0:(_e.kernelShape[Bt?2:3]-1)*(_e.dilations[1]-1))],wn=[en[0]-1-Math.floor((_e.pads[0]+_e.pads[2])/2),en[1]-1-Math.floor(_e.pads[1]+_e.pads[3])/2],_o=!1,vn=_e.group,Ws=_[1].dims,Jo=Ws[0]/vn,So=Ws[1],xa=[{type:12,data:pt},{type:12,data:er},{type:12,data:Yr},{type:12,data:It},{type:12,data:en},{type:6,data:wn},{type:12,data:Jo},{type:12,data:So},...U_(_[0].dims,_[1].dims)];ut&&(xa.push(...U_(_[2].dims)),Gt.push("rank")),xa.push(...U_(ct));let $a=ft[1]===1&&ft[2]===1,gu=u_=>{let c_=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:er.length},{name:"filter_dims",type:"u32",length:Yr.length},{name:"dilations",type:"u32",length:Yr.length},{name:"effective_filter_dims",type:"u32",length:en.length},{name:"pads",type:"i32",length:wn.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],R_=jy(_[0].dataType);return`${_T(u_,_,ct,ut,$a,_o,R_,c_,Bt)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${_e.cacheKey};`,inputDependencies:Gt},getRunData:()=>({dispatchGroup:{x:ft[0],y:ft[1],z:ft[2]},outputs:[{dims:it?it(ct):ct,dataType:_[0].dataType}],programUniforms:xa}),getShaderSource:gu}}}),fv,kE,mT,qv,gT,yT,bT,Xv,wT,vT,xT=$(()=>{ME(),PE(),Yw(),$y(),fv=(_,_e,it,ut,ct,pt)=>(_-1)*_e+it+(ut-1)*ct+1-pt,kE=(_,_e,it,ut,ct)=>{let pt=Math.floor(_/2);_e==="SAME_UPPER"?(it[ut]=pt,it[ct]=_-pt):_e==="SAME_LOWER"&&(it[ut]=_-pt,it[ct]=pt)},mT=(_,_e,it,ut,ct,pt,ft,Bt,Gt,er)=>{let Yr=_.length-2,It=er.length===0;if(Gt.length===0)for(let _o=0;_o<Yr;++_o)Gt.push(0);let en=_[0],wn=_e[Bt?3:1]*ct;for(let _o=0,vn=_.length-Yr-(Bt?1:0);_o<Yr;++_o,++vn){let Ws=_[vn],Jo=It?Ws*ft[_o]:er[_o],So=fv(Ws,ft[_o],pt[_o],_e[vn],it[_o],Jo);kE(So,ut,pt,_o,_o+Yr),It&&er.push(ft[_o]*(Ws-1)+Gt[_o]+(_e[vn]-1)*it[_o]+1-pt[_o]-pt[_o+Yr])}er.splice(0,0,en),er.splice(Bt?3:1,0,wn)},qv=(_,_e)=>{let it=_.kernelShape.slice();if(_.kernelShape.length===0||_.kernelShape.reduce((It,en)=>It*en,1)===0){it.length=0;for(let It=2;It<_e[1].dims.length;++It)it.push(_e[1].dims[It])}let ut=_.format==="NHWC";it.splice(0,0,_e[1].dims[0]),it.splice(ut?3:1,0,_e[1].dims[1]);let ct=_.pads.slice(),pt=_.outputShape.slice(),ft=_.outputPadding.slice(),Bt=_e[0].dims,Gt=_.dilations.slice();if(Gt.reduce((It,en)=>It+en,0)===0){let It=_e[0].dims.length-2;Gt=new Array(It).fill(1)}let er=_.strides.slice();if(er.reduce((It,en)=>It+en,0)===0){let It=_e[0].dims.length-2;er=new Array(It).fill(1)}mT(Bt,it,Gt,_.autoPad,_.group,ct,er,ut,ft,pt);let Yr=Object.assign({},_);return Object.assign(Yr,{kernelShape:it,pads:ct,outputPadding:ft,outputShape:pt,dilations:Gt,strides:er}),Yr},gT=_=>{let _e=Bv(_),it=_.format,ut=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof _.autoPad>"u"?0:_.autoPad],ct=_.dilations,pt=_.group,ft=_.kernelShape,Bt=_.pads,Gt=_.strides,er=_.wIsConst(),Yr=_.outputPadding,It=_.outputShape;return{autoPad:ut,format:it,dilations:ct,group:pt,kernelShape:ft,outputPadding:Yr,outputShape:It,pads:Bt,strides:Gt,wIsConst:er,..._e,cacheKey:`${_.format};${_e.activation};`}},yT=(_,_e)=>{if(!_||_.length!==2&&_.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(_[0].dims.length!==4&&_[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(_[0].dims.length!==_[1].dims.length)throw new Error("filter does not have same dimension as input");let it=_[0].dims[_e.format==="NHWC"?_[0].dims.length-1:1],ut=_[1].dims[0];if(it!==ut)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let ct=_[1].dims[1]*_e.group;if(_.length===3&&(_[2].dims.length!==1||_[2].dims[0]!==ct))throw new Error("invalid bias");let pt=_[0].dims.length-2;if(_e.dilations.reduce((ft,Bt)=>ft+Bt,0)>0&&_e.dilations.length!==pt)throw new Error(`dilations should be ${pt}D`);if(_e.strides.reduce((ft,Bt)=>ft+Bt,0)>0&&_e.strides.length!==pt)throw new Error(`strides should be ${pt}D`);if(_e.pads.reduce((ft,Bt)=>ft+Bt,0)>0&&_e.pads.length!==pt*2)throw new Error(`pads should be ${pt*2}D`);if(_e.outputPadding.length!==pt&&_e.outputPadding.length!==0)throw new Error(`output_padding should be ${pt}D`);if(_e.kernelShape.reduce((ft,Bt)=>ft+Bt,0)>0&&_e.kernelShape.length!==0&&_e.kernelShape.length!==_[1].dims.length-2)throw new Error("invalid kernel shape");if(_e.outputShape.length!==0&&_e.outputShape.length!==_[0].dims.length-2)throw new Error("invalid output shape")},bT=[2,3,1,0],Xv=(_,_e,it)=>{let ut=qv(it,_e),ct=it.format==="NHWC",pt=ut.outputShape,ft=pt[ct?3:1],Bt=_e[0].dims[ct?3:1];if(ut.group!==1||ft===1&&Bt===1){_.compute(Hv(_e,ut));return}let Gt=pt[ct?1:2],er=pt[ct?2:3],Yr=_e[1].dims[2],It=_e[1].dims[3],en=ct?Gt*er:ft,wn=ct?ft:Gt*er,_o=Yr*It*Bt,vn=!0,Ws=_.kernelCustomData.wT??_.compute(B0(_e[1],bT),{inputs:[1],outputs:[it.wIsConst?-2:-1]})[0];it.wIsConst&&!_.kernelCustomData.wT&&(_.kernelCustomData.wT=Ws);let Jo=[_e[0],Ws],So=_e.length===3;So&&(!ct&&_e[2].dims.length===1?Jo.push(_e[2].reshape([_e[2].dims[0],1,1])):Jo.push(_e[2])),_.compute(hT(Jo,ut,pt,en,wn,_o,So,vn),{inputs:Jo})},wT=(_,_e)=>{let it=_e.format==="NHWC",ut=[_.inputs[0].reshape(it?[_.inputs[0].dims[0],1,_.inputs[0].dims[1],_.inputs[0].dims[2]]:[_.inputs[0].dims[0],_.inputs[0].dims[1],1,_.inputs[0].dims[2]]),_.inputs[1].reshape([_.inputs[1].dims[0],_.inputs[1].dims[1],1,_.inputs[1].dims[2]])];_.inputs.length===3&&ut.push(_.inputs[2]);let ct=_e.kernelShape;(ct.length===0||ct[0]===0)&&(ct=[_.inputs[1].dims[2]]);let pt=_e.dilations;(pt.length===0||pt[0]===0)&&(pt=[1]);let ft=_e.strides;(ft.length===0||ft[0]===0)&&(ft=[1]);let Bt=_e.pads;Bt.length===0&&(Bt=[0,0]),Bt=[0,Bt[0],0,Bt[1]],ft=[1].concat(ft),pt=[1].concat(pt),ct=[1].concat(ct);let Gt=qv({..._e,pads:Bt,strides:ft,dilations:pt,kernelShape:ct},ut);_.compute(Hv(ut,Gt,er=>it?[er[0],er[2],er[3]]:[er[0],er[1],er[3]]))},vT=(_,_e)=>{yT(_.inputs,_e),_.inputs[0].dims.length===3?wT(_,_e):Xv(_,_.inputs,_e)}}),TT,ET,Yv,SE=$(()=>{ly(),J_(),Ey(),n_(),TT=(_,_e,it,ut)=>{let ct=Uu.size(_e),pt=_e.length,ft=v_("input",_,pt),Bt=Xr("output",_,pt),Gt=it.dataType===6?it.getInt32Array()[0]:Number(it.getBigInt64Array()[0]),er=Uu.normalizeAxis(Gt,pt),Yr=It=>{let en=` i32(${ft.indicesGet("inputIndices","uniforms.axis")}) `,wn=X_("uniforms.input_shape","uniforms.axis",pt),_o=ut.reverse?en+(ut.exclusive?" + 1":""):"0",vn=ut.reverse?wn:en+(ut.exclusive?"":" + 1");return`
                ${It.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(ft,Bt)}
                ${It.mainStart()}
                  ${It.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${Bt.offsetToIndices("global_idx")};
                  var sum = ${Bt.type.value}(0);
                  let first : i32 = ${_o};
                  let last : i32 = ${vn};
                  for (var i : i32 = first; i < last; i++) {
                    ${ft.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${ft.getByIndices("inputIndices")};
                  }
                  ${Bt.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:ut.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:_e,dataType:_}],dispatchGroup:{x:Math.ceil(ct/64)},programUniforms:[{type:12,data:ct},{type:12,data:er},...U_(_e,_e)]}),getShaderSource:Yr}},ET=(_,_e)=>{let it=_.inputs[0].dims,ut=_.inputs[0].dataType,ct=_.inputs[1];_.compute(TT(ut,it,ct,_e),{inputs:[0]})},Yv=_=>{let _e=_.exclusive===1,it=_.reverse===1;return sy({exclusive:_e,reverse:it})}}),$T,hv,MT,PT,kT,OE=$(()=>{ly(),J_(),Ey(),n_(),$T=_=>{if(!_||_.length!==1)throw new Error("DepthToSpace requires 1 input.");if(_[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},hv=(_,_e,it,ut)=>{let ct=[];ct.push(`fn perm(i: ${ut.type.indices}) -> ${it.type.indices} {
    var a: ${it.type.indices};`);for(let pt=0;pt<_e;++pt)ct.push(it.indicesSet("a",_[pt],`i[${pt}]`));return ct.push("return a;}"),ct.join(`
`)},MT=(_,_e)=>{let it,ut,ct,pt,ft,Bt,Gt=_e.format==="NHWC",er=_e.blocksize,Yr=_e.mode==="DCR";Gt?([it,ut,ct,pt]=_.dims,ft=Yr?[it,ut,ct,er,er,pt/er**2]:[it,ut,ct,pt/er**2,er,er],Bt=Yr?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([it,ut,ct,pt]=[_.dims[0],_.dims[2],_.dims[3],_.dims[1]],ft=Yr?[it,er,er,pt/er**2,ut,ct]:[it,pt/er**2,er,er,ut,ct],Bt=Yr?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let It=_.reshape(ft),en=It.dims.length,wn=_.dataType,_o=v_("a",wn,en),vn=Xr("output",wn,en),Ws=Jo=>`
  ${Jo.registerUniform("output_size","u32").declareVariables(_o,vn)}

  ${hv(Bt,en,_o,vn)}

  ${Jo.mainStart()}
    ${Jo.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${vn.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${vn.setByOffset("global_idx",_o.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${_.dims};${_e.blocksize};${_e.mode}`,inputDependencies:["rank"]},getRunData:Jo=>{let So=Gt?[it,ut*er,ct*er,pt/er**2]:[it,pt/er**2,ut*er,ct*er],xa=Uu.size(So),$a=It.dims,gu=Uu.sortBasedOnPerm($a,Bt);return{outputs:[{dims:So,dataType:Jo[0].dataType}],dispatchGroup:{x:Math.ceil(xa/64)},programUniforms:[{type:12,data:xa},...U_($a,gu)]}},getShaderSource:Ws}},PT=(_,_e)=>{$T(_.inputs),_.compute(MT(_.inputs[0],_e))},kT=_=>sy({blocksize:_.blocksize,mode:_.mode,format:_.format})}),z1,c1,ST,OT,AT,Qv,CT,Zv,Jv,IT,DT,FT=$(()=>{ly(),J_(),Ey(),n_(),z1="[a-zA-Z]|\\.\\.\\.",c1="("+z1+")+",ST="^"+c1+"$",OT="("+c1+",)*"+c1,AT="^"+OT+"$",Qv=class{constructor(_=-1){this.symbolToIndices=new Map,this.inputIndex=_}addSymbol(_,_e){let it=this.symbolToIndices.get(_);it===void 0?it=[_e]:it.push(_e),this.symbolToIndices.set(_,it)}},CT=class{constructor(_,_e){this.equation=_e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[it,ut]=_e.includes("->")?_e.split("->",2):[_e,""];if(!it.match(RegExp(AT)))throw new Error("Invalid LHS term");if(it.split(",").forEach((ct,pt)=>{let ft=_[pt].dims.slice();if(!ct.match(RegExp(ST)))throw new Error("Invalid LHS term");let Bt=this.processTerm(ct,!0,ft,pt);this.lhs.push(Bt)}),ut==="")ut+=[...this.symbolToInfo.entries()].filter(([ct,pt])=>pt.count===1||ct==="...").map(([ct])=>ct).join("");else if(!ut.match(RegExp(c1)))throw new Error("Invalid RHS");ut.match(RegExp(z1,"g"))?.forEach(ct=>{if(ct==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let pt=this.symbolToInfo.get(ct);if(pt===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(pt.dimValue)}}),this.rhs=this.processTerm(ut,!1,this.outputDims)}addSymbol(_,_e,it){let ut=this.symbolToInfo.get(_);if(ut!==void 0){if(ut.dimValue!==_e&&ut.count!==1)throw new Error("Dimension mismatch");ut.count++,ut.inputIndices.push(it)}else ut={count:1,dimValue:_e,inputIndices:[it]};this.symbolToInfo.set(_,ut)}processTerm(_,_e,it,ut=-1){let ct=it.length,pt=!1,ft=[],Bt=0;if(!_.match(RegExp(ST))&&!_e&&_!=="")throw new Error("Invalid LHS term");let Gt=_.match(RegExp(z1,"g")),er=new Qv(ut);return Gt?.forEach((Yr,It)=>{if(Yr==="..."){if(pt)throw new Error("Only one ellipsis is allowed per input term");pt=!0;let en=ct-Gt.length+1;if(en<0)throw new Error("Ellipsis out of bounds");if(ft=it.slice(Bt,Bt+en),this.hasEllipsis){if(this.ellipsisDims.length!==ft.length||this.ellipsisDims.toString()!==ft.toString())throw new Error("Ellipsis dimensions mismatch")}else if(_e)this.hasEllipsis=!0,this.ellipsisDims=ft;else throw new Error("Ellipsis must be specified in the LHS");for(let wn=0;wn<ft.length;wn++){let _o=String.fromCharCode(48+wn);er.addSymbol(_o,It+wn),this.addSymbol(_o,it[Bt++],ut)}}else er.addSymbol(Yr,It+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(Yr,it[Bt++],ut)}),er}},Zv=_=>_+"_max",Jv=(_,_e,it,ut)=>{let ct=_.map(er=>er.length).map((er,Yr)=>v_(`input${Yr}`,_e,er)),pt=Uu.size(ut),ft=Xr("output",_e,ut.length),Bt=[...it.symbolToInfo.keys()].filter(er=>!it.rhs.symbolToIndices.has(er)),Gt=er=>{let Yr=[],It="var prod = 1.0;",en="var sum = 0.0;",wn="sum += prod;",_o=[],vn=[],Ws=[],Jo=[],So=it.symbolToInfo.size===it.rhs.symbolToIndices.size;it.symbolToInfo.forEach(($a,gu)=>{if(it.rhs.symbolToIndices.has(gu)){let u_=it.rhs.symbolToIndices.get(gu)?.[0];u_!==void 0&&it.lhs.forEach((c_,R_)=>{if($a.inputIndices.includes(R_)){let ny=c_.symbolToIndices.get(gu);if(ny===void 0)throw new Error("Invalid symbol error");ny.forEach(ty=>{Yr.push(`${ct[R_].indicesSet(`input${R_}Indices`,ty,ft.indicesGet("outputIndices",u_))}`)})}})}else it.lhs.forEach((u_,c_)=>{if($a.inputIndices.includes(c_)){let R_=u_.symbolToIndices.get(gu);if(R_===void 0)throw new Error("Invalid symbol error");R_.forEach(ny=>{_o.push(`${ct[c_].indicesSet(`input${c_}Indices`,ny,`${gu}`)}`)}),Jo.push(`prod *= ${ct[c_].getByIndices(`input${c_}Indices`)};`)}}),vn.push(`for(var ${gu}: u32 = 0; ${gu} < uniforms.${Zv(gu)}; ${gu}++) {`),Ws.push("}")});let xa=So?[...Yr,`let sum = ${ct.map(($a,gu)=>$a.getByIndices(`input${gu}Indices`)).join(" * ")};`]:[...Yr,en,...vn,..._o,It,...Jo,wn,...Ws];return`
            ${er.registerUniforms(Bt.map($a=>({name:`${Zv($a)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...ct,ft)}

            ${er.mainStart()}
            ${er.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${ft.offsetToIndices("global_idx")};
            ${ct.map(($a,gu)=>`var input${gu}Indices: ${ct[gu].type.indices};`).join(`
`)}
            ${xa.join(`
`)};
            ${ft.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:it.equation,inputDependencies:_.map(()=>"rank")},getRunData:()=>{let er=Bt.filter(It=>it.symbolToInfo.has(It)).map(It=>({type:12,data:it.symbolToInfo.get(It)?.dimValue||0}));er.push({type:12,data:pt});let Yr=_.map((It,en)=>[...U_(It)]).reduce((It,en)=>It.concat(en),er);return Yr.push(...U_(ut)),{outputs:[{dims:ut,dataType:_e}],dispatchGroup:{x:Math.ceil(pt/64)},programUniforms:Yr}},getShaderSource:Gt}},IT=(_,_e)=>{let it=new CT(_.inputs,_e.equation),ut=it.outputDims,ct=_.inputs.map((pt,ft)=>pt.dims);_.compute(Jv(ct,_.inputs[0].dataType,it,ut))},DT=_=>{let _e=_.equation.replace(/\s+/g,"");return sy({equation:_e})}}),AE,RT,ex,tx,LT,CE=$(()=>{ly(),J_(),n_(),AE=_=>{if(!_||_.length!==2)throw new Error("Expand requires 2 input.");let _e=_[0].dims,it=Array.from(_[1].getBigInt64Array(),Number),ut=it.length<_e.length?0:it.length-_e.length,ct=_e.length<it.length?0:_e.length-it.length;for(;ut<it.length&&ct<_e.length;++ut,++ct)if(it[ut]!==_e[ct]&&it[ut]!==1&&_e[ct]!==1)throw new Error("Expand requires shape to be broadcastable to input")},RT=(_,_e)=>{let it=_.length-_e.length,ut=[];for(let ct=0;ct<it;++ct)ut.push(_[ct]);for(let ct=0;ct<_e.length;++ct)ut.push(_e[ct]===1?_[ct+it]:_e[ct]);return ut},ex=(_,_e)=>_.length>_e.length?RT(_,_e):RT(_e,_),tx=_=>{let _e=_[0].dims,it=Array.from(_[1].getBigInt64Array(),Number),ut=ex(_e,it),ct=_[0].dataType,pt=ct===9?4:1,ft=Math.ceil(Uu.size(ut)/pt),Bt=er=>{let Yr=v_("input",ct,_e.length,pt),It=Xr("output",ct,ut.length,pt),en;if(ct===9){let wn=(_o,vn,Ws="")=>`
          let outputIndices${vn} = ${It.offsetToIndices(`outputOffset + ${vn}u`)};
          let offset${vn} = ${Yr.broadcastedIndicesToOffset(`outputIndices${vn}`,It)};
          let index${vn} = offset${vn} / 4u;
          let component${vn} = offset${vn} % 4u;
          ${_o}[${vn}] = ${Ws}(${Yr.getByOffset(`index${vn}`)}[component${vn}]);
        `;en=`
        let outputOffset = global_idx * ${pt};
        var data = vec4<u32>(0);
        ${wn("data",0,"u32")}
        ${wn("data",1,"u32")}
        ${wn("data",2,"u32")}
        ${wn("data",3,"u32")}
        ${It.setByOffset("global_idx","data")}
      }`}else en=`
        let outputIndices = ${It.offsetToIndices("global_idx")};
        let inputOffset = ${Yr.broadcastedIndicesToOffset("outputIndices",It)};
        ${It.setByOffset("global_idx",Yr.getByOffset("inputOffset"))}
      }`;return`
    ${er.registerUniform("vec_size","u32").declareVariables(Yr,It)}
    ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${en}`},Gt=[{type:12,data:ft},...U_(_e,ut)];return{name:"Expand",shaderCache:{hint:`${ut.length}`,inputDependencies:["rank"]},getShaderSource:Bt,getRunData:()=>({outputs:[{dims:ut,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(ft/64)},programUniforms:Gt})}},LT=_=>{AE(_.inputs),_.compute(tx(_.inputs),{inputs:[0]})}}),rx,BT,IE=$(()=>{ly(),J_(),n_(),Cv(),rx=_=>{let _e=_[0].dataType,it=Uu.size(_[0].dims),ut=Uu.size(_[1].dims),ct=ut%4===0,pt=ft=>{let Bt=v_("x",_e,[1],4),Gt=v_("bias",_e,[1],4),er=Xr("y",_e,[1],4),Yr=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],It=wn=>`
      let bias${wn}_offset: u32 = (global_idx * 4 + ${wn}) % uniforms.bias_size;
      let bias${wn} = ${Gt.getByOffset(`bias${wn}_offset / 4`)}[bias${wn}_offset % 4];`,en=ct?`
      let bias = ${Gt.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${It(0)}${It(1)}${It(2)}${It(3)}
      let bias = ${Bt.type.value}(bias0, bias1, bias2, bias3);`;return`${ft.registerUniforms(Yr).declareVariables(Bt,Gt,er)}

    ${Sv(zy(_e))}

    ${ft.mainStart(k0)}
      ${ft.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${Bt.getByOffset("global_idx")};
      ${en}
      let x_in = x + bias;
      ${er.setByOffset("global_idx",nv("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${ct}`,inputDependencies:["type","type"]},getShaderSource:pt,getRunData:ft=>({outputs:[{dims:ft[0].dims,dataType:ft[0].dataType}],programUniforms:[{type:12,data:Math.ceil(it/4)},{type:12,data:ut}],dispatchGroup:{x:Math.ceil(it/k0/4)}})}},BT=_=>{_.inputs.length<2||Uu.size(_.inputs[1].dims)===0?Ax(_):_.compute(rx(_.inputs))}}),nx,jT,zT,ox,DE=$(()=>{ly(),J_(),Ey(),n_(),nx=_=>{if(!_||_.length!==2)throw new Error("Gather requires 2 inputs.")},jT=(_,_e)=>{let it=_[0].dims,ut=_[1].dims,ct=it.length,pt=Uu.normalizeAxis(_e.axis,ct),ft=it.slice(0);ft.splice(pt,1,...ut);let Bt=it[pt],Gt=_[0].dataType===9?4:1,er=Math.ceil(Uu.size(ft)/Gt),Yr=[{type:12,data:er},{type:6,data:Bt},{type:12,data:pt},...U_(_[0].dims,_[1].dims,ft)],It=en=>{let wn=v_("data",_[0].dataType,_[0].dims.length,Gt),_o=v_("inputIndices",_[1].dataType,_[1].dims.length),vn=Xr("output",_[0].dataType,ft.length,Gt),Ws=So=>{let xa=ut.length,$a=`var indicesIndices${So}  = ${_o.type.indices}(0);`;for(let gu=0;gu<xa;gu++)$a+=`${xa>1?`indicesIndices${So}[${gu}]`:`indicesIndices${So}`} = ${ft.length>1?`outputIndices${So}[uniforms.axis + ${gu}]`:`outputIndices${So}`};`;$a+=`
          var idx${So} = ${_o.getByIndices(`indicesIndices${So}`)};
          if (idx${So} < 0) {
            idx${So} = idx${So} + uniforms.axisDimLimit;
          }
          var dataIndices${So} : ${wn.type.indices};
        `;for(let gu=0,u_=0;gu<ct;gu++)gu===pt?($a+=`${ct>1?`dataIndices${So}[${gu}]`:`dataIndices${So}`} = u32(idx${So});`,u_+=xa):($a+=`${ct>1?`dataIndices${So}[${gu}]`:`dataIndices${So}`} = ${ft.length>1?`outputIndices${So}[${u_}]`:`outputIndices${So}`};`,u_++);return $a},Jo;if(_[0].dataType===9){let So=(xa,$a,gu="")=>`
          let outputIndices${$a} = ${vn.offsetToIndices(`outputOffset + ${$a}u`)};
          ${Ws($a)};
          let offset${$a} = ${wn.indicesToOffset(`dataIndices${$a}`)};
          let index${$a} = offset${$a} / 4u;
          let component${$a} = offset${$a} % 4u;
          ${xa}[${$a}] = ${gu}(${wn.getByOffset(`index${$a}`)}[component${$a}]);
        `;Jo=`
        let outputOffset = global_idx * ${Gt};
        var value = vec4<u32>(0);
        ${So("value",0,"u32")}
        ${So("value",1,"u32")}
        ${So("value",2,"u32")}
        ${So("value",3,"u32")}
        ${vn.setByOffset("global_idx","value")}
      `}else Jo=`
      let outputIndices = ${vn.offsetToIndices("global_idx")};
      ${Ws("")};
      let value = ${wn.getByIndices("dataIndices")};
      ${vn.setByOffset("global_idx","value")};
      `;return`
      ${en.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(wn,_o,vn)}
      ${en.mainStart()}
        ${en.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${Jo}
      }`};return{name:"Gather",shaderCache:{hint:_e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:ft,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(er/64)},programUniforms:Yr}),getShaderSource:It}},zT=_=>sy({axis:_.axis}),ox=(_,_e)=>{let it=_.inputs;nx(it),_.compute(jT(_.inputs,_e))}}),NT,UT,WT,a0,O2=$(()=>{ly(),J_(),Ey(),n_(),NT=(_,_e)=>{if(_.length<3||_.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let it=Uu.normalizeAxis(_e.quantizeAxis,_[0].dims.length),ut=_e.blockSize,ct=_[0],pt=_[2],ft=_.length===4?_[3]:void 0;if(pt.dims.length!==ct.dims.length||!ct.dims.map((Bt,Gt)=>Gt===it?Math.ceil(Bt/ut)===pt.dims[Gt]:Bt===pt.dims[Gt]).reduce((Bt,Gt)=>Bt&&Gt,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(ft){if(ft.dataType!==ct.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(ft.dims.length!==pt.dims.length||!ft.dims.map((Bt,Gt)=>Bt===pt.dims[Gt]).reduce((Bt,Gt)=>Bt&&Gt,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},UT=(_,_e)=>{let it=_[0].dims,ut=_[1].dims,ct=it.length,pt=Uu.normalizeAxis(_e.gatherAxis,ct),ft=Uu.normalizeAxis(_e.quantizeAxis,ct),Bt=it.slice(0);Bt.splice(pt,1,...ut);let Gt=Uu.size(Bt),er=_[2].dataType,Yr=_[0].dataType===22,It=[{type:12,data:Gt},{type:12,data:ft},{type:12,data:pt},{type:12,data:_e.blockSize},...U_(..._.map((wn,_o)=>wn.dims),Bt)],en=wn=>{let _o=v_("data",_[0].dataType,_[0].dims.length),vn=v_("inputIndices",_[1].dataType,_[1].dims.length),Ws=v_("scales",_[2].dataType,_[2].dims.length),Jo=_.length>3?v_("zeroPoint",_[3].dataType,_[3].dims.length):void 0,So=Xr("output",er,Bt.length),xa=[_o,vn,Ws];Jo&&xa.push(Jo);let $a=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${wn.registerUniforms($a).declareVariables(...xa,So)}
        ${wn.mainStart()}
        let output_indices = ${So.offsetToIndices("global_idx")};
        var indices_indices = ${vn.type.indices}(0);
        ${ut.length>1?`
          for (var i: u32 = 0; i < ${ut.length}; i++) {
            let index = ${So.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${vn.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${So.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${_o.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${So.indicesGet("output_indices","i")};
          ${_o.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${vn.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${it[pt]};
        }
        ${_o.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${Bt.length}; i++) {
          let index = ${So.indicesGet("output_indices",`i + ${ut.length} - 1`)};
          ${_o.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${_o.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${_o.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${Yr?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${Ws.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${Ws.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${Ws.getByIndices("scale_indices")};
        ${Jo?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${Jo.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${Jo.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${Yr?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${zy(er)}(quantized_data - zero_point) * scale;
        ${So.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${_e.cacheKey};${_.filter((wn,_o)=>_o!==1).map(wn=>wn.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:_.length},(wn,_o)=>"rank")},getRunData:()=>({outputs:[{dims:Bt,dataType:er}],dispatchGroup:{x:Math.ceil(Gt/64)},programUniforms:It}),getShaderSource:en}},WT=(_,_e)=>{let it=_.inputs;NT(it,_e),_.compute(UT(_.inputs,_e))},a0=_=>sy({blockSize:_.blockSize,gatherAxis:_.gatherAxis,quantizeAxis:_.quantizeAxis})}),FE,RE,ix,VT,LE=$(()=>{ly(),J_(),Ey(),n_(),FE=_=>{if(!_||_.length!==2)throw new Error("GatherElements requires 2 inputs.");if(_[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(_[0].dims.length!==_[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},RE=(_,_e)=>{let it=_[0].dims,ut=_[0].dataType,ct=it.length,pt=_[1].dims,ft=_[1].dataType,Bt=Uu.normalizeAxis(_e.axis,ct),Gt=it[Bt],er=pt.slice(0),Yr=Uu.size(er),It=v_("input",ut,ct),en=v_("indicesInput",ft,pt.length),wn=Xr("output",ut,er.length),_o=[{type:12,data:Yr},{type:6,data:Gt},{type:12,data:Bt}];return _o.push(...U_(it,pt,er)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:er,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(Yr/64)},programUniforms:_o}),getShaderSource:vn=>`
      ${vn.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(It,en,wn)}
      ${vn.mainStart()}
      ${vn.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${wn.offsetToIndices("global_idx")};

      var idx = ${en.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${It.type.indices}(outputIndices);
      ${It.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${It.getByIndices("inputIndices")};

      ${wn.setByOffset("global_idx","value")};
  }`}},ix=_=>sy({axis:_.axis}),VT=(_,_e)=>{let it=_.inputs;FE(it),_.compute(RE(_.inputs,_e))}}),KT,GT,sx,ax,BE=$(()=>{ly(),J_(),n_(),KT=_=>{if(!_)throw new Error("Input is missing");if(_.length<2||_.length>3)throw new Error("Invaid input number.");if(_.length===3&&_[2].dims.length>2)throw new Error("Invalid input shape of C");if(_[0].dataType!==_[1].dataType||_.length===3&&_[0].dataType!==_[2].dataType)throw new Error("Input types are mismatched")},GT=(_,_e)=>{let it=_[0].dims.slice(),ut=_[1].dims.slice(),[ct,pt,ft]=Iy.getShapeOfGemmResult(it,_e.transA,ut,_e.transB,_.length===3?_[2].dims:void 0),Bt=[ct,pt];if(!Bt)throw new Error("Can't use gemm on the given tensors");let Gt=Uu.size(Bt),er=[{type:12,data:Gt},{type:12,data:ct},{type:12,data:pt},{type:12,data:ft},{type:1,data:_e.alpha},{type:1,data:_e.beta}],Yr=["type","type"];_.length===3&&(er.push(...U_(_[2].dims)),Yr.push("rank")),er.push(...U_(Bt));let It=en=>{let wn="";_e.transA&&_e.transB?wn="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":_e.transA&&!_e.transB?wn="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!_e.transA&&_e.transB?wn="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!_e.transA&&!_e.transB&&(wn="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let _o=_e.alpha===1?"":"value *= uniforms.alpha;",vn=v_("a",_[0].dataType,_[0].dims),Ws=v_("b",_[1].dataType,_[1].dims),Jo=vn.type.value,So=null,xa=[vn,Ws];_.length===3&&(So=v_("c",_[2].dataType,_[2].dims.length),xa.push(So));let $a=Xr("output",_[0].dataType,Bt.length);xa.push($a);let gu=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${en.registerUniforms(gu).declareVariables(...xa)}

  ${en.mainStart()}
    ${en.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${Jo}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${wn}
    }

    ${_o}
    ${So!=null?`let cOffset = ${So.broadcastedIndicesToOffset("vec2(m, n)",$a)}; value += ${Jo}(uniforms.beta) * ${So.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${_e.cacheKey}`,inputDependencies:Yr},getRunData:()=>({outputs:[{dims:Bt,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(Gt/64)},programUniforms:er}),getShaderSource:It}},sx=_=>{let _e=_.transA,it=_.transB,ut=_.alpha,ct=_.beta;return{transA:_e,transB:it,alpha:ut,beta:ct,cacheKey:`${_.transA};${_.transB};${_.alpha===1}`}},ax=(_,_e)=>{KT(_.inputs),_.compute(GT(_.inputs,_e))}}),J0,lx,jE,HT,qT,N1,XT,YT=$(()=>{ly(),J_(),Ey(),Po(),Su(),n_(),$y(),J0=(_,_e)=>_.length>_e&&_[_e].dims.length>0?_[_e]:void 0,lx=(_,_e)=>{let it=_[0],ut=J0(_,1),ct=J0(_,2),pt=J0(_,3),ft=J0(_,4),Bt=J0(_,5),Gt=J0(_,6),er=J0(_,7);if(it.dims.length!==3&&it.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let Yr=it.dims[0],It=it.dims[1],en=it.dims.length===3?it.dims[2]:_e.numHeads*it.dims[4],wn=It,_o=0,vn=0,Ws=Math.floor(en/_e.numHeads);if(Gt&&er&&Uu.size(Gt.dims)&&Uu.size(er.dims)){if(Gt.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(Gt.dims[0]!==Yr||Gt.dims[1]!==_e.numHeads||Gt.dims[3]!==Ws)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(er.dims[0]!==Yr||er.dims[1]!==_e.numHeads||er.dims[3]!==Ws)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(Gt.dims[2]!==er.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(er.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');_o=Gt.dims[2],vn=Gt.dims[2]}else if(Gt&&Uu.size(Gt.dims)||er&&Uu.size(er.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let Jo;if(ut&&Uu.size(ut.dims)>0){if(it.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(ut.dims.length<3||ut.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(it.dims[0]!==ut.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(ut.dims.length===3){if(ut.dims[2]!==it.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');Jo=2,wn=ut.dims[1]}else if(ut.dims.length===5){if(ut.dims[2]!==_e.numHeads||ut.dims[3]!==2||ut.dims[4]!==Ws)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(ct)throw new Error('Expect "value" be none when "key" has packed kv format.');Jo=5,wn=ut.dims[1]}else{if(ut.dims[1]!==_e.numHeads||ut.dims[3]!==Ws)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');Jo=0,wn=ut.dims[2]}}else{if(it.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(it.dims[2]!==_e.numHeads||it.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');Jo=3}if(pt&&Uu.size(pt.dims)>0){if(pt.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(ut&&ut.dims.length===5&&ut.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let So=_o+wn,xa=0;if(ft&&Uu.size(ft.dims)>0){xa=8;let c_=ft.dims;throw c_.length===1?c_[0]===Yr?xa=1:c_[0]===3*Yr+2&&(xa=3):c_.length===2&&c_[0]===Yr&&c_[1]===So&&(xa=5),xa===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let $a=!1,gu=en;if(ct&&Uu.size(ct.dims)>0){if(ct.dims.length!==3&&ct.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(it.dims[0]!==ct.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(ct.dims.length===3){if(wn!==ct.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');gu=ct.dims[2]}else{if(wn!==ct.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');gu=ct.dims[1]*ct.dims[3],$a=!0}}let u_=!1;if(ft&&Uu.size(ft.dims)>0)throw new Error("Key padding mask is not supported");if(Bt&&Uu.size(Bt.dims)>0){if(Bt.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(Bt.dims[0]!==Yr||Bt.dims[1]!==_e.numHeads||Bt.dims[2]!==It||Bt.dims[3]!==So)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:Yr,sequenceLength:It,pastSequenceLength:_o,kvSequenceLength:wn,totalSequenceLength:So,maxSequenceLength:vn,inputHiddenSize:0,hiddenSize:en,vHiddenSize:gu,headSize:Ws,vHeadSize:Math.floor(gu/_e.numHeads),numHeads:_e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:_e.maskFilterValue,maskType:xa,scale:_e.scale,broadcastResPosBias:u_,passPastInKv:$a,qkvFormat:Jo}},jE=_=>sy({..._}),HT=sy({perm:[0,2,1,3]}),qT=(_,_e,it,ut,ct,pt,ft)=>{let Bt=[ut,ct,pt],Gt=Uu.size(Bt),er=[{type:12,data:Gt},{type:12,data:ft},{type:12,data:pt}],Yr=It=>{let en=Xr("qkv_with_bias",_e.dataType,Bt),wn=v_("qkv",_e.dataType,Bt),_o=v_("bias",it.dataType,Bt),vn=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${It.registerUniforms(vn).declareVariables(wn,_o,en)}
  ${It.mainStart()}
    ${It.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return _.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:Bt,dataType:_e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(Gt/64)},programUniforms:er}),getShaderSource:Yr},{inputs:[_e,it],outputs:[-1]})[0]},N1=(_,_e,it,ut,ct,pt,ft,Bt)=>{let Gt=pt;if(ft&&Uu.size(ft.dims)>0){if(ut===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return Gt=qT(_,pt,ft,_e,ut,it*ct,Bt),Gt=Gt.reshape([_e,ut,it,ct]),_.compute(B0(Gt,HT.perm),{inputs:[Gt],outputs:[-1]})[0]}else return pt.dims.length===3&&(Gt=pt.reshape([_e,ut,it,ct])),_.compute(B0(Gt,HT.perm),{inputs:[Gt],outputs:[-1]})[0]},XT=(_,_e)=>{let it=lx(_.inputs,_e),ut=_.inputs[0],ct=J0(_.inputs,1),pt=J0(_.inputs,2),ft=J0(_.inputs,3),Bt=J0(_.inputs,4),Gt=J0(_.inputs,5),er=J0(_.inputs,6),Yr=J0(_.inputs,7);if(ut.dims.length===5)throw new Error("Packed QKV is not implemented");if(ct?.dims.length===5)throw new Error("Packed KV is not implemented");let It=ct&&pt&&ct.dims.length===4&&pt.dims.length===4,en=N1(_,it.batchSize,it.numHeads,it.sequenceLength,it.headSize,ut,ft,0);if(It)return ga(_,en,ct,pt,Bt,void 0,er,Yr,Gt,it,_e);if(!ct||!pt)throw new Error("key and value must be provided");let wn=N1(_,it.batchSize,it.numHeads,it.kvSequenceLength,it.headSize,ct,ft,it.hiddenSize),_o=N1(_,it.batchSize,it.numHeads,it.kvSequenceLength,it.vHeadSize,pt,ft,2*it.hiddenSize);ga(_,en,wn,_o,Bt,void 0,er,Yr,Gt,it,_e)}}),ux,QT,ZT,cx,JT,eE=$(()=>{ly(),J_(),n_(),ux=_=>Array.from(_.getBigInt64Array(),Number),QT=_=>{if(!_||_.length!==2)throw new Error("Tile requires 2 inputs.");if(_[0].dataType!==1&&_[0].dataType!==10&&_[0].dataType!==6&&_[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(_[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(_[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(ux(_[1]).length!==_[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ZT=(_,_e)=>{let it=[];for(let ut=0;ut<_.length;++ut)it.push(_[ut]*_e[ut]);return it},cx=(_,_e)=>{let it=_[0].dims,ut=_e??ux(_[1]),ct=ZT(it,ut),pt=Uu.size(ct),ft=_[0].dataType,Bt=v_("input",ft,it.length),Gt=Xr("output",ft,ct.length),er=Yr=>`
      const inputShape = ${Bt.indices(...it)};
      ${Yr.registerUniform("output_size","u32").declareVariables(Bt,Gt)}
      ${Yr.mainStart()}
      ${Yr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${Gt.offsetToIndices("global_idx")};
      var input_indices: ${Bt.type.indices};
      for (var i = 0; i < ${it.length}; i++) {
        let input_dim_i = ${Bt.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${Gt.indicesGet("output_indices","i")}  % input_dim_i;

        ${Bt.indicesSet("input_indices","i","input_dim_value")}
      }
      ${Gt.setByOffset("global_idx",Bt.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${ut}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:ct,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(pt/64)},programUniforms:[{type:12,data:pt},...U_(_[0].dims,ct)]}),getShaderSource:er}},JT=_=>{QT(_.inputs),_.compute(cx(_.inputs),{inputs:[0]})}}),tE,dx,rE,nE,px,oE,zE=$(()=>{ly(),J_(),Ey(),Su(),n_(),YT(),eE(),$y(),tE=(_,_e)=>{let it=_[0],ut=_[1],ct=_[2],pt=_[3],ft=_[4];if(it.dims.length!==3&&it.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let Bt=!1,Gt=it.dims[0],er=it.dims[1],Yr=it.dims.length===3?Bt?it.dims[2]/3:it.dims[2]:_e.numHeads*it.dims[4],It=er,en=0,wn=0,_o=Math.floor(Yr/_e.numHeads),vn=pt&&pt.dims.length!==0,Ws=ft&&ft.dims.length!==0,Jo=!0;if(vn&&Ws){if(pt.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(ft.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');en=pt.dims[1],wn=pt.dims[1]}else if(vn||Ws)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let So;if(ut){if(it.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(ut.dims.length<3||ut.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(it.dims[0]!==ut.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(ut.dims.length===3){if(it.dims[2]%ut.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');So=2,It=ut.dims[1]}else if(ut.dims.length===5){if(ut.dims[2]!==_e.numHeads||ut.dims[3]!==2||ut.dims[4]!==_o)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(ct)throw new Error('Expect "value" be none when "key" has packed kv format.');So=5,It=ut.dims[1]}else{if(ut.dims[1]!==_e.numHeads||ut.dims[3]!==_o)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');So=0,It=ut.dims[2]}}else{if(it.dims.length!==3&&it.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(it.dims.length===5&&(it.dims[2]!==_e.numHeads||it.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');So=3}let xa=0,$a=!1,gu=Yr;if(ct){if(ct.dims.length!==3&&ct.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(it.dims[0]!==ct.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(ct.dims.length===3){if(It!==ct.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');gu=ct.dims[2]}else{if(It!==ct.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');gu=ct.dims[1]*ct.dims[3],$a=!0}}let u_=en+It;return{batchSize:Gt,sequenceLength:er,pastSequenceLength:en,kvSequenceLength:It,totalSequenceLength:u_,maxSequenceLength:wn,inputHiddenSize:0,hiddenSize:Yr,vHiddenSize:gu,headSize:_o,vHeadSize:Math.floor(gu/_e.kvNumHeads),numHeads:_e.numHeads,kvNumHeads:_e.kvNumHeads,nReps:_e.numHeads/_e.kvNumHeads,pastPresentShareBuffer:!1,maskType:xa,scale:_e.scale,broadcastResPosBias:!1,passPastInKv:$a,qkvFormat:So,isPastkvBSNH:Jo}},dx=(_,_e,it,ut)=>{let ct=[ut.batchSize,ut.totalSequenceLength,ut.kvNumHeads,ut.headSize],pt=4,ft=Uu.size(ct)/pt,Bt=ut.totalSequenceLength,Gt=Xr("present_kv",it,ct.length,pt),er=v_("new_kv",_.dataType,_.dims.length,pt),Yr=_e?v_("past_kv",_e.dataType,_e.dims.length,pt):void 0,It=Math.ceil(ut.headSize/pt),en={x:Bt,y:_.dims[0],z:1},wn=_e?["rank","rank"]:["rank"],_o=[{type:12,data:ft},{type:12,data:ut.pastSequenceLength},{type:12,data:ut.kvSequenceLength},{type:12,data:ut.totalSequenceLength}],vn=[er];Yr?(_o.push(...U_(_.dims),...U_(_e.dims),...U_(ct)),vn.push(Yr)):_o.push(...U_(_.dims),...U_(ct));let Ws=[{name:"output_size",type:"u32"},{name:"past_seqlen",type:"u32"},{name:"new_seqlen",type:"u32"},{name:"present_seqlen",type:"u32"}],Jo=`      let past_batch_stride = uniforms.past_seqlen * num_heads * H;
        var past_head_stride = uniforms.past_seqlen * H;
        if (is_bsnh) {
          past_head_stride = H;
        }
        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;
        present_kv[out_offset] = past_kv[in_offset];`,So=`      let new_batch_stride = uniforms.new_seqlen * num_heads * H;
        let new_row_stride = num_heads * H;
        let new_head_stride = H;
        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;
        present_kv[out_offset] = new_kv[in_offset];`,xa=_e?`if (s < past_seqlen) {
        ${Jo}
        } else if (s < past_seqlen + uniforms.new_seqlen) {
        ${So}
        }`:`if (s < past_seqlen + uniforms.new_seqlen) {
          ${So}
        }`,$a=gu=>`

  ${gu.registerUniforms(Ws).declareVariables(...vn,Gt)}
  ${gu.mainStart([It,ut.kvNumHeads,1])}
    ${gu.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    var indices = ${Gt.offsetToIndices("global_idx")};
    let h = local_id.x;
    let n = local_id.y;
    let s = workgroup_id.x;
    let b = workgroup_id.y;
    let num_heads = ${ut.kvNumHeads}u;
    let H = ${It}u;

    let present_seqlen = uniforms.present_seqlen;
    let present_batch_stride = present_seqlen * num_heads * H;
    var row_stride = H;
    let is_bsnh = ${ut.isPastkvBSNH};

    if (is_bsnh) {
      row_stride = num_heads * H;
    }
    var present_head_stride = present_seqlen * H;
    if (is_bsnh) {
      present_head_stride = H;
    }

    let past_seqlen = uniforms.past_seqlen;

    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;
    ${xa}
  }`;return{name:"ConcatPastNew",shaderCache:{hint:`${ut.kvNumHeads}${It}${!!_e}`,inputDependencies:wn},getRunData:()=>({outputs:[{dims:ct,dataType:it}],dispatchGroup:en,programUniforms:_o}),getShaderSource:$a}},rE=_=>sy({..._}),nE=sy({perm:[0,2,1,3]}),px=(_,_e,it,ut,ct)=>{let pt=_e,ft=ut.kvNumHeads,Bt=ut.nReps;return _e.dims.length===3&&ut.kvSequenceLength!==0&&(pt=_e.reshape([ut.batchSize,ut.kvSequenceLength,ft,ut.headSize])),it?pt=_.compute(dx(pt,it,pt.dataType,ut),{inputs:[pt,it],outputs:[ut.isPastkvBSNH?ct:-1]})[0]:pt=_.compute(dx(pt,void 0,pt.dataType,ut),{inputs:[pt],outputs:[ut.isPastkvBSNH?ct:-1]})[0],Bt!==1&&(pt=_.compute(cx([pt],[1,1,1,Bt]),{inputs:[pt],outputs:[-1]})[0],pt=pt.reshape([ut.batchSize,ut.totalSequenceLength,ft*Bt,ut.headSize])),_.compute(B0(pt,nE.perm),{inputs:[pt],outputs:[-1]})[0]},oE=(_,_e)=>{let it=tE(_.inputs,_e);if(_.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(_.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let ut=N1(_,it.batchSize,it.numHeads,it.sequenceLength,it.headSize,_.inputs[0],void 0,0),ct=_.inputs[3]&&_.inputs[3].dims.length!==0?_.inputs[3]:void 0,pt=_.inputs[4]&&_.inputs[4].dims.length!==0?_.inputs[4]:void 0,ft=px(_,_.inputs[1],ct,it,1),Bt=px(_,_.inputs[2],pt,it,2);ga(_,ut,ft,Bt,void 0,void 0,void 0,void 0,void 0,it,_e)}}),NE,UE,WE,VE,A2=$(()=>{ly(),J_(),n_(),NE=(_,_e)=>{let it=_[0].dims,ut=it,ct=2,pt=Uu.sizeToDimension(it,ct),ft=Uu.sizeFromDimension(it,ct),Bt=_y(ft),Gt=ft/Bt,er=[it[0],it[1],Gt],Yr=["rank","type","type"],It=[{type:12,data:ft},{type:12,data:Gt}];It.push(...U_(er,er));let en=wn=>{let _o=v_("x",_[0].dataType,er.length,Bt),vn=v_("scale",_[1].dataType,_[1].dims),Ws=v_("bias",_[2].dataType,_[2].dims),Jo=Xr("output",_[0].dataType,er.length,Bt),So=[_o,vn,Ws,Jo],xa=_o.type.value,$a=Bt===1?"f32":`vec${Bt}<f32>`,gu=64,u_=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${$a}, ${gu}>;
  const workgroupSize = ${gu}u;
  ${wn.registerUniforms(u_).declareVariables(...So)}
  ${wn.mainStart(gu)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${$a}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${$a}(${_o.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${S0("workgroupShared[0]",Bt)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${$a}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${$a}(${_o.get("batch","channel","h")}) - ${$a}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${S0("workgroupShared[0]",Bt)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${_e.epsilon}));
    let channelScale = invStdDev * f32(${vn.getByOffset("channel")});
    let channelShift = f32(${Ws.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${_o.get("batch","channel","h")} * ${xa}(${$a}(channelScale)) + ${xa}(${$a}(channelShift));
      ${Jo.set("batch","channel","h","value")};
    }
  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${_e.epsilon};${Bt}`,inputDependencies:Yr},getRunData:()=>({outputs:[{dims:ut,dataType:_[0].dataType}],dispatchGroup:{x:pt},programUniforms:It}),getShaderSource:en}},UE=(_,_e,it,ut,ct,pt,ft,Bt)=>{let Gt=_y(ft),er=64,Yr=Gt===1?"vec2f":`mat2x${Gt}f`,It=Gt===1?"f32":`vec${Gt}f`,en=(u_,c_)=>`${Yr}(${u_}, ${c_})`,wn=ct*ft/Gt,_o=Math.ceil(pt/er),vn=["type"],Ws=[{type:12,data:_o},{type:12,data:pt},{type:12,data:Math.floor(ft/Gt)},{type:12,data:Math.floor(pt*ft/Gt)}],Jo=u_=>{let c_=v_("input",_e.dataType,_e.dims,Gt);return`
  ${u_.declareVariables(c_)}
  @group(0) @binding(1) var<storage, read_write> output : array<${Yr}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${u_.mainStart(er)}
    let currentImageNumber = global_idx / ${er} / uniforms.C;
    let currentChannelNumber = (global_idx / ${er}) % uniforms.C;
    let wgOffset = local_id.x * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${Ky("f32",Gt)};
    var squaredSum = ${Ky("f32",Gt)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${It}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${en("sum","squaredSum")};
  }`},So=_.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${Gt}`,inputDependencies:vn},getRunData:()=>({outputs:[{dims:[ct,ft,er,2],dataType:1}],dispatchGroup:{x:ct*ft/Gt},programUniforms:Ws}),getShaderSource:Jo},{inputs:[_e],outputs:[-1]})[0],xa=[{type:12,data:wn},{type:12,data:pt},{type:12,data:Math.floor(ft/Gt)},{type:12,data:Math.floor(er*ft/Gt)}],$a=["type","type","type"],gu=u_=>{let c_=v_("scale",it.dataType,it.dims,Gt),R_=v_("bias",ut.dataType,ut.dims,Gt);return`
  @group(0) @binding(0) var<storage, read> input : array<${Yr}>;
  @group(0) @binding(1) var<storage, read> scale : array<${c_.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${R_.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${Yr}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${u_.mainStart()}
    ${u_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${Ky("f32",Gt)};
    var squaredSum = ${Ky("f32",Gt)};
    for (var i: u32 = 0; i < min(${er}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${er}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${Bt}));
    let channelScale = invStdDev * ${It}(scale[currentChannelNumber]);
    let channelShift = ${It}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${en("channelScale","channelShift")};
  }`};return _.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${Gt};${Bt}`,inputDependencies:$a},getRunData:()=>({outputs:[{dims:[ct,ft,2],dataType:1}],dispatchGroup:{x:Math.ceil(wn/64)},programUniforms:xa}),getShaderSource:gu},{inputs:[So,it,ut],outputs:[-1]})[0]},WE=(_,_e,it)=>{let ut=_e[0].dims,ct=ut,pt=ut[0],ft=ut[ut.length-1],Bt=Uu.sizeFromDimension(ut,1)/ft,Gt=_y(ft),er=Uu.size(ct)/Gt,Yr=[{type:12,data:Bt},{type:12,data:Math.floor(ft/Gt)}],It=["type","type"],en=UE(_,_e[0],_e[1],_e[2],pt,Bt,ft,it.epsilon),wn=_o=>{let vn=jy(_e[0].dataType),Ws=Gt===1?"vec2f":`mat2x${Gt}f`,Jo=Gt===1?vn:`vec${Gt}<${vn}>`,So=v_("input",_e[0].dataType,_e[0].dims,Gt),xa=Xr("output",_e[0].dataType,ct,Gt);return`
  @group(0) @binding(0) var<storage, read> input : array<${So.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${Ws}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${xa.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${_o.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${Jo}(scale[0]), ${Jo}(scale[1]));
  }`};_.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${Gt}`,inputDependencies:It},getRunData:()=>({outputs:[{dims:ct,dataType:_e[0].dataType}],dispatchGroup:{x:Math.ceil(er/64)},programUniforms:Yr}),getShaderSource:wn},{inputs:[_e[0],en]})},VE=(_,_e)=>{_e.format==="NHWC"?WE(_,_.inputs,_e):_.compute(NE(_.inputs,_e))}}),KE,GE,HE,C2=$(()=>{ly(),J_(),n_(),KE=_=>{if(!_||_.length<2)throw new Error("layerNorm requires at least 2 inputs.")},GE=(_,_e,it)=>{let ut=_e.simplified,ct=_[0].dims,pt=_[1],ft=!ut&&_[2],Bt=ct,Gt=Uu.normalizeAxis(_e.axis,ct.length),er=Uu.sizeToDimension(ct,Gt),Yr=Uu.sizeFromDimension(ct,Gt),It=Uu.size(pt.dims),en=ft?Uu.size(ft.dims):0;if(It!==Yr||ft&&en!==Yr)throw new Error(`Size of X.shape()[axis:] == ${Yr}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${It} and bias size of ${en}`);let wn=[];for(let gu=0;gu<ct.length;++gu)gu<Gt?wn.push(ct[gu]):wn.push(1);let _o=_y(Yr),vn=["type","type"],Ws=[{type:12,data:er},{type:1,data:Yr},{type:12,data:Math.floor(Yr/_o)},{type:1,data:_e.epsilon}];ft&&vn.push("type");let Jo=it>1,So=it>2,xa=gu=>{let u_=jy(_[0].dataType),c_=[v_("x",_[0].dataType,_[0].dims,_o),v_("scale",pt.dataType,pt.dims,_o)];ft&&c_.push(v_("bias",ft.dataType,ft.dims,_o)),c_.push(Xr("output",_[0].dataType,Bt,_o)),Jo&&c_.push(Xr("mean_data_output",1,wn)),So&&c_.push(Xr("inv_std_output",1,wn));let R_=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${gu.registerUniforms(R_).declareVariables(...c_)}
  ${gu.mainStart()}
    ${gu.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Ky("f32",_o)};
    var mean_square_vector = ${Ky("f32",_o)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${s0(u_,_o,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${S0("mean_vector",_o)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${S0("mean_square_vector",_o)} / uniforms.norm_size ${ut?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${s0(u_,_o,"x[j + offset]")};
      let f32scale = ${s0(u_,_o,"scale[j]")};
      output[j + offset] = ${c_[0].type.value}((f32input ${ut?"":"- mean"}) * inv_std_dev * f32scale
        ${ft?`+ ${s0(u_,_o,"bias[j]")}`:""}
      );
    }

    ${Jo?"mean_data_output[global_idx] = mean":""};
    ${So?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},$a=[{dims:Bt,dataType:_[0].dataType}];return Jo&&$a.push({dims:wn,dataType:1}),So&&$a.push({dims:wn,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${_o};${it};${ut}`,inputDependencies:vn},getRunData:()=>({outputs:$a,dispatchGroup:{x:Math.ceil(er/64)},programUniforms:Ws}),getShaderSource:xa}},HE=(_,_e)=>{KE(_.inputs),_.compute(GE(_.inputs,_e,_.outputCount))}}),qE,XE,YE,QE,I2=$(()=>{ly(),J_(),Ey(),n_(),qE=(_,_e)=>{if(_.length<3||_.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let it=_[0],ut=it.dims.length;if(it.dims[ut-1]!==_e.k)throw new Error("The last dim of input shape does not match the k value");let ct=Math.floor((_e.k+_e.blockSize-1)/_e.blockSize),pt=_e.blockSize/8*_e.bits,ft=_[1];if(!Uu.areEqual(ft.dims,[_e.n,ct,pt]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let Bt=_[2].dims;if(Uu.size(Bt)!==_e.n*ct)throw new Error("scales input size error.");if(_.length===4){let Gt=_[3].dims,er=_e.bits>4?_e.n*ct:_e.n*Math.floor((ct+1)/2);if(Uu.size(Gt)!==er)throw new Error("zeroPoints input size error.")}},XE=(_,_e)=>{let it=_[0].dims,ut=it.length,ct=it[ut-2],pt=_e.k,ft=_e.n,Bt=it.slice(0,ut-2),Gt=Uu.size(Bt),er=_[1].dims[2]/4,Yr=_[0].dataType,It=_y(_e.k),en=_y(er),wn=_y(ft),_o=Bt.concat([ct,ft]),vn=ct>1&&ft/wn%2===0?2:1,Ws=Uu.size(_o)/wn/vn,Jo=64,So=[],xa=[Gt,ct,pt/It],$a=Uu.convertShape(_[1].dims).slice();$a.splice(-1,1,er/en),So.push(...U_(xa)),So.push(...U_($a)),So.push(...U_(_[2].dims)),_.length===4&&So.push(...U_(Uu.convertShape(_[3].dims)));let gu=[Gt,ct,ft/wn];So.push(...U_(gu));let u_=c_=>{let R_=xa.length,ny=v_("a",_[0].dataType,R_,It),ty=v_("b",12,$a.length,en),Ly=v_("scales",_[2].dataType,_[2].dims.length),ky=[ny,ty,Ly],Wy=_.length===4?v_("zero_points",12,_[3].dims.length):void 0;Wy&&ky.push(Wy);let t0=gu.length,Uy=Xr("output",_[0].dataType,t0,wn),dy=jy(_[0].dataType),r0=(()=>{switch(It){case 1:return`array<${dy}, 8>`;case 2:return`mat4x2<${dy}>`;case 4:return`mat2x4<${dy}>`;default:throw new Error(`${It}-component is not supported.`)}})(),d0=()=>{let x_=`
          // reuse a data
            var input_offset = ${ny.indicesToOffset(`${ny.type.indices}(batch, row, word_offset)`)};
            var a_data: ${r0};
            for (var j: u32 = 0; j < ${8/It}; j++) {
              a_data[j] = ${ny.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let G_=0;G_<wn*vn;G_++)x_+=`
            b_value = ${en===1?`b${G_}_data`:`b${G_}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${r0}(${Array.from({length:4},(By,b0)=>`${dy}(b_value_lower[${b0}]), ${dy}(b_value_upper[${b0}])`).join(", ")});
            b_dequantized_values = ${It===1?`${r0}(${Array.from({length:8},(By,b0)=>`(b_quantized_values[${b0}] - ${Wy?`zero_point${G_}`:"zero_point"}) * scale${G_}`).join(", ")});`:`(b_quantized_values - ${r0}(${Array(8).fill(`${Wy?`zero_point${G_}`:"zero_point"}`).join(",")})) * scale${G_};`};
            workgroup_shared[local_id.x * ${vn} + ${Math.floor(G_/wn)}]${wn>1?`[${G_%wn}]`:""} += ${Array.from({length:8/It},(By,b0)=>`${It===1?`a_data[${b0}] * b_dequantized_values[${b0}]`:`dot(a_data[${b0}], b_dequantized_values[${b0}])`}`).join(" + ")};
          `;return x_},gy=()=>{let x_=`
            var col_index = col * ${wn};
            ${Wy?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dy}(8);`}
            `;for(let G_=0;G_<wn*vn;G_++)x_+=`
            let scale${G_} = ${Ly.getByOffset("col_index * nBlocksPerCol + block")};
            ${Wy?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${Wy.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${G_} = ${dy}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return x_},Vy=()=>{let x_=`col_index = col * ${wn};`;for(let G_=0;G_<wn*vn;G_++)x_+=`
            let b${G_}_data = ${ty.getByIndices(`${ty.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return x_+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${r0};
            var b_dequantized_values: ${r0};`,x_};return`
        var<workgroup> workgroup_shared: array<${Uy.type.value}, ${vn*Jo}>;
        ${c_.declareVariables(...ky,Uy)}
        ${c_.mainStart([Jo,1,1])}
          let output_indices = ${Uy.offsetToIndices(`(global_idx / ${Jo}) * ${vn}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${Jo}) {
            //process one block
            var word_offset: u32 = block * ${_e.blockSize/It};
            ${gy()}
            for (var word: u32 = 0; word < ${er}; word += ${en}) {
              ${Vy()}
              for (var i: u32 = 0; i < ${en}; i++) {
                ${d0()}
                word_offset += ${8/It};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${vn}) {
            var output_value: ${Uy.type.value} = ${Uy.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${Jo}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${vn};
            }
            ${Uy.setByIndices(`${Uy.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${_e.blockSize};${_e.bits};${It};${en};${wn};${vn};${Jo}`,inputDependencies:Array(_.length).fill("rank")},getRunData:()=>({outputs:[{dims:_o,dataType:Yr}],dispatchGroup:{x:Ws},programUniforms:So}),getShaderSource:u_}},YE=(_,_e)=>{qE(_.inputs,_e),_.compute(XE(_.inputs,_e))},QE=_=>sy(_)}),ZE,JE,e2,t2,r2,n2,o2,i2,s2,D2=$(()=>{ly(),J_(),n_(),ZE=_=>{if(!_||_.length<1)throw new Error("Too few inputs");if(_[0].dataType!==1&&_[0].dataType!==10)throw new Error("Input type must be float or float16.");if(_.length>=2){let _e=_[0].dims.length*2===_[1].dims[0];if(_.length===4&&(_e=_[3].dims[0]*2===_[1].dims[0]),!_e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},JE=(_,_e,it)=>{let ut="";for(let ct=_e-1;ct>=0;--ct)ut+=`
            k = i32(${_.indicesGet("indices",ct)}) - ${X_("uniforms.pads",ct,it)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${X_("uniforms.x_shape",ct,_e)})) {
              break;
            }
            offset += k * i32(${X_("uniforms.x_strides",ct,_e)});
        `;return`
          value = ${_.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${ut}
            value = x[offset];
          }
      `},e2=(_,_e,it)=>{let ut="";for(let ct=_e-1;ct>=0;--ct)ut+=`
                k = i32(${_.indicesGet("indices",ct)}) - ${X_("uniforms.pads",ct,it)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${X_("uniforms.x_shape",ct,_e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${X_("uniforms.x_shape",ct,_e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${X_("uniforms.x_strides",ct,_e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${ut}
              value = x[offset];
          `},t2=(_,_e,it)=>{let ut="";for(let ct=_e-1;ct>=0;--ct)ut+=`
                k = i32(${_.indicesGet("indices",ct)}) - ${X_("uniforms.pads",ct,it)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${X_("uniforms.x_shape",ct,_e)})) {
                  k = i32(${X_("uniforms.x_shape",ct,_e)}) - 1;
                }
                offset += k * i32(${X_("uniforms.x_strides",ct,_e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${ut}
              value = x[offset];
          `},r2=(_,_e,it)=>{let ut="";for(let ct=_e-1;ct>=0;--ct)ut+=`
                k = i32(${_.indicesGet("indices",ct)}) - ${X_("uniforms.pads",ct,it)};
                if (k < 0)  {
                  k += i32(${X_("uniforms.x_shape",ct,_e)}]);
                }
                if (k >= i32(${X_("uniforms.x_shape",ct,_e)})) {
                  k -= i32(${X_("uniforms.x_shape",ct,_e)});
                }
                offset += k * i32(${X_("uniforms.x_strides",ct,_e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${ut}
              value = x[offset];
          `},n2=(_,_e,it)=>{switch(it.mode){case 0:return JE(_,_e,it.pads.length);case 1:return e2(_,_e,it.pads.length);case 2:return t2(_,_e,it.pads.length);case 3:return r2(_,_e,it.pads.length);default:throw new Error("Invalid mode")}},o2=(_,_e)=>{let it=Uu.padShape(_[0].dims.slice(),_e.pads),ut=_[0].dims,ct=Uu.size(it),pt=[{type:12,data:ct},{type:6,data:_e.pads}],ft=_.length>=3&&_[2].data;_e.mode===0&&pt.push({type:ft?_[2].dataType:1,data:_e.value}),pt.push(...U_(_[0].dims,it));let Bt=["rank"],Gt=er=>{let Yr=Xr("output",_[0].dataType,it.length),It=v_("x",_[0].dataType,ut.length),en=It.type.value,wn=n2(Yr,ut.length,_e),_o=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:_e.pads.length}];return _e.mode===0&&_o.push({name:"constant_value",type:ft?en:"f32"}),`
            ${er.registerUniforms(_o).declareVariables(It,Yr)}
            ${er.mainStart()}
            ${er.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${Yr.offsetToIndices("global_idx")};

            var value = ${en}(0);
            ${wn}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${_e.mode}${ft}`,inputDependencies:Bt},getRunData:()=>({outputs:[{dims:it,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(Uu.size(it)/64)},programUniforms:pt}),getShaderSource:Gt}},i2=(_,_e)=>{if(_.length>1){let it=_[1].getBigInt64Array(),ut=_.length>=3&&_[2].data?_[2].dataType===10?_[2].getUint16Array()[0]:_[2].getFloat32Array()[0]:0,ct=_[0].dims.length,pt=new Int32Array(2*ct).fill(0);if(_.length>=4){let Bt=_[3].getBigInt64Array();for(let Gt=0;Gt<Bt.length;Gt++)pt[Number(Bt[Gt])]=Number(it[Gt]),pt[Number(Bt[Gt])+ct]=Number(it[Gt+Bt.length])}else it.forEach((Bt,Gt)=>pt[Number(Gt)]=Number(Bt));let ft=[];return pt.forEach(Bt=>ft.push(Bt)),{mode:_e.mode,value:ut,pads:ft}}else return _e},s2=(_,_e)=>{ZE(_.inputs);let it=i2(_.inputs,_e);_.compute(o2(_.inputs,it),{inputs:[0]})}}),_v,iE,sE,aE,lE,a2,My,fx,D0,V0,H0,Qw,l2,uE,hx,jr,tr,Io,eu,l_=$(()=>{L_(),ly(),J_(),n_(),_v=_=>{if(Er.webgpu.validateInputContent&&(!_||_.length!==1))throw new Error("Pool ops requires 1 input.")},iE=(_,_e,it)=>{let ut=_e.format==="NHWC",ct=_.dims.slice();ut&&ct.splice(1,0,ct.pop());let pt=Object.hasOwnProperty.call(_e,"dilations"),ft=_e.kernelShape.slice(),Bt=_e.strides.slice(),Gt=pt?_e.dilations.slice():[],er=_e.pads.slice();g0.adjustPoolAttributes(it,ct,ft,Bt,Gt,er);let Yr=g0.computePoolOutputShape(it,ct,Bt,Gt,ft,er,_e.autoPad),It=Object.assign({},_e);pt?Object.assign(It,{kernelShape:ft,strides:Bt,pads:er,dilations:Gt,cacheKey:_e.cacheKey}):Object.assign(It,{kernelShape:ft,strides:Bt,pads:er,cacheKey:_e.cacheKey});let en=Yr.slice();return en.push(en.splice(1,1)[0]),[It,ut?en:Yr]},sE=(_,_e)=>{let it=_e.format==="NHWC",ut=Uu.size(_),ct=Uu.size(_e.kernelShape),pt=[{type:12,data:ut},{type:12,data:ct}],ft=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(_e.kernelShape.length<=2){let Bt=_e.kernelShape[_e.kernelShape.length-1],Gt=_e.strides[_e.strides.length-1],er=_e.pads[_e.pads.length/2-1],Yr=_e.pads[_e.pads.length-1],It=!!(er+Yr);pt.push({type:12,data:Bt},{type:12,data:Gt},{type:12,data:er},{type:12,data:Yr}),ft.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let en=!1;if(_e.kernelShape.length===2){let wn=_e.kernelShape[_e.kernelShape.length-2],_o=_e.strides[_e.strides.length-2],vn=_e.pads[_e.pads.length/2-2],Ws=_e.pads[_e.pads.length-2];en=!!(vn+Ws),pt.push({type:12,data:wn},{type:12,data:_o},{type:12,data:vn},{type:12,data:Ws}),ft.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[pt,ft,!0,It,en]}else{if(it)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let Bt=Uu.computeStrides(_e.kernelShape);pt.push({type:12,data:Bt},{type:12,data:_e.pads},{type:12,data:_e.strides}),ft.push({name:"kernelStrides",type:"u32",length:Bt.length},{name:"pads",type:"u32",length:_e.pads.length},{name:"strides",type:"u32",length:_e.strides.length});let Gt=_e.pads.reduce((er,Yr)=>er+Yr);return[pt,ft,!!Gt,!1,!1]}},aE=(_,_e,it,ut,ct,pt,ft,Bt,Gt,er,Yr,It)=>{let en=ct.format==="NHWC",wn=_e.type.value,_o=Xr("output",_e.type.tensor,ut);if(ct.kernelShape.length<=2){let vn="",Ws="",Jo="",So=it-(en?2:1);if(Yr?vn=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${So}] = indices[${So}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${So}] < 0 || xIndices[${So}]
                      >= uniforms.x_shape[${So}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${_e.indicesToOffset("xIndices")}];
                  ${pt}
                }`:vn=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${So}] = indices[${So}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${_e.indicesToOffset("xIndices")}];
                  ${pt}
                }`,ct.kernelShape.length===2){let xa=it-(en?3:2);It?Ws=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${xa}] = indices[${xa}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${xa}] < 0 || xIndices[${xa}] >= uniforms.x_shape[${xa}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:Ws=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${xa}] = indices[${xa}] * uniforms.sh - uniforms.phStart + j;
                `,Jo=`
              }
            `}return`
            ${_.registerUniforms(Gt).declareVariables(_e,_o)}

            ${_.mainStart()}
              ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${_o.offsetToIndices("global_idx")};
              var xIndices = ${_o.offsetToIndices("global_idx")};

              var value = ${wn}(${Bt});
              var pad = 0;
              ${Ws}
              ${vn}
              ${Jo}
              ${ft}

              output[global_idx] = value;
            }`}else{if(en)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let vn=ct.kernelShape.length,Ws=ct.pads.length,Jo="";return er?Jo=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${_e.indicesToOffset("xIndices")}];
                ${pt}
              }`:Jo=`
              }
              let x_val = x[${_e.indicesToOffset("xIndices")}];
              ${pt}
            `,`
            ${_.registerUniforms(Gt).declareVariables(_e,_o)}

            ${_.mainStart()}
              ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${_o.offsetToIndices("global_idx")};
              var xIndices = ${_o.offsetToIndices("global_idx")};

              var offsets: array<u32, ${vn}>;

              var value = ${wn}(${Bt});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${vn-1}u; j++) {
                  offsets[j] = offset / ${X_("uniforms.kernelStrides","j",vn)};
                  offset -= offsets[j] * ${X_("uniforms.kernelStrides","j",vn)};
                }
                offsets[${vn-1}] = offset;

                isPad = false;
                for (var j = ${it-vn}u; j < ${it}u; j++) {
                  xIndices[j] = indices[j] * ${X_("uniforms.strides",`j - ${it-vn}u`,vn)}
                    + offsets[j - ${it-vn}u] - ${X_("uniforms.pads","j - 2u",Ws)};
                  ${Jo}
              }
              ${ft}

              output[global_idx] = value;
            }`}},lE=_=>`${_.format};${_.ceilMode};${_.autoPad};${_.kernelShape.length}`,a2=_=>`${lE(_)};${_.countIncludePad}`,My=_=>`${lE(_)};${_.storageOrder};${_.dilations}`,fx=_=>({format:_.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][_.auto_pad],ceilMode:_.ceil_mode,kernelShape:_.kernel_shape,strides:_.strides,pads:_.pads}),D0=(_,_e,it,ut)=>{let[ct,pt]=iE(_e,ut,it),ft=v_("x",_e.dataType,_e.dims.length),Bt=ft.type.value,Gt="value += x_val;",er="";ct.countIncludePad?er+=`value /= ${Bt}(uniforms.kernelSize);`:er+=`value /= ${Bt}(i32(uniforms.kernelSize) - pad);`;let[Yr,It,en,wn,_o]=sE(pt,ct);Yr.push(...U_(_e.dims,pt));let vn=["rank"];return{name:_,shaderCache:{hint:`${ut.cacheKey};${en};${wn};${_o}`,inputDependencies:vn},getRunData:()=>({outputs:[{dims:pt,dataType:_e.dataType}],dispatchGroup:{x:Math.ceil(Uu.size(pt)/64)},programUniforms:Yr}),getShaderSource:Ws=>aE(Ws,ft,_e.dims.length,pt.length,ct,Gt,er,0,It,en,wn,_o)}},V0=_=>{let _e=_.count_include_pad!==0,it=fx(_);if(it.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let ut={countIncludePad:_e,...it,cacheKey:""};return{...ut,cacheKey:a2(ut)}},H0=(_,_e)=>{_v(_.inputs),_.compute(D0("AveragePool",_.inputs[0],!1,_e))},Qw={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},l2=_=>{let _e=_.format;return{format:_e,...Qw,cacheKey:_e}},uE=(_,_e)=>{_v(_.inputs),_.compute(D0("GlobalAveragePool",_.inputs[0],!0,_e))},hx=(_,_e,it,ut)=>{let[ct,pt]=iE(_e,ut,it),ft=`
      value = max(x_val, value);
    `,Bt="",Gt=v_("x",_e.dataType,_e.dims.length),er=["rank"],[Yr,It,en,wn,_o]=sE(pt,ct);return Yr.push(...U_(_e.dims,pt)),{name:_,shaderCache:{hint:`${ut.cacheKey};${en};${wn};${_o}`,inputDependencies:er},getRunData:()=>({outputs:[{dims:pt,dataType:_e.dataType}],dispatchGroup:{x:Math.ceil(Uu.size(pt)/64)},programUniforms:Yr}),getShaderSource:vn=>aE(vn,Gt,_e.dims.length,pt.length,ct,ft,Bt,_e.dataType===10?-65504:-1e5,It,en,wn,_o)}},jr=(_,_e)=>{_v(_.inputs),_.compute(hx("MaxPool",_.inputs[0],!1,_e))},tr=_=>{let _e=_.storage_order,it=_.dilations,ut=fx(_);if(_e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(ut.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let ct={storageOrder:_e,dilations:it,...ut,cacheKey:""};return{...ct,cacheKey:My(ct)}},Io=_=>{let _e=_.format;return{format:_e,...Qw,cacheKey:_e}},eu=(_,_e)=>{_v(_.inputs),_.compute(hx("GlobalMaxPool",_.inputs[0],!0,_e))}}),$_,F_,Q_,py,Gy=$(()=>{ly(),J_(),Ey(),n_(),$_=(_,_e)=>{if(_.length<2||_.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(_.length===3&&_[1].dims===_[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(_.length===3&&_[0].dataType!==_[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(_[0].dataType===6&&_.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(_[1].dims.length!==0&&_[1].dims.length!==1&&_[1].dims.length!==_[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(_.length>2){if(_[0].dataType!==_[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(_[1].dims.length!==_[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!_[1].dims.map((it,ut)=>it===_[2].dims[ut]).reduce((it,ut)=>it&&ut,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(_e.blockSize>0){if(_[1].dims.length===0||_[1].dims.length===1&&_[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!_[1].dims.map((ct,pt)=>pt===_e.axis||ct===_[0].dims[pt]).reduce((ct,pt)=>ct&&pt,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(_[1].dims.length!==_[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let it=_[0].dims[_e.axis],ut=_[1].dims[_e.axis];if(_e.blockSize<Math.ceil(it/ut)||_e.blockSize>Math.ceil(it/(ut-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},F_=(_,_e)=>{let it=Uu.normalizeAxis(_e.axis,_[0].dims.length),ut=_[0].dataType,ct=ut===3,pt=_[0].dims,ft=_[1].dataType,Bt=Uu.size(pt),Gt=ut===3||ut===2,er=Gt?[Math.ceil(Uu.size(_[0].dims)/4)]:_[0].dims,Yr=_[1].dims,It=_.length>2?_[2]:void 0,en=It?Gt?[Math.ceil(Uu.size(It.dims)/4)]:It.dims:void 0,wn=Yr.length===0||Yr.length===1&&Yr[0]===1,_o=wn===!1&&Yr.length===1,vn=_y(Bt),Ws=wn&&(!Gt||vn===4),Jo=Ws?vn:1,So=Ws&&!Gt?vn:1,xa=v_("input",Gt?12:ut,er.length,So),$a=v_("scale",ft,Yr.length),gu=It?v_("zero_point",Gt?12:ut,en.length):void 0,u_=Xr("output",ft,pt.length,Jo),c_=[xa,$a];gu&&c_.push(gu);let R_=[er,Yr];It&&R_.push(en);let ny=[{type:12,data:Bt/Jo},{type:12,data:it},{type:12,data:_e.blockSize},...U_(...R_,pt)],ty=Ly=>{let ky=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${Ly.registerUniforms(ky).declareVariables(...c_,u_)}
      ${Ly.mainStart()}
          ${Ly.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${u_.offsetToIndices("global_idx")};

          // Set input x
          ${Gt?`
            let input = ${xa.getByOffset("global_idx / 4")};
            let x_vec = ${ct?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${Jo===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${xa.getByOffset("global_idx")};`};

          // Set scale input
          ${wn?`let scale_value= ${$a.getByOffset("0")}`:_o?`
            let scale_index = ${u_.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${$a.getByOffset("scale_index")};`:`
            var scale_indices: ${$a.type.indices} = output_indices;
            let index = ${$a.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${$a.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${$a.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${gu?wn?Gt?`
                let zero_point_input = ${gu.getByOffset("0")};
                let zero_point_vec =  ${ct?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${gu.getByOffset("0")}`:_o?Gt?`
                let zero_point_index = ${u_.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${gu.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${ct?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${u_.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${gu.getByOffset("zero_point_index")};`:Gt?`
                let zero_point_offset = ${$a.indicesToOffset("scale_indices")};
                let zero_point_input = ${gu.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${ct?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${gu.getByIndices("scale_indices")};`:`let zero_point_value = ${Gt?ct?"i32":"u32":xa.type.value}(0);`};
      // Compute and write output
      ${u_.setByOffset("global_idx",`${u_.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:_e.cacheKey,inputDependencies:gu?["rank","rank","rank"]:["rank","rank"]},getShaderSource:ty,getRunData:()=>({outputs:[{dims:pt,dataType:ft}],dispatchGroup:{x:Math.ceil(Bt/Jo/64),y:1,z:1},programUniforms:ny})}},Q_=(_,_e)=>{$_(_.inputs,_e),_.compute(F_(_.inputs,_e))},py=_=>sy({axis:_.axis,blockSize:_.blockSize})}),o0,l0,Ny,xy=$(()=>{L_(),ly(),n_(),o0=(_,_e,it)=>{let ut=_===_e,ct=_<_e&&it<0,pt=_>_e&&it>0;if(ut||ct||pt)throw new Error("Range these inputs' contents are invalid.")},l0=(_,_e,it,ut)=>{let ct=Math.abs(Math.ceil((_e-_)/it)),pt=[ct],ft=ct,Bt=[{type:12,data:ft},{type:ut,data:_},{type:ut,data:it},...U_(pt)],Gt=er=>{let Yr=Xr("output",ut,pt.length),It=Yr.type.value,en=[{name:"outputSize",type:"u32"},{name:"start",type:It},{name:"delta",type:It}];return`
        ${er.registerUniforms(en).declareVariables(Yr)}
        ${er.mainStart()}
        ${er.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${It}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${ut}`},getShaderSource:Gt,getRunData:()=>({outputs:[{dims:pt,dataType:ut}],dispatchGroup:{x:Math.ceil(ft/64)},programUniforms:Bt})}},Ny=_=>{let _e=0,it=0,ut=0;_.inputs[0].dataType===6?(_e=_.inputs[0].getInt32Array()[0],it=_.inputs[1].getInt32Array()[0],ut=_.inputs[2].getInt32Array()[0]):_.inputs[0].dataType===1&&(_e=_.inputs[0].getFloat32Array()[0],it=_.inputs[1].getFloat32Array()[0],ut=_.inputs[2].getFloat32Array()[0]),Er.webgpu.validateInputContent&&o0(_e,it,ut),_.compute(l0(_e,it,ut,_.inputs[0].dataType),{inputs:[]})}}),f0,Py,Hy,T0,z0,Zw,ww,pw,E0,fw,mv,x1,F2,Ow,T1,u2,c2,d2,cE,UP=$(()=>{ly(),J_(),Ey(),n_(),f0=(_,_e)=>{if(_.every(it=>it>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),_.length>0){if(_e.mode==="linear"){if(!(_.length===2||_.length===3||_.length===4&&_[0]===1&&_[1]===1||_.length===4&&_[0]===1&&_[3]===1||_.length===5&&_[0]===1&&_[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(_e.mode==="cubic"&&!(_.length===2||_.length===4&&_[0]===1&&_[1]===1||_.length===4&&_[0]===1&&_[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Py=(_,_e,it)=>{_e.every(ct=>ct>=0&&ct<it||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let ut=new Array(it).fill(1);return _e.forEach((ct,pt)=>ut[ct]=_[pt]),ut},Hy=(_,_e,it,ut,ct,pt)=>{let[ft,Bt,Gt]=it>10?[1,2,3]:[-1,_.length>1?1:-1,-1],er=_[0].dims.length;if(ft>0&&_.length>ft&&_[ft].dims.length>0)_[ft].getFloat32Array().forEach(Yr=>pt.push(Yr));else if(_e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(Bt>0&&_.length>Bt&&_[Bt].dims.length>0){if(_[Bt].getFloat32Array().forEach(Yr=>ut.push(Yr)),ut.length!==0&&ut.length!==er&&it>=18&&ut.length!==_e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");f0(ut,_e),_e.axes.length>0&&Py(ut,_e.axes,er).forEach((Yr,It)=>ut[It]=Yr)}if(Gt>0&&_.length>Gt&&(_[Gt].getBigInt64Array().forEach(Yr=>ct.push(Number(Yr))),ct.length!==er||it>=18&&ct.length===_e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(_e.axes.length>0){if(ut.length!==_e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(ct.length!==_e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof ut<"u"&&typeof ct<"u"&&ut.length>0&&ct.length>er)throw new Error("Resize requires only of scales or sizes to be specified")},T0=(_,_e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${_e} { `+(()=>{switch(_){case"asymmetric":return`return ${_e}(xResized) / ${_e}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${_e}(xResized) + 0.5) / ${_e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${_e}(xResized) + 0.5) / ${_e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${_e}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${_e}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${_e}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${_e}(roiStart) * ${_e}(lengthOriginal - 1) +
                        (${_e}(xResized) * ${_e}(roiEnd - roiStart) * ${_e}(lengthOriginal - 1)) /
                        ${_e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${_e}(roiStart + roiEnd) * ${_e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${_e}xScale * ${_e}(lengthResized);
                  const adjustment = ${_e}(lengthResized) / outputWidth;
                  const center = ${_e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${_e}(xResized) + 0.5) / ${_e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${_e}(xResized) + 0.5) / ${_e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${_} is not supported`)}})()+"}",z0=(_,_e,it)=>`fn getNearestPixelFromOriginal(xOriginal: ${it}, isDownSample: bool) -> ${it} {`+(()=>{switch(_){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(_e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${_} is not supported`)}})()+"}",Zw=(_,_e,it)=>{let ut=new Array(it).fill(0).concat(new Array(it).fill(1)),ct=_.length===0?ut:_.slice();return _e.length>0?(_e.forEach((pt,ft)=>{ut[pt]=ct[ft],ut[ft+it]=ct[_e.length+ft]}),ut):ct},ww=(_,_e,it,ut)=>{let ct=[];if(it.length>0)if(ut.length>0){if(_.forEach(pt=>ct.push(pt)),Math.max(...ut)>_.length)throw new Error("axes is out of bound");ut.forEach((pt,ft)=>ct[pt]=it[ft])}else it.forEach(pt=>ct.push(pt));else{if(_e.length===0)throw new Error("Resize requires either scales or sizes.");ct=_.map((pt,ft)=>Math.round(pt*_e[ft]))}return ct},pw=(_,_e,it)=>{let ut=(()=>{switch(it.keepAspectRatioPolicy){case"not_larger":return it.axes.length>0?Math.min(...it.axes.map(pt=>_e[pt]),Number.MAX_VALUE):Math.min(..._e,Number.MAX_VALUE);case"not_smaller":return it.axes.length>0?Math.max(...it.axes.map(pt=>_e[pt]),Number.MIN_VALUE):Math.max(..._e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${it.keepAspectRatioPolicy} is not supported`)}})();_e.fill(1,0,_e.length);let ct=_.slice();return it.axes.length>0?(it.axes.forEach(pt=>_e[pt]=ut),it.axes.forEach(pt=>ct[pt]=Math.round(_[pt]*_e[pt]))):(_e.fill(ut,0,_e.length),ct.forEach((pt,ft)=>ct[ft]=Math.round(pt*_e[ft]))),ct},E0=(_,_e,it,ut,ct)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${_.type.indices}) -> array<${_.type.value}, ${it.length}> {
      var original_indices: array<${_.type.value}, ${it.length}>;
      for (var i:u32 = 0; i < ${it.length}; i++) {
        var output_index = ${_.indicesGet("output_indices","i")};
        var scale = ${X_("uniforms.scales","i",ut)};
        var roi_low = ${X_("uniforms.roi","i",ct)};
        var roi_hi = ${X_("uniforms.roi",`i + ${_e.length}`,ct)};
        if (scale == 1.0) {
          original_indices[i] = ${_.type.value}(output_index);
        } else {
          var input_shape_i = ${X_("uniforms.input_shape","i",_e.length)};
          var output_shape_i = ${X_("uniforms.output_shape","i",it.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,fw=(_,_e,it,ut,ct,pt,ft)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${_e.type.indices}) -> ${_.type.indices} {
      var input_indices: ${_.type.indices};
      for (var i:u32 = 0; i < ${ut.length}; i++) {
        var output_index = ${_e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${X_("uniforms.scales","i",ct)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${X_("uniforms.roi","i",pt)};
          var roi_hi = ${X_("uniforms.roi",`i + ${it.length}`,pt)};
          var input_shape_i = ${X_("uniforms.input_shape","i",it.length)};
          var output_shape_i = ${X_("uniforms.output_shape","i",ut.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${ft} || (original_idx >= 0 && original_idx < ${_e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${_e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${_.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,mv=(_,_e)=>`
    fn checkInputIndices(input_indices: ${_.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${_e.length}; i++) {
        var input_index = ${_.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${X_("uniforms.input_shape","i",_e.length)}) {
          return false;
        }
      }
      return true;
    }`,x1=(_,_e,it,ut)=>_.rank>ut?`
    ${_.indicesSet("input_indices",_e,"channel")};
    ${_.indicesSet("input_indices",it,"batch")};
`:"",F2=(_,_e,it,ut,ct)=>{let[pt,ft,Bt,Gt]=it.length===2?[-1,0,1,-1]:[0,2,3,1],er=_.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${er} {
      var input_indices: ${_.type.indices};
      ${_.indicesSet("input_indices",ft,`max(0, min(row, ${it[ft]} - 1))`)};
      ${_.indicesSet("input_indices",Bt,`max(0, min(col, ${it[Bt]} - 1))`)};
      ${x1(_,Gt,pt,2)}
      return ${_.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${_e.type.indices}) -> ${er} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${er} = originalIndices[${ft}];
      var col:${er} = originalIndices[${Bt}];
      ${ut?`if (row < 0 || row > (${it[ft]} - 1) || col < 0 || col > (${it[Bt]} - 1)) {
        return ${ct};
      }`:""};
      row = max(0, min(row, ${it[ft]} - 1));
      col = max(0, min(col, ${it[Bt]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${it.length>2?`u32(originalIndices[${Gt}])`:"0"};
      var batch: u32 =  ${it.length>2?`u32(originalIndices[${pt}])`:"0"};
      var x11: ${er} = getInputValue(batch, channel, row1, col1);
      var x12: ${er} = getInputValue(batch, channel, row1, col2);
      var x21: ${er} = getInputValue(batch, channel, row2, col1);
      var x22: ${er} = getInputValue(batch, channel, row2, col2);
      var dx1: ${er} = abs(row - ${er}(row1));
      var dx2: ${er} = abs(${er}(row2) - row);
      var dy1: ${er} = abs(col - ${er}(col1));
      var dy2: ${er} = abs(${er}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Ow=(_,_e,it,ut,ct,pt,ft,Bt,Gt,er)=>{let Yr=it.length===2,[It,en]=Yr?[0,1]:[2,3],wn=_.type.value,_o=vn=>{let Ws=vn===It?"row":"col";return`
      fn ${Ws}CubicInterpolation(input_indices: ${_.type.indices}, output_indices: ${_e.type.indices}) -> ${wn} {
        var output_index = ${_e.indicesGet("output_indices",vn)};
        var originalIdx: ${wn} = getOriginalCoordinateFromResizedCoordinate(output_index, ${ct[vn]},
        ${ut[vn]}, ${it[vn]}, ${pt[vn]}, ${pt[vn]} + ${it.length});
        var fractOriginalIdx: ${wn} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${Bt} && (originalIdx < 0 || originalIdx > (${it[vn]} - 1))) {
          return ${Gt};
        }
        var data: array<${wn}, 4> = array<${wn}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${Ws}: ${wn} = originalIdx + ${wn}(i);
          if (${Ws} < 0 || ${Ws} >= ${it[vn]}) {
            ${er?`coefs[i + 1] = 0.0;
                        continue;`:Bt?`return ${Gt};`:`${Ws} = max(0, min(${Ws}, ${it[vn]} - 1));`};
          }
        var input_indices_copy: ${_.type.indices} = input_indices;
          ${_.indicesSet("input_indices_copy",vn,`u32(${Ws})`)};
          data[i + 1] = ${vn===It?_.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${_o(It)};
    ${_o(en)};
  fn getCubicInterpolationCoefs(s: ${wn}) -> array<${wn}, 4> {
    var absS = abs(s);
    var coeffs: array<${wn}, 4> = array<${wn}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${wn} = 1.0 - absS;
    var twoMinusAbsS: ${wn} = 2.0 - absS;
    var onePlusAbsS: ${wn} = 1.0 + absS;
    coeffs[0] = ((${ft} * onePlusAbsS - 5 * ${ft}) * onePlusAbsS + 8 * ${ft}) * onePlusAbsS - 4 * ${ft};
    coeffs[1] = ((${ft} + 2) * absS - (${ft} + 3)) * absS * absS + 1;
    coeffs[2] = ((${ft} + 2) * oneMinusAbsS - (${ft} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${ft} * twoMinusAbsS - 5 * ${ft}) * twoMinusAbsS + 8 * ${ft}) * twoMinusAbsS - 4 * ${ft};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${wn}, 4>, coefs: array<${wn}, 4>) -> ${wn} {
    var coefsSum: ${wn} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${_e.type.indices}) -> ${wn} {
    var input_indices: ${_.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},T1=(_,_e,it,ut,ct)=>{let[pt,ft,Bt,Gt,er]=it.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],Yr=_.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${Yr} {
      var input_indices: ${_.type.indices};
      ${_.indicesSet("input_indices",ft,`max(0, min(depth, ${it[ft]} - 1))`)};
      ${_.indicesSet("input_indices",Bt,`max(0, min(height, ${it[Bt]} - 1))`)};
      ${_.indicesSet("input_indices",Gt,`max(0, min(width, ${it[Gt]} - 1))`)};
      ${x1(_,er,pt,3)}
      return ${_.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${_e.type.indices}) -> ${Yr} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${Yr} = originalIndices[${ft}];
      var height:${Yr} = originalIndices[${Bt}];
      var width:${Yr} = originalIndices[${Gt}];
      ${ut?`if (depth < 0 || depth > (${it[ft]} - 1) || height < 0 || height > (${it[Bt]} - 1) || width < 0 || (width > ${it[Gt]} - 1)) {
      return ${ct};
        }`:""};

    depth = max(0, min(depth, ${it[ft]} - 1));
      height = max(0, min(height, ${it[Bt]} - 1));
      width = max(0, min(width, ${it[Gt]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${it.length>3?`u32(originalIndices[${er}])`:"0"};
      var batch: u32 =  ${it.length>3?`u32(originalIndices[${pt}])`:"0"};

      var x111: ${Yr} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${Yr} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${Yr} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${Yr} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${Yr} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${Yr} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${Yr} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${Yr} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${Yr} = abs(depth - ${Yr}(depth1));
      var dx2: ${Yr} = abs(${Yr}(depth2) - depth);
      var dy1: ${Yr} = abs(height - ${Yr}(height1));
      var dy2: ${Yr} = abs(${Yr}(height2) - height);
      var dz1: ${Yr} = abs(width - ${Yr}(width1));
      var dz2: ${Yr} = abs(${Yr}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},u2=(_,_e,it,ut,ct,pt)=>{let ft=_.dims,Bt=Zw(pt,_e.axes,ft.length),Gt=ww(ft,ut,ct,_e.axes),er=ut.slice();ut.length===0&&(er=ft.map((So,xa)=>So===0?1:Gt[xa]/So),_e.keepAspectRatioPolicy!=="stretch"&&(Gt=pw(ft,er,_e)));let Yr=Xr("output",_.dataType,Gt.length),It=v_("input",_.dataType,ft.length),en=Uu.size(Gt),wn=ft.length===Gt.length&&ft.every((So,xa)=>So===Gt[xa]),_o=_e.coordinateTransformMode==="tf_crop_and_resize",vn=_e.extrapolationValue,Ws=It.type.value,Jo=So=>`
      ${wn?"":`
      ${T0(_e.coordinateTransformMode,Ws)};
      ${(()=>{switch(_e.mode){case"nearest":return`
              ${mv(It,ft)};
              ${z0(_e.nearestMode,it,Ws)};
              ${fw(It,Yr,ft,Gt,er.length,Bt.length,_o)};
              `;case"linear":return`
              ${E0(Yr,ft,Gt,er.length,Bt.length)};
              ${(()=>{if(ft.length===2||ft.length===4)return`${F2(It,Yr,ft,_o,vn)}`;if(ft.length===3||ft.length===5)return`${T1(It,Yr,ft,_o,vn)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(ft.length===2||ft.length===4)return`${Ow(It,Yr,ft,Gt,er,Bt,_e.cubicCoeffA,_o,_e.extrapolationValue,_e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${So.registerUniform("output_size","u32").registerUniform("scales","f32",er.length).registerUniform("roi","f32",Bt.length).declareVariables(It,Yr)}
      ${So.mainStart()}
        ${So.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${wn?"output[global_idx] = input[global_idx];":`
        let output_indices = ${Yr.offsetToIndices("global_idx")};
        var input_indices: ${It.type.indices};
        ${(()=>{switch(_e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${It.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${_e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${ft.length===2||ft.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${_e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${_e.cacheKey}|${it}|${er.length>0?er:""}|${ct.length>0?ct:""}|${Bt.length>0?Bt:""}|${wn}|${ft}`,inputDependencies:["rank"]},getShaderSource:Jo,getRunData:()=>({outputs:[{dims:Gt,dataType:_.dataType}],dispatchGroup:{x:Math.ceil(en/64)},programUniforms:[{type:12,data:en},{type:1,data:er},{type:1,data:Bt},...U_(ft,Gt)]})}},c2=_=>{let _e=_.customDataBuffer;return new Uint32Array(_e,_e.byteOffset,1)[0]},d2=(_,_e)=>{let it=[],ut=[],ct=[],pt=c2(_);if(_e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Hy(_.inputs,_e,pt,it,ut,ct),_.compute(u2(_.inputs[0],_e,pt,it,ut,ct),{inputs:[0]})},cE=_=>{let _e=_.antialias,it=_.axes,ut=_.coordinateTransformMode,ct=_.cubicCoeffA,pt=_.excludeOutside!==0,ft=_.extrapolationValue,Bt=_.keepAspectRatioPolicy,Gt=_.mode,er=_.nearestMode===""?"simple":_.nearestMode;return sy({antialias:_e,axes:it,coordinateTransformMode:ut,cubicCoeffA:ct,excludeOutside:pt,extrapolationValue:ft,keepAspectRatioPolicy:Bt,mode:Gt,nearestMode:er})}}),y$,b$,w$,WP=$(()=>{ly(),J_(),Ey(),n_(),y$=(_,_e)=>{let[it,ut,ct,pt]=_,{numHeads:ft,rotaryEmbeddingDim:Bt}=_e;if(it.dims.length!==3&&it.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${it.dims.length}`);if(!Uu.areEqual(ut.dims,[])&&!Uu.areEqual(ut.dims,[1])&&ut.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${ut.dims.length}`);if(ct.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${ct.dims.length}`);if(pt.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${pt.dims.length}`);if(!Uu.areEqual(ct.dims,pt.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(Bt>0&&ft===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let Gt=it.dims[0],er=it.dims[it.dims.length-2],Yr=ct.dims[0],It=Uu.sizeFromDimension(it.dims,1)/er,en=Bt===0?ct.dims[1]*2:It/ft;if(Bt>en)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(ut.dims.length===2){if(Gt!==ut.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${ut.dims[0]}`);if(er!==ut.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${ut.dims[1]}`)}if(en/2!==ct.dims[1]&&Bt/2!==ct.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${ct.dims[1]}`);if(er>Yr)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},b$=(_,_e)=>{let{interleaved:it,numHeads:ut,rotaryEmbeddingDim:ct,scale:pt}=_e,ft=_[0].dims[0],Bt=Uu.sizeFromDimension(_[0].dims,1),Gt=_[0].dims[_[0].dims.length-2],er=Bt/Gt,Yr=_[2].dims[1],It=ct===0?Yr*2:er/ut,en=new Array(ft,Gt,er/It,It-Yr),wn=Uu.computeStrides(en),_o=[{type:1,data:pt},{type:12,data:en},{type:12,data:wn},..._[0].dims.length===3?new Array({type:12,data:[Bt,er,It,1]}):[],..._[0].dims.length===4?new Array({type:12,data:[Bt,It,Gt*It,1]}):[],...U_(_[0].dims,_[1].dims,_[2].dims,_[3].dims,_[0].dims)],vn=Ws=>{let Jo=v_("input",_[0].dataType,_[0].dims.length),So=v_("position_ids",_[1].dataType,_[1].dims.length),xa=v_("cos_cache",_[2].dataType,_[2].dims.length),$a=v_("sin_cache",_[3].dataType,_[3].dims.length),gu=Xr("output",_[0].dataType,_[0].dims.length);return Ws.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:en.length},{name:"global_strides",type:"u32",length:wn.length},{name:"input_output_strides",type:"u32",length:wn.length}]),`
        ${Ws.declareVariables(Jo,So,xa,$a,gu)}

        ${Ws.mainStart(k0)}
          let half_rotary_emb_dim = uniforms.${xa.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${Ws.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${So.broadcastedIndicesToOffset("bsnh.xy",Xr("",So.type.tensor,2))};
            let position_id =
                u32(${So.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${it});
            let j = i + select(half_rotary_emb_dim, 1, ${it});
            let re = ${Jo.getByOffset("i")} * ${xa.get("position_id","bsnh[3]")} -
                ${Jo.getByOffset("j")} * ${$a.get("position_id","bsnh[3]")};
            ${gu.setByOffset("i","re")}
            let im = ${Jo.getByOffset("i")} * ${$a.get("position_id","bsnh[3]")} +
                ${Jo.getByOffset("j")} * ${xa.get("position_id","bsnh[3]")};
            ${gu.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${gu.setByOffset("k",Jo.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:sy({interleaved:it}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:vn,getRunData:()=>({outputs:[{dims:_[0].dims,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(Uu.size(en)/k0)},programUniforms:_o})}},w$=(_,_e)=>{y$(_.inputs,_e),_.compute(b$(_.inputs,_e))}}),v$,x$,T$,VP=$(()=>{ly(),J_(),n_(),v$=_=>{if(!_||_.length<3)throw new Error("layerNorm requires at least 3 inputs.");let _e=_[0],it=_[1],ut=_[2];if(_e.dataType!==it.dataType||_e.dataType!==ut.dataType)throw new Error("All inputs must have the same data type");if(_e.dims.length!==3&&_e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(it.dims.length!==3&&it.dims.length!==2)throw new Error("Skip must be 2D or 3D");let ct=_e.dims[_e.dims.length-1],pt=_e.dims[_e.dims.length-2];if(it.dims[it.dims.length-1]!==ct)throw new Error("Skip must have the same hidden size as input");if(it.dims[it.dims.length-2]!==pt)throw new Error("Skip must have the same sequence length as input");if(ut.dims.length!==1)throw new Error("Gamma must be 1D");if(ut.dims[ut.dims.length-1]!==ct)throw new Error("Gamma must have the same hidden size as input");if(_.length>3){let ft=_[3];if(ft.dims.length!==1)throw new Error("Beta must be 1D");if(ft.dims[ft.dims.length-1]!==ct)throw new Error("Beta must have the same hidden size as input")}if(_.length>4){let ft=_[4];if(ft.dims.length!==1)throw new Error("Bias must be 1D");if(ft.dims[ft.dims.length-1]!==ct)throw new Error("Bias must have the same hidden size as input")}},x$=(_,_e,it,ut)=>{let ct=_e.simplified,pt=_[0].dims,ft=Uu.size(pt),Bt=pt,Gt=ft,er=pt.slice(-1)[0],Yr=ut?pt.slice(0,-1).concat(1):[],It=!ct&&_.length>3,en=_.length>4,wn=ut&&it>1,_o=ut&&it>2,vn=it>3,Ws=64,Jo=_y(er),So=[{type:12,data:Gt},{type:12,data:Jo},{type:12,data:er},{type:1,data:_e.epsilon}],xa=gu=>{let u_=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],c_=[v_("x",_[0].dataType,_[0].dims,Jo),v_("skip",_[1].dataType,_[1].dims,Jo),v_("gamma",_[2].dataType,_[2].dims,Jo)];It&&c_.push(v_("beta",_[3].dataType,_[3].dims,Jo)),en&&c_.push(v_("bias",_[4].dataType,_[4].dims,Jo)),c_.push(Xr("output",_[0].dataType,Bt,Jo)),wn&&c_.push(Xr("mean_output",1,Yr)),_o&&c_.push(Xr("inv_std_output",1,Yr)),vn&&c_.push(Xr("input_skip_bias_sum",_[0].dataType,Bt,Jo));let R_=jy(_[0].dataType),ny=jy(1,Jo);return`

      ${gu.registerUniforms(u_).declareVariables(...c_)}
      var<workgroup> sum_shared : array<${ny}, ${Ws}>;
      var<workgroup> sum_squared_shared : array<${ny}, ${Ws}>;

      ${gu.mainStart([Ws,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${Ws};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${Ws};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${Ws-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${en?"bias[offset1d + i]":R_+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${vn?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${s0(R_,Jo,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${Ws};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${S0("sum",Jo)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${S0("square_sum",Jo)} / f32(uniforms.hidden_size) ${ct?"":"- mean * mean"} + uniforms.epsilon);
        ${wn?"mean_output[global_idx] = mean;":""}
        ${_o?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${ct?"":`- ${R_}(mean)`}) *
            ${R_}(inv_std_dev) * gamma[offset1d + i]
            ${It?"+ beta[offset1d + i]":""};
        }
      }`},$a=[{dims:Bt,dataType:_[0].dataType}];return it>1&&$a.push({dims:Yr,dataType:1}),it>2&&$a.push({dims:Yr,dataType:1}),it>3&&$a.push({dims:pt,dataType:_[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${Jo};${wn};${_o};${vn}`,inputDependencies:_.map((gu,u_)=>"type")},getShaderSource:xa,getRunData:()=>({outputs:$a,dispatchGroup:{x:Math.ceil(Gt/er)},programUniforms:So})}},T$=(_,_e)=>{v$(_.inputs);let it=[0];_.outputCount>1&&it.push(-3),_.outputCount>2&&it.push(-3),_.outputCount>3&&it.push(3),_.compute(x$(_.inputs,_e,_.outputCount,!1),{outputs:it})}}),E$,dE,$$,R2,M$,P$,k$,S$,KP=$(()=>{ly(),J_(),Ey(),n_(),E$=(_,_e)=>{if(!_||_.length<1)throw new Error("too few inputs");if(_e.axes.length!==0){if(_e.axes.length!==_e.starts.length||_e.axes.length!==_e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(_e.starts.length!==_e.ends.length)throw new Error("starts and ends must have the same length");_.slice(1).forEach((it,ut)=>{if(_[ut+1].dataType!==6&&_[ut+1].dataType!==7)throw new Error(`Input ${ut} must be an array of int32 or int64`)})},dE=(_,_e)=>{let it=[];if(_.length>_e)if(_[_e].dataType===7)_[_e].getBigInt64Array().forEach(ut=>it.push(Number(ut)));else if(_[_e].dataType===6)_[_e].getInt32Array().forEach(ut=>it.push(Number(ut)));else throw new Error(`Input ${_e} must be an array of int32 or int64`);return it},$$=(_,_e)=>{if(_.length>1){let it=dE(_,1),ut=dE(_,2),ct=dE(_,3);return ct.length===0&&(ct=[...Array(_[0].dims.length).keys()]),sy({starts:it,ends:ut,axes:ct})}else return _e},R2=(_,_e,it,ut,ct)=>{let pt=_;return _<0&&(pt+=it[ut[_e]]),ct[_e]<0?Math.max(0,Math.min(pt,it[ut[_e]]-1)):Math.max(0,Math.min(pt,it[ut[_e]]))},M$=(_,_e,it)=>`fn calculateInputIndices(output_indices: ${_e.type.indices}) -> ${_.type.indices} {
          var input_indices: ${_.type.indices};
          var carry = 0u;
          for (var i = ${it.length}; i >= 0; i--) {
            let input_shape_i = ${X_("uniforms.input_shape","i",it.length)};
            let steps_i = ${X_("uniforms.steps","i",it.length)};
            let signs_i = ${X_("uniforms.signs","i",it.length)};
            let starts_i = ${X_("uniforms.starts","i",it.length)};
            var output_index = ${_e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${_.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,P$=(_,_e)=>{let it=_[0].dims,ut=Uu.size(it),ct=_e.axes.length>0?Uu.normalizeAxes(_e.axes,it.length):[...Array(it.length).keys()],pt=dE(_,4);pt.forEach(Jo=>Jo!==0||(()=>{throw new Error("step cannot be 0")})),pt.length===0&&(pt=Array(ct.length).fill(1));let ft=_e.starts.map((Jo,So)=>R2(Jo,So,it,ct,pt)),Bt=_e.ends.map((Jo,So)=>R2(Jo,So,it,ct,pt));if(ct.length!==ft.length||ct.length!==Bt.length)throw new Error("start, ends and axes should have the same number of elements");if(ct.length!==it.length)for(let Jo=0;Jo<it.length;++Jo)ct.includes(Jo)||(ft.splice(Jo,0,0),Bt.splice(Jo,0,it[Jo]),pt.splice(Jo,0,1));let Gt=pt.map(Jo=>Math.sign(Jo));pt.forEach((Jo,So,xa)=>{if(Jo<0){let $a=(Bt[So]-ft[So])/Jo,gu=ft[So],u_=gu+$a*pt[So];ft[So]=u_,Bt[So]=gu,xa[So]=-Jo}});let er=it.slice(0);ct.forEach((Jo,So)=>{er[Jo]=Math.ceil((Bt[Jo]-ft[Jo])/pt[Jo])});let Yr={dims:er,dataType:_[0].dataType},It=Xr("output",_[0].dataType,er.length),en=v_("input",_[0].dataType,_[0].dims.length),wn=Uu.size(er),_o=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:ft.length},{name:"signs",type:"i32",length:Gt.length},{name:"steps",type:"u32",length:pt.length}],vn=[{type:12,data:wn},{type:12,data:ft},{type:6,data:Gt},{type:12,data:pt},...U_(_[0].dims,er)],Ws=Jo=>`
      ${Jo.registerUniforms(_o).declareVariables(en,It)}
        ${M$(en,It,it)}
        ${Jo.mainStart()}
          ${Jo.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${It.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${It.setByOffset("global_idx",en.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${Gt.length}_${ft.length}_${pt.length}`,inputDependencies:["rank"]},getShaderSource:Ws,getRunData:()=>({outputs:[Yr],dispatchGroup:{x:Math.ceil(ut/64)},programUniforms:vn})}},k$=(_,_e)=>{E$(_.inputs,_e);let it=$$(_.inputs,_e);_.compute(P$(_.inputs,it),{inputs:[0]})},S$=_=>{let _e=_.starts,it=_.ends,ut=_.axes;return sy({starts:_e,ends:it,axes:ut})}}),O$,A$,C$,I$,GP=$(()=>{ly(),J_(),Ey(),n_(),O$=_=>{if(!_||_.length!==1)throw new Error("Softmax op requires 1 input.")},A$=(_,_e)=>{let it=_.dims,ut=Uu.size(it),ct=64,pt=_e.axis;if(pt<0&&(pt=it.length+pt),pt<it.length-1)throw new Error("softmax only supports last axis for now.");let ft=it[pt],Bt=ut/ft,Gt=_y(ft),er=ft/Gt,Yr=(Ws,Jo)=>Jo===4?`max(max(${Ws}.x, ${Ws}.y), max(${Ws}.z, ${Ws}.w))`:Jo===2?`max(${Ws}.x, ${Ws}.y)`:Jo===3?`max(max(${Ws}.x, ${Ws}.y), ${Ws}.z)`:Ws,It=v_("x",_.dataType,_.dims,Gt),en=Xr("result",_.dataType,_.dims,Gt),wn=It.type.value,_o=jy(_.dataType)==="f32"?`var threadMax = ${wn}(-3.402823e+38f);`:`var threadMax = ${wn}(-65504.0h);`,vn=Ws=>`
      var<workgroup> rowMaxShared : ${wn};
      var<workgroup> rowSumShared : ${wn};
      var<workgroup> threadShared : array<${wn}, ${ct}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${wn} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${wn}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${Ws.registerUniform("packedCols","i32").declareVariables(It,en)}
      ${Ws.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${ct};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${_o}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${wn}(${Yr("threadShared[0]",Gt)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${wn}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${wn}(${S0("threadShared[0]",Gt)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${Gt}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:it,dataType:_.dataType}],dispatchGroup:{x:Bt},programUniforms:[{type:6,data:er}]}),getShaderSource:vn}},C$=(_,_e)=>{O$(_.inputs),_.compute(A$(_.inputs[0],_e))},I$=_=>sy({axis:_.axis})}),D$,F$,R$,L$,B$,j$,z$,HP=$(()=>{ly(),J_(),Ey(),n_(),D$=_=>{if(!_||_.length<1)throw new Error("too few inputs")},F$=(_,_e)=>{let it=[],ut=_e.numOutputs;return _[1].dims[0]>0&&(_[1].getBigInt64Array().forEach(ct=>it.push(Number(ct))),ut=it.length),sy({numOutputs:ut,axis:_e.axis,splitSizes:it})},R$=_=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${_}u; i += 1u ) {
    if (index < ${X_("uniforms.size_in_split_axis","i",_)}) {
        return i;
    }
    }
    return ${_}u;
}`,L$=_=>{let _e=_.length,it=[];for(let ut=0;ut<_e;++ut){let ct=_[ut].setByIndices("indices","input[global_idx]");_e===1?it.push(ct):ut===0?it.push(`if (output_number == ${ut}u) { ${ct} }`):ut===_e-1?it.push(`else { ${ct} }`):it.push(`else if (output_number == ${ut}) { ${ct} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${_[0].type.indices}, global_idx: u32) {
        ${it.join(`
`)}
      }`},B$=(_,_e)=>{let it=_[0].dims,ut=Uu.size(it),ct=_[0].dataType,pt=Uu.normalizeAxis(_e.axis,it.length),ft=new Array(_e.numOutputs),Bt=v_("input",ct,it.length),Gt=new Array(_e.numOutputs),er=[],Yr=[],It=0,en=[{type:12,data:ut}];for(let _o=0;_o<_e.numOutputs;_o++){It+=_e.splitSizes[_o],Gt[_o]=It;let vn=it.slice();vn[pt]=_e.splitSizes[_o],Yr.push(vn),ft[_o]=Xr(`output${_o}`,ct,vn.length),er.push({dims:Yr[_o],dataType:_[0].dataType})}en.push({type:12,data:Gt},...U_(it,...Yr));let wn=_o=>`
  ${_o.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",Gt.length).declareVariables(Bt,...ft)}
  ${R$(Gt.length)}
  ${L$(ft)}

  ${_o.mainStart()}
    ${_o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${Bt.offsetToIndices("global_idx")};
    var index = ${Bt.indicesGet("indices",pt)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${X_("uniforms.size_in_split_axis","output_number - 1u",Gt.length)};
      ${Bt.indicesSet("indices",pt,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:_e.cacheKey,inputDependencies:["rank"]},getShaderSource:wn,getRunData:()=>({outputs:er,dispatchGroup:{x:Math.ceil(ut/64)},programUniforms:en})}},j$=(_,_e)=>{D$(_.inputs);let it=_.inputs.length===1?_e:F$(_.inputs,_e);_.compute(B$(_.inputs,it),{inputs:[0]})},z$=_=>{let _e=_.axis,it=_.splitSizes,ut=_.numOutputs<0?it.length:_.numOutputs;if(ut!==it.length)throw new Error("numOutputs and splitSizes lengh must be equal");return sy({axis:_e,numOutputs:ut,splitSizes:it})}}),N$,U$,W$,qP=$(()=>{ly(),J_(),n_(),N$=(_,_e,it,ut,ct)=>{let pt=Xr("output_data",ct,it.length,4),ft=v_("a_data",_e[1].dataType,_e[1].dims.length,4),Bt=v_("b_data",_e[2].dataType,_e[2].dims.length,4),Gt=v_("c_data",_e[0].dataType,_e[0].dims.length,4),er,Yr=(It,en,wn)=>`select(${en}, ${It}, ${wn})`;if(!ut)er=pt.setByOffset("global_idx",Yr(ft.getByOffset("global_idx"),Bt.getByOffset("global_idx"),Gt.getByOffset("global_idx")));else{let It=(en,wn,_o="")=>{let vn=`a_data[index_a${wn}][component_a${wn}]`,Ws=`b_data[index_b${wn}][component_b${wn}]`,Jo=`bool(c_data[index_c${wn}] & (0xffu << (component_c${wn} * 8)))`;return`
            let output_indices${wn} = ${pt.offsetToIndices(`global_idx * 4u + ${wn}u`)};
            let offset_a${wn} = ${ft.broadcastedIndicesToOffset(`output_indices${wn}`,pt)};
            let offset_b${wn} = ${Bt.broadcastedIndicesToOffset(`output_indices${wn}`,pt)};
            let offset_c${wn} = ${Gt.broadcastedIndicesToOffset(`output_indices${wn}`,pt)};
            let index_a${wn} = offset_a${wn} / 4u;
            let index_b${wn} = offset_b${wn} / 4u;
            let index_c${wn} = offset_c${wn} / 4u;
            let component_a${wn} = offset_a${wn} % 4u;
            let component_b${wn} = offset_b${wn} % 4u;
            let component_c${wn} = offset_c${wn} % 4u;
            ${en}[${wn}] = ${_o}(${Yr(vn,Ws,Jo)});
          `};ct===9?er=`
            var data = vec4<u32>(0);
            ${It("data",0,"u32")}
            ${It("data",1,"u32")}
            ${It("data",2,"u32")}
            ${It("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:er=`
            ${It("output_data[global_idx]",0)}
            ${It("output_data[global_idx]",1)}
            ${It("output_data[global_idx]",2)}
            ${It("output_data[global_idx]",3)}
          `}return`
        ${_.registerUniform("vec_size","u32").declareVariables(Gt,ft,Bt,pt)}
        ${_.mainStart()}
        ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${er}
      }`},U$=_=>{let _e=_[1].dims,it=_[2].dims,ut=_[0].dims,ct=_[1].dataType,pt=!(Uu.areEqual(_e,it)&&Uu.areEqual(it,ut)),ft=_e,Bt=Uu.size(_e);if(pt){let er=h0.calcShape(h0.calcShape(_e,it,!1),ut,!1);if(!er)throw new Error("Can't perform where op on the given tensors");ft=er,Bt=Uu.size(ft)}let Gt=Math.ceil(Bt/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:er=>N$(er,_,ft,pt,ct),getRunData:()=>({outputs:[{dims:ft,dataType:ct}],dispatchGroup:{x:Math.ceil(Bt/64/4)},programUniforms:[{type:12,data:Gt},...U_(ut,_e,it,ft)]})}},W$=_=>{_.compute(U$(_.inputs))}}),V$,XP=$(()=>{zt(),Su(),Au(),o_(),wE(),vE(),Yx(),$E(),xT(),SE(),OE(),FT(),CE(),IE(),DE(),O2(),LE(),BE(),zE(),A2(),C2(),dT(),I2(),YT(),D2(),l_(),Gy(),xy(),kw(),UP(),WP(),VP(),KP(),GP(),HP(),eE(),$y(),Cv(),qP(),V$=new Map([["Abs",[V_]],["Acos",[I_]],["Acosh",[W_]],["Add",[Fv]],["ArgMax",[lt,wt]],["ArgMin",[w1,wt]],["Asin",[K_]],["Asinh",[A_]],["Atan",[my]],["Atanh",[vy]],["Attention",[uu]],["AveragePool",[H0,V0]],["BatchNormalization",[yu]],["BiasAdd",[t_]],["BiasSplitGelu",[Rx]],["Cast",[Fy,Dy]],["Ceil",[C0]],["Clip",[Oy]],["Concat",[qx,Xx]],["Conv",[Gv,Vv]],["ConvTranspose",[vT,gT]],["Cos",[I0]],["Cosh",[Hw]],["CumSum",[ET,Yv]],["DepthToSpace",[PT,kT]],["DequantizeLinear",[Q_,py]],["Div",[Bx]],["Einsum",[IT,DT]],["Elu",[Sw,x0]],["Equal",[jx]],["Erf",[wx]],["Exp",[vx]],["Expand",[LT]],["FastGelu",[BT]],["Floor",[Tv]],["FusedConv",[Gv,Vv]],["Gather",[ox,zT]],["GatherElements",[VT,ix]],["GatherBlockQuantized",[WT,a0]],["Gelu",[xx]],["Gemm",[ax,sx]],["GlobalAveragePool",[uE,l2]],["GlobalMaxPool",[eu,Io]],["Greater",[Ux]],["GreaterOrEqual",[Vx]],["GroupQueryAttention",[oE,rE]],["HardSigmoid",[Mv,Mx]],["InstanceNormalization",[VE]],["LayerNormalization",[HE]],["LeakyRelu",[Tx,x0]],["Less",[Wx]],["LessOrEqual",[Rv]],["Log",[Ov]],["MatMul",[cT]],["MatMulNBits",[YE,QE]],["MaxPool",[jr,tr]],["Mul",[zx]],["MultiHeadAttention",[XT,jE]],["Neg",[Ex]],["Not",[rv]],["Pad",[s2]],["Pow",[Nx]],["QuickGelu",[Av,x0]],["Range",[Ny]],["Reciprocal",[$x]],["ReduceMin",[tv]],["ReduceMean",[Kw]],["ReduceMax",[Z0]],["ReduceSum",[F1]],["ReduceProd",[a1]],["ReduceL1",[mw]],["ReduceL2",[m0]],["ReduceLogSum",[l1]],["ReduceLogSumExp",[Gw]],["ReduceSumSquare",[Pw]],["Relu",[Ev]],["Resize",[d2,cE]],["RotaryEmbedding",[w$]],["Sigmoid",[$v]],["Sin",[Px]],["Sinh",[kx]],["Slice",[k$,S$]],["SkipLayerNormalization",[T$]],["Split",[j$,z$]],["Sqrt",[Sx]],["Softmax",[C$,I$]],["Sub",[ov]],["Tan",[Pv]],["Tanh",[Ox]],["ThresholdedRelu",[Cx,x0]],["Tile",[JT]],["Transpose",[e1,h_]],["Where",[W$]]])}),K$,YP=$(()=>{L_(),R0(),n_(),K$=class{constructor(_){this.backend=_,this.repo=new Map,this.attributesBound=!1}getArtifact(_){return this.repo.get(_)}setArtifact(_,_e){this.repo.set(_,_e)}run(_,_e,it,ut,ct){e_(_.programInfo.name);let pt=this.backend.device,ft=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let Bt=[];for(let er of _e)Bt.push({binding:Bt.length,resource:{buffer:er.buffer}});for(let er of it)Bt.push({binding:Bt.length,resource:{buffer:er.buffer}});ct&&Bt.push({binding:Bt.length,resource:ct});let Gt=pt.createBindGroup({layout:_.computePipeline.getBindGroupLayout(0),entries:Bt,label:_.programInfo.name});if(this.backend.sessionStatus==="capturing"){let er={kernelId:this.backend.currentKernelId,computePipeline:_.computePipeline,bindGroup:Gt,dispatchGroup:ut};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(er)}ft.setPipeline(_.computePipeline),ft.setBindGroup(0,Gt),ft.dispatchWorkgroups(...ut),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),ar(_.programInfo.name)}dispose(){}build(_,_e){e_(_.name);let it=this.backend.device,ut=[];it.features.has("shader-f16")&&ut.push("enable f16;");let ct=Pu(_e,this.backend.device.limits),pt=_.getShaderSource(ct),ft=`${ut.join(`
`)}
${ct.additionalImplementations}
${pt}`,Bt=it.createShaderModule({code:ft,label:_.name});Jy("verbose",()=>`[WebGPU] ${_.name} shader code: ${ft}`);let Gt=it.createComputePipeline({compute:{module:Bt,entryPoint:"main"},layout:"auto",label:_.name});return ar(_.name),{programInfo:_,computePipeline:Gt,uniformVariablesInfo:ct.variablesInfo}}normalizeDispatchGroupSize(_){let _e=typeof _=="number"?_:_.x,it=typeof _=="number"?1:_.y||1,ut=typeof _=="number"?1:_.z||1,ct=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(_e<=ct&&it<=ct&&ut<=ct)return[_e,it,ut];let pt=_e*it*ut,ft=Math.ceil(Math.sqrt(pt));if(ft>ct){if(ft=Math.ceil(Math.cbrt(pt)),ft>ct)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[ft,ft,ft]}else return[ft,ft,1]}}}),G$,H$,q$,X$,QP=$(()=>{L_(),ly(),R0(),wr(),ay(),XP(),YP(),G$=(_,_e)=>{if(_e.length!==_.length)throw new Error(`inputDependencies length ${_e.length} is not equal to inputTensors length ${_.length}.`);let it=[];for(let ut=0;ut<_.length;++ut){let ct=_[ut].dataType;switch(_e[ut]){case"none":{it.push("");break}case"type":{it.push(`${ct}`);break}case"rank":{let pt=_[ut].dims.length;it.push(`${ct};${pt}`);break}case"dims":{let pt=_[ut].dims.join(",");it.push(`${ct};${pt}`);break}default:throw new Error(`unsupported input dependency: ${_e[ut]}`)}}return it.join("|")},H$=(_,_e,it)=>{let ut=_.name;return _.shaderCache?.hint&&(ut+="["+_.shaderCache.hint+"]"),ut+=":"+it+`:${G$(_e,_.shaderCache?.inputDependencies??new Array(_e.length).fill("dims"))}`,ut},q$=class{constructor(_){_&&(this.architecture=_.architecture,this.vendor=_.vendor)}isArchitecture(_){return this.architecture===_}isVendor(_){return this.vendor===_}},X$=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let _=this.kernelCustomData.get(this.currentKernelId);return _||(_={},this.kernelCustomData.set(this.currentKernelId,_)),_}async initialize(_,_e){this.env=_;let it=[],ut={requiredLimits:{maxComputeWorkgroupStorageSize:_e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:_e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:_e.limits.maxStorageBufferBindingSize,maxBufferSize:_e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:_e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:_e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:_e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:_e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:it};_e.features.has("chromium-experimental-timestamp-query-inside-passes")?it.push("chromium-experimental-timestamp-query-inside-passes"):_e.features.has("timestamp-query")&&it.push("timestamp-query"),_e.features.has("shader-f16")&&it.push("shader-f16"),this.device=await _e.requestDevice(ut),this.adapterInfo=new q$(_e.info||await _e.requestAdapterInfo()),this.gpuDataManager=Cy(this),this.programManager=new K$(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,nw(_.logLevel,!!_.debug),this.device.onuncapturederror=ct=>{ct.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${ct.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:_e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let _=this.getCommandEncoder(),_e={};this.queryType==="at-passes"&&(_e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=_.beginComputePass(_e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;e_(),this.endComputePass();let _;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),_=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(_,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,_,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&_.mapAsync(GPUMapMode.READ).then(()=>{let _e=new BigUint64Array(_.getMappedRange()),it=this.pendingQueries.get(_);for(let ut=0;ut<_e.length/2;ut++){let ct=it[ut],pt=ct.kernelId,ft=this.kernels.get(pt),Bt=ft.kernelType,Gt=ft.kernelName,er=ct.programName,Yr=ct.inputTensorViews,It=ct.outputTensorViews,en=_e[ut*2],wn=_e[ut*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=en);let _o=Number(en-this.queryTimeBase),vn=Number(wn-this.queryTimeBase);if(!Number.isSafeInteger(_o)||!Number.isSafeInteger(vn))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:Yr.map(Ws=>({dims:Ws.dims,dataType:F0(Ws.dataType)})),outputsMetadata:It.map(Ws=>({dims:Ws.dims,dataType:F0(Ws.dataType)})),kernelId:pt,kernelType:Bt,kernelName:Gt,programName:er,startTime:_o,endTime:vn});else{let Ws="";Yr.forEach((So,xa)=>{Ws+=`input[${xa}]: [${So.dims}] | ${F0(So.dataType)}, `});let Jo="";It.forEach((So,xa)=>{Jo+=`output[${xa}]: [${So.dims}] | ${F0(So.dataType)}, `}),console.log(`[profiling] kernel "${pt}|${Bt}|${Gt}|${er}" ${Ws}${Jo}execution time: ${vn-_o} ns`)}vu("GPU",`${er}::${en}::${wn}`)}_.unmap(),this.pendingQueries.delete(_)}),ar()}run(_,_e,it,ut,ct,pt){e_(_.name);let ft=[];for(let So=0;So<_e.length;++So){let xa=_e[So].data;if(xa===0)continue;let $a=this.gpuDataManager.get(xa);if(!$a)throw new Error(`no GPU data for input: ${xa}`);ft.push($a)}let{outputs:Bt,dispatchGroup:Gt,programUniforms:er}=_.getRunData(_e),Yr=it.length===0?Bt.map((So,xa)=>xa):it;if(Yr.length!==Bt.length)throw new Error(`Output size ${Yr.length} must be equal to ${Bt.length}.`);let It=[],en=[];for(let So=0;So<Bt.length;++So){if(!Number.isInteger(Yr[So])||Yr[So]<-3||Yr[So]>=pt)throw new Error(`Invalid output index: ${Yr[So]}`);if(Yr[So]===-3)continue;let xa=Yr[So]===-1,$a=Yr[So]===-2,gu=xa||$a?ct(Bt[So].dataType,Bt[So].dims):ut(Yr[So],Bt[So].dataType,Bt[So].dims);if(It.push(gu),gu.data===0)continue;let u_=this.gpuDataManager.get(gu.data);if(!u_)throw new Error(`no GPU data for output: ${gu.data}`);if(xa&&this.temporaryData.push(u_),$a){let c_=this.kernelPersistentData.get(this.currentKernelId);c_||(c_=[],this.kernelPersistentData.set(this.currentKernelId,c_)),c_.push(u_)}en.push(u_)}if(ft.length!==_e.length||en.length!==It.length){if(en.length===0)return ar(_.name),It;throw new Error(`Program ${_.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let wn;if(er){let So=0,xa=[];er.forEach(c_=>{let R_=typeof c_.data=="number"?[c_.data]:c_.data;if(R_.length===0)return;let ny=c_.type===10?2:4,ty,Ly;c_.type===10?(Ly=R_.length>4?16:R_.length>2?8:R_.length*ny,ty=R_.length>4?16:ny*R_.length):(Ly=R_.length<=2?R_.length*ny:16,ty=16),So=Math.ceil(So/Ly)*Ly,xa.push(So);let ky=c_.type===10?8:4;So+=R_.length>4?Math.ceil(R_.length/ky)*ty:R_.length*ny});let $a=16;So=Math.ceil(So/$a)*$a;let gu=new ArrayBuffer(So);er.forEach((c_,R_)=>{let ny=xa[R_],ty=typeof c_.data=="number"?[c_.data]:c_.data;if(c_.type===6)new Int32Array(gu,ny,ty.length).set(ty);else if(c_.type===12)new Uint32Array(gu,ny,ty.length).set(ty);else if(c_.type===10)new Uint16Array(gu,ny,ty.length).set(ty);else if(c_.type===1)new Float32Array(gu,ny,ty.length).set(ty);else throw new Error(`Unsupported uniform type: ${F0(c_.type)}`)});let u_=this.gpuDataManager.create(So,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(u_.buffer,0,gu,0,So),this.gpuDataManager.release(u_.id),wn={offset:0,size:So,buffer:u_.buffer}}let _o=this.programManager.normalizeDispatchGroupSize(Gt),vn=_o[1]===1&&_o[2]===1,Ws=H$(_,_e,vn),Jo=this.programManager.getArtifact(Ws);if(Jo||(Jo=this.programManager.build(_,_o),this.programManager.setArtifact(Ws,Jo),Jy("info",()=>`[artifact] key: ${Ws}, programName: ${_.name}`)),er&&Jo.uniformVariablesInfo){if(er.length!==Jo.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${Jo.uniformVariablesInfo.length}, got ${er.length} in program "${Jo.programInfo.name}".`);for(let So=0;So<er.length;So++){let xa=er[So],$a=xa.type,gu=typeof xa.data=="number"?1:xa.data.length,[u_,c_]=Jo.uniformVariablesInfo[So];if($a!==u_||gu!==c_)throw new Error(`Uniform variable ${So} mismatch: expect type ${u_} with size ${c_}, got type ${$a} with size ${gu} in program "${Jo.programInfo.name}".`)}}if(Jy("info",()=>`[ProgramManager] run "${_.name}" (key=${Ws}) with ${_o[0]}x${_o[1]}x${_o[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let So={kernelId:this.currentKernelId,programName:Jo.programInfo.name,inputTensorViews:_e,outputTensorViews:It};this.pendingKernels.push(So),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(So)}return this.programManager.run(Jo,ft,en,_o,wn),ar(_.name),It}upload(_,_e){this.gpuDataManager.upload(_,_e)}memcpy(_,_e){this.gpuDataManager.memcpy(_,_e)}async download(_,_e){await this.gpuDataManager.download(_,_e)}alloc(_){return this.gpuDataManager.create(_).id}free(_){return this.gpuDataManager.release(_)}createKernel(_,_e,it,ut){let ct=V$.get(_);if(!ct)throw new Error(`kernel not implemented: ${_}`);let pt={kernelType:_,kernelName:ut,kernelEntry:ct[0],attributes:[ct[1],it]};this.kernels.set(_e,pt)}releaseKernel(_){let _e=this.kernelPersistentData.get(_);if(_e){for(let it of _e)this.gpuDataManager.release(it.id);this.kernelPersistentData.delete(_)}this.kernelCustomData.delete(_),this.kernels.delete(_)}computeKernel(_,_e,it){let ut=this.kernels.get(_);if(!ut)throw new Error(`kernel not created: ${_}`);let ct=ut.kernelType,pt=ut.kernelName,ft=ut.kernelEntry,Bt=ut.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${ct}] ${pt}" is not allowed to be called recursively`);this.currentKernelId=_,Bt[0]&&(Bt[1]=Bt[0](Bt[1]),Bt[0]=void 0),Jy("info",()=>`[WebGPU] Start to run kernel "[${ct}] ${pt}"...`);let Gt=this.env.debug;this.temporaryData=[];try{return Gt&&this.device.pushErrorScope("validation"),ft(_e,Bt[1]),0}catch(er){return it.push(Promise.resolve(`[WebGPU] Kernel "[${ct}] ${pt}" failed. ${er}`)),1}finally{Gt&&it.push(this.device.popErrorScope().then(er=>er?`GPU validation error for kernel "[${ct}] ${pt}": ${er.message}`:null));for(let er of this.temporaryData)this.gpuDataManager.release(er.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(_,_e,it,ut){let ct=this.sessionExternalDataMapping.get(_);ct||(ct=new Map,this.sessionExternalDataMapping.set(_,ct));let pt=ct.get(_e),ft=this.gpuDataManager.registerExternalBuffer(it,ut,pt?.[1]);return ct.set(_e,[ft,it]),ft}unregisterBuffers(_){let _e=this.sessionExternalDataMapping.get(_);_e&&(_e.forEach(it=>this.gpuDataManager.unregisterExternalBuffer(it[1])),this.sessionExternalDataMapping.delete(_))}getBuffer(_){let _e=this.gpuDataManager.get(_);if(!_e)throw new Error(`no GPU data for buffer: ${_}`);return _e.buffer}createDownloader(_,_e,it){return async()=>{let ut=await z_(this,_,_e);return xu(ut.buffer,it)}}writeTimestamp(_){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,_)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Jy("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Jy("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Jy("info","replay"),this.sessionStatus="replaying";let _=this.capturedCommandList.get(this.currentSessionId),_e=this.capturedPendingKernels.get(this.currentSessionId),it=_.length;this.pendingKernels=[];for(let ut=0;ut<it;ut++){let ct=this.getComputePassEncoder(),pt=_[ut];this.writeTimestamp(this.pendingDispatchNumber*2),ct.setPipeline(pt.computePipeline),ct.setBindGroup(0,pt.bindGroup),ct.dispatchWorkgroups(...pt.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(_e[ut]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(_){this.unregisterBuffers(_),this.capturedCommandList.has(_)&&this.capturedCommandList.delete(_),this.capturedPendingKernels.has(_)&&this.capturedPendingKernels.delete(_),this.gpuDataManager.onReleaseSession(_)}onRunStart(_){this.currentSessionId=_,this.setQueryType()}}}),Y$={};c(Y$,{init:()=>Z$});var p2,Q$,Z$,ZP=$(()=>{ly(),QP(),R0(),J_(),p2=class BP{constructor(_e,it,ut,ct){this.module=_e,this.dataType=it,this.data=ut,this.dims=ct}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let _e=Uu.size(this.dims);return _e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,_e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let _e=Uu.size(this.dims);return _e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,_e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let _e=Uu.size(this.dims);return _e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,_e)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let _e=Uu.size(this.dims);return _e===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,_e)}reshape(_e){if(Uu.size(_e)!==Uu.size(this.dims))throw new Error("Invalid new shape");return new BP(this.module,this.dataType,this.data,_e)}},Q$=class{constructor(_,_e,it){this.module=_,this.backend=_e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=_e.adapterInfo;let ut=_.HEAPU32,ct=it>>>2;this.opKernelContext=ut[ct++];let pt=ut[ct++];this.outputCount=ut[ct++],this.customDataOffset=ut[ct++],this.customDataSize=ut[ct++];let ft=[];for(let Bt=0;Bt<pt;Bt++){let Gt=ut[ct++],er=ut[ct++],Yr=ut[ct++],It=[];for(let en=0;en<Yr;en++)It.push(ut[ct++]);ft.push(new p2(_,Gt,er,It))}this.inputs=ft}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(_,_e){let it=_e?.inputs?.map(ft=>typeof ft=="number"?this.inputs[ft]:ft)??this.inputs,ut=_e?.outputs??[],ct=(ft,Bt,Gt)=>new p2(this.module,Bt,this.output(ft,Gt),Gt),pt=(ft,Bt)=>{let Gt=X0(ft,Bt);if(!Gt)throw new Error(`Unsupported data type: ${ft}`);let er=Gt>0?this.backend.gpuDataManager.create(Gt).id:0;return new p2(this.module,ft,er,Bt)};return this.backend.run(_,it,ut,ct,pt,this.outputCount)}output(_,_e){let it=this.module.stackSave();try{let ut=this.module.stackAlloc((1+_e.length)*4),ct=ut>>2;this.module.HEAPU32[ct++]=_e.length;for(let pt=0;pt<_e.length;pt++)this.module.HEAPU32[ct++]=_e[pt];return this.module._JsepOutput(this.opKernelContext,_,ut)}catch(ut){throw new Error(`Failed to generate kernel's output[${_}] with dims [${_e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${ut}`)}finally{this.module.stackRestore(it)}}},Z$=async(_,_e,it,ut)=>{let ct=_e.jsepInit;if(!ct)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(_==="webgpu"){let pt=new X$;await pt.initialize(it,ut),ct("webgpu",[pt,ft=>pt.alloc(ft),ft=>pt.free(ft),(ft,Bt,Gt,er=!1)=>{if(er)Jy("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${ft}, dst=${Bt}, size=${Gt}`),pt.memcpy(ft,Bt);else{Jy("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${ft}, gpuDataId=${Bt}, size=${Gt}`);let Yr=_e.HEAPU8.subarray(ft>>>0,(ft>>>0)+Gt);pt.upload(Bt,Yr)}},async(ft,Bt,Gt)=>{Jy("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${ft}, dataOffset=${Bt}, size=${Gt}`),await pt.download(ft,()=>_e.HEAPU8.subarray(Bt>>>0,(Bt>>>0)+Gt))},(ft,Bt,Gt)=>pt.createKernel(ft,Bt,Gt,_e.UTF8ToString(_e._JsepGetNodeName(Bt))),ft=>pt.releaseKernel(ft),(ft,Bt,Gt,er)=>{Jy("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${Gt}, kernel=${ft}, contextDataOffset=${Bt}`);let Yr=new Q$(_e,pt,Bt);return pt.computeKernel(ft,Yr,er)},()=>pt.captureBegin(),()=>pt.captureEnd(),()=>pt.replay()])}else ct("webnn")}}),J$,L2,B2,U1,eM,f2,j2,z2,N2,U2,W2,V2,tM=$(()=>{N0(),Cw(),ly(),Ay(),A0(),Tw(),J$=(_,_e)=>{hy()._OrtInit(_,_e)!==0&&n0("Can't initialize onnxruntime.")},L2=async _=>{J$(_.wasm.numThreads,U0(_.logLevel))},B2=async(_,_e)=>{{let it=(ZP(),g(Y$)).init;if(_e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let ut=_.webgpu.adapter;if(ut){if(typeof ut.limits!="object"||typeof ut.features!="object"||typeof ut.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let ct=_.webgpu.powerPreference;if(ct!==void 0&&ct!=="low-power"&&ct!=="high-performance")throw new Error(`Invalid powerPreference setting: "${ct}"`);let pt=_.webgpu.forceFallbackAdapter;if(pt!==void 0&&typeof pt!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${pt}"`);if(ut=await navigator.gpu.requestAdapter({powerPreference:ct,forceFallbackAdapter:pt}),!ut)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await it("webgpu",hy(),_,ut)}if(_e==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await it("webnn",hy(),_)}}},U1=new Map,eM=_=>{let _e=hy(),it=_e.stackSave();try{let ut=_e.stackAlloc(8);return _e._OrtGetInputOutputCount(_,ut,ut+4)!==0&&n0("Can't get session input/output count."),[_e.HEAP32[ut/4],_e.HEAP32[ut/4+1]]}finally{_e.stackRestore(it)}},f2=_=>{let _e=hy(),it=_e._malloc(_.byteLength);if(it===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${_.byteLength}.`);return _e.HEAPU8.set(_,it),[it,_.byteLength]},j2=async(_,_e)=>{let it,ut,ct=hy();Array.isArray(_)?[it,ut]=_:_.buffer===ct.HEAPU8.buffer?[it,ut]=[_.byteOffset,_.byteLength]:[it,ut]=f2(_);let pt=0,ft=0,Bt=0,Gt=[],er=[],Yr=[];try{if([ft,Gt]=M0(_e),_e?.externalData&&ct.mountExternalData){let So=[];for(let xa of _e.externalData){let $a=typeof xa=="string"?xa:xa.path;So.push(by(typeof xa=="string"?xa:xa.data).then(gu=>{ct.mountExternalData($a,gu)}))}await Promise.all(So)}for(let So of _e?.executionProviders??[])if((typeof So=="string"?So:So.name)==="webnn"){if(ct.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof So!="string"){let xa=So,$a=xa?.context,gu=xa?.gpuDevice,u_=xa?.deviceType,c_=xa?.numThreads,R_=xa?.powerPreference;$a?ct.currentContext=$a:gu?ct.currentContext=await navigator.ml.createContext(gu):ct.currentContext=await navigator.ml.createContext({deviceType:u_,numThreads:c_,powerPreference:R_})}else ct.currentContext=await navigator.ml.createContext();break}pt=await ct._OrtCreateSession(it,ut,ft),pt===0&&n0("Can't create a session."),ct.currentContext&&(ct.currentContext=void 0);let[It,en]=eM(pt),wn=!!_e?.enableGraphCapture,_o=[],vn=[],Ws=[];for(let So=0;So<It;So++){let xa=ct._OrtGetInputName(pt,So);xa===0&&n0("Can't get an input name."),er.push(xa),_o.push(ct.UTF8ToString(xa))}for(let So=0;So<en;So++){let xa=ct._OrtGetOutputName(pt,So);xa===0&&n0("Can't get an output name."),Yr.push(xa);let $a=ct.UTF8ToString(xa);vn.push($a);{if(wn&&_e?.preferredOutputLocation===void 0){Ws.push("gpu-buffer");continue}let gu=typeof _e?.preferredOutputLocation=="string"?_e.preferredOutputLocation:_e?.preferredOutputLocation?.[$a]??"cpu";if(gu!=="cpu"&&gu!=="cpu-pinned"&&gu!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${gu}.`);if(wn&&gu!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${gu}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);Ws.push(gu)}}let Jo=null;return Ws.some(So=>So==="gpu-buffer")&&(Bt=ct._OrtCreateBinding(pt),Bt===0&&n0("Can't create IO binding."),Jo={handle:Bt,outputPreferredLocations:Ws,outputPreferredLocationsEncoded:Ws.map(So=>tw(So))}),U1.set(pt,[pt,er,Yr,Jo,wn,!1]),[pt,_o,vn]}catch(It){throw er.forEach(en=>ct._OrtFree(en)),Yr.forEach(en=>ct._OrtFree(en)),Bt!==0&&ct._OrtReleaseBinding(Bt),pt!==0&&ct._OrtReleaseSession(pt),It}finally{ct._free(it),ft!==0&&ct._OrtReleaseSessionOptions(ft),Gt.forEach(It=>ct._free(It)),ct.unmountExternalData?.()}},z2=_=>{let _e=hy(),it=U1.get(_);if(!it)throw new Error(`cannot release session. invalid session id: ${_}`);let[ut,ct,pt,ft,Bt]=it;ft&&(Bt&&_e._OrtClearBoundOutputs(ft.handle),_e._OrtReleaseBinding(ft.handle)),_e.jsepOnReleaseSession?.(_),ct.forEach(Gt=>_e._OrtFree(Gt)),pt.forEach(Gt=>_e._OrtFree(Gt)),_e._OrtReleaseSession(ut),U1.delete(_)},N2=(_,_e,it,ut,ct,pt=!1)=>{if(!_){_e.push(0);return}let ft=hy(),Bt=_[0],Gt=_[1],er=_[3],Yr,It;if(Bt==="string"&&er==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(pt&&er!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${ct} when enableGraphCapture is true.`);if(er==="gpu-buffer"){let _o=_[2].gpuBuffer;It=X0(P0(Bt),Gt);let vn=ft.jsepRegisterBuffer;if(!vn)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');Yr=vn(ut,ct,_o,It)}else{let _o=_[2];if(Array.isArray(_o)){It=4*_o.length,Yr=ft._malloc(It),it.push(Yr);let vn=Yr/4;for(let Ws=0;Ws<_o.length;Ws++){if(typeof _o[Ws]!="string")throw new TypeError(`tensor data at index ${Ws} is not a string`);ft.HEAPU32[vn++]=Sy(_o[Ws],it)}}else It=_o.byteLength,Yr=ft._malloc(It),it.push(Yr),ft.HEAPU8.set(new Uint8Array(_o.buffer,_o.byteOffset,It),Yr)}let en=ft.stackSave(),wn=ft.stackAlloc(4*Gt.length);try{let _o=wn/4;Gt.forEach(Ws=>ft.HEAP32[_o++]=Ws);let vn=ft._OrtCreateTensor(P0(Bt),Yr,It,wn,Gt.length,tw(er));vn===0&&n0(`Can't create tensor for input/output. session=${ut}, index=${ct}.`),_e.push(vn)}finally{ft.stackRestore(en)}},U2=async(_,_e,it,ut,ct,pt)=>{let ft=hy(),Bt=U1.get(_);if(!Bt)throw new Error(`cannot run inference. invalid session id: ${_}`);let Gt=Bt[0],er=Bt[1],Yr=Bt[2],It=Bt[3],en=Bt[4],wn=Bt[5],_o=_e.length,vn=ut.length,Ws=0,Jo=[],So=[],xa=[],$a=[],gu=ft.stackSave(),u_=ft.stackAlloc(_o*4),c_=ft.stackAlloc(_o*4),R_=ft.stackAlloc(vn*4),ny=ft.stackAlloc(vn*4);try{[Ws,Jo]=G0(pt);for(let dy=0;dy<_o;dy++)N2(it[dy],So,$a,_,_e[dy],en);for(let dy=0;dy<vn;dy++)N2(ct[dy],xa,$a,_,_o+ut[dy],en);let ty=u_/4,Ly=c_/4,ky=R_/4,Wy=ny/4;for(let dy=0;dy<_o;dy++)ft.HEAPU32[ty++]=So[dy],ft.HEAPU32[Ly++]=er[_e[dy]];for(let dy=0;dy<vn;dy++)ft.HEAPU32[ky++]=xa[dy],ft.HEAPU32[Wy++]=Yr[ut[dy]];if(It&&!wn){let{handle:dy,outputPreferredLocations:r0,outputPreferredLocationsEncoded:d0}=It;if(er.length!==_o)throw new Error(`input count from feeds (${_o}) is expected to be always equal to model's input count (${er.length}).`);for(let gy=0;gy<_o;gy++){let Vy=_e[gy];await ft._OrtBindInput(dy,er[Vy],So[gy])!==0&&n0(`Can't bind input[${gy}] for session=${_}.`)}for(let gy=0;gy<vn;gy++){let Vy=ut[gy];ct[gy]?.[3]?ft._OrtBindOutput(dy,Yr[Vy],xa[gy],0)!==0&&n0(`Can't bind pre-allocated output[${gy}] for session=${_}.`):ft._OrtBindOutput(dy,Yr[Vy],0,d0[Vy])!==0&&n0(`Can't bind output[${gy}] to ${r0[gy]} for session=${_}.`)}U1.set(_,[Gt,er,Yr,It,en,!0])}ft.jsepOnRunStart?.(Gt);let t0;It?t0=await ft._OrtRunWithBinding(Gt,It.handle,vn,R_,Ws):t0=await ft._OrtRun(Gt,c_,u_,_o,ny,vn,R_,Ws),t0!==0&&n0("failed to call OrtRun().");let Uy=[];for(let dy=0;dy<vn;dy++){let r0=ft.HEAPU32[R_/4+dy];if(r0===xa[dy]){Uy.push(ct[dy]);continue}let d0=ft.stackSave(),gy=ft.stackAlloc(4*4),Vy=!1,x_,G_=0;try{ft._OrtGetTensorData(r0,gy,gy+4,gy+8,gy+12)!==0&&n0(`Can't access output tensor data on index ${dy}.`);let By=gy/4,b0=ft.HEAPU32[By++];G_=ft.HEAPU32[By++];let w0=ft.HEAPU32[By++],Bw=ft.HEAPU32[By++],Jw=[];for(let hw=0;hw<Bw;hw++)Jw.push(ft.HEAPU32[w0/4+hw]);ft._OrtFree(w0);let Aw=Jw.reduce((hw,lw)=>hw*lw,1);x_=F0(b0);let vw=It?.outputPreferredLocations[ut[dy]];if(x_==="string"){if(vw==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let hw=[],lw=G_/4;for(let V1=0;V1<Aw;V1++){let K1=ft.HEAPU32[lw++],bv=V1===Aw-1?void 0:ft.HEAPU32[lw]-K1;hw.push(ft.UTF8ToString(K1,bv))}Uy.push([x_,Jw,hw,"cpu"])}else if(vw==="gpu-buffer"&&Aw>0){let hw=ft.jsepGetBuffer;if(!hw)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let lw=hw(G_),V1=X0(b0,Aw);if(V1===void 0||!_w(x_))throw new Error(`Unsupported data type: ${x_}`);Vy=!0,Uy.push([x_,Jw,{gpuBuffer:lw,download:ft.jsepCreateDownloader(lw,V1,x_),dispose:()=>{ft._OrtReleaseTensor(r0)}},"gpu-buffer"])}else{let hw=Y0(x_),lw=new hw(Aw);new Uint8Array(lw.buffer,lw.byteOffset,lw.byteLength).set(ft.HEAPU8.subarray(G_,G_+lw.byteLength)),Uy.push([x_,Jw,lw,"cpu"])}}finally{ft.stackRestore(d0),x_==="string"&&G_&&ft._free(G_),Vy||ft._OrtReleaseTensor(r0)}}return It&&!en&&(ft._OrtClearBoundOutputs(It.handle),U1.set(_,[Gt,er,Yr,It,en,!1])),Uy}finally{ft.stackRestore(gu),So.forEach(ty=>ft._OrtReleaseTensor(ty)),xa.forEach(ty=>ft._OrtReleaseTensor(ty)),$a.forEach(ty=>ft._free(ty)),Ws!==0&&ft._OrtReleaseRunOptions(Ws),Jo.forEach(ty=>ft._free(ty))}},W2=_=>{let _e=hy(),it=U1.get(_);if(!it)throw new Error("invalid session id");let ut=it[0],ct=_e._OrtEndProfiling(ut);ct===0&&n0("Can't get an profile file name."),_e._OrtFree(ct)},V2=_=>{let _e=[];for(let it of _){let ut=it[2];!Array.isArray(ut)&&"buffer"in ut&&_e.push(ut.buffer)}return _e}}),W1,Lw,_x,pE,fE,h2,K2,_2,gv,yv,rM,nM,oM,iM,sM,aM,lM,uM,cM=$(()=>{L_(),tM(),Ay(),H_(),W1=()=>!!Er.wasm.proxy&&typeof document<"u",_x=!1,pE=!1,fE=!1,_2=new Map,gv=(_,_e)=>{let it=_2.get(_);it?it.push(_e):_2.set(_,[_e])},yv=()=>{if(_x||!pE||fE||!Lw)throw new Error("worker not ready")},rM=_=>{switch(_.data.type){case"init-wasm":_x=!1,_.data.err?(fE=!0,K2[1](_.data.err)):(pE=!0,K2[0]()),h2&&(URL.revokeObjectURL(h2),h2=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let _e=_2.get(_.data.type);_.data.err?_e.shift()[1](_.data.err):_e.shift()[0](_.data.out);break}}},nM=async()=>{if(!pE){if(_x)throw new Error("multiple calls to 'initWasm()' detected.");if(fE)throw new Error("previous call to 'initWasm()' failed.");if(_x=!0,W1())return new Promise((_,_e)=>{Lw?.terminate(),P_().then(([it,ut])=>{try{Lw=ut,Lw.onerror=pt=>_e(pt),Lw.onmessage=rM,K2=[_,_e];let ct={type:"init-wasm",in:Er};Lw.postMessage(ct),h2=it}catch(ct){_e(ct)}},_e)});try{await Zy(Er.wasm),await L2(Er),pE=!0}catch(_){throw fE=!0,_}finally{_x=!1}}},oM=async _=>{if(W1())return yv(),new Promise((_e,it)=>{gv("init-ep",[_e,it]);let ut={type:"init-ep",in:{epName:_,env:Er}};Lw.postMessage(ut)});await B2(Er,_)},iM=async _=>W1()?(yv(),new Promise((_e,it)=>{gv("copy-from",[_e,it]);let ut={type:"copy-from",in:{buffer:_}};Lw.postMessage(ut,[_.buffer])})):f2(_),sM=async(_,_e)=>{if(W1()){if(_e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return yv(),new Promise((it,ut)=>{gv("create",[it,ut]);let ct={type:"create",in:{model:_,options:{..._e}}},pt=[];_ instanceof Uint8Array&&pt.push(_.buffer),Lw.postMessage(ct,pt)})}else return j2(_,_e)},aM=async _=>{if(W1())return yv(),new Promise((_e,it)=>{gv("release",[_e,it]);let ut={type:"release",in:_};Lw.postMessage(ut)});z2(_)},lM=async(_,_e,it,ut,ct,pt)=>{if(W1()){if(it.some(ft=>ft[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(ct.some(ft=>ft))throw new Error("pre-allocated output tensor is not supported for proxy.");return yv(),new Promise((ft,Bt)=>{gv("run",[ft,Bt]);let Gt=it,er={type:"run",in:{sessionId:_,inputIndices:_e,inputs:Gt,outputIndices:ut,options:pt}};Lw.postMessage(er,V2(Gt))})}else return U2(_,_e,it,ut,ct,pt)},uM=async _=>{if(W1())return yv(),new Promise((_e,it)=>{gv("end-profiling",[_e,it]);let ut={type:"end-profiling",in:_};Lw.postMessage(ut)});W2(_)}}),G2,dM,pM,JP=$(()=>{L_(),cM(),ly(),Z_(),Tw(),G2=(_,_e)=>{switch(_.location){case"cpu":return[_.type,_.dims,_.data,"cpu"];case"gpu-buffer":return[_.type,_.dims,{gpuBuffer:_.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${_.location} for ${_e()}`)}},dM=_=>{switch(_[3]){case"cpu":return new na(_[0],_[2],_[1]);case"gpu-buffer":{let _e=_[0];if(!_w(_e))throw new Error(`not supported data type: ${_e} for deserializing GPU tensor`);let{gpuBuffer:it,download:ut,dispose:ct}=_[2];return na.fromGpuBuffer(it,{dataType:_e,dims:_[1],download:ut,dispose:ct})}default:throw new Error(`invalid data location: ${_[3]}`)}},pM=class{async fetchModelAndCopyToWasmMemory(_){return iM(await by(_))}async loadModel(_,_e){e_();let it;typeof _=="string"?it=await this.fetchModelAndCopyToWasmMemory(_):it=_,[this.sessionId,this.inputNames,this.outputNames]=await sM(it,_e),ar()}async dispose(){return aM(this.sessionId)}async run(_,_e,it){e_();let ut=[],ct=[];Object.entries(_).forEach(It=>{let en=It[0],wn=It[1],_o=this.inputNames.indexOf(en);if(_o===-1)throw new Error(`invalid input '${en}'`);ut.push(wn),ct.push(_o)});let pt=[],ft=[];Object.entries(_e).forEach(It=>{let en=It[0],wn=It[1],_o=this.outputNames.indexOf(en);if(_o===-1)throw new Error(`invalid output '${en}'`);pt.push(wn),ft.push(_o)});let Bt=ut.map((It,en)=>G2(It,()=>`input "${this.inputNames[ct[en]]}"`)),Gt=pt.map((It,en)=>It?G2(It,()=>`output "${this.outputNames[ft[en]]}"`):null),er=await lM(this.sessionId,ct,Bt,ft,Gt,it),Yr={};for(let It=0;It<er.length;It++)Yr[this.outputNames[ft[It]]]=pt[It]??dM(er[It]);return ar(),Yr}startProfiling(){}endProfiling(){uM(this.sessionId)}}}),fM,hM,_k=$(()=>{L_(),cM(),JP(),H_(),fM=()=>{if((typeof Er.wasm.initTimeout!="number"||Er.wasm.initTimeout<0)&&(Er.wasm.initTimeout=0),Er.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof Er.wasm.proxy!="boolean"&&(Er.wasm.proxy=!1),typeof Er.wasm.trace!="boolean"&&(Er.wasm.trace=!1),typeof Er.wasm.numThreads!="number"||!Number.isInteger(Er.wasm.numThreads)||Er.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Er.wasm.numThreads=1;else{let _=typeof navigator>"u"?et("node:os").cpus().length:navigator.hardwareConcurrency;Er.wasm.numThreads=Math.min(4,Math.ceil((_||1)/2))}},hM=class{async init(_){fM(),await nM(),await oM(_)}async createInferenceSessionHandler(_,_e){let it=new pM;return await it.loadModel(_,_e),Promise.resolve(it)}}}),_M={};c(_M,{wasmBackend:()=>mM});var mM,eS=$(()=>{_k(),mM=new hM});L_(),L_(),L_();var tS="1.20.0-dev.20240908-de7a02beef",rS=m_;{let _=(eS(),g(_M)).wasmBackend;Ot("webgpu",_,5),Ot("webnn",_,5),Ot("cpu",_,10),Ot("wasm",_,10)}Object.defineProperty(Er.versions,"web",{value:tS,enumerable:!0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},"./src/backends/onnx.js":(e,o,i)=>{var s;i.r(o),i.d(o,{Tensor:()=>et.Tensor,createInferenceSession:()=>At,deviceToExecutionProviders:()=>at,isONNXProxy:()=>xt,isONNXTensor:()=>Ct});var h=i("./src/env.js"),a=i("?2ce3"),d=i("./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs"),et=i("./node_modules/onnxruntime-common/dist/esm/index.js");const $=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),c=[];let b,g;if(h.apis.IS_NODE_ENV){switch(g=a??(s||(s=i.t(a,2))),process.platform){case"win32":c.push("dml");break;case"linux":process.arch==="x64"&&c.push("cuda");break}c.push("cpu"),b=["cpu"]}else g=d,h.apis.IS_WEBNN_AVAILABLE&&c.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),h.apis.IS_WEBGPU_AVAILABLE&&c.push("webgpu"),c.push("wasm"),b=["wasm"];const nt=g.InferenceSession;function at(Dt=null){if(!Dt)return b;switch(Dt){case"auto":return c;case"gpu":return c.filter(Qt=>["webgpu","cuda","dml","webnn-gpu"].includes(Qt))}if(c.includes(Dt))return[$[Dt]??Dt];throw new Error(`Unsupported device: "${Dt}". Should be one of: ${c.join(", ")}.`)}let Ot=null;async function At(Dt,Qt){Ot&&await Ot;const Zt=nt.create(Dt,Qt);return Ot??=Zt,await Zt}function Ct(Dt){return Dt instanceof g.Tensor}const St=g?.env;St?.wasm&&(St.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${h.env.version}/dist/`,St.wasm.proxy=!1,(typeof crossOriginIsolated>"u"||!crossOriginIsolated)&&(St.wasm.numThreads=1)),St?.webgpu&&(St.webgpu.powerPreference="high-performance");function xt(){return St?.wasm?.proxy}h.env.backends.onnx=St},"./src/configs.js":(e,o,i)=>{i.r(o),i.d(o,{AutoConfig:()=>c,PretrainedConfig:()=>$,getKeyValueShapes:()=>et});var s=i("./src/utils/core.js"),h=i("./src/utils/hub.js");async function a(b,g){return await(0,h.getModelJSON)(b,"config.json",!0,g)}function d(b){const g={};let nt={};switch(b.model_type){case"llava":case"paligemma":case"florence2":nt=d(b.text_config);break;case"moondream1":nt=d(b.phi_config);break;case"musicgen":nt=d(b.decoder);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":g.num_heads="n_head",g.num_layers="n_layer",g.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"phi":case"phi3":case"falcon":g.num_heads="num_attention_heads",g.num_layers="num_hidden_layers",g.hidden_size="hidden_size";break;case"llama":case"cohere":case"mistral":case"starcoder2":case"qwen2":g.num_heads="num_key_value_heads",g.num_layers="num_hidden_layers",g.hidden_size="hidden_size",g.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":g.num_heads="num_key_value_heads",g.num_layers="num_hidden_layers",g.dim_kv="head_dim";break;case"openelm":g.num_heads="num_kv_heads",g.num_layers="num_transformer_layers",g.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":g.num_heads="num_heads",g.num_layers="num_layers",g.hidden_size="hidden_size";break;case"bloom":g.num_heads="n_head",g.num_layers="n_layer",g.hidden_size="hidden_size";break;case"mpt":g.num_heads="n_heads",g.num_layers="n_layers",g.hidden_size="d_model";break;case"t5":case"mt5":case"longt5":g.num_decoder_layers="num_decoder_layers",g.num_decoder_heads="num_heads",g.decoder_dim_kv="d_kv",g.num_encoder_layers="num_layers",g.num_encoder_heads="num_heads",g.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":g.num_decoder_layers="decoder_layers",g.num_decoder_heads="decoder_attention_heads",g.decoder_hidden_size="d_model",g.num_encoder_layers="encoder_layers",g.num_encoder_heads="encoder_attention_heads",g.encoder_hidden_size="d_model";break;case"speecht5":g.num_decoder_layers="decoder_layers",g.num_decoder_heads="decoder_attention_heads",g.decoder_hidden_size="hidden_size",g.num_encoder_layers="encoder_layers",g.num_encoder_heads="encoder_attention_heads",g.encoder_hidden_size="hidden_size";break;case"trocr":g.num_encoder_layers=g.num_decoder_layers="decoder_layers",g.num_encoder_heads=g.num_decoder_heads="decoder_attention_heads",g.encoder_hidden_size=g.decoder_hidden_size="d_model";break;case"musicgen_decoder":g.num_encoder_layers=g.num_decoder_layers="num_hidden_layers",g.num_encoder_heads=g.num_decoder_heads="num_attention_heads",g.encoder_hidden_size=g.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const Ot=d(b.decoder),At="num_decoder_layers"in Ot,Ct=(0,s.pick)(b,["model_type","is_encoder_decoder"]);return At?(Ct.num_decoder_layers=Ot.num_decoder_layers,Ct.num_decoder_heads=Ot.num_decoder_heads,Ct.decoder_hidden_size=Ot.decoder_hidden_size,Ct.num_encoder_layers=Ot.num_encoder_layers,Ct.num_encoder_heads=Ot.num_encoder_heads,Ct.encoder_hidden_size=Ot.encoder_hidden_size):(Ct.num_layers=Ot.num_layers,Ct.num_heads=Ot.num_heads,Ct.hidden_size=Ot.hidden_size),Ct}const at={...nt,...(0,s.pick)(b,["model_type","multi_query","is_encoder_decoder"])};for(const Ot in g)at[Ot]=b[g[Ot]];return at}function et(b,{prefix:g="past_key_values"}={}){const nt={},at=b.normalized_config,Ot=1;if(at.is_encoder_decoder&&"num_encoder_heads"in at&&"num_decoder_heads"in at){const At=at.encoder_dim_kv??at.encoder_hidden_size/at.num_encoder_heads,Ct=at.decoder_dim_kv??at.decoder_hidden_size/at.num_decoder_heads,St=[Ot,at.num_encoder_heads,0,At],xt=[Ot,at.num_decoder_heads,0,Ct];for(let Dt=0;Dt<at.num_decoder_layers;++Dt)nt[`${g}.${Dt}.encoder.key`]=St,nt[`${g}.${Dt}.encoder.value`]=St,nt[`${g}.${Dt}.decoder.key`]=xt,nt[`${g}.${Dt}.decoder.value`]=xt}else{const At=at.num_heads,Ct=at.num_layers,St=at.dim_kv??at.hidden_size/(at.num_attention_heads??At);if(at.model_type==="falcon"){const xt=[Ot*At,0,St];for(let Dt=0;Dt<Ct;++Dt)nt[`${g}.${Dt}.key`]=xt,nt[`${g}.${Dt}.value`]=xt}else if(at.multi_query){const xt=[Ot*At,0,2*St];for(let Dt=0;Dt<Ct;++Dt)nt[`${g}.${Dt}.key_value`]=xt}else if(at.model_type==="bloom"){const xt=[Ot*At,St,0],Dt=[Ot*At,0,St];for(let Qt=0;Qt<Ct;++Qt)nt[`${g}.${Qt}.key`]=xt,nt[`${g}.${Qt}.value`]=Dt}else if(at.model_type==="openelm")for(let xt=0;xt<Ct;++xt){const Dt=[Ot,At[xt],0,St];nt[`${g}.${xt}.key`]=Dt,nt[`${g}.${xt}.value`]=Dt}else{const xt=[Ot,At,0,St];for(let Dt=0;Dt<Ct;++Dt)nt[`${g}.${Dt}.key`]=xt,nt[`${g}.${Dt}.value`]=xt}}return nt}class ${max_position_embeddings;constructor(g){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,g),this.normalized_config=d(this)}static async from_pretrained(g,{progress_callback:nt=null,config:at=null,cache_dir:Ot=null,local_files_only:At=!1,revision:Ct="main"}={}){at&&!(at instanceof $)&&(at=new $(at));const St=at??await a(g,{progress_callback:nt,config:at,cache_dir:Ot,local_files_only:At,revision:Ct});return new this(St)}}class c{static async from_pretrained(...g){return $.from_pretrained(...g)}}},"./src/env.js":(e,o,i)=>{i.r(o),i.d(o,{apis:()=>Ct,env:()=>gr});var s=i("?569f"),h=i("?3f59"),a=i("?154a");const d="3.0.0-alpha.15",et=typeof self<"u",$=et&&self.constructor.name==="DedicatedWorkerGlobalScope",c=et&&"caches"in self,b=typeof navigator<"u"&&"gpu"in navigator,g=typeof navigator<"u"&&"ml"in navigator,nt=typeof process<"u",at=nt&&process?.release?.name==="node",Ot=!vr(s),At=!vr(h),Ct=Object.freeze({IS_BROWSER_ENV:et,IS_WEBWORKER_ENV:$,IS_WEB_CACHE_AVAILABLE:c,IS_WEBGPU_AVAILABLE:b,IS_WEBNN_AVAILABLE:g,IS_PROCESS_AVAILABLE:nt,IS_NODE_ENV:at,IS_FS_AVAILABLE:Ot,IS_PATH_AVAILABLE:At}),St=Ot&&At,xt=St?h.dirname(h.dirname(a.fileURLToPath(import.meta.url))):"./",Dt=St?h.join(xt,"/.cache/"):null,Qt="/models/",Zt=St?h.join(xt,Qt):Qt,gr={version:d,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!et,localModelPath:Zt,useFS:Ot,useBrowserCache:c,useFSCache:Ot,cacheDir:Dt,useCustomCache:!1,customCache:null};function vr(Er){return Object.keys(Er).length===0}},"./src/generation/configuration_utils.js":(e,o,i)=>{i.r(o),i.d(o,{GenerationConfig:()=>h});var s=i("./src/utils/core.js");class h{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(d){Object.assign(this,(0,s.pick)(d,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,o,i)=>{i.r(o),i.d(o,{ClassifierFreeGuidanceLogitsProcessor:()=>St,ForcedBOSTokenLogitsProcessor:()=>$,ForcedEOSTokenLogitsProcessor:()=>c,LogitsProcessor:()=>a,LogitsProcessorList:()=>et,LogitsWarper:()=>d,MinLengthLogitsProcessor:()=>Ot,MinNewTokensLengthLogitsProcessor:()=>At,NoBadWordsLogitsProcessor:()=>Ct,NoRepeatNGramLogitsProcessor:()=>nt,RepetitionPenaltyLogitsProcessor:()=>at,SuppressTokensAtBeginLogitsProcessor:()=>b,TemperatureLogitsWarper:()=>xt,TopKLogitsWarper:()=>Qt,TopPLogitsWarper:()=>Dt,WhisperTimeStampLogitsProcessor:()=>g});var s=i("./src/utils/generic.js");i("./src/utils/tensor.js");var h=i("./src/utils/maths.js");class a extends s.Callable{_call(gr,vr){throw Error("`_call` should be implemented in a subclass")}}class d extends s.Callable{_call(gr,vr){throw Error("`_call` should be implemented in a subclass")}}class et extends s.Callable{constructor(){super(),this.processors=[]}push(gr){this.processors.push(gr)}extend(gr){this.processors.push(...gr)}_call(gr,vr){let Er=vr;for(const wo of this.processors)Er=wo(gr,Er);return Er}[Symbol.iterator](){return this.processors.values()}}class $ extends a{constructor(gr){super(),this.bos_token_id=gr}_call(gr,vr){for(let Er=0;Er<gr.length;++Er)if(gr[Er].length===1){const wo=vr[Er].data;wo.fill(-1/0),wo[this.bos_token_id]=0}return vr}}class c extends a{constructor(gr,vr){super(),this.max_length=gr,this.eos_token_id=Array.isArray(vr)?vr:[vr]}_call(gr,vr){for(let Er=0;Er<gr.length;++Er)if(gr[Er].length===this.max_length-1){const wo=vr[Er].data;wo.fill(-1/0);for(const Do of this.eos_token_id)wo[Do]=0}return vr}}class b extends a{constructor(gr,vr){super(),this.begin_suppress_tokens=gr,this.begin_index=vr}_call(gr,vr){for(let Er=0;Er<gr.length;++Er)if(gr[Er].length===this.begin_index){const wo=vr[Er].data;for(const Do of this.begin_suppress_tokens)wo[Do]=-1/0}return vr}}class g extends a{constructor(gr,vr){super(),this.eos_token_id=Array.isArray(gr.eos_token_id)?gr.eos_token_id[0]:gr.eos_token_id,this.no_timestamps_token_id=gr.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=vr.length,vr.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=gr.max_initial_timestamp_index}_call(gr,vr){for(let Er=0;Er<gr.length;++Er){const wo=vr[Er].data;if(wo[this.no_timestamps_token_id]=-1/0,gr[Er].length===this.begin_index-1){wo.fill(-1/0),wo[this.timestamp_begin]=0;continue}const Do=gr[Er].slice(this.begin_index),Js=Do.length>=1&&Do[Do.length-1]>=this.timestamp_begin,In=Do.length<2||Do[Do.length-2]>=this.timestamp_begin;if(Js&&(In?wo.subarray(this.timestamp_begin).fill(-1/0):wo.subarray(0,this.eos_token_id).fill(-1/0)),gr[Er].length===this.begin_index&&this.max_initial_timestamp_index!==null){const Bu=this.timestamp_begin+this.max_initial_timestamp_index;wo.subarray(Bu+1).fill(-1/0)}const Wo=(0,h.log_softmax)(wo),Ir=Math.log(Wo.subarray(this.timestamp_begin).map(Math.exp).reduce((Bu,Ho)=>Bu+Ho)),Yo=(0,h.max)(Wo.subarray(0,this.timestamp_begin))[0];Ir>Yo&&wo.subarray(0,this.timestamp_begin).fill(-1/0)}return vr}}class nt extends a{constructor(gr){super(),this.no_repeat_ngram_size=gr}getNgrams(gr){const vr=gr.length,Er=[];for(let Do=0;Do<vr+1-this.no_repeat_ngram_size;++Do){const Js=[];for(let In=0;In<this.no_repeat_ngram_size;++In)Js.push(gr[Do+In]);Er.push(Js.map(Number))}const wo=new Map;for(const Do of Er){const Js=Do.slice(0,Do.length-1),In=JSON.stringify(Js),Wo=wo.get(In)??[];Wo.push(Do[Do.length-1]),wo.set(In,Wo)}return wo}getGeneratedNgrams(gr,vr){const Er=vr.slice(vr.length+1-this.no_repeat_ngram_size,vr.length);return gr.get(JSON.stringify(Er.map(Number)))??[]}calcBannedNgramTokens(gr){const vr=[];if(gr.length+1<this.no_repeat_ngram_size)return vr;{const Er=this.getNgrams(gr);return this.getGeneratedNgrams(Er,gr)}}_call(gr,vr){for(let Er=0;Er<gr.length;++Er){const wo=vr[Er].data,Do=this.calcBannedNgramTokens(gr[Er]);for(const Js of Do)wo[Js]=-1/0}return vr}}class at extends a{constructor(gr){super(),this.penalty=gr}_call(gr,vr){for(let Er=0;Er<gr.length;++Er){const wo=vr[Er].data;for(const Do of gr[Er]){const Js=Number(Do);wo[Js]<0?wo[Js]*=this.penalty:wo[Js]/=this.penalty}}return vr}}class Ot extends a{constructor(gr,vr){super(),this.min_length=gr,this.eos_token_id=Array.isArray(vr)?vr:[vr]}_call(gr,vr){for(let Er=0;Er<gr.length;++Er)if(gr[Er].length<this.min_length){const wo=vr[Er].data;for(const Do of this.eos_token_id)wo[Do]=-1/0}return vr}}class At extends a{constructor(gr,vr,Er){super(),this.prompt_length_to_skip=gr,this.min_new_tokens=vr,this.eos_token_id=Array.isArray(Er)?Er:[Er]}_call(gr,vr){for(let Er=0;Er<gr.length;++Er)if(gr[Er].length-this.prompt_length_to_skip<this.min_new_tokens){const Do=vr[Er].data;for(const Js of this.eos_token_id)Do[Js]=-1/0}return vr}}class Ct extends a{constructor(gr,vr){super(),this.bad_words_ids=gr,this.eos_token_id=Array.isArray(vr)?vr:[vr]}_call(gr,vr){for(let Er=0;Er<gr.length;++Er){const wo=vr[Er].data,Do=gr[Er];for(const Js of this.bad_words_ids){let In=!0;for(let Wo=1;Wo<=Js.length-1&&Js.length<Do.length;++Wo)if(Js.at(-Wo-1)!=Do.at(-Wo)){In=!1;break}In&&(wo[Js.at(-1)]=-1/0)}}return vr}}class St extends a{constructor(gr){if(super(),gr<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${gr}.`);this.guidance_scale=gr}_call(gr,vr){if(vr.dims[0]!==2*gr.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${vr.dims[0]} for the logits and ${gr.length} for the input ids.`);const Er=gr.length,wo=vr.slice([0,Er],null),Do=vr.slice([Er,vr.dims[0]],null);for(let Js=0;Js<Do.data.length;++Js)Do.data[Js]+=(wo.data[Js]-Do.data[Js])*this.guidance_scale;return Do}}class xt extends d{constructor(gr){super(),this.temperature=gr}_call(gr,vr){const Er=vr.data;for(let wo=0;wo<Er.length;++wo)Er[wo]/=this.temperature;return vr}}class Dt extends d{constructor(gr,{filter_value:vr=-1/0,min_tokens_to_keep:Er=1}={}){if(super(),gr<0||gr>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${gr}`);if(!Number.isInteger(Er)||Er<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${Er}`);this.top_p=gr,this.filter_value=vr,this.min_tokens_to_keep=Er}}class Qt extends d{constructor(gr,{filter_value:vr=-1/0,min_tokens_to_keep:Er=1}={}){if(super(),!Number.isInteger(gr)||gr<0)throw new Error(`\`top_k\` must be a positive integer, but is ${gr}`);this.top_k=Math.max(gr,Er),this.filter_value=vr}}},"./src/generation/logits_sampler.js":(e,o,i)=>{i.r(o),i.d(o,{LogitsSampler:()=>d});var s=i("./src/utils/generic.js"),h=i("./src/utils/tensor.js"),a=i("./src/utils/maths.js");i("./src/generation/configuration_utils.js");class d extends s.Callable{constructor(g){super(),this.generation_config=g}async _call(g){return this.sample(g)}async sample(g){throw Error("sample should be implemented in subclasses.")}getLogits(g,nt){let at=g.dims.at(-1),Ot=g.data;if(nt===-1)Ot=Ot.slice(-at);else{let At=nt*at;Ot=Ot.slice(At,At+at)}return Ot}randomSelect(g){let nt=0;for(let Ot=0;Ot<g.length;++Ot)nt+=g[Ot];let at=Math.random()*nt;for(let Ot=0;Ot<g.length;++Ot)if(at-=g[Ot],at<=0)return Ot;return 0}static getSampler(g){if(g.do_sample)return new $(g);if(g.num_beams>1)return new c(g);if(g.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${g.num_return_sequences}.`);return new et(g)}}class et extends d{async sample(g){const nt=(0,a.max)(g.data)[1];return[[BigInt(nt),0]]}}class $ extends d{async sample(g){let nt=g.dims.at(-1);this.generation_config.top_k>0&&(nt=Math.min(this.generation_config.top_k,nt));const[at,Ot]=await(0,h.topk)(g,nt),At=(0,a.softmax)(at.data);return Array.from({length:this.generation_config.num_beams},()=>{const Ct=this.randomSelect(At);return[Ot.data[Ct],Math.log(At[Ct])]})}}class c extends d{async sample(g){let nt=g.dims.at(-1);this.generation_config.top_k>0&&(nt=Math.min(this.generation_config.top_k,nt));const[at,Ot]=await(0,h.topk)(g,nt),At=(0,a.softmax)(at.data);return Array.from({length:this.generation_config.num_beams},(Ct,St)=>[Ot.data[St],Math.log(At[St])])}}},"./src/generation/stopping_criteria.js":(e,o,i)=>{i.r(o),i.d(o,{EosTokenCriteria:()=>et,InterruptableStoppingCriteria:()=>$,MaxLengthCriteria:()=>d,StoppingCriteria:()=>h,StoppingCriteriaList:()=>a});var s=i("./src/utils/generic.js");class h extends s.Callable{_call(b,g){throw Error("StoppingCriteria needs to be subclassed")}}class a extends s.Callable{constructor(){super(),this.criteria=[]}push(b){this.criteria.push(b)}extend(b){b instanceof a?b=b.criteria:b instanceof h&&(b=[b]),this.criteria.push(...b)}_call(b,g){const nt=new Array(b.length).fill(!1);for(const at of this.criteria){const Ot=at(b,g);for(let At=0;At<nt.length;++At)nt[At]||=Ot[At]}return nt}[Symbol.iterator](){return this.criteria.values()}}class d extends h{constructor(b,g=null){super(),this.max_length=b,this.max_position_embeddings=g}_call(b){return b.map(g=>g.length>=this.max_length)}}class et extends h{constructor(b){super(),Array.isArray(b)||(b=[b]),this.eos_token_id=b}_call(b,g){return b.map(nt=>{const at=nt.at(-1);return this.eos_token_id.some(Ot=>at==Ot)})}}class $ extends h{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(b,g){return new Array(b.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,o,i)=>{i.r(o),i.d(o,{BaseStreamer:()=>d,TextStreamer:()=>$,WhisperTextStreamer:()=>c});var s=i("./src/utils/core.js"),h=i("./src/tokenizers.js"),a=i("./src/env.js");class d{put(g){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const et=a.apis.IS_PROCESS_AVAILABLE?b=>process.stdout.write(b):b=>console.log(b);class $ extends d{constructor(g,{skip_prompt:nt=!1,callback_function:at=null,token_callback_function:Ot=null,decode_kwargs:At={},...Ct}={}){super(),this.tokenizer=g,this.skip_prompt=nt,this.callback_function=at??et,this.token_callback_function=Ot,this.decode_kwargs={...At,...Ct},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(g){if(g.length>1)throw Error("TextStreamer only supports batch size of 1");if(this.skip_prompt&&this.next_tokens_are_prompt){this.next_tokens_are_prompt=!1;return}const nt=g[0];this.token_callback_function?.(nt),this.token_cache=(0,s.mergeArrays)(this.token_cache,nt);const at=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let Ot;at.endsWith(`
`)?(Ot=at.slice(this.print_len),this.token_cache=[],this.print_len=0):at.length>0&&(0,h.is_chinese_char)(at.charCodeAt(at.length-1))?(Ot=at.slice(this.print_len),this.print_len+=Ot.length):(Ot=at.slice(this.print_len,at.lastIndexOf(" ")+1),this.print_len+=Ot.length),this.on_finalized_text(Ot,!1)}end(){let g;this.token_cache.length>0?(g=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):g="",this.next_tokens_are_prompt=!0,this.on_finalized_text(g,!0)}on_finalized_text(g,nt){g.length>0&&this.callback_function?.(g),nt&&this.callback_function===et&&a.apis.IS_PROCESS_AVAILABLE&&this.callback_function?.(`
`)}}class c extends ${constructor(g,{skip_prompt:nt=!1,callback_function:at=null,token_callback_function:Ot=null,on_chunk_start:At=null,on_chunk_end:Ct=null,on_finalize:St=null,time_precision:xt=.02,skip_special_tokens:Dt=!0,decode_kwargs:Qt={}}={}){super(g,{skip_prompt:nt,callback_function:at,token_callback_function:Ot,decode_kwargs:{skip_special_tokens:Dt,...Qt}}),this.timestamp_begin=g.timestamp_begin,this.on_chunk_start=At,this.on_chunk_end=Ct,this.on_finalize=St,this.time_precision=xt,this.waiting_for_timestamp=!1}put(g){if(g.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const nt=g[0];if(nt.length===1){const at=Number(nt[0])-this.timestamp_begin;if(at>=0){const Ot=at*this.time_precision;this.waiting_for_timestamp?this.on_chunk_end?.(Ot):this.on_chunk_start?.(Ot),this.waiting_for_timestamp=!this.waiting_for_timestamp,g=[[]]}}return super.put(g)}end(){super.end(),this.on_finalize?.()}}},"./src/models.js":(e,o,i)=>{i.r(o),i.d(o,{ASTForAudioClassification:()=>$w,ASTModel:()=>X_,ASTPreTrainedModel:()=>S0,AlbertForMaskedLM:()=>ly,AlbertForQuestionAnswering:()=>tw,AlbertForSequenceClassification:()=>_w,AlbertModel:()=>U0,AlbertPreTrainedModel:()=>Y0,AutoModel:()=>UE,AutoModelForAudioClassification:()=>o2,AutoModelForAudioFrameClassification:()=>s2,AutoModelForCTC:()=>n2,AutoModelForCausalLM:()=>C2,AutoModelForDepthEstimation:()=>sE,AutoModelForDocumentQuestionAnswering:()=>D2,AutoModelForImageClassification:()=>QE,AutoModelForImageFeatureExtraction:()=>lE,AutoModelForImageMatting:()=>_v,AutoModelForImageSegmentation:()=>I2,AutoModelForImageToImage:()=>iE,AutoModelForMaskGeneration:()=>r2,AutoModelForMaskedLM:()=>qE,AutoModelForNormalEstimation:()=>aE,AutoModelForObjectDetection:()=>e2,AutoModelForQuestionAnswering:()=>XE,AutoModelForSemanticSegmentation:()=>ZE,AutoModelForSeq2SeqLM:()=>A2,AutoModelForSequenceClassification:()=>WE,AutoModelForSpeechSeq2Seq:()=>KE,AutoModelForTextToSpectrogram:()=>GE,AutoModelForTextToWaveform:()=>HE,AutoModelForTokenClassification:()=>VE,AutoModelForUniversalSegmentation:()=>JE,AutoModelForVision2Seq:()=>YE,AutoModelForXVector:()=>i2,AutoModelForZeroShotObjectDetection:()=>t2,BartForConditionalGeneration:()=>wr,BartForSequenceClassification:()=>Po,BartModel:()=>xu,BartPretrainedModel:()=>R0,BaseModelOutput:()=>Du,BeitForImageClassification:()=>Tx,BeitModel:()=>xx,BeitPreTrainedModel:()=>Tv,BertForMaskedLM:()=>wu,BertForQuestionAnswering:()=>na,BertForSequenceClassification:()=>r_,BertForTokenClassification:()=>d_,BertModel:()=>du,BertPreTrainedModel:()=>_u,BlenderbotForConditionalGeneration:()=>C_,BlenderbotModel:()=>z_,BlenderbotPreTrainedModel:()=>b_,BlenderbotSmallForConditionalGeneration:()=>wy,BlenderbotSmallModel:()=>ay,BlenderbotSmallPreTrainedModel:()=>Cy,BloomForCausalLM:()=>Zr,BloomModel:()=>Dr,BloomPreTrainedModel:()=>zt,CLIPModel:()=>y0,CLIPPreTrainedModel:()=>p0,CLIPSegForImageSegmentation:()=>M1,CLIPSegModel:()=>Nw,CLIPSegPreTrainedModel:()=>Dw,CLIPTextModel:()=>v0,CLIPTextModelWithProjection:()=>B0,CLIPVisionModel:()=>e1,CLIPVisionModelWithProjection:()=>h_,CamembertForMaskedLM:()=>Ty,CamembertForQuestionAnswering:()=>O_,CamembertForSequenceClassification:()=>ey,CamembertForTokenClassification:()=>yy,CamembertModel:()=>Z_,CamembertPreTrainedModel:()=>L_,CausalLMOutput:()=>Qw,CausalLMOutputWithPast:()=>l2,ChineseCLIPModel:()=>j0,ChineseCLIPPreTrainedModel:()=>_1,ClapAudioModelWithProjection:()=>kT,ClapModel:()=>MT,ClapPreTrainedModel:()=>hv,ClapTextModelWithProjection:()=>PT,CodeGenForCausalLM:()=>O1,CodeGenModel:()=>Z1,CodeGenPreTrainedModel:()=>Q0,CohereForCausalLM:()=>I1,CohereModel:()=>C1,CoherePreTrainedModel:()=>s1,ConvBertForMaskedLM:()=>Lr,ConvBertForQuestionAnswering:()=>Oo,ConvBertForSequenceClassification:()=>rn,ConvBertForTokenClassification:()=>Kr,ConvBertModel:()=>js,ConvBertPreTrainedModel:()=>Eo,ConvNextForImageClassification:()=>Xw,ConvNextModel:()=>qw,ConvNextPreTrainedModel:()=>Yx,ConvNextV2ForImageClassification:()=>Yw,ConvNextV2Model:()=>Bv,ConvNextV2PreTrainedModel:()=>Rw,DPTForDepthEstimation:()=>jx,DPTModel:()=>Bx,DPTPreTrainedModel:()=>Fv,DebertaForMaskedLM:()=>jo,DebertaForQuestionAnswering:()=>w_,DebertaForSequenceClassification:()=>Xs,DebertaForTokenClassification:()=>_d,DebertaModel:()=>g_,DebertaPreTrainedModel:()=>fy,DebertaV2ForMaskedLM:()=>k_,DebertaV2ForQuestionAnswering:()=>P_,DebertaV2ForSequenceClassification:()=>S_,DebertaV2ForTokenClassification:()=>B_,DebertaV2Model:()=>y_,DebertaV2PreTrainedModel:()=>mu,DecisionTransformerModel:()=>WT,DecisionTransformerPreTrainedModel:()=>UT,DeiTForImageClassification:()=>Cx,DeiTModel:()=>Ax,DeiTPreTrainedModel:()=>nv,DepthAnythingForDepthEstimation:()=>Nx,DepthAnythingPreTrainedModel:()=>zx,DetrForObjectDetection:()=>$x,DetrForSegmentation:()=>Ev,DetrModel:()=>Ex,DetrObjectDetectionOutput:()=>$v,DetrPreTrainedModel:()=>rv,DetrSegmentationOutput:()=>Mx,Dinov2ForImageClassification:()=>iv,Dinov2Model:()=>jv,Dinov2PreTrainedModel:()=>W0,DistilBertForMaskedLM:()=>T_,DistilBertForQuestionAnswering:()=>pu,DistilBertForSequenceClassification:()=>H_,DistilBertForTokenClassification:()=>j_,DistilBertModel:()=>q_,DistilBertPreTrainedModel:()=>N_,DonutSwinModel:()=>Xx,DonutSwinPreTrainedModel:()=>qx,EfficientNetForImageClassification:()=>DT,EfficientNetModel:()=>IT,EfficientNetPreTrainedModel:()=>Jv,ElectraForMaskedLM:()=>au,ElectraForQuestionAnswering:()=>m_,ElectraForSequenceClassification:()=>i_,ElectraForTokenClassification:()=>$u,ElectraModel:()=>qs,ElectraPreTrainedModel:()=>Mo,EsmForMaskedLM:()=>Ry,EsmForSequenceClassification:()=>Zy,EsmForTokenClassification:()=>hy,EsmModel:()=>iy,EsmPreTrainedModel:()=>E_,FalconForCausalLM:()=>$T,FalconModel:()=>SE,FalconPreTrainedModel:()=>Yv,FastViTForImageClassification:()=>A_,FastViTModel:()=>K_,FastViTPreTrainedModel:()=>W_,Florence2ForConditionalGeneration:()=>Qy,Florence2PreTrainedModel:()=>oy,GLPNForDepthEstimation:()=>Hx,GLPNModel:()=>Gx,GLPNPreTrainedModel:()=>Lv,GPT2LMHeadModel:()=>sw,GPT2Model:()=>P1,GPT2PreTrainedModel:()=>Uw,GPTBigCodeForCausalLM:()=>S1,GPTBigCodeModel:()=>Vw,GPTBigCodePreTrainedModel:()=>i1,GPTJForCausalLM:()=>cw,GPTJModel:()=>y1,GPTJPreTrainedModel:()=>o1,GPTNeoForCausalLM:()=>r1,GPTNeoModel:()=>g1,GPTNeoPreTrainedModel:()=>t1,GPTNeoXForCausalLM:()=>Q1,GPTNeoXModel:()=>k1,GPTNeoXPreTrainedModel:()=>n1,Gemma2ForCausalLM:()=>m0,Gemma2Model:()=>mw,Gemma2PreTrainedModel:()=>Kw,GemmaForCausalLM:()=>dw,GemmaModel:()=>ev,GemmaPreTrainedModel:()=>D1,GroupViTModel:()=>I_,GroupViTPreTrainedModel:()=>V_,HieraForImageClassification:()=>Dx,HieraModel:()=>Ix,HieraPreTrainedModel:()=>Ov,HubertForCTC:()=>Gv,HubertForSequenceClassification:()=>$E,HubertModel:()=>fT,HubertPreTrainedModel:()=>EE,ImageMattingOutput:()=>uE,JAISLMHeadModel:()=>Mw,JAISModel:()=>m1,JAISPreTrainedModel:()=>Ww,LlamaForCausalLM:()=>A1,LlamaModel:()=>J1,LlamaPreTrainedModel:()=>b1,LlavaForConditionalGeneration:()=>Nu,LlavaPreTrainedModel:()=>Pu,LongT5ForConditionalGeneration:()=>rw,LongT5Model:()=>Yy,LongT5PreTrainedModel:()=>yw,M2M100ForConditionalGeneration:()=>nT,M2M100Model:()=>rT,M2M100PreTrainedModel:()=>L1,MBartForCausalLM:()=>D_,MBartForConditionalGeneration:()=>Iu,MBartForSequenceClassification:()=>a_,MBartModel:()=>ba,MBartPreTrainedModel:()=>Zs,MPNetForMaskedLM:()=>xw,MPNetForQuestionAnswering:()=>q0,MPNetForSequenceClassification:()=>uw,MPNetForTokenClassification:()=>i0,MPNetModel:()=>N0,MPNetPreTrainedModel:()=>G0,MT5ForConditionalGeneration:()=>Jy,MT5Model:()=>ow,MT5PreTrainedModel:()=>nw,MarianMTModel:()=>Nv,MarianModel:()=>tT,MarianPreTrainedModel:()=>R1,MaskFormerForInstanceSegmentation:()=>Kx,MaskFormerModel:()=>vE,MaskFormerPreTrainedModel:()=>Rv,MaskedLMOutput:()=>V0,MistralForCausalLM:()=>vT,MistralModel:()=>wT,MistralPreTrainedModel:()=>Xv,MobileBertForMaskedLM:()=>K0,MobileBertForQuestionAnswering:()=>A0,MobileBertForSequenceClassification:()=>n0,MobileBertModel:()=>Sy,MobileBertPreTrainedModel:()=>Ay,MobileNetV1ForImageClassification:()=>CE,MobileNetV1Model:()=>LT,MobileNetV1PreTrainedModel:()=>tx,MobileNetV2ForImageClassification:()=>IE,MobileNetV2Model:()=>BT,MobileNetV2PreTrainedModel:()=>rx,MobileNetV3ForImageClassification:()=>zT,MobileNetV3Model:()=>jT,MobileNetV3PreTrainedModel:()=>nx,MobileNetV4ForImageClassification:()=>NT,MobileNetV4Model:()=>DE,MobileNetV4PreTrainedModel:()=>ox,MobileViTForImageClassification:()=>aw,MobileViTModel:()=>Fy,MobileViTPreTrainedModel:()=>Dy,MobileViTV2ForImageClassification:()=>I0,MobileViTV2Model:()=>C0,MobileViTV2PreTrainedModel:()=>Oy,ModelOutput:()=>Lo,Moondream1ForConditionalGeneration:()=>n_,MptForCausalLM:()=>ga,MptModel:()=>qo,MptPreTrainedModel:()=>vo,MusicgenForCausalLM:()=>RT,MusicgenForConditionalGeneration:()=>ex,MusicgenModel:()=>AE,MusicgenPreTrainedModel:()=>FT,NomicBertModel:()=>vu,NomicBertPreTrainedModel:()=>Ko,OPTForCausalLM:()=>Su,OPTModel:()=>uu,OPTPreTrainedModel:()=>fu,OpenELMForCausalLM:()=>tv,OpenELMModel:()=>Z0,OpenELMPreTrainedModel:()=>Gw,OwlViTForObjectDetection:()=>Sw,OwlViTModel:()=>x0,OwlViTPreTrainedModel:()=>Hw,Owlv2ForObjectDetection:()=>vx,Owlv2Model:()=>wx,Owlv2PreTrainedModel:()=>Fw,Phi3ForCausalLM:()=>wt,Phi3Model:()=>lt,Phi3PreTrainedModel:()=>w1,PhiForCausalLM:()=>gw,PhiModel:()=>kw,PhiPreTrainedModel:()=>l1,PreTrainedModel:()=>Jr,PretrainedMixin:()=>a0,PvtForImageClassification:()=>bu,PvtModel:()=>Au,PvtPreTrainedModel:()=>yu,PyAnnoteForAudioFrameClassification:()=>aT,PyAnnoteModel:()=>sT,PyAnnotePreTrainedModel:()=>lv,QuestionAnsweringModelOutput:()=>H0,Qwen2ForCausalLM:()=>Pw,Qwen2Model:()=>F1,Qwen2PreTrainedModel:()=>a1,RTDetrForObjectDetection:()=>kx,RTDetrModel:()=>Px,RTDetrObjectDetectionOutput:()=>Sx,RTDetrPreTrainedModel:()=>Mv,ResNetForImageClassification:()=>Fx,ResNetModel:()=>Cv,ResNetPreTrainedModel:()=>Av,RoFormerForMaskedLM:()=>ar,RoFormerForQuestionAnswering:()=>$o,RoFormerForSequenceClassification:()=>Qs,RoFormerForTokenClassification:()=>_a,RoFormerModel:()=>e_,RoFormerPreTrainedModel:()=>Cu,RobertaForMaskedLM:()=>L0,RobertaForQuestionAnswering:()=>g0,RobertaForSequenceClassification:()=>h0,RobertaForTokenClassification:()=>Uu,RobertaModel:()=>Ey,RobertaPreTrainedModel:()=>sy,SamImageSegmentationOutput:()=>eT,SamModel:()=>zv,SamPreTrainedModel:()=>av,SapiensForDepthEstimation:()=>Wx,SapiensForNormalEstimation:()=>Vx,SapiensForSemanticSegmentation:()=>Ux,SapiensPreTrainedModel:()=>ov,SegformerForImageClassification:()=>OT,SegformerForSemanticSegmentation:()=>AT,SegformerModel:()=>ST,SegformerPreTrainedModel:()=>c1,Seq2SeqLMOutput:()=>a2,SequenceClassifierOutput:()=>My,SiglipModel:()=>c0,SiglipPreTrainedModel:()=>$y,SiglipTextModel:()=>iw,SiglipVisionModel:()=>Iw,SpeechT5ForSpeechToText:()=>mT,SpeechT5ForTextToSpeech:()=>qv,SpeechT5HifiGan:()=>gT,SpeechT5Model:()=>kE,SpeechT5PreTrainedModel:()=>fv,SqueezeBertForMaskedLM:()=>P0,SqueezeBertForQuestionAnswering:()=>X0,SqueezeBertForSequenceClassification:()=>F0,SqueezeBertModel:()=>Cw,SqueezeBertPreTrainedModel:()=>M0,StableLmForCausalLM:()=>Zv,StableLmModel:()=>CT,StableLmPreTrainedModel:()=>Qv,Starcoder2ForCausalLM:()=>ET,Starcoder2Model:()=>TT,Starcoder2PreTrainedModel:()=>xT,Swin2SRForImageSuperResolution:()=>bw,Swin2SRModel:()=>Lx,Swin2SRPreTrainedModel:()=>Dv,SwinForImageClassification:()=>wE,SwinModel:()=>Rx,SwinPreTrainedModel:()=>Iv,T5ForConditionalGeneration:()=>Ew,T5Model:()=>Tw,T5PreTrainedModel:()=>by,TableTransformerForObjectDetection:()=>Ox,TableTransformerModel:()=>kv,TableTransformerObjectDetectionOutput:()=>Sv,TableTransformerPreTrainedModel:()=>Pv,TokenClassifierOutput:()=>D0,TrOCRForCausalLM:()=>bT,TrOCRPreTrainedModel:()=>yT,UniSpeechForCTC:()=>TE,UniSpeechForSequenceClassification:()=>Wv,UniSpeechModel:()=>uT,UniSpeechPreTrainedModel:()=>uv,UniSpeechSatForAudioFrameClassification:()=>cv,UniSpeechSatForCTC:()=>dT,UniSpeechSatForSequenceClassification:()=>pT,UniSpeechSatModel:()=>cT,UniSpeechSatPreTrainedModel:()=>j1,ViTForImageClassification:()=>hu,ViTMAEModel:()=>t_,ViTMAEPreTrainedModel:()=>Gu,ViTMSNForImageClassification:()=>p_,ViTMSNModel:()=>__,ViTMSNPreTrainedModel:()=>o_,ViTModel:()=>Ou,ViTPreTrainedModel:()=>tu,VisionEncoderDecoderModel:()=>ru,VitMatteForImageMatting:()=>vy,VitMattePreTrainedModel:()=>my,VitsModel:()=>z1,VitsModelOutput:()=>hx,VitsPreTrainedModel:()=>OE,Wav2Vec2BertForCTC:()=>Vv,Wav2Vec2BertForSequenceClassification:()=>Kv,Wav2Vec2BertModel:()=>pv,Wav2Vec2BertPreTrainedModel:()=>dv,Wav2Vec2ForAudioFrameClassification:()=>iT,Wav2Vec2ForCTC:()=>Uv,Wav2Vec2ForSequenceClassification:()=>B1,Wav2Vec2Model:()=>oT,Wav2Vec2PreTrainedModel:()=>u1,WavLMForAudioFrameClassification:()=>PE,WavLMForCTC:()=>ME,WavLMForSequenceClassification:()=>_T,WavLMForXVector:()=>Hv,WavLMModel:()=>hT,WavLMPreTrainedModel:()=>v1,WeSpeakerResNetModel:()=>xE,WeSpeakerResNetPreTrainedModel:()=>lT,WhisperForConditionalGeneration:()=>Xo,WhisperModel:()=>Xr,WhisperPreTrainedModel:()=>v_,XLMForQuestionAnswering:()=>e0,XLMForSequenceClassification:()=>J_,XLMForTokenClassification:()=>k0,XLMModel:()=>_0,XLMPreTrainedModel:()=>Iy,XLMRobertaForMaskedLM:()=>U_,XLMRobertaForQuestionAnswering:()=>s0,XLMRobertaForSequenceClassification:()=>_y,XLMRobertaForTokenClassification:()=>Ky,XLMRobertaModel:()=>zy,XLMRobertaPreTrainedModel:()=>jy,XLMWithLMHeadModel:()=>ry,XVectorOutput:()=>fx,YolosForObjectDetection:()=>Zx,YolosModel:()=>Qx,YolosObjectDetectionOutput:()=>Jx,YolosPreTrainedModel:()=>sv});var s=i("./src/configs.js"),h=i("./src/backends/onnx.js"),a=i("./src/utils/dtypes.js"),d=i("./src/utils/generic.js"),et=i("./src/utils/core.js"),$=i("./src/utils/hub.js"),c=i("./src/generation/logits_process.js"),b=i("./src/generation/configuration_utils.js"),g=i("./src/utils/tensor.js"),nt=i("./src/utils/maths.js"),at=i("./src/generation/stopping_criteria.js"),Ot=i("./src/generation/logits_sampler.js"),At=i("./src/env.js"),Ct=i("./src/models/whisper/generation_whisper.js"),St=i("./src/models/whisper/common_whisper.js");const xt={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7},Dt=new Map,Qt=new Map,Zt=new Map;async function gr(jr,tr,Io){let eu=Io.device;eu&&typeof eu!="string"&&(eu.hasOwnProperty(tr)?eu=eu[tr]:(console.warn(`device not specified for "${tr}". Using the default device.`),eu=null));const l_=eu??(At.apis.IS_NODE_ENV?"cpu":"wasm"),$_=(0,h.deviceToExecutionProviders)(l_);let F_=Io.dtype;typeof F_!="string"&&(F_&&F_.hasOwnProperty(tr)?F_=F_[tr]:(F_=a.DEFAULT_DEVICE_DTYPE_MAPPING[l_]??a.DATA_TYPES.fp32,console.warn(`dtype not specified for "${tr}". Using the default dtype (${F_}) for this device (${l_}).`)));const Q_=F_;if(a.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(Q_)){if(Q_===a.DATA_TYPES.fp16&&l_==="webgpu"&&!await(0,a.isWebGpuFp16Supported)())throw new Error(`The device (${l_}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${Q_}. Should be one of: ${Object.keys(a.DATA_TYPES).join(", ")}`);const py=a.DEFAULT_DTYPE_SUFFIX_MAPPING[Q_],Gy=`${Io.subfolder??""}/${tr}${py}.onnx`,o0={...Io.session_options};o0.executionProviders??=$_;const l0=(0,$.getModelFile)(jr,Gy,!0,Io);let Ny=[];if(Io.use_external_data_format&&(Io.use_external_data_format===!0||typeof Io.use_external_data_format=="object"&&Io.use_external_data_format.hasOwnProperty(tr)&&Io.use_external_data_format[tr]===!0)){if(At.apis.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const f0=`${tr}${py}.onnx_data`,Py=`${Io.subfolder??""}/${f0}`;Ny.push(new Promise(async(Hy,T0)=>{const z0=await(0,$.getModelFile)(jr,Py,!0,Io);Hy({path:f0,data:z0})}))}else o0.externalData!==void 0&&(Ny=o0.externalData.map(async f0=>{if(typeof f0.data=="string"){const Py=await(0,$.getModelFile)(jr,f0.data,!0,Io);return{...f0,data:Py}}return f0}));if(Ny.length>0&&(o0.externalData=await Promise.all(Ny)),l_==="webgpu"){const f0=(0,s.getKeyValueShapes)(Io.config,{prefix:"present"});if(Object.keys(f0).length>0&&!(0,h.isONNXProxy)()){const Py={};for(const Hy in f0)Py[Hy]="gpu-buffer";o0.preferredOutputLocation=Py}}return{buffer:await l0,session_options:o0}}async function vr(jr,tr,Io){return Object.fromEntries(await Promise.all(Object.keys(tr).map(async eu=>{const{buffer:l_,session_options:$_}=await gr(jr,tr[eu],Io),F_=await(0,h.createInferenceSession)(l_,$_);return[eu,F_]})))}function Er(jr,tr){const Io=Object.create(null),eu=[];for(const F_ of jr.inputNames){const Q_=tr[F_];if(!(Q_ instanceof g.Tensor)){eu.push(F_);continue}Io[F_]=(0,h.isONNXProxy)()?Q_.clone():Q_}if(eu.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${eu.join(", ")}.`);const l_=Object.keys(tr).length,$_=jr.inputNames.length;if(l_>$_){let F_=Object.keys(tr).filter(Q_=>!jr.inputNames.includes(Q_));console.warn(`WARNING: Too many inputs were provided (${l_} > ${$_}). The following inputs will be ignored: "${F_.join(", ")}".`)}return Io}async function wo(jr,tr){const Io=Er(jr,tr);try{const eu=Object.fromEntries(Object.entries(Io).map(([$_,F_])=>[$_,F_.ort_tensor]));let l_=await jr.run(eu);return l_=Do(l_),l_}catch(eu){throw console.error(`An error occurred during model execution: "${eu}".`),console.error("Inputs given to model:",Io),eu}}function Do(jr){for(let tr in jr)(0,h.isONNXTensor)(jr[tr])?jr[tr]=new g.Tensor(jr[tr]):typeof jr[tr]=="object"&&Do(jr[tr]);return jr}function Js(jr){if(jr instanceof g.Tensor)return jr;if(jr.length===0)throw Error("items must be non-empty");if(Array.isArray(jr[0])){if(jr.some(tr=>tr.length!==jr[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new g.Tensor("int64",BigInt64Array.from(jr.flat().map(tr=>BigInt(tr))),[jr.length,jr[0].length])}else return new g.Tensor("int64",BigInt64Array.from(jr.map(tr=>BigInt(tr))),[1,jr.length])}function In(jr){return new g.Tensor("bool",[jr],[1])}async function Wo(jr,tr){let{encoder_outputs:Io,input_ids:eu,decoder_input_ids:l_,...$_}=tr;if(!Io){const Q_=(0,et.pick)(tr,jr.sessions.model.inputNames);Io=(await Ir(jr,Q_)).last_hidden_state}return $_.input_ids=l_,$_.encoder_hidden_states=Io,jr.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&($_.encoder_attention_mask=tr.attention_mask),await Yo(jr,$_,!0)}async function Ir(jr,tr){const Io=jr.sessions.model,eu=(0,et.pick)(tr,Io.inputNames);if(Io.inputNames.includes("inputs_embeds")&&!eu.inputs_embeds){if(!tr.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");eu.inputs_embeds=await jr.encode_text({input_ids:tr.input_ids})}return Io.inputNames.includes("token_type_ids")&&!eu.token_type_ids&&(eu.token_type_ids=new g.Tensor("int64",new BigInt64Array(eu.input_ids.data.length),eu.input_ids.dims)),await wo(Io,eu)}async function Yo(jr,tr,Io=!1){const eu=jr.sessions[Io?"decoder_model_merged":"model"],{past_key_values:l_,...$_}=tr;eu.inputNames.includes("use_cache_branch")&&($_.use_cache_branch=In(!!l_)),eu.inputNames.includes("position_ids")&&$_.attention_mask&&!$_.position_ids&&($_.position_ids=Ho($_,l_)),jr.addPastKeyValues($_,l_);const F_=(0,et.pick)($_,eu.inputNames);return await wo(eu,F_)}async function Bu(jr,{input_ids:tr=null,attention_mask:Io=null,pixel_values:eu=null,position_ids:l_=null,inputs_embeds:$_=null,past_key_values:F_=null,generation_config:Q_=null,logits_processor:py=null,...Gy}){if(!$_){if($_=await jr.encode_text({input_ids:tr}),eu&&tr.dims[1]!==1){const l0=await jr.encode_image({pixel_values:eu});({inputs_embeds:$_,attention_mask:Io}=jr._merge_input_ids_with_image_features({image_features:l0,inputs_embeds:$_,input_ids:tr,attention_mask:Io}))}else if(F_&&eu&&tr.dims[1]===1){const l0=tr.dims[1],Ny=Object.values(F_)[0].dims.at(-2);Io=(0,g.cat)([(0,g.ones)([tr.dims[0],Ny]),Io.slice(null,[Io.dims[1]-l0,Io.dims[1]])],1)}}return await Yo(jr,{inputs_embeds:$_,past_key_values:F_,attention_mask:Io,position_ids:l_,generation_config:Q_,logits_processor:py},!0)}function Ho(jr,tr=null){const{input_ids:Io,inputs_embeds:eu,attention_mask:l_}=jr,[$_,F_]=l_.dims,Q_=new BigInt64Array(l_.data.length);for(let Gy=0;Gy<$_;++Gy){const o0=Gy*F_;let l0=BigInt(0);for(let Ny=0;Ny<F_;++Ny){const xy=o0+Ny;l_.data[xy]===0n?Q_[xy]=BigInt(1):(Q_[xy]=l0,l0+=l_.data[xy])}}let py=new g.Tensor("int64",Q_,l_.dims);if(tr){const Gy=-(Io??eu).dims.at(1);py=py.slice(null,[Gy,null])}return py}function tn(jr,tr,Io,eu){if(Io.past_key_values){const l_=Object.values(Io.past_key_values)[0].dims.at(-2),{input_ids:$_,attention_mask:F_}=Io;if(!(F_&&F_.dims[1]>$_.dims[1])){if(l_<$_.dims[1])Io.input_ids=$_.slice(null,[l_,null]);else if(jr.config.image_token_index!=null&&$_.data.some(Q_=>Q_==jr.config.image_token_index)){const Q_=jr.config.num_image_tokens;if(!Q_)throw new Error("`num_image_tokens` is missing in the model configuration.");const py=$_.dims[1]-(l_-Q_);Io.input_ids=$_.slice(null,[-py,null]),Io.attention_mask=(0,g.ones)([1,l_+py])}}}return Io}function To(jr,tr,Io,eu){return Io.past_key_values&&(tr=tr.map(l_=>[l_.at(-1)])),{...Io,decoder_input_ids:Js(tr)}}function Qo(jr,...tr){return jr.config.is_encoder_decoder?To(jr,...tr):tn(jr,...tr)}class Jr extends d.Callable{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(tr,Io){super(),this.config=tr,this.sessions=Io;const eu=Zt.get(this.constructor),l_=Dt.get(eu);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,l_){case xt.DecoderOnly:this.can_generate=!0,this._forward=Yo,this._prepare_inputs_for_generation=tn;break;case xt.Seq2Seq:case xt.Vision2Seq:case xt.Musicgen:this.can_generate=!0,this._forward=Wo,this._prepare_inputs_for_generation=To;break;case xt.EncoderDecoder:this._forward=Wo;break;case xt.ImageTextToText:this.can_generate=!0,this._forward=Bu,this._prepare_inputs_for_generation=Qo;break;default:this._forward=Ir;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const tr=[];for(const Io of Object.values(this.sessions))Io?.handler?.dispose&&tr.push(Io.handler.dispose());return await Promise.all(tr)}static async from_pretrained(tr,{progress_callback:Io=null,config:eu=null,cache_dir:l_=null,local_files_only:$_=!1,revision:F_="main",model_file_name:Q_=null,subfolder:py="onnx",device:Gy=null,dtype:o0=null,use_external_data_format:l0=null,session_options:Ny={}}={}){let xy={progress_callback:Io,config:eu,cache_dir:l_,local_files_only:$_,revision:F_,model_file_name:Q_,subfolder:py,device:Gy,dtype:o0,use_external_data_format:l0,session_options:Ny};const f0=Zt.get(this),Py=Dt.get(f0);eu=xy.config=await s.AutoConfig.from_pretrained(tr,xy);let Hy;if(Py===xt.DecoderOnly)Hy=await Promise.all([vr(tr,{model:xy.model_file_name??"model"},xy),(0,$.getModelJSON)(tr,"generation_config.json",!1,xy)]);else if(Py===xt.Seq2Seq||Py===xt.Vision2Seq)Hy=await Promise.all([vr(tr,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},xy),(0,$.getModelJSON)(tr,"generation_config.json",!1,xy)]);else if(Py===xt.MaskGeneration)Hy=await Promise.all([vr(tr,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},xy)]);else if(Py===xt.EncoderDecoder)Hy=await Promise.all([vr(tr,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},xy)]);else if(Py===xt.ImageTextToText){const T0={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};eu.is_encoder_decoder&&(T0.model="encoder_model"),Hy=await Promise.all([vr(tr,T0,xy),(0,$.getModelJSON)(tr,"generation_config.json",!1,xy)])}else Py===xt.Musicgen?Hy=await Promise.all([vr(tr,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},xy),(0,$.getModelJSON)(tr,"generation_config.json",!1,xy)]):(Py!==xt.EncoderOnly&&console.warn(`Model type for '${f0??eu?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),Hy=await Promise.all([vr(tr,{model:xy.model_file_name??"model"},xy)]));return new this(eu,...Hy)}async _call(tr){return await this.forward(tr)}async forward(tr){return await this._forward(this,tr)}_get_logits_warper(tr){const Io=new c.LogitsProcessorList;return tr.temperature!==null&&tr.temperature!==1&&Io.push(new c.TemperatureLogitsWarper(tr.temperature)),tr.top_k!==null&&tr.top_k!==0&&Io.push(new c.TopKLogitsWarper(tr.top_k)),tr.top_p!==null&&tr.top_p<1&&Io.push(new c.TopPLogitsWarper(tr.top_p)),Io}_get_logits_processor(tr,Io,eu=null){const l_=new c.LogitsProcessorList;if(tr.repetition_penalty!==null&&tr.repetition_penalty!==1&&l_.push(new c.RepetitionPenaltyLogitsProcessor(tr.repetition_penalty)),tr.no_repeat_ngram_size!==null&&tr.no_repeat_ngram_size>0&&l_.push(new c.NoRepeatNGramLogitsProcessor(tr.no_repeat_ngram_size)),tr.bad_words_ids!==null&&l_.push(new c.NoBadWordsLogitsProcessor(tr.bad_words_ids,tr.eos_token_id)),tr.min_length!==null&&tr.eos_token_id!==null&&tr.min_length>0&&l_.push(new c.MinLengthLogitsProcessor(tr.min_length,tr.eos_token_id)),tr.min_new_tokens!==null&&tr.eos_token_id!==null&&tr.min_new_tokens>0&&l_.push(new c.MinNewTokensLengthLogitsProcessor(Io,tr.min_new_tokens,tr.eos_token_id)),tr.forced_bos_token_id!==null&&l_.push(new c.ForcedBOSTokenLogitsProcessor(tr.forced_bos_token_id)),tr.forced_eos_token_id!==null&&l_.push(new c.ForcedEOSTokenLogitsProcessor(tr.max_length,tr.forced_eos_token_id)),tr.begin_suppress_tokens!==null){const $_=Io>1||tr.forced_bos_token_id===null?Io:Io+1;l_.push(new c.SuppressTokensAtBeginLogitsProcessor(tr.begin_suppress_tokens,$_))}return tr.guidance_scale!==null&&tr.guidance_scale>1&&l_.push(new c.ClassifierFreeGuidanceLogitsProcessor(tr.guidance_scale)),eu!==null&&l_.extend(eu),l_}_prepare_generation_config(tr,Io,eu=b.GenerationConfig){const l_={...this.config};for(const F_ of["decoder","generator","text_config"])F_ in l_&&Object.assign(l_,l_[F_]);const $_=new eu(l_);return"generation_config"in this&&Object.assign($_,this.generation_config),tr&&Object.assign($_,tr),Io&&Object.assign($_,(0,et.pick)(Io,Object.getOwnPropertyNames($_))),$_}_get_stopping_criteria(tr,Io=null){const eu=new at.StoppingCriteriaList;return tr.max_length!==null&&eu.push(new at.MaxLengthCriteria(tr.max_length,this.config.max_position_embeddings??null)),tr.eos_token_id!==null&&eu.push(new at.EosTokenCriteria(tr.eos_token_id)),Io&&eu.extend(Io),eu}_validate_model_class(){if(!this.can_generate){const tr=[ax,lx,sx,ix],Io=Zt.get(this.constructor),eu=new Set,l_=this.config.model_type;for(const F_ of tr){const Q_=F_.get(l_);Q_&&eu.add(Q_[0])}let $_=`The current model class (${Io}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw eu.size>0&&($_+=` Please use the following class instead: ${[...eu].join(", ")}`),Error($_)}}prepare_inputs_for_generation(...tr){return this._prepare_inputs_for_generation(this,...tr)}_update_model_kwargs_for_generation({generated_input_ids:tr,outputs:Io,model_inputs:eu,is_encoder_decoder:l_}){return eu.past_key_values=this.getPastKeyValues(Io,eu.past_key_values),eu.input_ids=new g.Tensor("int64",tr.flat(),[tr.length,1]),l_||(eu.attention_mask=(0,g.cat)([eu.attention_mask,(0,g.ones)([eu.attention_mask.dims[0],1])],1)),eu.position_ids=null,eu}_prepare_model_inputs({inputs:tr,bos_token_id:Io,model_kwargs:eu}){const l_=(0,et.pick)(eu,this.forward_params),$_=this.main_input_name;if($_ in l_){if(tr)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else l_[$_]=tr;return{inputs_tensor:l_[$_],model_inputs:l_,model_input_name:$_}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:tr,model_inputs:Io,model_input_name:eu,generation_config:l_}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!Io.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:F_,pixel_values:Q_,attention_mask:py,...Gy}=Io,o0=await this._prepare_inputs_embeds(Io);Io={...Gy,...(0,et.pick)(o0,["inputs_embeds","attention_mask"])}}let{last_hidden_state:$_}=await Ir(this,Io);if(l_.guidance_scale!==null&&l_.guidance_scale>1)$_=(0,g.cat)([$_,(0,g.full_like)($_,0)],0),"attention_mask"in Io&&(Io.attention_mask=(0,g.cat)([Io.attention_mask,(0,g.zeros_like)(Io.attention_mask)],0));else if(Io.decoder_input_ids){const F_=Js(Io.decoder_input_ids).dims[0];if(F_!==$_.dims[0]){if($_.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${$_.dims[0]}) than the decoder inputs (${F_}).`);$_=(0,g.cat)(Array.from({length:F_},()=>$_),0)}}return Io.encoder_outputs=$_,Io}_prepare_decoder_input_ids_for_generation({batch_size:tr,model_input_name:Io,model_kwargs:eu,decoder_start_token_id:l_,bos_token_id:$_,generation_config:F_}){let{decoder_input_ids:Q_,...py}=eu;if(Q_)Array.isArray(Q_[0])||(Q_=Array.from({length:tr},()=>Q_));else if(l_??=$_,this.config.model_type==="musicgen")Q_=Array.from({length:tr*this.config.decoder.num_codebooks},()=>[l_]);else if(Array.isArray(l_)){if(l_.length!==tr)throw new Error(`\`decoder_start_token_id\` expcted to have length ${tr} but got ${l_.length}`);Q_=l_}else Q_=Array.from({length:tr},()=>[l_]);return Q_=Js(Q_),eu.decoder_attention_mask=(0,g.ones_like)(Q_),{input_ids:Q_,model_inputs:py}}async generate({inputs:tr=null,generation_config:Io=null,logits_processor:eu=null,stopping_criteria:l_=null,streamer:$_=null,...F_}){this._validate_model_class(),Io=this._prepare_generation_config(Io,F_);let{inputs_tensor:Q_,model_inputs:py,model_input_name:Gy}=this._prepare_model_inputs({inputs:tr,model_kwargs:F_});const o0=this.config.is_encoder_decoder;o0&&("encoder_outputs"in py||(py=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:Q_,model_inputs:py,model_input_name:Gy,generation_config:Io})));let l0;o0?{input_ids:l0,model_inputs:py}=this._prepare_decoder_input_ids_for_generation({batch_size:py[Gy].dims.at(0),model_input_name:Gy,model_kwargs:py,decoder_start_token_id:Io.decoder_start_token_id,bos_token_id:Io.bos_token_id,generation_config:Io}):l0=py[Gy];let Ny=l0.dims.at(-1);Io.max_new_tokens!==null&&(Io.max_length=Ny+Io.max_new_tokens);const xy=this._get_logits_processor(Io,Ny,eu),f0=this._get_stopping_criteria(Io,l_),Py=py[Gy].dims.at(0),Hy=Ot.LogitsSampler.getSampler(Io),T0=new Array(Py).fill(0),z0=l0.tolist();$_&&$_.put(z0);let Zw=null,ww={};for(;;){py=this.prepare_inputs_for_generation(z0,py,Io);const E0=await this.forward(py);if(Io.output_attentions&&Io.return_dict_in_generate){const Ow=this.getAttentions(E0);for(const T1 in Ow)T1 in ww||(ww[T1]=[]),ww[T1].push(Ow[T1])}const fw=E0.logits.slice(null,-1,null),mv=xy(z0,fw),x1=[];for(let Ow=0;Ow<mv.dims.at(0);++Ow){const T1=mv[Ow],u2=await Hy(T1);for(const[c2,d2]of u2){const cE=BigInt(c2);T0[Ow]+=d2,z0[Ow].push(cE),x1.push([cE]);break}}if($_&&$_.put(x1),f0(z0).every(Ow=>Ow)){Io.return_dict_in_generate&&(Zw=this.getPastKeyValues(E0,py.past_key_values,!1));break}py=this._update_model_kwargs_for_generation({generated_input_ids:x1,outputs:E0,model_inputs:py,is_encoder_decoder:o0})}$_&&$_.end();const pw=new g.Tensor("int64",z0.flat(),[z0.length,z0[0].length]);return Io.return_dict_in_generate?{sequences:pw,past_key_values:Zw,...ww}:pw}getPastKeyValues(tr,Io,eu=!0){const l_=Object.create(null);for(const $_ in tr)if($_.startsWith("present")){const F_=$_.replace("present","past_key_values");if(Io&&$_.includes("encoder"))l_[F_]=Io[F_];else{if(eu&&Io){const Q_=Io[F_];Q_.location==="gpu-buffer"&&Q_.dispose()}l_[F_]=tr[$_]}}return l_}getAttentions(tr){const Io={};for(const eu of["cross_attentions","encoder_attentions","decoder_attentions"])for(const l_ in tr)l_.startsWith(eu)&&(eu in Io||(Io[eu]=[]),Io[eu].push(tr[l_]));return Io}addPastKeyValues(tr,Io){if(Io)Object.assign(tr,Io);else{const eu=this.custom_config.kv_cache_dtype??"float32",l_=eu==="float16"?new Uint16Array:[],$_=(0,s.getKeyValueShapes)(this.config);for(const F_ in $_)tr[F_]=new g.Tensor(eu,l_,$_[F_])}}async encode_image({pixel_values:tr}){const Io=(await wo(this.sessions.vision_encoder,{pixel_values:tr})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${Io.dims[1]}).`),this.config.num_image_tokens=Io.dims[1]),Io}async encode_text({input_ids:tr}){return(await wo(this.sessions.embed_tokens,{input_ids:tr})).inputs_embeds}}class Lo{}class Du extends Lo{constructor({last_hidden_state:tr,hidden_states:Io=null,attentions:eu=null}){super(),this.last_hidden_state=tr,this.hidden_states=Io,this.attentions=eu}}class _u extends Jr{}class du extends _u{}class wu extends _u{async _call(tr){return new V0(await super._call(tr))}}class r_ extends _u{async _call(tr){return new My(await super._call(tr))}}class d_ extends _u{async _call(tr){return new D0(await super._call(tr))}}class na extends _u{async _call(tr){return new H0(await super._call(tr))}}class Ko extends Jr{}class vu extends Ko{}class Cu extends Jr{}class e_ extends Cu{}class ar extends Cu{async _call(tr){return new V0(await super._call(tr))}}class Qs extends Cu{async _call(tr){return new My(await super._call(tr))}}class _a extends Cu{async _call(tr){return new D0(await super._call(tr))}}class $o extends Cu{async _call(tr){return new H0(await super._call(tr))}}class Eo extends Jr{}class js extends Eo{}class Lr extends Eo{async _call(tr){return new V0(await super._call(tr))}}class rn extends Eo{async _call(tr){return new My(await super._call(tr))}}class Kr extends Eo{async _call(tr){return new D0(await super._call(tr))}}class Oo extends Eo{async _call(tr){return new H0(await super._call(tr))}}class Mo extends Jr{}class qs extends Mo{}class au extends Mo{async _call(tr){return new V0(await super._call(tr))}}class i_ extends Mo{async _call(tr){return new My(await super._call(tr))}}class $u extends Mo{async _call(tr){return new D0(await super._call(tr))}}class m_ extends Mo{async _call(tr){return new H0(await super._call(tr))}}class L_ extends Jr{}class Z_ extends L_{}class Ty extends L_{async _call(tr){return new V0(await super._call(tr))}}class ey extends L_{async _call(tr){return new My(await super._call(tr))}}class yy extends L_{async _call(tr){return new D0(await super._call(tr))}}class O_ extends L_{async _call(tr){return new H0(await super._call(tr))}}class fy extends Jr{}class g_ extends fy{}class jo extends fy{async _call(tr){return new V0(await super._call(tr))}}class Xs extends fy{async _call(tr){return new My(await super._call(tr))}}class _d extends fy{async _call(tr){return new D0(await super._call(tr))}}class w_ extends fy{async _call(tr){return new H0(await super._call(tr))}}class mu extends Jr{}class y_ extends mu{}class k_ extends mu{async _call(tr){return new V0(await super._call(tr))}}class S_ extends mu{async _call(tr){return new My(await super._call(tr))}}class B_ extends mu{async _call(tr){return new D0(await super._call(tr))}}class P_ extends mu{async _call(tr){return new H0(await super._call(tr))}}class N_ extends Jr{}class q_ extends N_{}class H_ extends N_{async _call(tr){return new My(await super._call(tr))}}class j_ extends N_{async _call(tr){return new D0(await super._call(tr))}}class pu extends N_{async _call(tr){return new H0(await super._call(tr))}}class T_ extends N_{async _call(tr){return new V0(await super._call(tr))}}class E_ extends Jr{}class iy extends E_{}class Ry extends E_{async _call(tr){return new V0(await super._call(tr))}}class Zy extends E_{async _call(tr){return new My(await super._call(tr))}}class hy extends E_{async _call(tr){return new D0(await super._call(tr))}}class Ay extends Jr{}class Sy extends Ay{}class K0 extends Ay{async _call(tr){return new V0(await super._call(tr))}}class n0 extends Ay{async _call(tr){return new My(await super._call(tr))}}class A0 extends Ay{async _call(tr){return new H0(await super._call(tr))}}class G0 extends Jr{}class N0 extends G0{}class xw extends G0{async _call(tr){return new V0(await super._call(tr))}}class uw extends G0{async _call(tr){return new My(await super._call(tr))}}class i0 extends G0{async _call(tr){return new D0(await super._call(tr))}}class q0 extends G0{async _call(tr){return new H0(await super._call(tr))}}class M0 extends Jr{}class Cw extends M0{}class P0 extends M0{async _call(tr){return new V0(await super._call(tr))}}class F0 extends M0{async _call(tr){return new My(await super._call(tr))}}class X0 extends M0{async _call(tr){return new H0(await super._call(tr))}}class Y0 extends Jr{}class U0 extends Y0{}class _w extends Y0{async _call(tr){return new My(await super._call(tr))}}class tw extends Y0{async _call(tr){return new H0(await super._call(tr))}}class ly extends Y0{async _call(tr){return new V0(await super._call(tr))}}class by extends Jr{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Tw extends by{}class Ew extends by{}class yw extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Yy extends yw{}class rw extends yw{}class nw extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class ow extends nw{}class Jy extends nw{}class R0 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class xu extends R0{}class wr extends R0{}class Po extends R0{async _call(tr){return new My(await super._call(tr))}}class Zs extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class ba extends Zs{}class Iu extends Zs{}class a_ extends Zs{async _call(tr){return new My(await super._call(tr))}}class D_ extends Zs{}class b_ extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class z_ extends b_{}class C_ extends b_{}class Cy extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class ay extends Cy{}class wy extends Cy{}class sy extends Jr{}class Ey extends sy{}class L0 extends sy{async _call(tr){return new V0(await super._call(tr))}}class h0 extends sy{async _call(tr){return new My(await super._call(tr))}}class Uu extends sy{async _call(tr){return new D0(await super._call(tr))}}class g0 extends sy{async _call(tr){return new H0(await super._call(tr))}}class Iy extends Jr{}class _0 extends Iy{}class ry extends Iy{async _call(tr){return new V0(await super._call(tr))}}class J_ extends Iy{async _call(tr){return new My(await super._call(tr))}}class k0 extends Iy{async _call(tr){return new D0(await super._call(tr))}}class e0 extends Iy{async _call(tr){return new H0(await super._call(tr))}}class jy extends Jr{}class zy extends jy{}class U_ extends jy{async _call(tr){return new V0(await super._call(tr))}}class _y extends jy{async _call(tr){return new My(await super._call(tr))}}class Ky extends jy{async _call(tr){return new D0(await super._call(tr))}}class s0 extends jy{async _call(tr){return new H0(await super._call(tr))}}class S0 extends Jr{}class X_ extends S0{}class $w extends S0{}class v_ extends Jr{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"];constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Xr extends v_{}class Xo extends v_{_prepare_generation_config(tr,Io){return super._prepare_generation_config(tr,Io,Ct.WhisperGenerationConfig)}_retrieve_init_tokens(tr){const Io=[tr.decoder_start_token_id];let eu=tr.language;const l_=tr.task;if(tr.is_multilingual){eu||(console.warn("No language specified - defaulting to English (en)."),eu="en");const F_=`<|${(0,St.whisper_language_to_code)(eu)}|>`;Io.push(tr.lang_to_id[F_]),Io.push(tr.task_to_id[l_??"transcribe"])}else if(eu||l_)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!tr.return_timestamps&&tr.no_timestamps_token_id&&Io.at(-1)!==tr.no_timestamps_token_id?Io.push(tr.no_timestamps_token_id):tr.return_timestamps&&Io.at(-1)===tr.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),Io.pop()),Io.filter($_=>$_!=null)}async generate({inputs:tr=null,generation_config:Io=null,logits_processor:eu=null,stopping_criteria:l_=null,...$_}){Io=this._prepare_generation_config(Io,$_);const F_=$_.decoder_input_ids??this._retrieve_init_tokens(Io);if(Io.return_timestamps&&(eu??=new c.LogitsProcessorList,eu.push(new c.WhisperTimeStampLogitsProcessor(Io,F_))),Io.begin_suppress_tokens&&(eu??=new c.LogitsProcessorList,eu.push(new c.SuppressTokensAtBeginLogitsProcessor(Io.begin_suppress_tokens,F_.length))),Io.return_token_timestamps){if(!Io.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");Io.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),Io.output_attentions=!0,Io.return_dict_in_generate=!0}const Q_=await super.generate({inputs:tr,generation_config:Io,logits_processor:eu,decoder_input_ids:F_,...$_});return Io.return_token_timestamps&&(Q_.token_timestamps=this._extract_token_timestamps(Q_,Io.alignment_heads,Io.num_frames)),Q_}_extract_token_timestamps(tr,Io,eu=null,l_=.02){if(!tr.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");eu==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let $_=this.config.median_filter_width;$_===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),$_=7);const F_=tr.cross_attentions,Q_=Array.from({length:this.config.decoder_layers},(Py,Hy)=>(0,g.cat)(F_.map(T0=>T0[Hy]),2)),py=(0,g.stack)(Io.map(([Py,Hy])=>{if(Py>=Q_.length)throw new Error(`Layer index ${Py} is out of bounds for cross attentions (length ${Q_.length}).`);return eu?Q_[Py].slice(null,Hy,null,[0,eu]):Q_[Py].slice(null,Hy)})).transpose(1,0,2,3),[Gy,o0]=(0,g.std_mean)(py,-2,0,!0),l0=py.clone();for(let Py=0;Py<l0.dims[0];++Py){const Hy=l0[Py];for(let T0=0;T0<Hy.dims[0];++T0){const z0=Hy[T0],Zw=Gy[Py][T0][0].data,ww=o0[Py][T0][0].data;for(let pw=0;pw<z0.dims[0];++pw){let E0=z0[pw].data;for(let fw=0;fw<E0.length;++fw)E0[fw]=(E0[fw]-ww[fw])/Zw[fw];E0.set((0,nt.medianFilter)(E0,$_))}}}const Ny=[(0,g.mean)(l0,1)],xy=tr.sequences.dims,f0=new g.Tensor("float32",new Float32Array(xy[0]*xy[1]),xy);for(let Py=0;Py<xy[0];++Py){const Hy=Ny[Py].neg().squeeze_(0),[T0,z0]=(0,nt.dynamic_time_warping)(Hy.tolist()),Zw=Array.from({length:T0.length-1},(E0,fw)=>T0[fw+1]-T0[fw]),ww=(0,et.mergeArrays)([1],Zw).map(E0=>!!E0),pw=[];for(let E0=0;E0<ww.length;++E0)ww[E0]&&pw.push(z0[E0]*l_);f0[Py].data.set(pw,1)}return f0}}class ru extends Jr{main_input_name="pixel_values";forward_params=["pixel_values","input_ids","encoder_hidden_states","past_key_values"];constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Pu extends Jr{forward_params=["input_ids","pixel_values","attention_mask","position_ids","past_key_values"];constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Nu extends Pu{_merge_input_ids_with_image_features({inputs_embeds:tr,image_features:Io,input_ids:eu,attention_mask:l_}){const $_=this.config.image_token_index,Q_=eu.tolist().map(Ny=>Ny.findIndex(xy=>xy==$_)),py=Q_.every(Ny=>Ny===-1),Gy=Q_.every(Ny=>Ny!==-1);if(!py&&!Gy)throw new Error("Every input should contain either 0 or 1 image token.");if(py)return{inputs_embeds:tr,attention_mask:l_};const o0=[],l0=[];for(let Ny=0;Ny<Q_.length;++Ny){const xy=Q_[Ny],f0=tr[Ny],Py=Io[Ny],Hy=l_[Ny];o0.push((0,g.cat)([f0.slice([0,xy]),Py,f0.slice([xy+1,f0.dims[0]])],0)),l0.push((0,g.cat)([Hy.slice([0,xy]),(0,g.ones)([Py.dims[0]]),Hy.slice([xy+1,Hy.dims[0]])],0))}return{inputs_embeds:(0,g.stack)(o0,0),attention_mask:(0,g.stack)(l0,0)}}}class n_ extends Nu{}class oy extends Jr{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds";constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Qy extends oy{_merge_input_ids_with_image_features({inputs_embeds:tr,image_features:Io,input_ids:eu,attention_mask:l_}){return{inputs_embeds:(0,g.cat)([Io,tr],1),attention_mask:(0,g.cat)([(0,g.ones)(Io.dims.slice(0,2)),l_],1)}}async _prepare_inputs_embeds({input_ids:tr,pixel_values:Io,inputs_embeds:eu,attention_mask:l_}){if(!tr&&!Io)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let $_,F_;return tr&&($_=await this.encode_text({input_ids:tr})),Io&&(F_=await this.encode_image({pixel_values:Io})),$_&&F_?{inputs_embeds:eu,attention_mask:l_}=this._merge_input_ids_with_image_features({inputs_embeds:$_,image_features:F_,input_ids:tr,attention_mask:l_}):eu=$_||F_,{inputs_embeds:eu,attention_mask:l_}}async forward({input_ids:tr,pixel_values:Io,attention_mask:eu,decoder_input_ids:l_,decoder_attention_mask:$_,encoder_outputs:F_,past_key_values:Q_,inputs_embeds:py,decoder_inputs_embeds:Gy}){if(py||({inputs_embeds:py,attention_mask:eu}=await this._prepare_inputs_embeds({input_ids:tr,pixel_values:Io,inputs_embeds:py,attention_mask:eu})),!F_){let{last_hidden_state:Ny}=await Ir(this,{inputs_embeds:py,attention_mask:eu});F_=Ny}if(!Gy){if(!l_)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");Gy=await this.encode_text({input_ids:l_})}return await Yo(this,{inputs_embeds:Gy,attention_mask:$_,encoder_attention_mask:eu,encoder_hidden_states:F_,past_key_values:Q_},!0)}}class p0 extends Jr{}class y0 extends p0{}class v0 extends p0{static async from_pretrained(tr,Io={}){return Io.model_file_name??="text_model",super.from_pretrained(tr,Io)}}class B0 extends p0{static async from_pretrained(tr,Io={}){return Io.model_file_name??="text_model",super.from_pretrained(tr,Io)}}class e1 extends p0{static async from_pretrained(tr,Io={}){return Io.model_file_name??="vision_model",super.from_pretrained(tr,Io)}}class h_ extends p0{static async from_pretrained(tr,Io={}){return Io.model_file_name??="vision_model",super.from_pretrained(tr,Io)}}class $y extends Jr{}class c0 extends $y{}class iw extends $y{static async from_pretrained(tr,Io={}){return Io.model_file_name??="text_model",super.from_pretrained(tr,Io)}}class Iw extends p0{static async from_pretrained(tr,Io={}){return Io.model_file_name??="vision_model",super.from_pretrained(tr,Io)}}class _1 extends Jr{}class j0 extends _1{}class Dw extends Jr{}class Nw extends Dw{}class M1 extends Dw{}class Uw extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class P1 extends Uw{}class sw extends Uw{}class Ww extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class m1 extends Ww{}class Mw extends Ww{}class t1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class g1 extends t1{}class r1 extends t1{}class n1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class k1 extends n1{}class Q1 extends n1{}class o1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class y1 extends o1{}class cw extends o1{}class i1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Vw extends i1{}class S1 extends i1{}class Q0 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Z1 extends Q0{}class O1 extends Q0{}class b1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class J1 extends b1{}class A1 extends b1{}class s1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class C1 extends s1{}class I1 extends s1{}class D1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class ev extends D1{}class dw extends D1{}class Kw extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class mw extends Kw{}class m0 extends Kw{}class Gw extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Z0 extends Gw{}class tv extends Gw{}class a1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class F1 extends a1{}class Pw extends a1{}class l1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class kw extends l1{}class gw extends l1{}class w1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class lt extends w1{}class wt extends w1{}class zt extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class Dr extends zt{}class Zr extends zt{}class vo extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class qo extends vo{}class ga extends vo{}class fu extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class uu extends fu{}class Su extends fu{}class tu extends Jr{}class Ou extends tu{}class hu extends tu{async _call(tr){return new My(await super._call(tr))}}class yu extends Jr{}class Au extends yu{}class bu extends yu{async _call(tr){return new My(await super._call(tr))}}class Gu extends Jr{}class t_ extends Gu{}class o_ extends Jr{}class __ extends o_{}class p_ extends o_{async _call(tr){return new My(await super._call(tr))}}class V_ extends Jr{}class I_ extends V_{}class W_ extends Jr{}class K_ extends W_{}class A_ extends W_{async _call(tr){return new My(await super._call(tr))}}class my extends Jr{}class vy extends my{async _call(tr){return new uE(await super._call(tr))}}class Dy extends Jr{}class Fy extends Dy{}class aw extends Dy{async _call(tr){return new My(await super._call(tr))}}class Oy extends Jr{}class C0 extends Oy{}class I0 extends Oy{async _call(tr){return new My(await super._call(tr))}}class Hw extends Jr{}class x0 extends Hw{}class Sw extends Hw{}class Fw extends Jr{}class wx extends Fw{}class vx extends Fw{}class Tv extends Jr{}class xx extends Tv{}class Tx extends Tv{async _call(tr){return new My(await super._call(tr))}}class rv extends Jr{}class Ex extends rv{}class $x extends rv{async _call(tr){return new $v(await super._call(tr))}}class Ev extends rv{async _call(tr){return new Mx(await super._call(tr))}}class $v extends Lo{constructor({logits:tr,pred_boxes:Io}){super(),this.logits=tr,this.pred_boxes=Io}}class Mx extends Lo{constructor({logits:tr,pred_boxes:Io,pred_masks:eu}){super(),this.logits=tr,this.pred_boxes=Io,this.pred_masks=eu}}class Mv extends Jr{}class Px extends Mv{}class kx extends Mv{async _call(tr){return new Sx(await super._call(tr))}}class Sx extends Lo{constructor({logits:tr,pred_boxes:Io}){super(),this.logits=tr,this.pred_boxes=Io}}class Pv extends Jr{}class kv extends Pv{}class Ox extends Pv{async _call(tr){return new Sv(await super._call(tr))}}class Sv extends $v{}class nv extends Jr{}class Ax extends nv{}class Cx extends nv{async _call(tr){return new My(await super._call(tr))}}class Ov extends Jr{}class Ix extends Ov{}class Dx extends Ov{async _call(tr){return new My(await super._call(tr))}}class Av extends Jr{}class Cv extends Av{}class Fx extends Av{async _call(tr){return new My(await super._call(tr))}}class Iv extends Jr{}class Rx extends Iv{}class wE extends Iv{async _call(tr){return new My(await super._call(tr))}}class Dv extends Jr{}class Lx extends Dv{}class bw extends Dv{}class Fv extends Jr{}class Bx extends Fv{}class jx extends Fv{}class zx extends Jr{}class Nx extends zx{}class ov extends Jr{}class Ux extends ov{}class Wx extends ov{}class Vx extends ov{}class Rv extends Jr{}class vE extends Rv{}class Kx extends Rv{}class Lv extends Jr{}class Gx extends Lv{}class Hx extends Lv{}class qx extends Jr{}class Xx extends qx{}class Yx extends Jr{}class qw extends Yx{}class Xw extends Yx{async _call(tr){return new My(await super._call(tr))}}class Rw extends Jr{}class Bv extends Rw{}class Yw extends Rw{async _call(tr){return new My(await super._call(tr))}}class W0 extends Jr{}class jv extends W0{}class iv extends W0{async _call(tr){return new My(await super._call(tr))}}class sv extends Jr{}class Qx extends sv{}class Zx extends sv{async _call(tr){return new Jx(await super._call(tr))}}class Jx extends Lo{constructor({logits:tr,pred_boxes:Io}){super(),this.logits=tr,this.pred_boxes=Io}}class av extends Jr{}class zv extends av{async get_image_embeddings({pixel_values:tr}){return await Ir(this,{pixel_values:tr})}async forward(tr){if((!tr.image_embeddings||!tr.image_positional_embeddings)&&(tr={...tr,...await this.get_image_embeddings(tr)}),!tr.input_labels&&tr.input_points){const eu=tr.input_points.dims.slice(0,-1),l_=eu.reduce(($_,F_)=>$_*F_,1);tr.input_labels=new g.Tensor("int64",new BigInt64Array(l_).fill(1n),eu)}const Io={image_embeddings:tr.image_embeddings,image_positional_embeddings:tr.image_positional_embeddings};return tr.input_points&&(Io.input_points=tr.input_points),tr.input_labels&&(Io.input_labels=tr.input_labels),tr.input_boxes&&(Io.input_boxes=tr.input_boxes),await wo(this.sessions.prompt_encoder_mask_decoder,Io)}async _call(tr){return new eT(await super._call(tr))}}class eT extends Lo{constructor({iou_scores:tr,pred_masks:Io}){super(),this.iou_scores=tr,this.pred_masks=Io}}class R1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class tT extends R1{}class Nv extends R1{}class L1 extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class rT extends L1{}class nT extends L1{}class u1 extends Jr{}class oT extends u1{}class Uv extends u1{async _call(tr){return new Qw(await super._call(tr))}}class B1 extends u1{async _call(tr){return new My(await super._call(tr))}}class iT extends u1{async _call(tr){return new D0(await super._call(tr))}}class lv extends Jr{}class sT extends lv{}class aT extends lv{async _call(tr){return new D0(await super._call(tr))}}class lT extends Jr{}class xE extends lT{}class uv extends Jr{}class uT extends uv{}class TE extends uv{async _call(tr){return new Qw(await super._call(tr))}}class Wv extends uv{async _call(tr){return new My(await super._call(tr))}}class j1 extends Jr{}class cT extends j1{}class dT extends j1{async _call(tr){return new Qw(await super._call(tr))}}class pT extends j1{async _call(tr){return new My(await super._call(tr))}}class cv extends j1{async _call(tr){return new D0(await super._call(tr))}}class dv extends Jr{}class pv extends dv{}class Vv extends dv{async _call(tr){return new Qw(await super._call(tr))}}class Kv extends dv{async _call(tr){return new My(await super._call(tr))}}class EE extends Jr{}class fT extends u1{}class Gv extends u1{async _call(tr){return new Qw(await super._call(tr))}}class $E extends u1{async _call(tr){return new My(await super._call(tr))}}class v1 extends Jr{}class hT extends v1{}class ME extends v1{async _call(tr){return new Qw(await super._call(tr))}}class _T extends v1{async _call(tr){return new My(await super._call(tr))}}class Hv extends v1{async _call(tr){return new fx(await super._call(tr))}}class PE extends v1{async _call(tr){return new D0(await super._call(tr))}}class fv extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class kE extends fv{}class mT extends fv{}class qv extends fv{async generate_speech(tr,Io,{threshold:eu=.5,minlenratio:l_=0,maxlenratio:$_=20,vocoder:F_=null}={}){const Q_={input_ids:tr},{encoder_outputs:py,encoder_attention_mask:Gy}=await Ir(this,Q_),o0=py.dims[1]/this.config.reduction_factor,l0=Math.floor(o0*$_),Ny=Math.floor(o0*l_),xy=this.config.num_mel_bins;let f0=[],Py=null,Hy=null,T0=0;for(;;){++T0;const ww=In(!!Hy);let pw;Hy?pw=Hy.output_sequence_out:pw=new g.Tensor("float32",new Float32Array(xy),[1,1,xy]);let E0={use_cache_branch:ww,output_sequence:pw,encoder_attention_mask:Gy,speaker_embeddings:Io,encoder_hidden_states:py};this.addPastKeyValues(E0,Py),Hy=await wo(this.sessions.decoder_model_merged,E0),Py=this.getPastKeyValues(Hy,Py);const{prob:fw,spectrum:mv}=Hy;if(f0.push(mv),T0>=Ny&&(Array.from(fw.data).filter(x1=>x1>=eu).length>0||T0>=l0))break}const z0=(0,g.cat)(f0),{waveform:Zw}=await wo(F_.sessions.model,{spectrogram:z0});return{spectrogram:z0,waveform:Zw}}}class gT extends Jr{main_input_name="spectrogram"}class yT extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class bT extends yT{}class Xv extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class wT extends Xv{}class vT extends Xv{}class xT extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class TT extends xT{}class ET extends xT{}class Yv extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class SE extends Yv{}class $T extends Yv{}class hv extends Jr{}class MT extends hv{}class PT extends hv{static async from_pretrained(tr,Io={}){return Io.model_file_name??="text_model",super.from_pretrained(tr,Io)}}class kT extends hv{static async from_pretrained(tr,Io={}){return Io.model_file_name??="audio_model",super.from_pretrained(tr,Io)}}class OE extends Jr{}class z1 extends OE{async _call(tr){return new hx(await super._call(tr))}}class c1 extends Jr{}class ST extends c1{}class OT extends c1{}class AT extends c1{}class Qv extends Jr{constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}}class CT extends Qv{}class Zv extends Qv{}class Jv extends Jr{}class IT extends Jv{}class DT extends Jv{async _call(tr){return new My(await super._call(tr))}}class FT extends Jr{}class AE extends FT{}class RT extends FT{}class ex extends Jr{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];constructor(tr,Io,eu){super(tr,Io),this.generation_config=eu}_apply_and_filter_by_delay_pattern_mask(tr){const[Io,eu]=tr.dims,l_=this.config.decoder.num_codebooks,$_=eu-l_;let F_=0;for(let Gy=0;Gy<tr.size;++Gy){if(tr.data[Gy]===this.config.decoder.pad_token_id)continue;const o0=Gy%eu,l0=Math.floor(Gy/eu)%l_,Ny=o0-l0;Ny>0&&Ny<=$_&&(tr.data[F_++]=tr.data[Gy])}const Q_=Math.floor(Io/l_),py=F_/(Q_*l_);return new g.Tensor(tr.type,tr.data.slice(0,F_),[Q_,l_,py])}prepare_inputs_for_generation(tr,Io,eu){let l_=structuredClone(tr);for(let F_=0;F_<l_.length;++F_)for(let Q_=0;Q_<l_[F_].length;++Q_)F_%this.config.decoder.num_codebooks>=Q_&&(l_[F_][Q_]=BigInt(this.config.decoder.pad_token_id));return eu.guidance_scale!==null&&eu.guidance_scale>1&&(l_=l_.concat(l_)),super.prepare_inputs_for_generation(l_,Io,eu)}async generate(tr){const Io=await super.generate(tr),eu=this._apply_and_filter_by_delay_pattern_mask(Io).unsqueeze_(0),{audio_values:l_}=await wo(this.sessions.encodec_decode,{audio_codes:eu});return l_}}class tx extends Jr{}class LT extends tx{}class CE extends tx{async _call(tr){return new My(await super._call(tr))}}class rx extends Jr{}class BT extends rx{}class IE extends rx{async _call(tr){return new My(await super._call(tr))}}class nx extends Jr{}class jT extends nx{}class zT extends nx{async _call(tr){return new My(await super._call(tr))}}class ox extends Jr{}class DE extends ox{}class NT extends ox{async _call(tr){return new My(await super._call(tr))}}class UT extends Jr{}class WT extends UT{}class a0{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(tr,{progress_callback:Io=null,config:eu=null,cache_dir:l_=null,local_files_only:$_=!1,revision:F_="main",model_file_name:Q_=null,subfolder:py="onnx",device:Gy=null,dtype:o0=null,use_external_data_format:l0=null,session_options:Ny={}}={}){const xy={progress_callback:Io,config:eu,cache_dir:l_,local_files_only:$_,revision:F_,model_file_name:Q_,subfolder:py,device:Gy,dtype:o0,use_external_data_format:l0,session_options:Ny};if(xy.config=await s.AutoConfig.from_pretrained(tr,xy),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(const f0 of this.MODEL_CLASS_MAPPINGS){const Py=f0.get(xy.config.model_type);if(Py)return await Py[1].from_pretrained(tr,xy)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${xy.config.model_type}", attempting to construct from base class.`),await Jr.from_pretrained(tr,xy);throw Error(`Unsupported model type: ${xy.config.model_type}`)}}const O2=new Map([["bert",["BertModel",du]],["nomic_bert",["NomicBertModel",vu]],["roformer",["RoFormerModel",e_]],["electra",["ElectraModel",qs]],["esm",["EsmModel",iy]],["convbert",["ConvBertModel",js]],["camembert",["CamembertModel",Z_]],["deberta",["DebertaModel",g_]],["deberta-v2",["DebertaV2Model",y_]],["mpnet",["MPNetModel",N0]],["albert",["AlbertModel",U0]],["distilbert",["DistilBertModel",q_]],["roberta",["RobertaModel",Ey]],["xlm",["XLMModel",_0]],["xlm-roberta",["XLMRobertaModel",zy]],["clap",["ClapModel",MT]],["clip",["CLIPModel",y0]],["clipseg",["CLIPSegModel",Nw]],["chinese_clip",["ChineseCLIPModel",j0]],["siglip",["SiglipModel",c0]],["mobilebert",["MobileBertModel",Sy]],["squeezebert",["SqueezeBertModel",Cw]],["wav2vec2",["Wav2Vec2Model",oT]],["wav2vec2-bert",["Wav2Vec2BertModel",pv]],["unispeech",["UniSpeechModel",uT]],["unispeech-sat",["UniSpeechSatModel",cT]],["hubert",["HubertModel",fT]],["wavlm",["WavLMModel",hT]],["audio-spectrogram-transformer",["ASTModel",X_]],["vits",["VitsModel",z1]],["pyannote",["PyAnnoteModel",sT]],["wespeaker-resnet",["WeSpeakerResNetModel",xE]],["detr",["DetrModel",Ex]],["rt_detr",["RTDetrModel",Px]],["table-transformer",["TableTransformerModel",kv]],["vit",["ViTModel",Ou]],["pvt",["PvtModel",Au]],["vit_msn",["ViTMSNModel",__]],["vit_mae",["ViTMAEModel",t_]],["groupvit",["GroupViTModel",I_]],["fastvit",["FastViTModel",K_]],["mobilevit",["MobileViTModel",Fy]],["mobilevitv2",["MobileViTV2Model",C0]],["owlvit",["OwlViTModel",x0]],["owlv2",["Owlv2Model",wx]],["beit",["BeitModel",xx]],["deit",["DeiTModel",Ax]],["hiera",["HieraModel",Ix]],["convnext",["ConvNextModel",qw]],["convnextv2",["ConvNextV2Model",Bv]],["dinov2",["Dinov2Model",jv]],["resnet",["ResNetModel",Cv]],["swin",["SwinModel",Rx]],["swin2sr",["Swin2SRModel",Lx]],["donut-swin",["DonutSwinModel",Xx]],["yolos",["YolosModel",Qx]],["dpt",["DPTModel",Bx]],["glpn",["GLPNModel",Gx]],["hifigan",["SpeechT5HifiGan",gT]],["efficientnet",["EfficientNetModel",IT]],["decision_transformer",["DecisionTransformerModel",WT]],["mobilenet_v1",["MobileNetV1Model",LT]],["mobilenet_v2",["MobileNetV2Model",BT]],["mobilenet_v3",["MobileNetV3Model",jT]],["mobilenet_v4",["MobileNetV4Model",DE]],["maskformer",["MaskFormerModel",vE]]]),FE=new Map([["t5",["T5Model",Tw]],["longt5",["LongT5Model",Yy]],["mt5",["MT5Model",ow]],["bart",["BartModel",xu]],["mbart",["MBartModel",ba]],["marian",["MarianModel",tT]],["whisper",["WhisperModel",Xr]],["m2m_100",["M2M100Model",rT]],["blenderbot",["BlenderbotModel",z_]],["blenderbot-small",["BlenderbotSmallModel",ay]]]),RE=new Map([["bloom",["BloomModel",Dr]],["jais",["JAISModel",m1]],["gpt2",["GPT2Model",P1]],["gptj",["GPTJModel",y1]],["gpt_bigcode",["GPTBigCodeModel",Vw]],["gpt_neo",["GPTNeoModel",g1]],["gpt_neox",["GPTNeoXModel",k1]],["codegen",["CodeGenModel",Z1]],["llama",["LlamaModel",J1]],["cohere",["CohereModel",C1]],["gemma",["GemmaModel",ev]],["gemma2",["Gemma2Model",mw]],["openelm",["OpenELMModel",Z0]],["qwen2",["Qwen2Model",F1]],["phi",["PhiModel",kw]],["phi3",["Phi3Model",lt]],["mpt",["MptModel",qo]],["opt",["OPTModel",uu]],["mistral",["MistralModel",wT]],["starcoder2",["Starcoder2Model",TT]],["falcon",["FalconModel",SE]],["stablelm",["StableLmModel",CT]]]),ix=new Map([["speecht5",["SpeechT5ForSpeechToText",mT]],["whisper",["WhisperForConditionalGeneration",Xo]]]),VT=new Map([["speecht5",["SpeechT5ForTextToSpeech",qv]]]),LE=new Map([["vits",["VitsModel",z1]],["musicgen",["MusicgenForConditionalGeneration",ex]]]),KT=new Map([["bert",["BertForSequenceClassification",r_]],["roformer",["RoFormerForSequenceClassification",Qs]],["electra",["ElectraForSequenceClassification",i_]],["esm",["EsmForSequenceClassification",Zy]],["convbert",["ConvBertForSequenceClassification",rn]],["camembert",["CamembertForSequenceClassification",ey]],["deberta",["DebertaForSequenceClassification",Xs]],["deberta-v2",["DebertaV2ForSequenceClassification",S_]],["mpnet",["MPNetForSequenceClassification",uw]],["albert",["AlbertForSequenceClassification",_w]],["distilbert",["DistilBertForSequenceClassification",H_]],["roberta",["RobertaForSequenceClassification",h0]],["xlm",["XLMForSequenceClassification",J_]],["xlm-roberta",["XLMRobertaForSequenceClassification",_y]],["bart",["BartForSequenceClassification",Po]],["mbart",["MBartForSequenceClassification",a_]],["mobilebert",["MobileBertForSequenceClassification",n0]],["squeezebert",["SqueezeBertForSequenceClassification",F0]]]),GT=new Map([["bert",["BertForTokenClassification",d_]],["roformer",["RoFormerForTokenClassification",_a]],["electra",["ElectraForTokenClassification",$u]],["esm",["EsmForTokenClassification",hy]],["convbert",["ConvBertForTokenClassification",Kr]],["camembert",["CamembertForTokenClassification",yy]],["deberta",["DebertaForTokenClassification",_d]],["deberta-v2",["DebertaV2ForTokenClassification",B_]],["mpnet",["MPNetForTokenClassification",i0]],["distilbert",["DistilBertForTokenClassification",j_]],["roberta",["RobertaForTokenClassification",Uu]],["xlm",["XLMForTokenClassification",k0]],["xlm-roberta",["XLMRobertaForTokenClassification",Ky]]]),sx=new Map([["t5",["T5ForConditionalGeneration",Ew]],["longt5",["LongT5ForConditionalGeneration",rw]],["mt5",["MT5ForConditionalGeneration",Jy]],["bart",["BartForConditionalGeneration",wr]],["mbart",["MBartForConditionalGeneration",Iu]],["marian",["MarianMTModel",Nv]],["m2m_100",["M2M100ForConditionalGeneration",nT]],["blenderbot",["BlenderbotForConditionalGeneration",C_]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",wy]]]),ax=new Map([["bloom",["BloomForCausalLM",Zr]],["gpt2",["GPT2LMHeadModel",sw]],["jais",["JAISLMHeadModel",Mw]],["gptj",["GPTJForCausalLM",cw]],["gpt_bigcode",["GPTBigCodeForCausalLM",S1]],["gpt_neo",["GPTNeoForCausalLM",r1]],["gpt_neox",["GPTNeoXForCausalLM",Q1]],["codegen",["CodeGenForCausalLM",O1]],["llama",["LlamaForCausalLM",A1]],["cohere",["CohereForCausalLM",I1]],["gemma",["GemmaForCausalLM",dw]],["gemma2",["Gemma2ForCausalLM",m0]],["openelm",["OpenELMForCausalLM",tv]],["qwen2",["Qwen2ForCausalLM",Pw]],["phi",["PhiForCausalLM",gw]],["phi3",["Phi3ForCausalLM",wt]],["mpt",["MptForCausalLM",ga]],["opt",["OPTForCausalLM",Su]],["mbart",["MBartForCausalLM",D_]],["mistral",["MistralForCausalLM",vT]],["starcoder2",["Starcoder2ForCausalLM",ET]],["falcon",["FalconForCausalLM",$T]],["trocr",["TrOCRForCausalLM",bT]],["stablelm",["StableLmForCausalLM",Zv]]]),BE=new Map([["bert",["BertForMaskedLM",wu]],["roformer",["RoFormerForMaskedLM",ar]],["electra",["ElectraForMaskedLM",au]],["esm",["EsmForMaskedLM",Ry]],["convbert",["ConvBertForMaskedLM",Lr]],["camembert",["CamembertForMaskedLM",Ty]],["deberta",["DebertaForMaskedLM",jo]],["deberta-v2",["DebertaV2ForMaskedLM",k_]],["mpnet",["MPNetForMaskedLM",xw]],["albert",["AlbertForMaskedLM",ly]],["distilbert",["DistilBertForMaskedLM",T_]],["roberta",["RobertaForMaskedLM",L0]],["xlm",["XLMWithLMHeadModel",ry]],["xlm-roberta",["XLMRobertaForMaskedLM",U_]],["mobilebert",["MobileBertForMaskedLM",K0]],["squeezebert",["SqueezeBertForMaskedLM",P0]]]),J0=new Map([["bert",["BertForQuestionAnswering",na]],["roformer",["RoFormerForQuestionAnswering",$o]],["electra",["ElectraForQuestionAnswering",m_]],["convbert",["ConvBertForQuestionAnswering",Oo]],["camembert",["CamembertForQuestionAnswering",O_]],["deberta",["DebertaForQuestionAnswering",w_]],["deberta-v2",["DebertaV2ForQuestionAnswering",P_]],["mpnet",["MPNetForQuestionAnswering",q0]],["albert",["AlbertForQuestionAnswering",tw]],["distilbert",["DistilBertForQuestionAnswering",pu]],["roberta",["RobertaForQuestionAnswering",g0]],["xlm",["XLMForQuestionAnswering",e0]],["xlm-roberta",["XLMRobertaForQuestionAnswering",s0]],["mobilebert",["MobileBertForQuestionAnswering",A0]],["squeezebert",["SqueezeBertForQuestionAnswering",X0]]]),lx=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",ru]]]),jE=new Map([["llava",["LlavaForConditionalGeneration",Nu]],["moondream1",["Moondream1ForConditionalGeneration",n_]],["florence2",["Florence2ForConditionalGeneration",Qy]]]),HT=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",ru]]]),qT=new Map([["vit",["ViTForImageClassification",hu]],["pvt",["PvtForImageClassification",bu]],["vit_msn",["ViTMSNForImageClassification",p_]],["fastvit",["FastViTForImageClassification",A_]],["mobilevit",["MobileViTForImageClassification",aw]],["mobilevitv2",["MobileViTV2ForImageClassification",I0]],["beit",["BeitForImageClassification",Tx]],["deit",["DeiTForImageClassification",Cx]],["hiera",["HieraForImageClassification",Dx]],["convnext",["ConvNextForImageClassification",Xw]],["convnextv2",["ConvNextV2ForImageClassification",Yw]],["dinov2",["Dinov2ForImageClassification",iv]],["resnet",["ResNetForImageClassification",Fx]],["swin",["SwinForImageClassification",wE]],["segformer",["SegformerForImageClassification",OT]],["efficientnet",["EfficientNetForImageClassification",DT]],["mobilenet_v1",["MobileNetV1ForImageClassification",CE]],["mobilenet_v2",["MobileNetV2ForImageClassification",IE]],["mobilenet_v3",["MobileNetV3ForImageClassification",zT]],["mobilenet_v4",["MobileNetV4ForImageClassification",NT]]]),N1=new Map([["detr",["DetrForObjectDetection",$x]],["rt_detr",["RTDetrForObjectDetection",kx]],["table-transformer",["TableTransformerForObjectDetection",Ox]],["yolos",["YolosForObjectDetection",Zx]]]),XT=new Map([["owlvit",["OwlViTForObjectDetection",Sw]],["owlv2",["Owlv2ForObjectDetection",vx]]]),YT=new Map([["detr",["DetrForSegmentation",Ev]],["clipseg",["CLIPSegForImageSegmentation",M1]]]),ux=new Map([["segformer",["SegformerForSemanticSegmentation",AT]],["sapiens",["SapiensForSemanticSegmentation",Ux]]]),QT=new Map([["detr",["DetrForSegmentation",Ev]],["maskformer",["MaskFormerForInstanceSegmentation",Kx]]]),ZT=new Map([["sam",["SamModel",zv]]]),cx=new Map([["wav2vec2",["Wav2Vec2ForCTC",Uv]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Vv]],["unispeech",["UniSpeechForCTC",TE]],["unispeech-sat",["UniSpeechSatForCTC",dT]],["wavlm",["WavLMForCTC",ME]],["hubert",["HubertForCTC",Gv]]]),JT=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",B1]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Kv]],["unispeech",["UniSpeechForSequenceClassification",Wv]],["unispeech-sat",["UniSpeechSatForSequenceClassification",pT]],["wavlm",["WavLMForSequenceClassification",_T]],["hubert",["HubertForSequenceClassification",$E]],["audio-spectrogram-transformer",["ASTForAudioClassification",$w]]]),eE=new Map([["wavlm",["WavLMForXVector",Hv]]]),tE=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",cv]],["wavlm",["WavLMForAudioFrameClassification",PE]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",iT]],["pyannote",["PyAnnoteForAudioFrameClassification",aT]]]),dx=new Map([["vitmatte",["VitMatteForImageMatting",vy]]]),rE=new Map([["swin2sr",["Swin2SRForImageSuperResolution",bw]]]),nE=new Map([["dpt",["DPTForDepthEstimation",jx]],["depth_anything",["DepthAnythingForDepthEstimation",Nx]],["glpn",["GLPNForDepthEstimation",Hx]],["sapiens",["SapiensForDepthEstimation",Wx]]]),px=new Map([["sapiens",["SapiensForNormalEstimation",Vx]]]),oE=new Map([["clip",["CLIPVisionModelWithProjection",h_]],["siglip",["SiglipVisionModel",Iw]]]),zE=[[O2,xt.EncoderOnly],[FE,xt.EncoderDecoder],[RE,xt.DecoderOnly],[KT,xt.EncoderOnly],[GT,xt.EncoderOnly],[sx,xt.Seq2Seq],[ix,xt.Seq2Seq],[ax,xt.DecoderOnly],[BE,xt.EncoderOnly],[J0,xt.EncoderOnly],[lx,xt.Vision2Seq],[jE,xt.ImageTextToText],[qT,xt.EncoderOnly],[YT,xt.EncoderOnly],[QT,xt.EncoderOnly],[ux,xt.EncoderOnly],[dx,xt.EncoderOnly],[rE,xt.EncoderOnly],[nE,xt.EncoderOnly],[px,xt.EncoderOnly],[N1,xt.EncoderOnly],[XT,xt.EncoderOnly],[ZT,xt.MaskGeneration],[cx,xt.EncoderOnly],[JT,xt.EncoderOnly],[VT,xt.Seq2Seq],[LE,xt.EncoderOnly],[eE,xt.EncoderOnly],[tE,xt.EncoderOnly],[oE,xt.EncoderOnly]];for(const[jr,tr]of zE)for(const[Io,eu]of jr.values())Dt.set(Io,tr),Zt.set(eu,Io),Qt.set(Io,eu);const NE=[["MusicgenForConditionalGeneration",ex,xt.Musicgen],["CLIPTextModelWithProjection",B0,xt.EncoderOnly],["SiglipTextModel",iw,xt.EncoderOnly],["ClapTextModelWithProjection",PT,xt.EncoderOnly],["ClapAudioModelWithProjection",kT,xt.EncoderOnly]];for(const[jr,tr,Io]of NE)Dt.set(jr,Io),Zt.set(tr,jr),Qt.set(jr,tr);class UE extends a0{static MODEL_CLASS_MAPPINGS=zE.map(tr=>tr[0]);static BASE_IF_FAIL=!0}class WE extends a0{static MODEL_CLASS_MAPPINGS=[KT]}class VE extends a0{static MODEL_CLASS_MAPPINGS=[GT]}class A2 extends a0{static MODEL_CLASS_MAPPINGS=[sx]}class KE extends a0{static MODEL_CLASS_MAPPINGS=[ix]}class GE extends a0{static MODEL_CLASS_MAPPINGS=[VT]}class HE extends a0{static MODEL_CLASS_MAPPINGS=[LE]}class C2 extends a0{static MODEL_CLASS_MAPPINGS=[ax]}class qE extends a0{static MODEL_CLASS_MAPPINGS=[BE]}class XE extends a0{static MODEL_CLASS_MAPPINGS=[J0]}class YE extends a0{static MODEL_CLASS_MAPPINGS=[lx]}class QE extends a0{static MODEL_CLASS_MAPPINGS=[qT]}class I2 extends a0{static MODEL_CLASS_MAPPINGS=[YT]}class ZE extends a0{static MODEL_CLASS_MAPPINGS=[ux]}class JE extends a0{static MODEL_CLASS_MAPPINGS=[QT]}class e2 extends a0{static MODEL_CLASS_MAPPINGS=[N1]}class t2 extends a0{static MODEL_CLASS_MAPPINGS=[XT]}class r2 extends a0{static MODEL_CLASS_MAPPINGS=[ZT]}class n2 extends a0{static MODEL_CLASS_MAPPINGS=[cx]}class o2 extends a0{static MODEL_CLASS_MAPPINGS=[JT]}class i2 extends a0{static MODEL_CLASS_MAPPINGS=[eE]}class s2 extends a0{static MODEL_CLASS_MAPPINGS=[tE]}class D2 extends a0{static MODEL_CLASS_MAPPINGS=[HT]}class _v extends a0{static MODEL_CLASS_MAPPINGS=[dx]}class iE extends a0{static MODEL_CLASS_MAPPINGS=[rE]}class sE extends a0{static MODEL_CLASS_MAPPINGS=[nE]}class aE extends a0{static MODEL_CLASS_MAPPINGS=[px]}class lE extends a0{static MODEL_CLASS_MAPPINGS=[oE]}class a2 extends Lo{constructor({logits:tr,past_key_values:Io,encoder_outputs:eu,decoder_attentions:l_=null,cross_attentions:$_=null}){super(),this.logits=tr,this.past_key_values=Io,this.encoder_outputs=eu,this.decoder_attentions=l_,this.cross_attentions=$_}}class My extends Lo{constructor({logits:tr}){super(),this.logits=tr}}class fx extends Lo{constructor({logits:tr,embeddings:Io}){super(),this.logits=tr,this.embeddings=Io}}class D0 extends Lo{constructor({logits:tr}){super(),this.logits=tr}}class V0 extends Lo{constructor({logits:tr}){super(),this.logits=tr}}class H0 extends Lo{constructor({start_logits:tr,end_logits:Io}){super(),this.start_logits=tr,this.end_logits=Io}}class Qw extends Lo{constructor({logits:tr}){super(),this.logits=tr}}class l2 extends Lo{constructor({logits:tr,past_key_values:Io}){super(),this.logits=tr,this.past_key_values=Io}}class uE extends Lo{constructor({alphas:tr}){super(),this.alphas=tr}}class hx extends Lo{constructor({waveform:tr,spectrogram:Io}){super(),this.waveform=tr,this.spectrogram=Io}}},"./src/models/whisper/common_whisper.js":(e,o,i)=>{i.r(o),i.d(o,{WHISPER_LANGUAGE_MAPPING:()=>h,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>a,whisper_language_to_code:()=>d});const s=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],h=new Map(s),a=new Map([...s.map(([et,$])=>[$,et]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function d(et){et=et.toLowerCase();let $=a.get(et);if($===void 0)if(h.has(et))$=et;else{const b=et.length===2?h.keys():h.values();throw new Error(`Language "${et}" is not supported. Must be one of: ${JSON.stringify(b)}`)}return $}},"./src/models/whisper/generation_whisper.js":(e,o,i)=>{i.r(o),i.d(o,{WhisperGenerationConfig:()=>h});var s=i("./src/generation/configuration_utils.js");class h extends s.GenerationConfig{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}},"./src/ops/registry.js":(e,o,i)=>{i.r(o),i.d(o,{TensorOpRegistry:()=>d});var s=i("./src/backends/onnx.js"),h=i("./src/utils/tensor.js");const a=async(et,$,c)=>{const b=await(0,s.createInferenceSession)(new Uint8Array(et),$);return async g=>{const nt=Object.fromEntries(Object.entries(g).map(([Ot,At])=>[Ot,At.ort_tensor])),at=await b.run(nt);return Array.isArray(c)?c.map(Ot=>new h.Tensor(at[Ot])):new h.Tensor(at[c])}};class d{static session_options={};static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=a([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=a([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=a([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=a([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=a([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=a([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}}},"./src/pipelines.js":(e,o,i)=>{i.r(o),i.d(o,{AudioClassificationPipeline:()=>In,AutomaticSpeechRecognitionPipeline:()=>Ir,DepthEstimationPipeline:()=>_u,DocumentQuestionAnsweringPipeline:()=>Jr,FeatureExtractionPipeline:()=>Do,FillMaskPipeline:()=>Dt,ImageClassificationPipeline:()=>Bu,ImageFeatureExtractionPipeline:()=>Js,ImageSegmentationPipeline:()=>Ho,ImageToImagePipeline:()=>Du,ImageToTextPipeline:()=>Yo,ObjectDetectionPipeline:()=>To,Pipeline:()=>At,QuestionAnsweringPipeline:()=>xt,SummarizationPipeline:()=>Zt,Text2TextGenerationPipeline:()=>Qt,TextClassificationPipeline:()=>Ct,TextGenerationPipeline:()=>Er,TextToAudioPipeline:()=>Lo,TokenClassificationPipeline:()=>St,TranslationPipeline:()=>gr,ZeroShotAudioClassificationPipeline:()=>Wo,ZeroShotClassificationPipeline:()=>wo,ZeroShotImageClassificationPipeline:()=>tn,ZeroShotObjectDetectionPipeline:()=>Qo,pipeline:()=>r_});var s=i("./src/tokenizers.js"),h=i("./src/models.js"),a=i("./src/processors.js"),d=i("./src/utils/generic.js"),et=i("./src/utils/core.js"),$=i("./src/utils/maths.js"),c=i("./src/utils/audio.js"),b=i("./src/utils/tensor.js"),g=i("./src/utils/image.js");async function nt(na){return Array.isArray(na)||(na=[na]),await Promise.all(na.map(Ko=>g.RawImage.read(Ko)))}async function at(na,Ko){return Array.isArray(na)||(na=[na]),await Promise.all(na.map(vu=>typeof vu=="string"||vu instanceof URL?(0,c.read_audio)(vu,Ko):vu instanceof Float64Array?new Float32Array(vu):vu))}function Ot(na,Ko){Ko&&(na=na.map(Qs=>Qs|0));const[vu,Cu,e_,ar]=na;return{xmin:vu,ymin:Cu,xmax:e_,ymax:ar}}class At extends d.Callable{constructor({task:Ko,model:vu,tokenizer:Cu=null,processor:e_=null}){super(),this.task=Ko,this.model=vu,this.tokenizer=Cu,this.processor=e_}async dispose(){await this.model.dispose()}}class Ct extends At{constructor(Ko){super(Ko)}async _call(Ko,{top_k:vu=1}={}){const Cu=this.tokenizer(Ko,{padding:!0,truncation:!0}),e_=await this.model(Cu),ar=this.model.config.problem_type==="multi_label_classification"?$o=>$o.sigmoid():$o=>new b.Tensor("float32",(0,$.softmax)($o.data),$o.dims),Qs=this.model.config.id2label,_a=[];for(const $o of e_.logits){const Eo=ar($o),js=await(0,b.topk)(Eo,vu),Lr=js[0].tolist(),Kr=js[1].tolist().map((Oo,Mo)=>({label:Qs?Qs[Oo]:`LABEL_${Oo}`,score:Lr[Mo]}));vu===1?_a.push(...Kr):_a.push(Kr)}return Array.isArray(Ko)||vu===1?_a:_a[0]}}class St extends At{constructor(Ko){super(Ko)}async _call(Ko,{ignore_labels:vu=["O"]}={}){const Cu=Array.isArray(Ko),e_=this.tokenizer(Cu?Ko:[Ko],{padding:!0,truncation:!0}),Qs=(await this.model(e_)).logits,_a=this.model.config.id2label,$o=[];for(let Eo=0;Eo<Qs.dims[0];++Eo){const js=e_.input_ids[Eo],Lr=Qs[Eo],rn=[];for(let Kr=0;Kr<Lr.dims[0];++Kr){const Oo=Lr[Kr],Mo=(0,$.max)(Oo.data)[1],qs=_a?_a[Mo]:`LABEL_${Mo}`;if(vu.includes(qs))continue;const au=this.tokenizer.decode([js[Kr].item()],{skip_special_tokens:!0});if(au==="")continue;const i_=(0,$.softmax)(Oo.data);rn.push({entity:qs,score:i_[Mo],index:Kr,word:au})}$o.push(rn)}return Cu?$o:$o[0]}}class xt extends At{constructor(Ko){super(Ko)}async _call(Ko,vu,{top_k:Cu=1}={}){const e_=this.tokenizer(Ko,{text_pair:vu,padding:!0,truncation:!0}),{start_logits:ar,end_logits:Qs}=await this.model(e_),_a=e_.input_ids.tolist(),$o=e_.attention_mask.tolist(),Eo=this.tokenizer.all_special_ids,js=[];for(let Lr=0;Lr<ar.dims[0];++Lr){const rn=_a[Lr],Kr=rn.findIndex($u=>$u==this.tokenizer.sep_token_id);$o[Lr].map(($u,m_)=>$u==1&&(m_===0||m_>Kr&&Eo.findIndex(L_=>L_==rn[m_])===-1));const Oo=ar[Lr].tolist(),Mo=Qs[Lr].tolist();for(let $u=1;$u<Oo.length;++$u)($o[Lr]==0||$u<=Kr||Eo.findIndex(m_=>m_==rn[$u])!==-1)&&(Oo[$u]=-1/0,Mo[$u]=-1/0);const qs=(0,$.softmax)(Oo).map(($u,m_)=>[$u,m_]),au=(0,$.softmax)(Mo).map(($u,m_)=>[$u,m_]);qs[0][0]=0,au[0][0]=0;const i_=(0,et.product)(qs,au).filter($u=>$u[0][1]<=$u[1][1]).map($u=>[$u[0][1],$u[1][1],$u[0][0]*$u[1][0]]).sort(($u,m_)=>m_[2]-$u[2]);for(let $u=0;$u<Math.min(i_.length,Cu);++$u){const[m_,L_,Z_]=i_[$u],Ty=rn.slice(m_,L_+1),ey=this.tokenizer.decode(Ty,{skip_special_tokens:!0});js.push({answer:ey,score:Z_})}}return Cu===1?js[0]:js}}class Dt extends At{constructor(Ko){super(Ko)}async _call(Ko,{top_k:vu=5}={}){const Cu=this.tokenizer(Ko,{padding:!0,truncation:!0}),{logits:e_}=await this.model(Cu),ar=[],Qs=Cu.input_ids.tolist();for(let _a=0;_a<Qs.length;++_a){const $o=Qs[_a],Eo=$o.findIndex(Oo=>Oo==this.tokenizer.mask_token_id);if(Eo===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const js=e_[_a][Eo],Lr=await(0,b.topk)(new b.Tensor("float32",(0,$.softmax)(js.data),js.dims),vu),rn=Lr[0].tolist(),Kr=Lr[1].tolist();ar.push(Kr.map((Oo,Mo)=>{const qs=$o.slice();return qs[Eo]=Oo,{score:rn[Mo],token:Number(Oo),token_str:this.tokenizer.model.vocab[Oo],sequence:this.tokenizer.decode(qs,{skip_special_tokens:!0})}}))}return Array.isArray(Ko)?ar:ar[0]}}class Qt extends At{_key="generated_text";constructor(Ko){super(Ko)}async _call(Ko,vu={}){Array.isArray(Ko)||(Ko=[Ko]),this.model.config.prefix&&(Ko=Ko.map($o=>this.model.config.prefix+$o));const Cu=this.model.config.task_specific_params;Cu&&Cu[this.task]&&Cu[this.task].prefix&&(Ko=Ko.map($o=>Cu[this.task].prefix+$o));const e_=this.tokenizer,ar={padding:!0,truncation:!0};let Qs;this instanceof gr&&"_build_translation_inputs"in e_?Qs=e_._build_translation_inputs(Ko,ar,vu):Qs=e_(Ko,ar);const _a=await this.model.generate({...Qs,...vu});return e_.batch_decode(_a,{skip_special_tokens:!0}).map($o=>({[this._key]:$o}))}}class Zt extends Qt{_key="summary_text";constructor(Ko){super(Ko)}}class gr extends Qt{_key="translation_text";constructor(Ko){super(Ko)}}function vr(na){return Array.isArray(na)&&na.every(Ko=>"role"in Ko&&"content"in Ko)}class Er extends At{constructor(Ko){super(Ko)}async _call(Ko,vu={}){let Cu=!1,e_=!1,ar;if(typeof Ko=="string")ar=Ko=[Ko];else if(Array.isArray(Ko)&&Ko.every(Kr=>typeof Kr=="string"))Cu=!0,ar=Ko;else{if(vr(Ko))Ko=[Ko];else if(Array.isArray(Ko)&&Ko.every(vr))Cu=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");e_=!0,ar=Ko.map(Kr=>this.tokenizer.apply_chat_template(Kr,{tokenize:!1,add_generation_prompt:!0}))}const Qs=vu.add_special_tokens??!1,_a=e_?!1:vu.return_full_text??!0;this.tokenizer.padding_side="left";const $o=this.tokenizer(ar,{add_special_tokens:Qs,padding:!0,truncation:!0}),Eo=await this.model.generate({...$o,...vu}),js=this.tokenizer.batch_decode(Eo,{skip_special_tokens:!0});let Lr;!_a&&$o.input_ids.dims.at(-1)>0&&(Lr=this.tokenizer.batch_decode($o.input_ids,{skip_special_tokens:!0}).map(Kr=>Kr.length));const rn=Array.from({length:Ko.length},Kr=>[]);for(let Kr=0;Kr<js.length;++Kr){const Oo=Math.floor(Kr/Eo.dims[0]*Ko.length);Lr&&(js[Kr]=js[Kr].slice(Lr[Oo])),rn[Oo].push({generated_text:e_?[...Ko[Oo],{role:"assistant",content:js[Kr]}]:js[Kr]})}return!Cu&&rn.length===1?rn[0]:rn}}class wo extends At{constructor(Ko){super(Ko),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([vu,Cu])=>[vu.toLowerCase(),Cu])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(Ko,vu,{hypothesis_template:Cu="This example is {}.",multi_label:e_=!1}={}){const ar=Array.isArray(Ko);ar||(Ko=[Ko]),Array.isArray(vu)||(vu=[vu]);const Qs=vu.map(Eo=>Cu.replace("{}",Eo)),_a=e_||vu.length===1,$o=[];for(const Eo of Ko){const js=[];for(const Kr of Qs){const Oo=this.tokenizer(Eo,{text_pair:Kr,padding:!0,truncation:!0}),Mo=await this.model(Oo);_a?js.push([Mo.logits.data[this.contradiction_id],Mo.logits.data[this.entailment_id]]):js.push(Mo.logits.data[this.entailment_id])}const rn=(_a?js.map(Kr=>(0,$.softmax)(Kr)[1]):(0,$.softmax)(js)).map((Kr,Oo)=>[Kr,Oo]).sort((Kr,Oo)=>Oo[0]-Kr[0]);$o.push({sequence:Eo,labels:rn.map(Kr=>vu[Kr[1]]),scores:rn.map(Kr=>Kr[0])})}return ar?$o:$o[0]}}class Do extends At{constructor(Ko){super(Ko)}async _call(Ko,{pooling:vu="none",normalize:Cu=!1,quantize:e_=!1,precision:ar="binary"}={}){const Qs=this.tokenizer(Ko,{padding:!0,truncation:!0}),_a=await this.model(Qs);let $o=_a.last_hidden_state??_a.logits??_a.token_embeddings;if(vu!=="none")if(vu==="mean")$o=(0,b.mean_pooling)($o,Qs.attention_mask);else if(vu==="cls")$o=$o.slice(null,0);else throw Error(`Pooling method '${vu}' not supported.`);return Cu&&($o=$o.normalize(2,-1)),e_&&($o=(0,b.quantize_embeddings)($o,ar)),$o}}class Js extends At{constructor(Ko){super(Ko)}async _call(Ko,{pool:vu=null}={}){const Cu=await nt(Ko),{pixel_values:e_}=await this.processor(Cu),ar=await this.model({pixel_values:e_});let Qs;if(vu){if(!("pooler_output"in ar))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");Qs=ar.pooler_output}else Qs=ar.last_hidden_state??ar.logits??ar.image_embeds;return Qs}}class In extends At{constructor(Ko){super(Ko)}async _call(Ko,{top_k:vu=5}={}){const Cu=this.processor.feature_extractor.config.sampling_rate,e_=await at(Ko,Cu),ar=this.model.config.id2label,Qs=[];for(const _a of e_){const $o=await this.processor(_a),js=(await this.model($o)).logits[0],Lr=await(0,b.topk)(new b.Tensor("float32",(0,$.softmax)(js.data),js.dims),vu),rn=Lr[0].tolist(),Oo=Lr[1].tolist().map((Mo,qs)=>({label:ar?ar[Mo]:`LABEL_${Mo}`,score:rn[qs]}));Qs.push(Oo)}return Array.isArray(Ko)?Qs:Qs[0]}}class Wo extends At{constructor(Ko){super(Ko)}async _call(Ko,vu,{hypothesis_template:Cu="This is a sound of {}."}={}){const e_=!Array.isArray(Ko);e_&&(Ko=[Ko]);const ar=vu.map(js=>Cu.replace("{}",js)),Qs=this.tokenizer(ar,{padding:!0,truncation:!0}),_a=this.processor.feature_extractor.config.sampling_rate,$o=await at(Ko,_a),Eo=[];for(const js of $o){const Lr=await this.processor(js),rn=await this.model({...Qs,...Lr}),Kr=(0,$.softmax)(rn.logits_per_audio.data);Eo.push([...Kr].map((Oo,Mo)=>({score:Oo,label:vu[Mo]})))}return e_?Eo[0]:Eo}}class Ir extends At{constructor(Ko){super(Ko)}async _call(Ko,vu={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(Ko,vu);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(Ko,vu);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(Ko,vu){vu.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),vu.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const Cu=!Array.isArray(Ko);Cu&&(Ko=[Ko]);const e_=this.processor.feature_extractor.config.sampling_rate,ar=await at(Ko,e_),Qs=[];for(const _a of ar){const $o=await this.processor(_a),js=(await this.model($o)).logits[0],Lr=[];for(const Kr of js)Lr.push((0,$.max)(Kr.data)[1]);const rn=this.tokenizer.decode(Lr);Qs.push({text:rn})}return Cu?Qs[0]:Qs}async _call_whisper(Ko,vu){const Cu=vu.return_timestamps??!1,e_=vu.chunk_length_s??0,ar=vu.force_full_sequences??!1;let Qs=vu.stride_length_s??null;const _a={...vu};Cu==="word"&&(_a.return_token_timestamps=!0,_a.return_timestamps=!1);const $o=!Array.isArray(Ko);$o&&(Ko=[Ko]);const Eo=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,js=this.processor.feature_extractor.config.hop_length,Lr=this.processor.feature_extractor.config.sampling_rate,rn=await at(Ko,Lr),Kr=[];for(const Oo of rn){let Mo=[];if(e_>0){if(Qs===null)Qs=e_/6;else if(e_<=Qs)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const i_=Lr*e_,$u=Lr*Qs,m_=i_-2*$u;let L_=0;for(;;){const Z_=L_+i_,Ty=Oo.subarray(L_,Z_),ey=await this.processor(Ty),yy=L_===0,O_=Z_>=Oo.length;if(Mo.push({stride:[Ty.length,yy?0:$u,O_?0:$u],input_features:ey.input_features,is_last:O_}),O_)break;L_+=m_}}else Mo=[{stride:[Oo.length,0,0],input_features:(await this.processor(Oo)).input_features,is_last:!0}];for(const i_ of Mo){_a.num_frames=Math.floor(i_.stride[0]/js);const $u=await this.model.generate({inputs:i_.input_features,..._a});Cu==="word"?(i_.tokens=$u.sequences.tolist()[0],i_.token_timestamps=$u.token_timestamps.tolist()[0].map(m_=>(0,$.round)(m_,2))):i_.tokens=$u[0].tolist(),i_.stride=i_.stride.map(m_=>m_/Lr)}const[qs,au]=this.tokenizer._decode_asr(Mo,{time_precision:Eo,return_timestamps:Cu,force_full_sequences:ar});Kr.push({text:qs,...au})}return $o?Kr[0]:Kr}}class Yo extends At{constructor(Ko){super(Ko)}async _call(Ko,vu={}){const Cu=Array.isArray(Ko),e_=await nt(Ko),{pixel_values:ar}=await this.processor(e_),Qs=[];for(const _a of ar){_a.dims=[1,..._a.dims];const $o=await this.model.generate({inputs:_a,...vu}),Eo=this.tokenizer.batch_decode($o,{skip_special_tokens:!0}).map(js=>({generated_text:js.trim()}));Qs.push(Eo)}return Cu?Qs:Qs[0]}}class Bu extends At{constructor(Ko){super(Ko)}async _call(Ko,{top_k:vu=5}={}){const Cu=await nt(Ko),{pixel_values:e_}=await this.processor(Cu),ar=await this.model({pixel_values:e_}),Qs=this.model.config.id2label,_a=[];for(const $o of ar.logits){const Eo=await(0,b.topk)(new b.Tensor("float32",(0,$.softmax)($o.data),$o.dims),vu),js=Eo[0].tolist(),rn=Eo[1].tolist().map((Kr,Oo)=>({label:Qs?Qs[Kr]:`LABEL_${Kr}`,score:js[Oo]}));_a.push(rn)}return Array.isArray(Ko)?_a:_a[0]}}class Ho extends At{constructor(Ko){super(Ko),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(Ko,{threshold:vu=.5,mask_threshold:Cu=.5,overlap_mask_area_threshold:e_=.8,label_ids_to_fuse:ar=null,target_sizes:Qs=null,subtask:_a=null}={}){if(Array.isArray(Ko)&&Ko.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const Eo=await nt(Ko),js=Eo.map(au=>[au.height,au.width]),{pixel_values:Lr,pixel_mask:rn}=await this.processor(Eo),Kr=await this.model({pixel_values:Lr,pixel_mask:rn});let Oo=null;if(_a!==null)Oo=this.subtasks_mapping[_a];else for(let[au,i_]of Object.entries(this.subtasks_mapping))if(i_ in this.processor.feature_extractor){Oo=this.processor.feature_extractor[i_].bind(this.processor.feature_extractor),_a=au;break}const Mo=this.model.config.id2label,qs=[];if(_a==="panoptic"||_a==="instance"){const au=Oo(Kr,vu,Cu,e_,ar,Qs??js)[0],i_=au.segmentation;for(const $u of au.segments_info){const m_=new Uint8ClampedArray(i_.data.length);for(let Z_=0;Z_<i_.data.length;++Z_)i_.data[Z_]===$u.id&&(m_[Z_]=255);const L_=new g.RawImage(m_,i_.dims[1],i_.dims[0],1);qs.push({score:$u.score,label:Mo[$u.label_id],mask:L_})}}else if(_a==="semantic"){const{segmentation:au,labels:i_}=Oo(Kr,Qs??js)[0];for(const $u of i_){const m_=new Uint8ClampedArray(au.data.length);for(let Z_=0;Z_<au.data.length;++Z_)au.data[Z_]===$u&&(m_[Z_]=255);const L_=new g.RawImage(m_,au.dims[1],au.dims[0],1);qs.push({score:null,label:Mo[$u],mask:L_})}}else throw Error(`Subtask ${_a} not supported.`);return qs}}class tn extends At{constructor(Ko){super(Ko)}async _call(Ko,vu,{hypothesis_template:Cu="This is a photo of {}"}={}){const e_=Array.isArray(Ko),ar=await nt(Ko),Qs=vu.map(rn=>Cu.replace("{}",rn)),_a=this.tokenizer(Qs,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:$o}=await this.processor(ar),Eo=await this.model({..._a,pixel_values:$o}),js=this.model.config.model_type==="siglip"?rn=>rn.sigmoid().data:rn=>(0,$.softmax)(rn.data),Lr=[];for(const rn of Eo.logits_per_image){const Oo=[...js(rn)].map((Mo,qs)=>({score:Mo,label:vu[qs]}));Oo.sort((Mo,qs)=>qs.score-Mo.score),Lr.push(Oo)}return e_?Lr:Lr[0]}}class To extends At{constructor(Ko){super(Ko)}async _call(Ko,{threshold:vu=.9,percentage:Cu=!1}={}){const e_=Array.isArray(Ko);if(e_&&Ko.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const ar=await nt(Ko),Qs=Cu?null:ar.map(Kr=>[Kr.height,Kr.width]),{pixel_values:_a,pixel_mask:$o}=await this.processor(ar),Eo=await this.model({pixel_values:_a,pixel_mask:$o}),js=this.processor.feature_extractor.post_process_object_detection(Eo,vu,Qs),Lr=this.model.config.id2label,rn=js.map(Kr=>Kr.boxes.map((Oo,Mo)=>({score:Kr.scores[Mo],label:Lr[Kr.classes[Mo]],box:Ot(Oo,!Cu)})));return e_?rn:rn[0]}}class Qo extends At{constructor(Ko){super(Ko)}async _call(Ko,vu,{threshold:Cu=.1,top_k:e_=null,percentage:ar=!1}={}){const Qs=Array.isArray(Ko),_a=await nt(Ko),$o=this.tokenizer(vu,{padding:!0,truncation:!0}),Eo=await this.processor(_a),js=[];for(let Lr=0;Lr<_a.length;++Lr){const rn=_a[Lr],Kr=ar?null:[[rn.height,rn.width]],Oo=Eo.pixel_values[Lr].unsqueeze_(0),Mo=await this.model({...$o,pixel_values:Oo}),qs=this.processor.feature_extractor.post_process_object_detection(Mo,Cu,Kr,!0)[0];let au=qs.boxes.map((i_,$u)=>({score:qs.scores[$u],label:vu[qs.classes[$u]],box:Ot(i_,!ar)})).sort((i_,$u)=>$u.score-i_.score);e_!==null&&(au=au.slice(0,e_)),js.push(au)}return Qs?js:js[0]}}class Jr extends At{constructor(Ko){super(Ko)}async _call(Ko,vu,Cu={}){throw new Error("This pipeline is not yet supported in Transformers.js v3.")}}class Lo extends At{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(Ko){super(Ko),this.vocoder=Ko.vocoder??null}async _call(Ko,{speaker_embeddings:vu=null}={}){return this.processor?this._call_text_to_spectrogram(Ko,{speaker_embeddings:vu}):this._call_text_to_waveform(Ko)}async _call_text_to_waveform(Ko){const vu=this.tokenizer(Ko,{padding:!0,truncation:!0}),{waveform:Cu}=await this.model(vu),e_=this.model.config.sampling_rate;return{audio:Cu.data,sampling_rate:e_}}async _call_text_to_spectrogram(Ko,{speaker_embeddings:vu}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await h.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof vu=="string"||vu instanceof URL)&&(vu=new Float32Array(await(await fetch(vu)).arrayBuffer())),vu instanceof Float32Array)vu=new b.Tensor("float32",vu,[1,vu.length]);else if(!(vu instanceof b.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:Cu}=this.tokenizer(Ko,{padding:!0,truncation:!0}),{waveform:e_}=await this.model.generate_speech(Cu,vu,{vocoder:this.vocoder}),ar=this.processor.feature_extractor.config.sampling_rate;return{audio:e_.data,sampling_rate:ar}}}class Du extends At{constructor(Ko){super(Ko)}async _call(Ko){const vu=await nt(Ko),Cu=await this.processor(vu),e_=await this.model(Cu),ar=[];for(const Qs of e_.reconstruction){const _a=Qs.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");ar.push(g.RawImage.fromTensor(_a))}return ar.length>1?ar:ar[0]}}class _u extends At{constructor(Ko){super(Ko)}async _call(Ko){const vu=await nt(Ko),Cu=await this.processor(vu),{predicted_depth:e_}=await this.model(Cu),ar=[];for(let Qs=0;Qs<vu.length;++Qs){const _a=(0,b.interpolate)(e_[Qs],vu[Qs].size.reverse(),"bilinear",!1),$o=_a.mul_(255/(0,$.max)(_a.data)[0]).to("uint8");ar.push({predicted_depth:e_[Qs],depth:g.RawImage.fromTensor($o)})}return ar.length>1?ar:ar[0]}}const du=Object.freeze({"text-classification":{tokenizer:s.AutoTokenizer,pipeline:Ct,model:h.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:s.AutoTokenizer,pipeline:St,model:h.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:s.AutoTokenizer,pipeline:xt,model:h.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:s.AutoTokenizer,pipeline:Dt,model:h.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:s.AutoTokenizer,pipeline:Zt,model:h.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:s.AutoTokenizer,pipeline:gr,model:h.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:s.AutoTokenizer,pipeline:Qt,model:h.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:s.AutoTokenizer,pipeline:Er,model:h.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:s.AutoTokenizer,pipeline:wo,model:h.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:In,model:h.AutoModelForAudioClassification,processor:a.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:s.AutoTokenizer,pipeline:Wo,model:h.AutoModel,processor:a.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:s.AutoTokenizer,pipeline:Ir,model:[h.AutoModelForSpeechSeq2Seq,h.AutoModelForCTC],processor:a.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:s.AutoTokenizer,pipeline:Lo,model:[h.AutoModelForTextToWaveform,h.AutoModelForTextToSpectrogram],processor:[a.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:s.AutoTokenizer,pipeline:Yo,model:h.AutoModelForVision2Seq,processor:a.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:Bu,model:h.AutoModelForImageClassification,processor:a.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:Ho,model:[h.AutoModelForImageSegmentation,h.AutoModelForSemanticSegmentation,h.AutoModelForUniversalSegmentation],processor:a.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:s.AutoTokenizer,pipeline:tn,model:h.AutoModel,processor:a.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:To,model:h.AutoModelForObjectDetection,processor:a.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:s.AutoTokenizer,pipeline:Qo,model:h.AutoModelForZeroShotObjectDetection,processor:a.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:s.AutoTokenizer,pipeline:Jr,model:h.AutoModelForDocumentQuestionAnswering,processor:a.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:Du,model:h.AutoModelForImageToImage,processor:a.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:_u,model:h.AutoModelForDepthEstimation,processor:a.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:s.AutoTokenizer,pipeline:Do,model:h.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:a.AutoProcessor,pipeline:Js,model:[h.AutoModelForImageFeatureExtraction,h.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),wu=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function r_(na,Ko=null,{progress_callback:vu=null,config:Cu=null,cache_dir:e_=null,local_files_only:ar=!1,revision:Qs="main",device:_a=null,dtype:$o=null,model_file_name:Eo=null,session_options:js={}}={}){na=wu[na]??na;const Lr=du[na.split("_",1)[0]];if(!Lr)throw Error(`Unsupported pipeline: ${na}. Must be one of [${Object.keys(du)}]`);Ko||(Ko=Lr.default.model,console.log(`No model specified. Using default model: "${Ko}".`));const rn={progress_callback:vu,config:Cu,cache_dir:e_,local_files_only:ar,revision:Qs,device:_a,dtype:$o,model_file_name:Eo,session_options:js},Kr=new Map([["tokenizer",Lr.tokenizer],["model",Lr.model],["processor",Lr.processor]]),Oo=await d_(Kr,Ko,rn);Oo.task=na,(0,et.dispatchCallback)(vu,{status:"ready",task:na,model:Ko});const Mo=Lr.pipeline;return new Mo(Oo)}async function d_(na,Ko,vu){const Cu=Object.create(null),e_=[];for(const[ar,Qs]of na.entries()){if(!Qs)continue;let _a;Array.isArray(Qs)?_a=new Promise(async($o,Eo)=>{let js;for(const Lr of Qs){if(Lr===null){$o(null);return}try{$o(await Lr.from_pretrained(Ko,vu));return}catch(rn){if(rn.message?.includes("Unsupported model type"))js=rn;else if(rn.message?.includes("Could not locate file"))js=rn;else{Eo(rn);return}}}Eo(js)}):_a=Qs.from_pretrained(Ko,vu),Cu[ar]=_a,e_.push(_a)}await Promise.all(e_);for(const[ar,Qs]of Object.entries(Cu))Cu[ar]=await Qs;return Cu}},"./src/processors.js":(e,o,i)=>{i.r(o),i.d(o,{ASTFeatureExtractor:()=>Oo,AutoProcessor:()=>fy,BeitFeatureExtractor:()=>vu,BitImageProcessor:()=>Do,CLIPFeatureExtractor:()=>In,CLIPImageProcessor:()=>Wo,ChineseCLIPFeatureExtractor:()=>Ir,ClapFeatureExtractor:()=>Mo,ConvNextFeatureExtractor:()=>Bu,ConvNextImageProcessor:()=>Ho,DPTFeatureExtractor:()=>Er,DPTImageProcessor:()=>wo,DeiTFeatureExtractor:()=>Ko,DetrFeatureExtractor:()=>ar,DonutFeatureExtractor:()=>Cu,EfficientNetImageProcessor:()=>Qo,FeatureExtractor:()=>Dt,Florence2Processor:()=>O_,GLPNFeatureExtractor:()=>Js,ImageFeatureExtractor:()=>Qt,MaskFormerFeatureExtractor:()=>Qs,MobileNetV1FeatureExtractor:()=>Jr,MobileNetV2FeatureExtractor:()=>Lo,MobileNetV3FeatureExtractor:()=>Du,MobileNetV4FeatureExtractor:()=>_u,MobileViTFeatureExtractor:()=>du,MobileViTImageProcessor:()=>wu,NougatImageProcessor:()=>e_,OwlViTFeatureExtractor:()=>r_,OwlViTProcessor:()=>yy,Owlv2ImageProcessor:()=>d_,Processor:()=>$u,PvtImageProcessor:()=>vr,PyAnnoteFeatureExtractor:()=>qs,PyAnnoteProcessor:()=>Ty,RTDetrImageProcessor:()=>na,SamImageProcessor:()=>$o,SamProcessor:()=>m_,SapiensFeatureExtractor:()=>Zt,SeamlessM4TFeatureExtractor:()=>Kr,SegformerFeatureExtractor:()=>gr,SiglipImageProcessor:()=>Yo,SpeechT5FeatureExtractor:()=>i_,SpeechT5Processor:()=>ey,Swin2SRImageProcessor:()=>Eo,ViTFeatureExtractor:()=>tn,ViTImageProcessor:()=>To,VitMatteImageProcessor:()=>js,Wav2Vec2FeatureExtractor:()=>rn,Wav2Vec2ProcessorWithLM:()=>Z_,WeSpeakerFeatureExtractor:()=>au,WhisperFeatureExtractor:()=>Lr,WhisperProcessor:()=>L_,YolosFeatureExtractor:()=>_a});var s=i("./src/utils/generic.js"),h=i("./src/utils/core.js"),a=i("./src/utils/hub.js"),d=i("./src/utils/maths.js"),et=i("./src/utils/tensor.js");i("./src/utils/image.js");var $=i("./src/utils/audio.js");function c([g_,jo,Xs,_d]){return[g_-Xs/2,jo-_d/2,g_+Xs/2,jo+_d/2]}function b(g_,jo=.5,Xs=null,_d=!1){const w_=g_.logits,mu=g_.pred_boxes,[y_,k_,S_]=w_.dims;if(Xs!==null&&Xs.length!==y_)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let B_=[];for(let P_=0;P_<y_;++P_){let N_=Xs!==null?Xs[P_]:null,q_={boxes:[],classes:[],scores:[]},H_=w_[P_],j_=mu[P_];for(let pu=0;pu<k_;++pu){let T_=H_[pu],E_=[],iy;if(_d){iy=T_.sigmoid().data;for(let Ry=0;Ry<iy.length;++Ry)iy[Ry]>jo&&E_.push(Ry)}else{let Ry=(0,d.max)(T_.data)[1];if(Ry===S_-1||(iy=(0,d.softmax)(T_.data),iy[Ry]<jo))continue;E_.push(Ry)}for(const Ry of E_){let Zy=j_[pu].data;Zy=c(Zy),N_!==null&&(Zy=Zy.map((hy,Ay)=>hy*N_[(Ay+1)%2])),q_.boxes.push(Zy),q_.classes.push(Ry),q_.scores.push(iy[Ry])}}B_.push(q_)}return B_}function g(g_,jo=null){const Xs=g_.logits,_d=Xs.dims[0];if(jo!==null&&jo.length!==_d)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const w_=[];for(let mu=0;mu<_d;++mu){const y_=jo!==null?jo[mu]:null;let k_=Xs[mu];y_!==null&&(k_=(0,et.interpolate)(k_,y_,"bilinear",!1));const[S_,B_]=y_??k_.dims.slice(-2),P_=new et.Tensor("int32",new Int32Array(S_*B_),[S_,B_]),N_=k_[0].data,q_=P_.data;for(let pu=1;pu<k_.dims[0];++pu){const T_=k_[pu].data;for(let E_=0;E_<T_.length;++E_)T_[E_]>N_[E_]&&(N_[E_]=T_[E_],q_[E_]=pu)}const H_=new Array(k_.dims[0]);for(let pu=0;pu<q_.length;++pu){const T_=q_[pu];H_[T_]=T_}const j_=H_.filter(pu=>pu!==void 0);w_.push({segmentation:P_,labels:j_})}return w_}function nt(g_,jo,Xs,_d){const w_=[],mu=[],y_=[];for(let k_=0;k_<g_.dims[0];++k_){const S_=g_[k_],B_=jo[k_],P_=(0,d.max)(S_.data)[1];if(P_===_d)continue;const q_=(0,d.softmax)(S_.data)[P_];q_>Xs&&(w_.push(B_),mu.push(q_),y_.push(P_))}return[w_,mu,y_]}function at(g_,jo,Xs,_d=.5,w_=.8){const mu=[];let y_=0,k_=0;const S_=jo[Xs].data;for(let P_=0;P_<g_.length;++P_)g_[P_]===Xs&&(mu.push(P_),++y_),S_[P_]>=_d&&++k_;let B_=y_>0&&k_>0;return B_&&(B_=y_/k_>w_),[B_,mu]}function Ot(g_,jo,Xs,_d,w_,mu=null,y_=null){const[k_,S_]=y_??g_[0].dims,B_=new et.Tensor("int32",new Int32Array(k_*S_),[k_,S_]),P_=[];if(y_!==null)for(let pu=0;pu<g_.length;++pu)g_[pu]=(0,et.interpolate)(g_[pu],y_,"bilinear",!1);const N_=new Int32Array(g_[0].data.length),q_=new Float32Array(g_[0].data.length);for(let pu=0;pu<g_.length;++pu){let T_=jo[pu];const E_=g_[pu].data;for(let iy=0;iy<E_.length;++iy)E_[iy]*=T_,E_[iy]>q_[iy]&&(N_[iy]=pu,q_[iy]=E_[iy])}let H_=0;const j_=B_.data;for(let pu=0;pu<Xs.length;++pu){const T_=Xs[pu],[E_,iy]=at(N_,g_,pu,_d,w_);if(E_){++H_;for(const Ry of iy)j_[Ry]=H_;P_.push({id:H_,label_id:T_,score:jo[pu]})}}return[B_,P_]}function At(g_,jo=.5,Xs=.5,_d=.8,w_=null,mu=null){w_===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),w_=new Set);const y_=g_.class_queries_logits??g_.logits,S_=(g_.masks_queries_logits??g_.pred_masks).sigmoid();let[B_,P_,N_]=y_.dims;if(N_-=1,mu!==null&&mu.length!==B_)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let q_=[];for(let H_=0;H_<B_;++H_){let j_=mu!==null?mu[H_]:null,pu=y_[H_],T_=S_[H_],[E_,iy,Ry]=nt(pu,T_,jo,N_);if(Ry.length===0){let[Ay,Sy]=j_??T_.dims.slice(-2),K0=new et.Tensor("int32",new Int32Array(Ay*Sy).fill(-1),[Ay,Sy]);q_.push({segmentation:K0,segments_info:[]});continue}let[Zy,hy]=Ot(E_,iy,Ry,Xs,_d,w_,j_);q_.push({segmentation:Zy,segments_info:hy})}return q_}function Ct(g_,jo){if(!(g_ instanceof Float32Array||g_ instanceof Float64Array))throw new Error(`${jo} expects input to be a Float32Array or a Float64Array, but got ${g_?.constructor?.name??typeof g_} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function St(g_,jo,Xs=0,_d=null){const w_=g_/jo;let mu=(0,d.bankers_round)(w_)*jo;return _d!==null&&mu>_d&&(mu=Math.floor(w_)*jo),mu<Xs&&(mu=Math.ceil(w_)*jo),mu}function xt([g_,jo],Xs){return[Math.max(Math.floor(g_/Xs),1)*Xs,Math.max(Math.floor(jo/Xs),1)*Xs]}class Dt extends s.Callable{constructor(jo){super(),this.config=jo}}class Qt extends Dt{constructor(jo){super(jo),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=this.config.do_flip_channel_order??!1}async thumbnail(jo,Xs,_d=2){const w_=jo.height,mu=jo.width,y_=Xs.height,k_=Xs.width;let S_=Math.min(w_,y_),B_=Math.min(mu,k_);return S_===w_&&B_===mu?jo:(w_>mu?B_=Math.floor(mu*S_/w_):mu>w_&&(S_=Math.floor(w_*B_/mu)),await jo.resize(B_,S_,{resample:_d}))}async crop_margin(jo,Xs=200){const _d=jo.clone().grayscale(),w_=(0,d.min)(_d.data)[0],y_=(0,d.max)(_d.data)[0]-w_;if(y_===0)return jo;const k_=Xs/255;let S_=_d.width,B_=_d.height,P_=0,N_=0;const q_=_d.data;for(let H_=0;H_<_d.height;++H_){const j_=H_*_d.width;for(let pu=0;pu<_d.width;++pu)(q_[j_+pu]-w_)/y_<k_&&(S_=Math.min(S_,pu),B_=Math.min(B_,H_),P_=Math.max(P_,pu),N_=Math.max(N_,H_))}return jo=await jo.crop([S_,B_,P_,N_]),jo}pad_image(jo,Xs,_d,{mode:w_="constant",center:mu=!1,constant_values:y_=0}={}){const[k_,S_,B_]=Xs;let P_,N_;if(typeof _d=="number"?(P_=_d,N_=_d):(P_=_d.width,N_=_d.height),P_!==S_||N_!==k_){const q_=new Float32Array(P_*N_*B_);if(Array.isArray(y_))for(let pu=0;pu<q_.length;++pu)q_[pu]=y_[pu%B_];else y_!==0&&q_.fill(y_);const[H_,j_]=mu?[Math.floor((P_-S_)/2),Math.floor((N_-k_)/2)]:[0,0];for(let pu=0;pu<k_;++pu){const T_=(pu+j_)*P_,E_=pu*S_;for(let iy=0;iy<S_;++iy){const Ry=(T_+iy+H_)*B_,Zy=(E_+iy)*B_;for(let hy=0;hy<B_;++hy)q_[Ry+hy]=jo[Zy+hy]}}if(w_==="symmetric"){if(mu)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const pu=k_-1,T_=S_-1;for(let E_=0;E_<N_;++E_){const iy=E_*P_,Ry=(0,h.calculateReflectOffset)(E_,pu)*S_;for(let Zy=0;Zy<P_;++Zy){if(E_<k_&&Zy<S_)continue;const hy=(iy+Zy)*B_,Ay=(Ry+(0,h.calculateReflectOffset)(Zy,T_))*B_;for(let Sy=0;Sy<B_;++Sy)q_[hy+Sy]=jo[Ay+Sy]}}}jo=q_,Xs=[N_,P_,B_]}return[jo,Xs]}rescale(jo){for(let Xs=0;Xs<jo.length;++Xs)jo[Xs]=this.rescale_factor*jo[Xs]}get_resize_output_image_size(jo,Xs){const[_d,w_]=jo.size;let mu,y_;if(this.do_thumbnail){const{height:k_,width:S_}=Xs;mu=Math.min(k_,S_)}else Number.isInteger(Xs)?(mu=Xs,y_=this.config.max_size??mu):Xs!==void 0&&(mu=Xs.shortest_edge,y_=Xs.longest_edge);if(mu!==void 0||y_!==void 0){const k_=mu===void 0?1:Math.max(mu/_d,mu/w_),S_=_d*k_,B_=w_*k_,P_=y_===void 0?1:Math.min(y_/S_,y_/B_);let N_=Math.floor(Number((S_*P_).toFixed(2))),q_=Math.floor(Number((B_*P_).toFixed(2)));return this.size_divisibility!==void 0&&([N_,q_]=xt([N_,q_],this.size_divisibility)),[N_,q_]}else if(Xs!==void 0&&Xs.width!==void 0&&Xs.height!==void 0){let k_=Xs.width,S_=Xs.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let B_=S_/w_,P_=k_/_d;Math.abs(1-P_)<Math.abs(1-B_)?B_=P_:P_=B_,S_=St(B_*w_,this.config.ensure_multiple_of),k_=St(P_*_d,this.config.ensure_multiple_of)}return[k_,S_]}else{if(this.size_divisibility!==void 0)return xt([_d,w_],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(Xs)}`)}}async resize(jo){const[Xs,_d]=this.get_resize_output_image_size(jo,this.size);return await jo.resize(Xs,_d,{resample:this.resample})}async preprocess(jo,{do_normalize:Xs=null,do_pad:_d=null,do_convert_rgb:w_=null,do_convert_grayscale:mu=null,do_flip_channel_order:y_=null}={}){this.do_crop_margin&&(jo=await this.crop_margin(jo));const[k_,S_]=jo.size;if(w_??this.do_convert_rgb?jo=jo.rgb():mu&&(jo=jo.grayscale()),this.do_resize&&(jo=await this.resize(jo)),this.do_thumbnail&&(jo=await this.thumbnail(jo,this.size,this.resample)),this.do_center_crop){let H_,j_;Number.isInteger(this.crop_size)?(H_=this.crop_size,j_=this.crop_size):(H_=this.crop_size.width,j_=this.crop_size.height),jo=await jo.center_crop(H_,j_)}const B_=[jo.height,jo.width];let P_=Float32Array.from(jo.data),N_=[jo.height,jo.width,jo.channels];if(this.do_rescale&&this.rescale(P_),Xs??this.do_normalize){let H_=this.image_mean;Array.isArray(this.image_mean)||(H_=new Array(jo.channels).fill(H_));let j_=this.image_std;if(Array.isArray(this.image_std)||(j_=new Array(jo.channels).fill(H_)),H_.length!==jo.channels||j_.length!==jo.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${H_.length}) and \`image_std\` (${j_.length}) must match the number of channels in the image (${jo.channels}).`);for(let pu=0;pu<P_.length;pu+=jo.channels)for(let T_=0;T_<jo.channels;++T_)P_[pu+T_]=(P_[pu+T_]-H_[T_])/j_[T_]}if(_d??this.do_pad){if(this.pad_size)[P_,N_]=this.pad_image(P_,[jo.height,jo.width,jo.channels],this.pad_size);else if(this.size_divisibility){const[H_,j_]=xt([N_[1],N_[0]],this.size_divisibility);[P_,N_]=this.pad_image(P_,N_,{width:H_,height:j_})}}if(y_??this.do_flip_channel_order){if(N_[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let H_=0;H_<P_.length;H_+=3){const j_=P_[H_];P_[H_]=P_[H_+2],P_[H_+2]=j_}}const q_=new et.Tensor("float32",P_,N_).permute(2,0,1);return{original_size:[S_,k_],reshaped_input_size:B_,pixel_values:q_}}async _call(jo,...Xs){Array.isArray(jo)||(jo=[jo]);const _d=await Promise.all(jo.map(mu=>this.preprocess(mu)));return{pixel_values:(0,et.stack)(_d.map(mu=>mu.pixel_values),0),original_sizes:_d.map(mu=>mu.original_size),reshaped_input_sizes:_d.map(mu=>mu.reshaped_input_size)}}}class Zt extends Qt{post_process_semantic_segmentation(...jo){return g(...jo)}}class gr extends Qt{post_process_semantic_segmentation(...jo){return g(...jo)}}class vr extends Qt{}class Er extends Qt{}class wo extends Er{}class Do extends Qt{}class Js extends Qt{}class In extends Qt{}class Wo extends In{}class Ir extends Qt{}class Yo extends Qt{}class Bu extends Qt{constructor(jo){super(jo),this.crop_pct=this.config.crop_pct??224/256}async resize(jo){const Xs=this.size?.shortest_edge;if(Xs===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(Xs<384){const _d=Math.floor(Xs/this.crop_pct),[w_,mu]=this.get_resize_output_image_size(jo,{shortest_edge:_d});jo=await jo.resize(w_,mu,{resample:this.resample}),jo=await jo.center_crop(Xs,Xs)}else jo=await jo.resize(Xs,Xs,{resample:this.resample});return jo}}class Ho extends Bu{}class tn extends Qt{}class To extends Qt{}class Qo extends Qt{constructor(jo){super(jo),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(Xs=>Xs*Xs))}}class Jr extends Qt{}class Lo extends Qt{}class Du extends Qt{}class _u extends Qt{}class du extends Qt{}class wu extends du{}class r_ extends Qt{post_process_object_detection(...jo){return b(...jo)}}class d_ extends r_{}class na extends Qt{post_process_object_detection(...jo){return b(...jo)}}class Ko extends Qt{}class vu extends Qt{}class Cu extends Qt{pad_image(jo,Xs,_d,w_={}){const[mu,y_,k_]=Xs;let S_=this.image_mean;Array.isArray(this.image_mean)||(S_=new Array(k_).fill(S_));let B_=this.image_std;Array.isArray(B_)||(B_=new Array(k_).fill(S_));const P_=S_.map((N_,q_)=>-N_/B_[q_]);return super.pad_image(jo,Xs,_d,{center:!0,constant_values:P_,...w_})}}class e_ extends Cu{}class ar extends Qt{async _call(jo){const Xs=await super._call(jo),_d=[Xs.pixel_values.dims[0],64,64],w_=(0,et.full)(_d,1n);return{...Xs,pixel_mask:w_}}post_process_object_detection(...jo){return b(...jo)}post_process_panoptic_segmentation(...jo){return At(...jo)}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class Qs extends Qt{post_process_panoptic_segmentation(...jo){return At(...jo)}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class _a extends Qt{post_process_object_detection(...jo){return b(...jo)}}class $o extends Qt{reshape_input_points(jo,Xs,_d,w_=!1){jo=structuredClone(jo);let mu=(0,h.calculateDimensions)(jo);if(mu.length===3)w_||(mu=[1,...mu]),jo=[jo];else if(mu.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let y_=0;y_<jo.length;++y_){let k_=Xs[y_],S_=_d[y_],B_=[S_[0]/k_[0],S_[1]/k_[1]];for(let P_=0;P_<jo[y_].length;++P_)for(let N_=0;N_<jo[y_][P_].length;++N_)for(let q_=0;q_<jo[y_][P_][N_].length;++q_)jo[y_][P_][N_][q_]*=B_[q_%2]}return new et.Tensor("float32",Float32Array.from(jo.flat(1/0)),mu)}add_input_labels(jo,Xs){let _d=(0,h.calculateDimensions)(jo);if(_d.length===2)_d=[1,..._d],jo=[jo];else if(_d.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(_d.some((w_,mu)=>w_!==Xs.dims[mu]))throw Error(`The first ${_d.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new et.Tensor("int64",jo.flat(1/0).map(BigInt),_d)}async _call(jo,{input_points:Xs=null,input_labels:_d=null,input_boxes:w_=null}={}){const mu=await super._call(jo);if(Xs&&(mu.input_points=this.reshape_input_points(Xs,mu.original_sizes,mu.reshaped_input_sizes)),_d){if(!mu.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");mu.input_labels=this.add_input_labels(_d,mu.input_points)}return w_&&(mu.input_boxes=this.reshape_input_points(w_,mu.original_sizes,mu.reshaped_input_sizes,!0)),mu}async post_process_masks(jo,Xs,_d,{mask_threshold:w_=0,binarize:mu=!0,pad_size:y_=null}={}){const k_=[];y_=y_??this.pad_size;const S_=[y_.height,y_.width];for(let B_=0;B_<Xs.length;++B_){const P_=Xs[B_],N_=_d[B_];let q_=await(0,et.interpolate_4d)(jo[B_],{mode:"bilinear",size:S_});if(q_=q_.slice(null,null,[0,N_[0]],[0,N_[1]]),q_=await(0,et.interpolate_4d)(q_,{mode:"bilinear",size:P_}),mu){const H_=q_.data,j_=new Uint8Array(H_.length);for(let pu=0;pu<H_.length;++pu)H_[pu]>w_&&(j_[pu]=1);q_=new et.Tensor("bool",j_,q_.dims)}k_.push(q_)}return k_}generate_crop_boxes(jo,Xs,{crop_n_layers:_d=0,overlap_ratio:w_=512/1500,points_per_crop:mu=32,crop_n_points_downscale_factor:y_=1}={}){}}class Eo extends Qt{pad_image(jo,Xs,_d,w_={}){const[mu,y_,k_]=Xs;return super.pad_image(jo,Xs,{width:y_+(_d-y_%_d)%_d,height:mu+(_d-mu%_d)%_d},{mode:"symmetric",center:!1,constant_values:-1,...w_})}}class js extends Qt{async _call(jo,Xs){Array.isArray(jo)||(jo=[jo]),Array.isArray(Xs)||(Xs=[Xs]);const _d=await Promise.all(jo.map(y_=>this.preprocess(y_))),w_=await Promise.all(Xs.map(y_=>this.preprocess(y_,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,et.stack)(_d.map((y_,k_)=>(0,et.cat)([y_.pixel_values,w_[k_].pixel_values],0)),0),original_sizes:_d.map(y_=>y_.original_size),reshaped_input_sizes:_d.map(y_=>y_.reshaped_input_size)}}}class Lr extends Dt{constructor(jo){super(jo),this.config.mel_filters??=(0,$.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=(0,$.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(jo){const Xs=await(0,$.spectrogram)(jo,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),_d=Xs.data,w_=(0,d.max)(_d)[0];for(let mu=0;mu<_d.length;++mu)_d[mu]=(Math.max(_d[mu],w_-8)+4)/4;return Xs}async _call(jo){Ct(jo,"WhisperFeatureExtractor");let Xs;return jo.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),Xs=jo.slice(0,this.config.n_samples)):(Xs=new Float32Array(this.config.n_samples),Xs.set(jo)),{input_features:(await this._extract_fbank_features(Xs)).unsqueeze_(0)}}}class rn extends Dt{_zero_mean_unit_var_norm(jo){const _d=jo.reduce((mu,y_)=>mu+y_,0)/jo.length,w_=jo.reduce((mu,y_)=>mu+(y_-_d)**2,0)/jo.length;return jo.map(mu=>(mu-_d)/Math.sqrt(w_+1e-7))}async _call(jo){Ct(jo,"Wav2Vec2FeatureExtractor"),jo instanceof Float64Array&&(jo=new Float32Array(jo));let Xs=jo;this.config.do_normalize&&(Xs=this._zero_mean_unit_var_norm(Xs));const _d=[1,Xs.length];return{input_values:new et.Tensor("float32",Xs,_d),attention_mask:new et.Tensor("int64",new BigInt64Array(Xs.length).fill(1n),_d)}}}class Kr extends Dt{constructor(jo){super(jo);const Xs=this.config.sampling_rate,_d=(0,$.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Xs/2),Xs,null,"kaldi",!0);for(let w_=0;w_<_d.length;++w_)_d[w_].push(0);this.mel_filters=_d,this.window=(0,$.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(jo,Xs){return jo=jo.map(_d=>_d*32768),(0,$.spectrogram)(jo,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:Xs,transpose:!0})}async _call(jo,{padding:Xs=!0,pad_to_multiple_of:_d=2,do_normalize_per_mel_bins:w_=!0,return_attention_mask:mu=!0}={}){Ct(jo,"SeamlessM4TFeatureExtractor");let y_=await this._extract_fbank_features(jo,this.config.max_length);if(w_){const[j_,pu]=y_.dims,T_=y_.data;for(let E_=0;E_<pu;++E_){let iy=0;for(let Ay=0;Ay<j_;++Ay)iy+=T_[Ay*pu+E_];const Ry=iy/j_;let Zy=0;for(let Ay=0;Ay<j_;++Ay)Zy+=(T_[Ay*pu+E_]-Ry)**2;Zy/=j_-1;const hy=Math.sqrt(Zy+1e-7);for(let Ay=0;Ay<j_;++Ay){const Sy=Ay*pu+E_;T_[Sy]=(T_[Sy]-Ry)/hy}}}let k_;if(Xs){const[j_,pu]=y_.dims,T_=y_.data,E_=j_%_d;if(E_>0){const iy=new Float32Array(pu*(j_+E_));iy.set(T_),iy.fill(this.config.padding_value,T_.length);const Ry=j_+E_;y_=new et.Tensor(y_.type,iy,[Ry,pu]),mu&&(k_=new et.Tensor("int64",new BigInt64Array(Ry),[1,Ry]),k_.data.fill(1n,0,j_))}}const[S_,B_]=y_.dims,P_=this.config.stride;if(S_%P_!==0)throw new Error(`The number of frames (${S_}) must be a multiple of the stride (${P_}).`);const q_=y_.view(1,Math.floor(S_/P_),B_*P_),H_={input_features:q_};if(mu){const j_=q_.dims[1],pu=new BigInt64Array(j_);if(k_){const T_=k_.data;for(let E_=1,iy=0;E_<S_;E_+=P_,++iy)pu[iy]=T_[E_]}else pu.fill(1n);H_.attention_mask=new et.Tensor("int64",pu,[1,j_])}return H_}}class Oo extends Dt{constructor(jo){super(jo);const Xs=this.config.sampling_rate,_d=(0,$.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Xs/2),Xs,null,"kaldi",!0);for(let w_=0;w_<_d.length;++w_)_d[w_].push(0);this.mel_filters=_d,this.window=(0,$.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(jo,Xs){return(0,$.spectrogram)(jo,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:Xs,transpose:!0})}async _call(jo){Ct(jo,"ASTFeatureExtractor");const Xs=await this._extract_fbank_features(jo,this.config.max_length);if(this.config.do_normalize){const _d=this.std*2,w_=Xs.data;for(let mu=0;mu<w_.length;++mu)w_[mu]=(w_[mu]-this.mean)/_d}return{input_values:Xs.unsqueeze_(0)}}}class Mo extends Dt{constructor(jo){super(jo),this.mel_filters=(0,$.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,$.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,$.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(jo,Xs,_d,w_){let mu;const y_=jo.length-Xs;if(y_>0)if(_d==="rand_trunc"){const k_=Math.floor(Math.random()*(y_+1));jo=jo.subarray(k_,k_+Xs),mu=await this._extract_fbank_features(jo,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${_d}" not implemented`);else{if(y_<0){let k_=new Float64Array(Xs);if(k_.set(jo),w_==="repeat")for(let S_=jo.length;S_<Xs;S_+=jo.length)k_.set(jo.subarray(0,Math.min(jo.length,Xs-S_)),S_);else if(w_==="repeatpad")for(let S_=jo.length;S_<-y_;S_+=jo.length)k_.set(jo,S_);jo=k_}if(_d==="fusion")throw new Error(`Truncation strategy "${_d}" not implemented`);mu=await this._extract_fbank_features(jo,this.mel_filters_slaney,this.config.nb_max_samples)}return mu.unsqueeze_(0)}async _extract_fbank_features(jo,Xs,_d=null){return(0,$.spectrogram)(jo,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:Xs,log_mel:"dB",max_num_frames:_d,do_pad:!1,transpose:!0})}async _call(jo,{max_length:Xs=null}={}){return Ct(jo,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(jo,Xs??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}class qs extends Dt{async _call(jo){Ct(jo,"PyAnnoteFeatureExtractor"),jo instanceof Float64Array&&(jo=new Float32Array(jo));const Xs=[1,1,jo.length];return{input_values:new et.Tensor("float32",jo,Xs)}}samples_to_frames(jo){return(jo-this.config.offset)/this.config.step}post_process_speaker_diarization(jo,Xs){const _d=Xs/this.samples_to_frames(Xs)/this.config.sampling_rate,w_=[];for(const mu of jo.tolist()){const y_=[];let k_=-1;for(let S_=0;S_<mu.length;++S_){const B_=(0,d.softmax)(mu[S_]),[P_,N_]=(0,d.max)(B_),[q_,H_]=[S_,S_+1];N_!==k_?(k_=N_,y_.push({id:N_,start:q_,end:H_,score:P_})):(y_.at(-1).end=H_,y_.at(-1).score+=P_)}w_.push(y_.map(({id:S_,start:B_,end:P_,score:N_})=>({id:S_,start:B_*_d,end:P_*_d,confidence:N_/(P_-B_)})))}return w_}}class au extends Dt{constructor(jo){super(jo);const Xs=this.config.sampling_rate,_d=(0,$.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Xs/2),Xs,null,"kaldi",!0);for(let w_=0;w_<_d.length;++w_)_d[w_].push(0);this.mel_filters=_d,this.window=(0,$.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(jo){return jo=jo.map(Xs=>Xs*32768),(0,$.spectrogram)(jo,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(jo){Ct(jo,"WeSpeakerFeatureExtractor");const Xs=(await this._extract_fbank_features(jo)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const _d=Xs.mean(1).data,w_=Xs.data,[mu,y_,k_]=Xs.dims;for(let S_=0;S_<mu;++S_){const B_=S_*y_*k_,P_=S_*k_;for(let N_=0;N_<y_;++N_){const q_=B_+N_*k_;for(let H_=0;H_<k_;++H_)w_[q_+H_]-=_d[P_+H_]}}}return{input_features:Xs}}}class i_ extends Dt{}class $u extends s.Callable{constructor(jo){super(),this.feature_extractor=jo}async _call(jo,...Xs){return await this.feature_extractor(jo,...Xs)}}class m_ extends $u{async _call(...jo){return await this.feature_extractor(...jo)}post_process_masks(...jo){return this.feature_extractor.post_process_masks(...jo)}reshape_input_points(...jo){return this.feature_extractor.reshape_input_points(...jo)}}class L_ extends $u{async _call(jo){return await this.feature_extractor(jo)}}class Z_ extends $u{async _call(jo){return await this.feature_extractor(jo)}}class Ty extends $u{async _call(jo){return await this.feature_extractor(jo)}post_process_speaker_diarization(...jo){return this.feature_extractor.post_process_speaker_diarization(...jo)}}class ey extends $u{async _call(jo){return await this.feature_extractor(jo)}}class yy extends $u{}class O_ extends $u{constructor(jo){super(jo);const{tasks_answer_post_processing_type:Xs,task_prompts_without_inputs:_d,task_prompts_with_input:w_}=jo.config;this.tasks_answer_post_processing_type=new Map(Object.entries(Xs??{})),this.task_prompts_without_inputs=new Map(Object.entries(_d??{})),this.task_prompts_with_input=new Map(Object.entries(w_??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(jo){typeof jo=="string"&&(jo=[jo]);const Xs=[];for(const _d of jo)if(this.task_prompts_without_inputs.has(_d))Xs.push(this.task_prompts_without_inputs.get(_d));else{for(const[w_,mu]of this.task_prompts_with_input)if(_d.includes(w_)){Xs.push(mu.replaceAll("{input}",_d).replaceAll(w_,""));break}Xs.length!==jo.length&&Xs.push(_d)}return Xs}post_process_generation(jo,Xs,_d){const w_=this.tasks_answer_post_processing_type.get(Xs)??"pure_text";jo=jo.replaceAll("<s>","").replaceAll("</s>","");let mu;switch(w_){case"pure_text":mu=jo;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const y_=w_==="ocr"?"quad_boxes":"bboxes",k_=jo.matchAll(this.regexes[y_]),S_=[],B_=[];for(const[P_,N_,...q_]of k_)S_.push(N_?N_.trim():S_.at(-1)??""),B_.push(q_.map((H_,j_)=>(Number(H_)+.5)/this.size_per_bin*_d[j_%2]));mu={labels:S_,[y_]:B_};break;default:throw new Error(`Task "${Xs}" (of type "${w_}") not yet implemented.`)}return{[Xs]:mu}}}class fy{static FEATURE_EXTRACTOR_CLASS_MAPPING={ImageFeatureExtractor:Qt,WhisperFeatureExtractor:Lr,ViTFeatureExtractor:tn,MobileViTFeatureExtractor:du,MobileViTImageProcessor:wu,MobileNetV1FeatureExtractor:Jr,MobileNetV2FeatureExtractor:Lo,MobileNetV3FeatureExtractor:Du,MobileNetV4FeatureExtractor:_u,OwlViTFeatureExtractor:r_,Owlv2ImageProcessor:d_,CLIPFeatureExtractor:In,CLIPImageProcessor:Wo,Florence2Processor:O_,ChineseCLIPFeatureExtractor:Ir,SiglipImageProcessor:Yo,ConvNextFeatureExtractor:Bu,ConvNextImageProcessor:Ho,SegformerFeatureExtractor:gr,SapiensFeatureExtractor:Zt,BitImageProcessor:Do,DPTImageProcessor:wo,DPTFeatureExtractor:Er,PvtImageProcessor:vr,GLPNFeatureExtractor:Js,BeitFeatureExtractor:vu,DeiTFeatureExtractor:Ko,DetrFeatureExtractor:ar,RTDetrImageProcessor:na,MaskFormerFeatureExtractor:Qs,YolosFeatureExtractor:_a,DonutFeatureExtractor:Cu,NougatImageProcessor:e_,EfficientNetImageProcessor:Qo,ViTImageProcessor:To,VitMatteImageProcessor:js,SamImageProcessor:$o,Swin2SRImageProcessor:Eo,Wav2Vec2FeatureExtractor:rn,SeamlessM4TFeatureExtractor:Kr,SpeechT5FeatureExtractor:i_,ASTFeatureExtractor:Oo,ClapFeatureExtractor:Mo,PyAnnoteFeatureExtractor:qs,WeSpeakerFeatureExtractor:au};static PROCESSOR_CLASS_MAPPING={WhisperProcessor:L_,Wav2Vec2ProcessorWithLM:Z_,PyAnnoteProcessor:Ty,SamProcessor:m_,SpeechT5Processor:ey,OwlViTProcessor:yy,Florence2Processor:O_};static async from_pretrained(jo,{progress_callback:Xs=null,config:_d=null,cache_dir:w_=null,local_files_only:mu=!1,revision:y_="main"}={}){let k_=_d??await(0,a.getModelJSON)(jo,"preprocessor_config.json",!0,{progress_callback:Xs,config:_d,cache_dir:w_,local_files_only:mu,revision:y_}),S_=k_.feature_extractor_type??k_.image_processor_type,B_=this.FEATURE_EXTRACTOR_CLASS_MAPPING[S_];if(!B_)if(k_.size!==void 0)console.warn(`Feature extractor type "${S_}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),B_=Qt;else throw new Error(`Unknown Feature Extractor type: ${S_}`);let P_=this.PROCESSOR_CLASS_MAPPING[k_.processor_class]??$u,N_=new B_(k_);return new P_(N_)}}},"./src/tokenizers.js":(e,o,i)=>{i.r(o),i.d(o,{AlbertTokenizer:()=>k_,AutoTokenizer:()=>R0,BartTokenizer:()=>hy,BertTokenizer:()=>y_,BlenderbotSmallTokenizer:()=>Yy,BlenderbotTokenizer:()=>yw,BloomTokenizer:()=>n0,CLIPTokenizer:()=>ly,CamembertTokenizer:()=>T_,CodeGenTokenizer:()=>tw,CodeLlamaTokenizer:()=>N0,CohereTokenizer:()=>Jy,ConvBertTokenizer:()=>H_,DebertaTokenizer:()=>P_,DebertaV2Tokenizer:()=>N_,DistilBertTokenizer:()=>pu,ElectraTokenizer:()=>iy,EsmTokenizer:()=>M0,FalconTokenizer:()=>i0,GPT2Tokenizer:()=>Zy,GPTNeoXTokenizer:()=>q0,GemmaTokenizer:()=>P0,Grok1Tokenizer:()=>F0,HerbertTokenizer:()=>q_,LlamaTokenizer:()=>G0,M2M100Tokenizer:()=>U0,MBart50Tokenizer:()=>Sy,MBartTokenizer:()=>Ay,MPNetTokenizer:()=>uw,MarianTokenizer:()=>Tw,MobileBertTokenizer:()=>S_,NllbTokenizer:()=>Y0,NougatTokenizer:()=>nw,PreTrainedTokenizer:()=>mu,Qwen2Tokenizer:()=>Cw,RoFormerTokenizer:()=>j_,RobertaTokenizer:()=>K0,SiglipTokenizer:()=>by,SpeechT5Tokenizer:()=>rw,SqueezeBertTokenizer:()=>B_,T5Tokenizer:()=>Ry,TokenizerModel:()=>Js,VitsTokenizer:()=>ow,Wav2Vec2CTCTokenizer:()=>Ew,WhisperTokenizer:()=>_w,XLMRobertaTokenizer:()=>xw,XLMTokenizer:()=>E_,is_chinese_char:()=>Qt});var s=i("./src/utils/generic.js"),h=i("./src/utils/core.js"),a=i("./src/utils/hub.js"),d=i("./src/utils/maths.js"),et=i("./src/utils/tensor.js"),$=i("./src/utils/data-structures.js"),c=i("./node_modules/@huggingface/jinja/dist/index.js"),b=i("./src/models/whisper/common_whisper.js"),g=i("./src/utils/constants.js");async function nt(xu,wr){const Po=await Promise.all([(0,a.getModelJSON)(xu,"tokenizer.json",!0,wr),(0,a.getModelJSON)(xu,"tokenizer_config.json",!0,wr)]);return wr.legacy!==null&&(Po[1].legacy=wr.legacy),Po}function at(xu,wr){const Po=[];let Zs=0;for(const ba of xu.matchAll(wr)){const Iu=ba[0];Zs<ba.index&&Po.push(xu.slice(Zs,ba.index)),Iu.length>0&&Po.push(Iu),Zs=ba.index+Iu.length}return Zs<xu.length&&Po.push(xu.slice(Zs)),Po}function Ot(xu,wr=!0){if(xu.Regex!==void 0){let Po=xu.Regex.replace(/\\([#&~])/g,"$1");for(const[Zs,ba]of wo)Po=Po.replaceAll(Zs,ba);return new RegExp(Po,"gu")}else if(xu.String!==void 0){const Po=(0,h.escapeRegExp)(xu.String);return new RegExp(wr?Po:`(${Po})`,"gu")}else return console.warn("Unknown pattern type:",xu),null}function At(xu){return new Map(Object.entries(xu))}function Ct(xu){const wr=xu.dims;switch(wr.length){case 1:return xu.tolist();case 2:if(wr[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return xu.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${wr.length}.`)}}function St(xu){return xu.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function xt(xu){return xu.replace(/[\u0300-\u036f]/g,"")}function Dt(xu){return xt(xu.toLowerCase())}function Qt(xu){return xu>=19968&&xu<=40959||xu>=13312&&xu<=19903||xu>=131072&&xu<=173791||xu>=173824&&xu<=177983||xu>=177984&&xu<=178207||xu>=178208&&xu<=183983||xu>=63744&&xu<=64255||xu>=194560&&xu<=195103}function Zt(xu,wr,Po){const Zs=[];let ba=0;for(;ba<xu.length;){if(Zs.push(xu[ba]),(wr.get(xu[ba])??Po)!==Po){++ba;continue}for(;++ba<xu.length&&(wr.get(xu[ba])??Po)===Po;)wr.get(Zs.at(-1))!==Po&&(Zs[Zs.length-1]+=xu[ba])}return Zs}function gr(xu){return xu.match(/\S+/g)||[]}const vr="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",Er=new RegExp(`^[${vr}]+$`,"gu"),wo=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class Do{constructor(wr){this.content=wr.content,this.id=wr.id,this.single_word=wr.single_word??!1,this.lstrip=wr.lstrip??!1,this.rstrip=wr.rstrip??!1,this.special=wr.special??!1,this.normalized=wr.normalized??null}}class Js extends s.Callable{constructor(wr){super(),this.config=wr,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(wr,...Po){switch(wr.type){case"WordPiece":return new In(wr);case"Unigram":return new Wo(wr,...Po);case"BPE":return new Bu(wr);default:if(wr.vocab)return new Ho(wr,...Po);throw new Error(`Unknown TokenizerModel type: ${wr.type}`)}}_call(wr){return wr=this.encode(wr),this.fuse_unk&&(wr=Zt(wr,this.tokens_to_ids,this.unk_token_id)),wr}encode(wr){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(wr){return wr.map(Po=>this.tokens_to_ids.get(Po)??this.unk_token_id)}convert_ids_to_tokens(wr){return wr.map(Po=>this.vocab[Po]??this.unk_token)}}class In extends Js{constructor(wr){super(wr),this.tokens_to_ids=At(wr.vocab),this.unk_token_id=this.tokens_to_ids.get(wr.unk_token),this.unk_token=wr.unk_token,this.max_input_chars_per_word=wr.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[Po,Zs]of this.tokens_to_ids)this.vocab[Zs]=Po}encode(wr){const Po=[];for(const Zs of wr){const ba=[...Zs];if(ba.length>this.max_input_chars_per_word){Po.push(this.unk_token);continue}let Iu=!1,a_=0;const D_=[];for(;a_<ba.length;){let b_=ba.length,z_=null;for(;a_<b_;){let C_=ba.slice(a_,b_).join("");if(a_>0&&(C_=this.config.continuing_subword_prefix+C_),this.tokens_to_ids.has(C_)){z_=C_;break}--b_}if(z_===null){Iu=!0;break}D_.push(z_),a_=b_}Iu?Po.push(this.unk_token):Po.push(...D_)}return Po}}class Wo extends Js{constructor(wr,Po){super(wr);const Zs=wr.vocab.length;this.vocab=new Array(Zs),this.scores=new Array(Zs);for(let ba=0;ba<Zs;++ba){const Iu=wr.vocab[ba];this.vocab[ba]=Iu[0],this.scores[ba]=Iu[1]}this.unk_token_id=wr.unk_id,this.unk_token=this.vocab[wr.unk_id],this.tokens_to_ids=new Map(this.vocab.map((ba,Iu)=>[ba,Iu])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=Po.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=(0,d.min)(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new $.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(wr){const Po=wr.sentence,Zs=Po.length;let ba=0;for(;ba<Zs;){let a_=!1;for(let D_ of this.trie.commonPrefixSearch(Po.slice(ba))){const b_=this.tokens_to_ids.get(D_),z_=this.scores[b_],C_=D_.length;wr.insert(ba,C_,z_,b_),!a_&&C_===1&&(a_=!0)}a_||wr.insert(ba,1,this.unkScore,this.unk_token_id),ba+=1}}tokenize(wr){const Po=new $.TokenLattice(wr,this.bosTokenId,this.eosTokenId);return this.populateNodes(Po),Po.tokens()}encode(wr){const Po=[];for(const Zs of wr){const ba=this.tokenize(Zs);Po.push(...ba)}return Po}}const Ir=(()=>{const xu=[...Array.from({length:94},(ba,Iu)=>Iu+33),...Array.from({length:12},(ba,Iu)=>Iu+161),...Array.from({length:82},(ba,Iu)=>Iu+174)],wr=xu.slice();let Po=0;for(let ba=0;ba<256;++ba)xu.includes(ba)||(xu.push(ba),wr.push(256+Po),Po+=1);const Zs=wr.map(ba=>String.fromCharCode(ba));return Object.fromEntries(xu.map((ba,Iu)=>[ba,Zs[Iu]]))})(),Yo=(0,h.reverseDictionary)(Ir);class Bu extends Js{constructor(wr){super(wr),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=At(wr.vocab),this.unk_token_id=this.tokens_to_ids.get(wr.unk_token),this.unk_token=wr.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[Po,Zs]of this.tokens_to_ids)this.vocab[Zs]=Po;this.bpe_ranks=new Map(wr.merges.map((Po,Zs)=>[Po,Zs])),this.merges=wr.merges.map(Po=>Po.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=wr.end_of_word_suffix,this.continuing_subword_suffix=wr.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(wr){if(wr.length===0)return[];const Po=this.cache.get(wr);if(Po!==void 0)return Po;const Zs=Array.from(wr);this.end_of_word_suffix&&(Zs[Zs.length-1]+=this.end_of_word_suffix);let ba=[];if(Zs.length>1){const Iu=new $.PriorityQueue((b_,z_)=>b_.score<z_.score);let a_={token:Zs[0],bias:0,prev:null,next:null},D_=a_;for(let b_=1;b_<Zs.length;++b_){const z_={bias:b_/Zs.length,token:Zs[b_],prev:D_,next:null};D_.next=z_,this._add_node(Iu,D_),D_=z_}for(;!Iu.isEmpty();){const b_=Iu.pop();if(b_.deleted||!b_.next||b_.next.deleted)continue;if(b_.deleted=!0,b_.next.deleted=!0,b_.prev){const C_={...b_.prev};b_.prev.deleted=!0,b_.prev=C_,C_.prev?C_.prev.next=C_:a_=C_}const z_={token:b_.token+b_.next.token,bias:b_.bias,prev:b_.prev,next:b_.next.next};z_.prev?(z_.prev.next=z_,this._add_node(Iu,z_.prev)):a_=z_,z_.next&&(z_.next.prev=z_,this._add_node(Iu,z_))}for(let b_=a_;b_!==null;b_=b_.next)ba.push(b_.token)}else ba=Zs;if(this.continuing_subword_suffix)for(let Iu=0;Iu<ba.length-1;++Iu)ba[Iu]+=this.continuing_subword_suffix;return this.cache.set(wr,ba),ba}_add_node(wr,Po){const Zs=this.bpe_ranks.get(Po.token+this.BPE_SPLIT_TOKEN+Po.next.token);Zs!==void 0&&(Po.score=Zs+Po.bias,wr.push(Po))}encode(wr){const Po=[];for(const Zs of wr){if(this.ignore_merges&&this.tokens_to_ids.has(Zs)){Po.push(Zs);continue}const ba=this.bpe(Zs);for(const Iu of ba)if(this.tokens_to_ids.has(Iu))Po.push(Iu);else if(this.byte_fallback){const a_=Array.from(this.text_encoder.encode(Iu)).map(D_=>`<0x${D_.toString(16).toUpperCase().padStart(2,"0")}>`);a_.every(D_=>this.tokens_to_ids.has(D_))?Po.push(...a_):Po.push(this.unk_token)}else Po.push(this.unk_token)}return Po}}class Ho extends Js{constructor(wr,Po){super(wr),this.tokens_to_ids=At(Po.target_lang?wr.vocab[Po.target_lang]:wr.vocab),this.bos_token=Po.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=Po.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=Po.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=Po.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[Zs,ba]of this.tokens_to_ids)this.vocab[ba]=Zs}encode(wr){return wr}}class tn extends s.Callable{constructor(wr){super(),this.config=wr}static fromConfig(wr){if(wr===null)return null;switch(wr.type){case"BertNormalizer":return new d_(wr);case"Precompiled":return new yy(wr);case"Sequence":return new r_(wr);case"Replace":return new To(wr);case"NFC":return new Qo(wr);case"NFKC":return new Jr(wr);case"NFKD":return new Lo(wr);case"Strip":return new Du(wr);case"StripAccents":return new _u(wr);case"Lowercase":return new du(wr);case"Prepend":return new wu(wr);default:throw new Error(`Unknown Normalizer type: ${wr.type}`)}}normalize(wr){throw Error("normalize should be implemented in subclass.")}_call(wr){return this.normalize(wr)}}class To extends tn{normalize(wr){const Po=Ot(this.config.pattern);return Po===null?wr:wr.replaceAll(Po,this.config.content)}}class Qo extends tn{normalize(wr){return wr=wr.normalize("NFC"),wr}}class Jr extends tn{normalize(wr){return wr=wr.normalize("NFKC"),wr}}class Lo extends tn{normalize(wr){return wr=wr.normalize("NFKD"),wr}}class Du extends tn{normalize(wr){return this.config.strip_left&&this.config.strip_right?wr=wr.trim():(this.config.strip_left&&(wr=wr.trimStart()),this.config.strip_right&&(wr=wr.trimEnd())),wr}}class _u extends tn{normalize(wr){return wr=xt(wr),wr}}class du extends tn{normalize(wr){return wr=wr.toLowerCase(),wr}}class wu extends tn{normalize(wr){return wr=this.config.prepend+wr,wr}}class r_ extends tn{constructor(wr){super(wr),this.normalizers=wr.normalizers.map(Po=>tn.fromConfig(Po))}normalize(wr){return this.normalizers.reduce((Po,Zs)=>Zs.normalize(Po),wr)}}class d_ extends tn{_tokenize_chinese_chars(wr){const Po=[];for(let Zs=0;Zs<wr.length;++Zs){const ba=wr[Zs],Iu=ba.charCodeAt(0);Qt(Iu)?(Po.push(" "),Po.push(ba),Po.push(" ")):Po.push(ba)}return Po.join("")}stripAccents(wr){return wr.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(wr){switch(wr){case"	":case`
`:case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(wr)}}_clean_text(wr){const Po=[];for(const Zs of wr){const ba=Zs.charCodeAt(0);ba===0||ba===65533||this._is_control(Zs)||(/^\s$/.test(Zs)?Po.push(" "):Po.push(Zs))}return Po.join("")}normalize(wr){return this.config.clean_text&&(wr=this._clean_text(wr)),this.config.handle_chinese_chars&&(wr=this._tokenize_chinese_chars(wr)),this.config.lowercase?(wr=wr.toLowerCase(),this.config.strip_accents!==!1&&(wr=this.stripAccents(wr))):this.config.strip_accents&&(wr=this.stripAccents(wr)),wr}}class na extends s.Callable{static fromConfig(wr){if(wr===null)return null;switch(wr.type){case"BertPreTokenizer":return new Ko(wr);case"Sequence":return new O_(wr);case"Whitespace":return new fy(wr);case"WhitespaceSplit":return new g_(wr);case"Metaspace":return new Ty(wr);case"ByteLevel":return new vu(wr);case"Split":return new Cu(wr);case"Punctuation":return new e_(wr);case"Digits":return new ar(wr);case"Replace":return new jo(wr);default:throw new Error(`Unknown PreTokenizer type: ${wr.type}`)}}pre_tokenize_text(wr,Po){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(wr,Po){return(Array.isArray(wr)?wr.map(Zs=>this.pre_tokenize_text(Zs,Po)):this.pre_tokenize_text(wr,Po)).flat()}_call(wr,Po){return this.pre_tokenize(wr,Po)}}class Ko extends na{constructor(wr){super(),this.pattern=new RegExp(`[^\\s${vr}]+|[${vr}]`,"gu")}pre_tokenize_text(wr,Po){return wr.trim().match(this.pattern)||[]}}class vu extends na{constructor(wr){super(),this.config=wr,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=Ir,this.text_encoder=new TextEncoder}pre_tokenize_text(wr,Po){return this.add_prefix_space&&!wr.startsWith(" ")&&(wr=" "+wr),(this.use_regex?wr.match(this.pattern)||[]:[wr]).map(ba=>Array.from(this.text_encoder.encode(ba),Iu=>this.byte_encoder[Iu]).join(""))}}class Cu extends na{constructor(wr){super(),this.config=wr,this.pattern=Ot(this.config.pattern,this.config.invert)}pre_tokenize_text(wr,Po){return this.pattern===null?[]:this.config.invert?wr.match(this.pattern)||[]:at(wr,this.pattern)}}class e_ extends na{constructor(wr){super(),this.config=wr,this.pattern=new RegExp(`[^${vr}]+|[${vr}]+`,"gu")}pre_tokenize_text(wr,Po){return wr.match(this.pattern)||[]}}class ar extends na{constructor(wr){super(),this.config=wr;const Po=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(Po,"gu")}pre_tokenize_text(wr,Po){return wr.match(this.pattern)||[]}}class Qs extends s.Callable{constructor(wr){super(),this.config=wr}static fromConfig(wr){if(wr===null)return null;switch(wr.type){case"TemplateProcessing":return new Eo(wr);case"ByteLevel":return new js(wr);case"RobertaProcessing":return new $o(wr);case"BertProcessing":return new _a(wr);case"Sequence":return new Lr(wr);default:throw new Error(`Unknown PostProcessor type: ${wr.type}`)}}post_process(wr,...Po){throw Error("post_process should be implemented in subclass.")}_call(wr,...Po){return this.post_process(wr,...Po)}}class _a extends Qs{constructor(wr){super(wr),this.cls=wr.cls[0],this.sep=wr.sep[0]}post_process(wr,Po=null,{add_special_tokens:Zs=!0}={}){Zs&&(wr=(0,h.mergeArrays)([this.cls],wr,[this.sep]));let ba=new Array(wr.length).fill(0);if(Po!==null){const Iu=Zs&&this instanceof $o?[this.sep]:[],a_=Zs?[this.sep]:[];wr=(0,h.mergeArrays)(wr,Iu,Po,a_),ba=(0,h.mergeArrays)(ba,new Array(Po.length+Iu.length+a_.length).fill(1))}return{tokens:wr,token_type_ids:ba}}}class $o extends _a{}class Eo extends Qs{constructor(wr){super(wr),this.single=wr.single,this.pair=wr.pair}post_process(wr,Po=null,{add_special_tokens:Zs=!0}={}){const ba=Po===null?this.single:this.pair;let Iu=[],a_=[];for(const D_ of ba)"SpecialToken"in D_?Zs&&(Iu.push(D_.SpecialToken.id),a_.push(D_.SpecialToken.type_id)):"Sequence"in D_&&(D_.Sequence.id==="A"?(Iu=(0,h.mergeArrays)(Iu,wr),a_=(0,h.mergeArrays)(a_,new Array(wr.length).fill(D_.Sequence.type_id))):D_.Sequence.id==="B"&&(Iu=(0,h.mergeArrays)(Iu,Po),a_=(0,h.mergeArrays)(a_,new Array(Po.length).fill(D_.Sequence.type_id))));return{tokens:Iu,token_type_ids:a_}}}class js extends Qs{post_process(wr,Po=null){return Po&&(wr=(0,h.mergeArrays)(wr,Po)),{tokens:wr}}}class Lr extends Qs{constructor(wr){super(wr),this.processors=wr.processors.map(Po=>Qs.fromConfig(Po))}post_process(wr,Po=null,Zs={}){let ba;for(const Iu of this.processors)if(Iu instanceof js)wr=Iu.post_process(wr).tokens,Po&&(Po=Iu.post_process(Po).tokens);else{const a_=Iu.post_process(wr,Po,Zs);wr=a_.tokens,ba=a_.token_type_ids}return{tokens:wr,token_type_ids:ba}}}class rn extends s.Callable{constructor(wr){super(),this.config=wr,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=wr.trim_offsets}static fromConfig(wr){if(wr===null)return null;switch(wr.type){case"WordPiece":return new au(wr);case"Metaspace":return new ey(wr);case"ByteLevel":return new i_(wr);case"Replace":return new Kr(wr);case"ByteFallback":return new Oo(wr);case"Fuse":return new Mo(wr);case"Strip":return new qs(wr);case"Sequence":return new m_(wr);case"CTC":return new $u(wr);case"BPEDecoder":return new L_(wr);default:throw new Error(`Unknown Decoder type: ${wr.type}`)}}_call(wr){return this.decode(wr)}decode(wr){return this.decode_chain(wr).join("")}decode_chain(wr){throw Error("`decode_chain` should be implemented in subclass.")}}class Kr extends rn{decode_chain(wr){const Po=Ot(this.config.pattern);return Po===null?wr:wr.map(Zs=>Zs.replaceAll(Po,this.config.content))}}class Oo extends rn{constructor(wr){super(wr),this.text_decoder=new TextDecoder}decode_chain(wr){const Po=[];let Zs=[];for(const ba of wr){let Iu=null;if(ba.length===6&&ba.startsWith("<0x")&&ba.endsWith(">")){const a_=parseInt(ba.slice(3,5),16);isNaN(a_)||(Iu=a_)}if(Iu!==null)Zs.push(Iu);else{if(Zs.length>0){const a_=this.text_decoder.decode(Uint8Array.from(Zs));Po.push(a_),Zs=[]}Po.push(ba)}}if(Zs.length>0){const ba=this.text_decoder.decode(Uint8Array.from(Zs));Po.push(ba),Zs=[]}return Po}}class Mo extends rn{decode_chain(wr){return[wr.join("")]}}class qs extends rn{constructor(wr){super(wr),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(wr){return wr.map(Po=>{let Zs=0;for(let Iu=0;Iu<this.start&&Po[Iu]===this.content;++Iu){Zs=Iu+1;continue}let ba=Po.length;for(let Iu=0;Iu<this.stop;++Iu){const a_=Po.length-Iu-1;if(Po[a_]===this.content){ba=a_;continue}else break}return Po.slice(Zs,ba)})}}class au extends rn{constructor(wr){super(wr),this.cleanup=wr.cleanup}decode_chain(wr){return wr.map((Po,Zs)=>(Zs!==0&&(Po.startsWith(this.config.prefix)?Po=Po.replace(this.config.prefix,""):Po=" "+Po),this.cleanup&&(Po=St(Po)),Po))}}class i_ extends rn{constructor(wr){super(wr),this.byte_decoder=Yo,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(wr){const Po=wr.join(""),Zs=new Uint8Array([...Po].map(Iu=>this.byte_decoder[Iu]));return this.text_decoder.decode(Zs)}decode_chain(wr){const Po=[];let Zs=[];for(const ba of wr)this.added_tokens.find(Iu=>Iu.content===ba)!==void 0?(Zs.length>0&&(Po.push(this.convert_tokens_to_string(Zs)),Zs=[]),Po.push(ba)):Zs.push(ba);return Zs.length>0&&Po.push(this.convert_tokens_to_string(Zs)),Po}}class $u extends rn{constructor(wr){super(wr),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(wr){if(wr.length===0)return"";const Po=[wr[0]];for(let Iu=1;Iu<wr.length;++Iu)wr[Iu]!==Po.at(-1)&&Po.push(wr[Iu]);let ba=Po.filter(Iu=>Iu!==this.pad_token).join("");return this.cleanup&&(ba=St(ba).replaceAll(this.word_delimiter_token," ").trim()),ba}decode_chain(wr){return[this.convert_tokens_to_string(wr)]}}class m_ extends rn{constructor(wr){super(wr),this.decoders=wr.decoders.map(Po=>rn.fromConfig(Po))}decode_chain(wr){return this.decoders.reduce((Po,Zs)=>Zs.decode_chain(Po),wr)}}class L_ extends rn{constructor(wr){super(wr),this.suffix=this.config.suffix}decode_chain(wr){return wr.map((Po,Zs)=>Po.replaceAll(this.suffix,Zs===wr.length-1?"":" "))}}class Z_ extends rn{decode_chain(wr){let Po="";for(let Zs=1;Zs<wr.length;Zs+=2)Po+=wr[Zs];return[Po]}}class Ty extends na{constructor(wr){super(),this.addPrefixSpace=wr.add_prefix_space,this.replacement=wr.replacement,this.strRep=wr.str_rep||this.replacement,this.prepend_scheme=wr.prepend_scheme??"always"}pre_tokenize_text(wr,{section_index:Po=void 0}={}){let Zs=wr.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!Zs.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&Po===0)&&(Zs=this.strRep+Zs),[Zs]}}class ey extends rn{constructor(wr){super(wr),this.addPrefixSpace=wr.add_prefix_space,this.replacement=wr.replacement}decode_chain(wr){const Po=[];for(let Zs=0;Zs<wr.length;++Zs){let ba=wr[Zs].replaceAll(this.replacement," ");this.addPrefixSpace&&Zs==0&&ba.startsWith(" ")&&(ba=ba.substring(1)),Po.push(ba)}return Po}}class yy extends tn{constructor(wr){super(wr),this.charsmap=wr.precompiled_charsmap}normalize(wr){return wr=wr.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),wr=wr.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," "),wr.includes("")?wr=wr.split("").map(Zs=>Zs.normalize("NFKC")).join(""):wr=wr.normalize("NFKC"),wr}}class O_ extends na{constructor(wr){super(),this.tokenizers=wr.pretokenizers.map(Po=>na.fromConfig(Po))}pre_tokenize_text(wr,Po){return this.tokenizers.reduce((Zs,ba)=>ba.pre_tokenize(Zs,Po),[wr])}}class fy extends na{constructor(wr){super()}pre_tokenize_text(wr,Po){return wr.match(/\w+|[^\w\s]+/g)||[]}}class g_ extends na{constructor(wr){super()}pre_tokenize_text(wr,Po){return gr(wr)}}class jo extends na{constructor(wr){super(),this.config=wr,this.pattern=Ot(this.config.pattern),this.content=this.config.content}pre_tokenize_text(wr,Po){return this.pattern===null?[wr]:[wr.replaceAll(this.pattern,this.config.content)]}}const Xs=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function _d(xu,wr,Po,Zs){for(const ba of Object.keys(xu)){const Iu=wr-xu[ba].length,a_=Po(ba),D_=new Array(Iu).fill(a_);xu[ba]=Zs==="right"?(0,h.mergeArrays)(xu[ba],D_):(0,h.mergeArrays)(D_,xu[ba])}}function w_(xu,wr){for(const Po of Object.keys(xu))xu[Po].length=wr}class mu extends s.Callable{return_token_type_ids=!1;padding_side="right";constructor(wr,Po){super(),this._tokenizer_config=Po,this.normalizer=tn.fromConfig(wr.normalizer),this.pre_tokenizer=na.fromConfig(wr.pre_tokenizer),this.model=Js.fromConfig(wr.model,Po),this.post_processor=Qs.fromConfig(wr.post_processor),this.decoder=rn.fromConfig(wr.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const Zs of wr.added_tokens){const ba=new Do(Zs);this.added_tokens.push(ba),this.model.tokens_to_ids.set(ba.content,ba.id),this.model.vocab[ba.id]=ba.content,ba.special&&(this.special_tokens.push(ba.content),this.all_special_ids.push(ba.id))}if(this.additional_special_tokens=Po.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort((Zs,ba)=>ba.content.length-Zs.content.length).map(Zs=>`${Zs.lstrip?"\\s*":""}(${(0,h.escapeRegExp)(Zs.content)})${Zs.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=Po.model_max_length,this.remove_space=Po.remove_space,this.clean_up_tokenization_spaces=Po.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=Po.do_lowercase_and_remove_accent??!1,Po.padding_side&&(this.padding_side=Po.padding_side),this.legacy=!1,this.chat_template=Po.chat_template??null,Array.isArray(this.chat_template)){const Zs=Object.create(null);for(const{name:ba,template:Iu}of this.chat_template){if(typeof ba!="string"||typeof Iu!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');Zs[ba]=Iu}this.chat_template=Zs}this._compiled_template_cache=new Map}getToken(...wr){for(const Po of wr){const Zs=this._tokenizer_config[Po];if(Zs)if(typeof Zs=="object"){if(Zs.__type==="AddedToken")return Zs.content;throw Error(`Unknown token: ${Zs}`)}else return Zs}return null}static async from_pretrained(wr,{progress_callback:Po=null,config:Zs=null,cache_dir:ba=null,local_files_only:Iu=!1,revision:a_="main",legacy:D_=null}={}){const b_=await nt(wr,{progress_callback:Po,config:Zs,cache_dir:ba,local_files_only:Iu,revision:a_,legacy:D_});return new this(...b_)}_call(wr,{text_pair:Po=null,add_special_tokens:Zs=!0,padding:ba=!1,truncation:Iu=null,max_length:a_=null,return_tensor:D_=!0,return_token_type_ids:b_=null}={}){const z_=Array.isArray(wr);let C_;if(z_){if(wr.length===0)throw Error("text array must be non-empty");if(Po!==null){if(Array.isArray(Po)){if(wr.length!==Po.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");C_=wr.map((ay,wy)=>this._encode_plus(ay,{text_pair:Po[wy],add_special_tokens:Zs,return_token_type_ids:b_}))}else C_=wr.map(ay=>this._encode_plus(ay,{add_special_tokens:Zs,return_token_type_ids:b_}))}else{if(wr==null)throw Error("text may not be null or undefined");if(Array.isArray(Po))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");C_=[this._encode_plus(wr,{text_pair:Po,add_special_tokens:Zs,return_token_type_ids:b_})]}if(a_===null?ba==="max_length"?a_=this.model_max_length:a_=(0,d.max)(C_.map(ay=>ay.input_ids.length))[0]:Iu||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),a_=Math.min(a_,this.model_max_length??1/0),ba||Iu)for(let ay=0;ay<C_.length;++ay)C_[ay].input_ids.length!==a_&&(C_[ay].input_ids.length>a_?Iu&&w_(C_[ay],a_):ba&&_d(C_[ay],a_,wy=>wy==="input_ids"?this.pad_token_id:0,this.padding_side));const Cy={};if(D_){if(!(ba&&Iu)&&C_.some(wy=>{for(const sy of Object.keys(wy))if(wy[sy].length!==C_[0][sy]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const ay=[C_.length,C_[0].input_ids.length];for(const wy of Object.keys(C_[0]))Cy[wy]=new et.Tensor("int64",BigInt64Array.from(C_.flatMap(sy=>sy[wy]).map(BigInt)),ay)}else{for(const ay of Object.keys(C_[0]))Cy[ay]=C_.map(wy=>wy[ay]);if(!z_)for(const ay of Object.keys(Cy))Cy[ay]=Cy[ay][0]}return Cy}_encode_text(wr){return wr===null?null:(this.added_tokens_regex?wr.split(this.added_tokens_regex).filter(ba=>ba):[wr]).map((ba,Iu)=>{if(this.added_tokens.find(D_=>D_.content===ba)!==void 0)return ba;{if(this.remove_space===!0&&(ba=ba.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(ba=Dt(ba)),this.normalizer!==null&&(ba=this.normalizer(ba)),ba.length===0)return[];const D_=this.pre_tokenizer!==null?this.pre_tokenizer(ba,{section_index:Iu}):[ba];return this.model(D_)}}).flat()}_encode_plus(wr,{text_pair:Po=null,add_special_tokens:Zs=!0,return_token_type_ids:ba=null}={}){const{tokens:Iu,token_type_ids:a_}=this._tokenize_helper(wr,{pair:Po,add_special_tokens:Zs}),D_=this.model.convert_tokens_to_ids(Iu),b_={input_ids:D_,attention_mask:new Array(D_.length).fill(1)};return(ba??this.return_token_type_ids)&&a_&&(b_.token_type_ids=a_),b_}_tokenize_helper(wr,{pair:Po=null,add_special_tokens:Zs=!1}={}){const ba=this._encode_text(wr),Iu=this._encode_text(Po);return this.post_processor?this.post_processor(ba,Iu,{add_special_tokens:Zs}):{tokens:(0,h.mergeArrays)(ba??[],Iu??[])}}tokenize(wr,{pair:Po=null,add_special_tokens:Zs=!1}={}){return this._tokenize_helper(wr,{pair:Po,add_special_tokens:Zs}).tokens}encode(wr,{text_pair:Po=null,add_special_tokens:Zs=!0,return_token_type_ids:ba=null}={}){return this._encode_plus(wr,{text_pair:Po,add_special_tokens:Zs,return_token_type_ids:ba}).input_ids}batch_decode(wr,Po={}){return wr instanceof et.Tensor&&(wr=wr.tolist()),wr.map(Zs=>this.decode(Zs,Po))}decode(wr,Po={}){if(wr instanceof et.Tensor&&(wr=Ct(wr)),!Array.isArray(wr)||wr.length===0||!(0,h.isIntegralNumber)(wr[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(wr,Po)}decode_single(wr,{skip_special_tokens:Po=!1,clean_up_tokenization_spaces:Zs=null}){let ba=this.model.convert_ids_to_tokens(wr);Po&&(ba=ba.filter(a_=>!this.special_tokens.includes(a_)));let Iu=this.decoder?this.decoder(ba):ba.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(Iu=Iu.replaceAll(this.decoder.end_of_word_suffix," "),Po&&(Iu=Iu.trim())),(Zs??this.clean_up_tokenization_spaces)&&(Iu=St(Iu)),Iu}get_chat_template({chat_template:wr=null,tools:Po=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const Zs=this.chat_template;if(wr!==null&&Object.hasOwn(Zs,wr))wr=Zs[wr];else if(wr===null)if(Po!==null&&"tool_use"in Zs)wr=Zs.tool_use;else if("default"in Zs)wr=Zs.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(Zs).sort()}.`)}else if(wr===null)if(this.chat_template)wr=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return wr}apply_chat_template(wr,{tools:Po=null,documents:Zs=null,chat_template:ba=null,add_generation_prompt:Iu=!1,tokenize:a_=!0,padding:D_=!1,truncation:b_=!1,max_length:z_=null,return_tensor:C_=!0,return_dict:Cy=!1,tokenizer_kwargs:ay={},...wy}={}){if(ba=this.get_chat_template({chat_template:ba,tools:Po}),typeof ba!="string")throw Error(`chat_template must be a string, but got ${typeof ba}`);let sy=this._compiled_template_cache.get(ba);sy===void 0&&(sy=new c.Template(ba),this._compiled_template_cache.set(ba,sy));const Ey=Object.create(null);for(const h0 of Xs){const Uu=this.getToken(h0);Uu&&(Ey[h0]=Uu)}const L0=sy.render({messages:wr,add_generation_prompt:Iu,tools:Po,documents:Zs,...Ey,...wy});if(a_){const h0=this._call(L0,{add_special_tokens:!1,padding:D_,truncation:b_,max_length:z_,return_tensor:C_,...ay});return Cy?h0:h0.input_ids}return L0}}class y_ extends mu{return_token_type_ids=!0}class k_ extends mu{return_token_type_ids=!0}class S_ extends mu{return_token_type_ids=!0}class B_ extends mu{return_token_type_ids=!0}class P_ extends mu{return_token_type_ids=!0}class N_ extends mu{return_token_type_ids=!0}class q_ extends mu{return_token_type_ids=!0}class H_ extends mu{return_token_type_ids=!0}class j_ extends mu{return_token_type_ids=!0}class pu extends mu{}class T_ extends mu{}class E_ extends mu{return_token_type_ids=!0;constructor(wr,Po){super(wr,Po),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class iy extends mu{return_token_type_ids=!0}class Ry extends mu{}class Zy extends mu{}class hy extends mu{}class Ay extends mu{constructor(wr,Po){super(wr,Po),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(Zs=>this.languageRegex.test(Zs)),this.lang_to_token=Zs=>Zs}_build_translation_inputs(wr,Po,Zs){return X0(this,wr,Po,Zs)}}class Sy extends Ay{}class K0 extends mu{}class n0 extends mu{constructor(wr,Po){const Zs=".,!?",ba=wr.pre_tokenizer?.pretokenizers[0]?.pattern;ba&&ba.Regex===` ?[^(\\s|[${Zs}])]+`&&(ba.Regex=` ?[^\\s${Zs}]+`),super(wr,Po)}}const A0="";class G0 extends mu{padding_side="left";constructor(wr,Po){super(wr,Po),this.legacy=Po.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new Ty({replacement:A0,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(wr){if(wr===null)return null;if(this.legacy||wr.length===0)return super._encode_text(wr);let Po=super._encode_text(A0+wr.replaceAll(A0," "));return Po.length>1&&Po[0]===A0&&this.special_tokens.includes(Po[1])&&(Po=Po.slice(1)),Po}}class N0 extends mu{}class xw extends mu{}class uw extends mu{}class i0 extends mu{}class q0 extends mu{}class M0 extends mu{}class Cw extends mu{}class P0 extends mu{}class F0 extends mu{}function X0(xu,wr,Po,Zs){if(!("language_codes"in xu)||!Array.isArray(xu.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in xu)||!(xu.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in xu)||typeof xu.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const ba=Zs.src_lang,Iu=Zs.tgt_lang;if(!xu.language_codes.includes(Iu))throw new Error(`Target language code "${Iu}" is not valid. Must be one of: {${xu.language_codes.join(", ")}}`);if(ba!==void 0){if(!xu.language_codes.includes(ba))throw new Error(`Source language code "${ba}" is not valid. Must be one of: {${xu.language_codes.join(", ")}}`);for(const a_ of xu.post_processor.config.single)if("SpecialToken"in a_&&xu.languageRegex.test(a_.SpecialToken.id)){a_.SpecialToken.id=xu.lang_to_token(ba);break}}return Zs.forced_bos_token_id=xu.model.convert_tokens_to_ids([xu.lang_to_token(Iu)])[0],xu._call(wr,Po)}class Y0 extends mu{constructor(wr,Po){super(wr,Po),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(Zs=>this.languageRegex.test(Zs)),this.lang_to_token=Zs=>Zs}_build_translation_inputs(wr,Po,Zs){return X0(this,wr,Po,Zs)}}class U0 extends mu{constructor(wr,Po){super(wr,Po),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(Zs=>this.languageRegex.test(Zs)).map(Zs=>Zs.slice(2,-2)),this.lang_to_token=Zs=>`__${Zs}__`}_build_translation_inputs(wr,Po,Zs){return X0(this,wr,Po,Zs)}}class _w extends mu{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(wr,{return_timestamps:Po=!1,return_language:Zs=!1,time_precision:ba=null,force_full_sequences:Iu=!0}={}){if(ba===null)throw Error("Must specify time_precision");let a_=null;const D_=Po==="word";function b_(){return{language:a_,timestamp:[null,null],text:""}}const z_=[];let C_=b_(),Cy=0;const ay=this.timestamp_begin;let wy=[],sy=[],Ey=!1,L0=null;const h0=new Set(this.all_special_ids);for(const Iy of wr){const _0=Iy.tokens,ry=D_?Iy.token_timestamps:null;let J_=null,k0=ay;if("stride"in Iy){const[zy,U_,_y]=Iy.stride;if(Cy-=U_,L0=zy-_y,U_&&(k0=U_/ba+ay),_y)for(let Ky=_0.length-1;Ky>=0;--Ky){const s0=Number(_0[Ky]);if(s0>=ay){if(J_!==null&&(s0-ay)*ba<L0)break;J_=s0}}}let e0=[],jy=[];for(let zy=0;zy<_0.length;++zy){const U_=Number(_0[zy]);if(h0.has(U_)){const _y=this.decode([U_]),Ky=b.WHISPER_LANGUAGE_MAPPING.get(_y.slice(2,-2));if(Ky!==void 0){if(a_!==null&&Ky!==a_&&!Po){wy.push(e0);const s0=this.findLongestCommonSequence(wy)[0],S0=this.decode(s0);C_.text=S0,z_.push(C_),wy=[],e0=[],C_=b_()}a_=C_.language=Ky}}else if(U_>=ay){const _y=(U_-ay)*ba+Cy,Ky=(0,d.round)(_y,2);if(J_!==null&&U_>=J_)Ey=!0;else if(Ey||wy.length>0&&U_<k0)Ey=!1;else if(C_.timestamp[0]===null)C_.timestamp[0]=Ky;else if(Ky!==C_.timestamp[0]){C_.timestamp[1]=Ky,wy.push(e0),D_&&sy.push(jy);const[s0,S0]=this.findLongestCommonSequence(wy,sy),X_=this.decode(s0);C_.text=X_,D_&&(C_.words=this.collateWordTimestamps(s0,S0,a_)),z_.push(C_),wy=[],e0=[],sy=[],jy=[],C_=b_()}}else if(e0.push(U_),D_){let _y=(0,d.round)(ry[zy]+Cy,2),Ky;if(zy+1<ry.length){Ky=(0,d.round)(ry[zy+1]+Cy,2);const s0=this.decode([U_]);Er.test(s0)&&(Ky=(0,d.round)(Math.min(_y+ba,Ky),2))}else Ky=null;jy.push([_y,Ky])}}if("stride"in Iy){const[zy,U_,_y]=Iy.stride;Cy+=zy-_y}e0.length>0?(wy.push(e0),D_&&sy.push(jy)):wy.every(zy=>zy.length===0)&&(C_=b_(),wy=[],e0=[],sy=[],jy=[])}if(wy.length>0){if(Iu&&Po)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[Iy,_0]=this.findLongestCommonSequence(wy,sy),ry=this.decode(Iy);C_.text=ry,D_&&(C_.words=this.collateWordTimestamps(Iy,_0,a_)),z_.push(C_)}let Uu=Object.create(null);const g0=z_.map(Iy=>Iy.text).join("");if(Po||Zs){for(let Iy=0;Iy<z_.length;++Iy){const _0=z_[Iy];Po||delete _0.timestamp,Zs||delete _0.language}if(D_){const Iy=[];for(const _0 of z_)for(const ry of _0.words)Iy.push(ry);Uu={chunks:Iy}}else Uu={chunks:z_}}return[g0,Uu]}findLongestCommonSequence(wr,Po=null){let Zs=wr[0],ba=Zs.length,Iu=[];const a_=Array.isArray(Po)&&Po.length>0;let D_=a_?[]:null,b_=a_?Po[0]:null;for(let z_=1;z_<wr.length;++z_){const C_=wr[z_];let Cy=0,ay=[ba,ba,0,0];const wy=C_.length;for(let Iy=1;Iy<ba+wy;++Iy){const _0=Math.max(0,ba-Iy),ry=Math.min(ba,ba+wy-Iy),J_=Zs.slice(_0,ry),k0=Math.max(0,Iy-ba),e0=Math.min(wy,Iy),jy=C_.slice(k0,e0);if(J_.length!==jy.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let zy;a_?zy=J_.filter((Ky,s0)=>Ky===jy[s0]&&b_[_0+s0]<=Po[z_][k0+s0]).length:zy=J_.filter((Ky,s0)=>Ky===jy[s0]).length;const U_=Iy/1e4,_y=zy/Iy+U_;zy>1&&_y>Cy&&(Cy=_y,ay=[_0,ry,k0,e0])}const[sy,Ey,L0,h0]=ay,Uu=Math.floor((Ey+sy)/2),g0=Math.floor((h0+L0)/2);Iu.push(...Zs.slice(0,Uu)),Zs=C_.slice(g0),ba=Zs.length,a_&&(D_.push(...b_.slice(0,Uu)),b_=Po[z_].slice(g0))}return Iu.push(...Zs),a_?(D_.push(...b_),[Iu,D_]):[Iu,[]]}collateWordTimestamps(wr,Po,Zs){const[ba,Iu,a_]=this.combineTokensIntoWords(wr,Zs),D_=[];for(let b_=0;b_<ba.length;++b_){const z_=a_[b_];D_.push({text:ba[b_],timestamp:[Po[z_.at(0)][0],Po[z_.at(-1)][1]]})}return D_}combineTokensIntoWords(wr,Po,Zs=`"'([{-`,ba=`"'.,!?:)]}`){Po=Po??"english";let Iu,a_,D_;return["chinese","japanese","thai","lao","myanmar"].includes(Po)?[Iu,a_,D_]=this.splitTokensOnUnicode(wr):[Iu,a_,D_]=this.splitTokensOnSpaces(wr),this.mergePunctuations(Iu,a_,D_,Zs,ba)}decode(wr,Po){let Zs;return Po?.decode_with_timestamps?(wr instanceof et.Tensor&&(wr=Ct(wr)),Zs=this.decodeWithTimestamps(wr,Po)):Zs=super.decode(wr,Po),Zs}decodeWithTimestamps(wr,Po){const Zs=Po?.time_precision??.02,ba=Array.from(this.all_special_ids).at(-1)+1;let Iu=[[]];for(let a_ of wr)if(a_=Number(a_),a_>=ba){const D_=((a_-ba)*Zs).toFixed(2);Iu.push(`<|${D_}|>`),Iu.push([])}else Iu[Iu.length-1].push(a_);return Iu=Iu.map(a_=>typeof a_=="string"?a_:super.decode(a_,Po)),Iu.join("")}splitTokensOnUnicode(wr){const Po=this.decode(wr,{decode_with_timestamps:!0}),Zs="",ba=[],Iu=[],a_=[];let D_=[],b_=[],z_=0;for(let C_=0;C_<wr.length;++C_){const Cy=wr[C_];D_.push(Cy),b_.push(C_);const ay=this.decode(D_,{decode_with_timestamps:!0});(!ay.includes(Zs)||Po[z_+ay.indexOf(Zs)]===Zs)&&(ba.push(ay),Iu.push(D_),a_.push(b_),D_=[],b_=[],z_+=ay.length)}return[ba,Iu,a_]}splitTokensOnSpaces(wr){const[Po,Zs,ba]=this.splitTokensOnUnicode(wr),Iu=[],a_=[],D_=[],b_=new RegExp(`^[${vr}]$`,"gu");for(let z_=0;z_<Po.length;++z_){const C_=Po[z_],Cy=Zs[z_],ay=ba[z_],wy=Cy[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),sy=C_.startsWith(" "),Ey=C_.trim(),L0=b_.test(Ey);if(wy||sy||L0||Iu.length===0)Iu.push(C_),a_.push(Cy),D_.push(ay);else{const h0=Iu.length-1;Iu[h0]+=C_,a_[h0].push(...Cy),D_[h0].push(...ay)}}return[Iu,a_,D_]}mergePunctuations(wr,Po,Zs,ba,Iu){const a_=structuredClone(wr),D_=structuredClone(Po),b_=structuredClone(Zs);let z_=a_.length-2,C_=a_.length-1;for(;z_>=0;)a_[z_].startsWith(" ")&&ba.includes(a_[z_].trim())?(a_[C_]=a_[z_]+a_[C_],D_[C_]=(0,h.mergeArrays)(D_[z_],D_[C_]),b_[C_]=(0,h.mergeArrays)(b_[z_],b_[C_]),a_[z_]="",D_[z_]=[],b_[z_]=[]):C_=z_,--z_;for(z_=0,C_=1;C_<a_.length;)!a_[z_].endsWith(" ")&&Iu.includes(a_[C_])?(a_[z_]+=a_[C_],D_[z_]=(0,h.mergeArrays)(D_[z_],D_[C_]),b_[z_]=(0,h.mergeArrays)(b_[z_],b_[C_]),a_[C_]="",D_[C_]=[],b_[C_]=[]):z_=C_,++C_;return[a_.filter(Cy=>Cy),D_.filter(Cy=>Cy.length>0),b_.filter(Cy=>Cy.length>0)]}get_decoder_prompt_ids({language:wr=null,task:Po=null,no_timestamps:Zs=!0}={}){const ba=[];if(wr){const Iu=(0,b.whisper_language_to_code)(wr),a_=this.model.tokens_to_ids.get(`<|${Iu}|>`);if(a_===void 0)throw new Error(`Unable to find language "${Iu}" in model vocabulary. Please report this issue at ${g.GITHUB_ISSUE_URL}.`);ba.push(a_)}else ba.push(null);if(Po){if(Po=Po.toLowerCase(),Po!=="transcribe"&&Po!=="translate")throw new Error(`Task "${Po}" is not supported. Must be one of: ["transcribe", "translate"]`);const Iu=this.model.tokens_to_ids.get(`<|${Po}|>`);if(Iu===void 0)throw new Error(`Unable to find task "${Po}" in model vocabulary. Please report this issue at ${g.GITHUB_ISSUE_URL}.`);ba.push(Iu)}else ba.push(null);if(Zs){const Iu=this.model.tokens_to_ids.get("<|notimestamps|>");if(Iu===void 0)throw new Error(`Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at ${g.GITHUB_ISSUE_URL}.`);ba.push(Iu)}return ba.map((Iu,a_)=>[a_+1,Iu]).filter(Iu=>Iu[1]!==null)}}class tw extends mu{}class ly extends mu{}class by extends mu{}class Tw extends mu{constructor(wr,Po){super(wr,Po),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(Zs=>this.languageRegex.test(Zs)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(wr){if(wr===null)return null;const[Po,...Zs]=wr.trim().split(this.languageRegex);if(Zs.length===0)return super._encode_text(Po);if(Zs.length===2){const[ba,Iu]=Zs;return this.supported_language_codes.includes(ba)||console.warn(`Unsupported language code "${ba}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,h.mergeArrays)([ba],super._encode_text(Iu))}}}class Ew extends mu{}class yw extends mu{}class Yy extends mu{}class rw extends mu{}class nw extends mu{}class ow extends mu{constructor(wr,Po){super(wr,Po),this.decoder=new Z_({})}}class Jy extends mu{}class R0{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:Ry,DistilBertTokenizer:pu,CamembertTokenizer:T_,DebertaTokenizer:P_,DebertaV2Tokenizer:N_,BertTokenizer:y_,HerbertTokenizer:q_,ConvBertTokenizer:H_,RoFormerTokenizer:j_,XLMTokenizer:E_,ElectraTokenizer:iy,MobileBertTokenizer:S_,SqueezeBertTokenizer:B_,AlbertTokenizer:k_,GPT2Tokenizer:Zy,BartTokenizer:hy,MBartTokenizer:Ay,MBart50Tokenizer:Sy,RobertaTokenizer:K0,WhisperTokenizer:_w,CodeGenTokenizer:tw,CLIPTokenizer:ly,SiglipTokenizer:by,MarianTokenizer:Tw,BloomTokenizer:n0,NllbTokenizer:Y0,M2M100Tokenizer:U0,LlamaTokenizer:G0,CodeLlamaTokenizer:N0,XLMRobertaTokenizer:xw,MPNetTokenizer:uw,FalconTokenizer:i0,GPTNeoXTokenizer:q0,EsmTokenizer:M0,Wav2Vec2CTCTokenizer:Ew,BlenderbotTokenizer:yw,BlenderbotSmallTokenizer:Yy,SpeechT5Tokenizer:rw,NougatTokenizer:nw,VitsTokenizer:ow,Qwen2Tokenizer:Cw,GemmaTokenizer:P0,Grok1Tokenizer:F0,CohereTokenizer:Jy,PreTrainedTokenizer:mu};static async from_pretrained(wr,{progress_callback:Po=null,config:Zs=null,cache_dir:ba=null,local_files_only:Iu=!1,revision:a_="main",legacy:D_=null}={}){const[b_,z_]=await nt(wr,{progress_callback:Po,config:Zs,cache_dir:ba,local_files_only:Iu,revision:a_,legacy:D_}),C_=z_.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let Cy=this.TOKENIZER_CLASS_MAPPING[C_];return Cy||(console.warn(`Unknown tokenizer class "${C_}", attempting to construct from base class.`),Cy=mu),new Cy(b_,z_)}}},"./src/utils/audio.js":(e,o,i)=>{i.r(o),i.d(o,{hamming:()=>b,hanning:()=>c,mel_filter_bank:()=>St,read_audio:()=>et,spectrogram:()=>gr,window_function:()=>vr});var s=i("./src/utils/hub.js"),h=i("./src/utils/maths.js"),a=i("./src/utils/core.js"),d=i("./src/utils/tensor.js");async function et(Er,wo){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const Do=await(await(0,s.getFile)(Er)).arrayBuffer(),Js=new AudioContext({sampleRate:wo});typeof wo>"u"&&console.warn(`No sampling rate provided, using default of ${Js.sampleRate}Hz.`);const In=await Js.decodeAudioData(Do);let Wo;if(In.numberOfChannels===2){const Ir=Math.sqrt(2),Yo=In.getChannelData(0),Bu=In.getChannelData(1);Wo=new Float32Array(Yo.length);for(let Ho=0;Ho<In.length;++Ho)Wo[Ho]=Ir*(Yo[Ho]+Bu[Ho])/2}else Wo=In.getChannelData(0);return Wo}function $(Er,wo){if(Er<1)return new Float64Array;if(Er===1)return new Float64Array([1]);const Do=1-wo,Js=2*Math.PI/(Er-1),In=new Float64Array(Er);for(let Wo=0;Wo<Er;++Wo)In[Wo]=wo-Do*Math.cos(Wo*Js);return In}function c(Er){return $(Er,.5)}function b(Er){return $(Er,.54)}const g={htk:Er=>2595*Math.log10(1+Er/700),kaldi:Er=>1127*Math.log(1+Er/700),slaney:(Er,wo=1e3,Do=15,Js=27/Math.log(6.4))=>Er>=wo?Do+Math.log(Er/wo)*Js:3*Er/200};function nt(Er,wo="htk"){const Do=g[wo];if(!Do)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof Er=="number"?Do(Er):Er.map(Js=>Do(Js))}const at={htk:Er=>700*(10**(Er/2595)-1),kaldi:Er=>700*(Math.exp(Er/1127)-1),slaney:(Er,wo=1e3,Do=15,Js=Math.log(6.4)/27)=>Er>=Do?wo*Math.exp(Js*(Er-Do)):200*Er/3};function Ot(Er,wo="htk"){const Do=at[wo];if(!Do)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof Er=="number"?Do(Er):Er.map(Js=>Do(Js))}function At(Er,wo){const Do=Float64Array.from({length:wo.length-1},(Ir,Yo)=>wo[Yo+1]-wo[Yo]),Js=Array.from({length:Er.length},()=>new Array(wo.length));for(let Ir=0;Ir<Er.length;++Ir){const Yo=Js[Ir];for(let Bu=0;Bu<wo.length;++Bu)Yo[Bu]=wo[Bu]-Er[Ir]}const In=wo.length-2,Wo=Array.from({length:In},()=>new Array(Er.length));for(let Ir=0;Ir<Er.length;++Ir){const Yo=Js[Ir];for(let Bu=0;Bu<In;++Bu){const Ho=-Yo[Bu]/Do[Bu],tn=Yo[Bu+2]/Do[Bu+1];Wo[Bu][Ir]=Math.max(0,Math.min(Ho,tn))}}return Wo}function Ct(Er,wo,Do){const Js=(wo-Er)/(Do-1);return Float64Array.from({length:Do},(In,Wo)=>Er+Js*Wo)}function St(Er,wo,Do,Js,In,Wo=null,Ir="htk",Yo=!1){if(Wo!==null&&Wo!=="slaney")throw new Error('norm must be one of null or "slaney"');const Bu=nt(Do,Ir),Ho=nt(Js,Ir),tn=Ct(Bu,Ho,wo+2);let To=Ot(tn,Ir),Qo;if(Yo){const Lo=In/(Er*2);Qo=nt(Float64Array.from({length:Er},(Du,_u)=>_u*Lo),Ir),To=tn}else Qo=Ct(0,Math.floor(In/2),Er);const Jr=At(Qo,To);if(Wo!==null&&Wo==="slaney")for(let Lo=0;Lo<wo;++Lo){const Du=Jr[Lo],_u=2/(To[Lo+2]-To[Lo]);for(let du=0;du<Er;++du)Du[du]*=_u}return Jr}function xt(Er,wo,Do){const Js=new Er.constructor(Er.length+wo+Do),In=Er.length-1;for(let Wo=0;Wo<Er.length;++Wo)Js[wo+Wo]=Er[Wo];for(let Wo=1;Wo<=wo;++Wo)Js[wo-Wo]=Er[(0,a.calculateReflectOffset)(Wo,In)];for(let Wo=1;Wo<=Do;++Wo)Js[In+wo+Wo]=Er[(0,a.calculateReflectOffset)(In-Wo,In)];return Js}function Dt(Er,wo,Do,Js,In){if(Do<=0)throw new Error("reference must be greater than zero");if(Js<=0)throw new Error("min_value must be greater than zero");Do=Math.max(Js,Do);const Wo=Math.log10(Do);for(let Ir=0;Ir<Er.length;++Ir)Er[Ir]=wo*Math.log10(Math.max(Js,Er[Ir])-Wo);if(In!==null){if(In<=0)throw new Error("db_range must be greater than zero");const Ir=(0,h.max)(Er)[0]-In;for(let Yo=0;Yo<Er.length;++Yo)Er[Yo]=Math.max(Er[Yo],Ir)}return Er}function Qt(Er,wo=1,Do=1e-5,Js=null){return Dt(Er,20,wo,Do,Js)}function Zt(Er,wo=1,Do=1e-10,Js=null){return Dt(Er,10,wo,Do,Js)}async function gr(Er,wo,Do,Js,{fft_length:In=null,power:Wo=1,center:Ir=!0,pad_mode:Yo="reflect",onesided:Bu=!0,preemphasis:Ho=null,mel_filters:tn=null,mel_floor:To=1e-10,log_mel:Qo=null,reference:Jr=1,min_value:Lo=1e-10,db_range:Du=null,remove_dc_offset:_u=null,min_num_frames:du=null,max_num_frames:wu=null,do_pad:r_=!0,transpose:d_=!1}={}){const na=wo.length;if(In===null&&(In=Do),Do>In)throw Error(`frame_length (${Do}) may not be larger than fft_length (${In})`);if(na!==Do)throw new Error(`Length of the window (${na}) must equal frame_length (${Do})`);if(Js<=0)throw new Error("hop_length must be greater than zero");if(Wo===null&&tn!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(Ir){if(Yo!=="reflect")throw new Error(`pad_mode="${Yo}" not implemented yet.`);const rn=Math.floor((In-1)/2)+1;Er=xt(Er,rn,rn)}let Ko=Math.floor(1+Math.floor((Er.length-Do)/Js));du!==null&&Ko<du&&(Ko=du);const vu=Bu?Math.floor(In/2)+1:In;let Cu=Ko,e_=Ko;wu!==null&&(wu>Ko?r_&&(e_=wu):e_=Cu=wu);const ar=new h.FFT(In),Qs=new Float64Array(In),_a=new Float64Array(ar.outputBufferSize),$o=new Float32Array(vu*e_);for(let rn=0;rn<Cu;++rn){const Kr=rn*Js,Oo=Math.min(Er.length-Kr,Do);Oo!==Do&&Qs.fill(0,0,Do);for(let Mo=0;Mo<Oo;++Mo)Qs[Mo]=Er[Kr+Mo];if(_u){let Mo=0;for(let au=0;au<Oo;++au)Mo+=Qs[au];const qs=Mo/Oo;for(let au=0;au<Oo;++au)Qs[au]-=qs}if(Ho!==null){for(let Mo=Oo-1;Mo>=1;--Mo)Qs[Mo]-=Ho*Qs[Mo-1];Qs[0]*=1-Ho}for(let Mo=0;Mo<wo.length;++Mo)Qs[Mo]*=wo[Mo];ar.realTransform(_a,Qs);for(let Mo=0;Mo<vu;++Mo){const qs=Mo<<1;$o[Mo*e_+rn]=_a[qs]**2+_a[qs+1]**2}}if(Wo!==null&&Wo!==2){const rn=2/Wo;for(let Kr=0;Kr<$o.length;++Kr)$o[Kr]**=rn}const Eo=tn.length;let js=await(0,d.matmul)(new d.Tensor("float32",tn.flat(),[Eo,vu]),new d.Tensor("float32",$o,[vu,e_]));d_&&(js=js.transpose(1,0));const Lr=js.data;for(let rn=0;rn<Lr.length;++rn)Lr[rn]=Math.max(To,Lr[rn]);if(Wo!==null&&Qo!==null){const rn=Math.min(Lr.length,Cu*Eo);switch(Qo){case"log":for(let Kr=0;Kr<rn;++Kr)Lr[Kr]=Math.log(Lr[Kr]);break;case"log10":for(let Kr=0;Kr<rn;++Kr)Lr[Kr]=Math.log10(Lr[Kr]);break;case"dB":if(Wo===1)Qt(Lr,Jr,Lo,Du);else if(Wo===2)Zt(Lr,Jr,Lo,Du);else throw new Error(`Cannot use log_mel option '${Qo}' with power ${Wo}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${Qo}'`)}}return js}function vr(Er,wo,{periodic:Do=!0,frame_length:Js=null,center:In=!0}={}){const Wo=Do?Er+1:Er;let Ir;switch(wo){case"boxcar":Ir=new Float64Array(Wo).fill(1);break;case"hann":case"hann_window":Ir=c(Wo);break;case"hamming":Ir=b(Wo);break;case"povey":Ir=c(Wo).map(Yo=>Math.pow(Yo,.85));break;default:throw new Error(`Unknown window type ${wo}.`)}if(Do&&(Ir=Ir.subarray(0,Er)),Js===null)return Ir;if(Er>Js)throw new Error(`Length of the window (${Er}) may not be larger than frame_length (${Js})`);return Ir}},"./src/utils/constants.js":(e,o,i)=>{i.r(o),i.d(o,{GITHUB_ISSUE_URL:()=>s});const s="https://github.com/xenova/transformers.js/issues/new/choose"},"./src/utils/core.js":(e,o,i)=>{i.r(o),i.d(o,{calculateDimensions:()=>$,calculateReflectOffset:()=>nt,dispatchCallback:()=>s,escapeRegExp:()=>a,isIntegralNumber:()=>et,isTypedArray:()=>d,mergeArrays:()=>b,pick:()=>at,pop:()=>c,product:()=>g,reverseDictionary:()=>h});function s(Ot,At){Ot&&Ot(At)}function h(Ot){return Object.fromEntries(Object.entries(Ot).map(([At,Ct])=>[Ct,At]))}function a(Ot){return Ot.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function d(Ot){return Ot?.prototype?.__proto__?.constructor?.name==="TypedArray"}function et(Ot){return Number.isInteger(Ot)||typeof Ot=="bigint"}function $(Ot){const At=[];let Ct=Ot;for(;Array.isArray(Ct);)At.push(Ct.length),Ct=Ct[0];return At}function c(Ot,At,Ct=void 0){const St=Ot[At];if(St!==void 0)return delete Ot[At],St;if(Ct===void 0)throw Error(`Key ${At} does not exist in object.`);return Ct}function b(...Ot){return Array.prototype.concat.apply([],Ot)}function g(...Ot){return Ot.reduce((At,Ct)=>At.flatMap(St=>Ct.map(xt=>[St,xt])))}function nt(Ot,At){return Math.abs((Ot+At)%(2*At)-At)}function at(Ot,At){return Object.assign({},...At.map(Ct=>{if(Ot[Ct]!==void 0)return{[Ct]:Ot[Ct]}}))}},"./src/utils/data-structures.js":(e,o,i)=>{i.r(o),i.d(o,{CharTrie:()=>h,PriorityQueue:()=>s,TokenLattice:()=>d});class s{constructor(c=(g,nt)=>g>nt,b=1/0){this._heap=[],this._comparator=c,this._maxSize=b}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...c){return this.extend(c)}extend(c){for(const b of c)if(this.size<this._maxSize)this._heap.push(b),this._siftUp();else{const g=this._smallest();this._comparator(b,this._heap[g])&&(this._heap[g]=b,this._siftUpFrom(g))}return this.size}pop(){const c=this.peek(),b=this.size-1;return b>0&&this._swap(0,b),this._heap.pop(),this._siftDown(),c}replace(c){const b=this.peek();return this._heap[0]=c,this._siftDown(),b}_parent(c){return(c+1>>>1)-1}_left(c){return(c<<1)+1}_right(c){return c+1<<1}_greater(c,b){return this._comparator(this._heap[c],this._heap[b])}_swap(c,b){const g=this._heap[c];this._heap[c]=this._heap[b],this._heap[b]=g}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(c){for(;c>0&&this._greater(c,this._parent(c));)this._swap(c,this._parent(c)),c=this._parent(c)}_siftDown(){let c=0;for(;this._left(c)<this.size&&this._greater(this._left(c),c)||this._right(c)<this.size&&this._greater(this._right(c),c);){const b=this._right(c)<this.size&&this._greater(this._right(c),this._left(c))?this._right(c):this._left(c);this._swap(c,b),c=b}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class h{constructor(){this.root=a.default()}extend(c){for(let b of c)this.push(b)}push(c){let b=this.root;for(let g of c){let nt=b.children.get(g);nt===void 0&&(nt=a.default(),b.children.set(g,nt)),b=nt}b.isLeaf=!0}*commonPrefixSearch(c){let b=this.root,g="";for(let nt=0;nt<c.length&&b!==void 0;++nt){const at=c[nt];g+=at,b=b.children.get(at),b!==void 0&&b.isLeaf&&(yield g)}}}class a{constructor(c,b){this.isLeaf=c,this.children=b}static default(){return new a(!1,new Map)}}class d{constructor(c,b,g){this.sentence=c,this.len=c.length,this.bosTokenId=b,this.eosTokenId=g,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const nt=new et(this.bosTokenId,0,0,0,0),at=new et(this.eosTokenId,1,this.len,0,0);this.nodes.push(nt.clone()),this.nodes.push(at.clone()),this.beginNodes[this.len].push(at),this.endNodes[0].push(nt)}insert(c,b,g,nt){const at=this.nodes.length,Ot=new et(nt,at,c,b,g);this.beginNodes[c].push(Ot),this.endNodes[c+b].push(Ot),this.nodes.push(Ot)}viterbi(){const c=this.len;let b=0;for(;b<=c;){if(this.beginNodes[b].length==0)return[];for(let At of this.beginNodes[b]){At.prev=null;let Ct=0,St=null;for(let xt of this.endNodes[b]){const Dt=xt.backtraceScore+At.score;(St===null||Dt>Ct)&&(St=xt.clone(),Ct=Dt)}if(St!==null)At.prev=St,At.backtraceScore=Ct;else return[]}++b}const g=[],at=this.beginNodes[c][0].prev;if(at===null)return[];let Ot=at.clone();for(;Ot.prev!==null;)g.push(Ot.clone()),Ot=Ot.clone().prev.clone();return g.reverse(),g}piece(c){return this.sentence.slice(c.pos,c.pos+c.length)}tokens(){return this.viterbi().map(b=>this.piece(b))}tokenIds(){return this.viterbi().map(b=>b.tokenId)}}class et{constructor(c,b,g,nt,at){this.tokenId=c,this.nodeId=b,this.pos=g,this.length=nt,this.score=at,this.prev=null,this.backtraceScore=0}clone(){const c=new et(this.tokenId,this.nodeId,this.pos,this.length,this.score);return c.prev=this.prev,c.backtraceScore=this.backtraceScore,c}}},"./src/utils/devices.js":(e,o,i)=>{i.r(o),i.d(o,{DEVICE_TYPES:()=>s});const s=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,o,i)=>{i.r(o),i.d(o,{DATA_TYPES:()=>d,DEFAULT_DEVICE_DTYPE_MAPPING:()=>et,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>$,isWebGpuFp16Supported:()=>a});var s=i("./src/env.js"),h=i("./src/utils/devices.js");const a=function(){let c;return async function(){if(c===void 0)if(!s.apis.IS_WEBGPU_AVAILABLE)c=!1;else try{c=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{c=!1}return c}}(),d=Object.freeze({fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),et=Object.freeze({[h.DEVICE_TYPES.wasm]:d.q8}),$=Object.freeze({[d.fp32]:"",[d.fp16]:"_fp16",[d.int8]:"_int8",[d.uint8]:"_uint8",[d.q8]:"_quantized",[d.q4]:"_q4",[d.q4f16]:"_q4f16",[d.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,o,i)=>{i.r(o),i.d(o,{Callable:()=>s});const s=class{constructor(){let h=function(...a){return h._call(...a)};return Object.setPrototypeOf(h,new.target.prototype)}_call(...h){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,o,i)=>{i.r(o),i.d(o,{getFile:()=>b,getModelFile:()=>At,getModelJSON:()=>Ct});var s=i("?7a2c"),h=i("?a42a"),a=i("./src/env.js"),d=i("./src/utils/core.js");const et={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class ${constructor(Qt){if(this.filePath=Qt,this.headers=new Headers,this.exists=s.existsSync(Qt),this.exists){this.status=200,this.statusText="OK";let Zt=s.statSync(Qt);this.headers.set("content-length",Zt.size.toString()),this.updateContentType();let gr=this;this.body=new ReadableStream({start(vr){gr.arrayBuffer().then(Er=>{vr.enqueue(new Uint8Array(Er)),vr.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const Qt=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",et[Qt]??"application/octet-stream")}clone(){let Qt=new $(this.filePath);return Qt.exists=this.exists,Qt.status=this.status,Qt.statusText=this.statusText,Qt.headers=new Headers(this.headers),Qt}async arrayBuffer(){return(await s.promises.readFile(this.filePath)).buffer}async blob(){const Qt=await s.promises.readFile(this.filePath);return new Blob([Qt],{type:this.headers.get("content-type")})}async text(){return await s.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function c(Dt,Qt=null,Zt=null){let gr;try{gr=new URL(Dt)}catch{return!1}return!(Qt&&!Qt.includes(gr.protocol)||Zt&&!Zt.includes(gr.hostname))}async function b(Dt){if(a.env.useFS&&!c(Dt,["http:","https:","blob:"]))return new $(Dt);if(typeof process<"u"&&process?.release?.name==="node"){const Qt=!!define_process_env_default?.TESTING_REMOTELY,Zt=a.env.version,gr=new Headers;if(gr.set("User-Agent",`transformers.js/${Zt}; is_ci/${Qt};`),c(Dt,["http:","https:"],["huggingface.co","hf.co"])){const Er=define_process_env_default?.HF_TOKEN??define_process_env_default?.HF_ACCESS_TOKEN;Er&&gr.set("Authorization",`Bearer ${Er}`)}return fetch(Dt,{headers:gr})}else return fetch(Dt)}const g={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function nt(Dt,Qt,Zt){if(!Zt)return null;const gr=g[Dt]??`Error (${Dt}) occurred while trying to load file`;throw Error(`${gr}: "${Qt}".`)}class at{constructor(Qt){this.path=Qt}async match(Qt){let Zt=h.join(this.path,Qt),gr=new $(Zt);if(gr.exists)return gr}async put(Qt,Zt){const gr=Buffer.from(await Zt.arrayBuffer());let vr=h.join(this.path,Qt);try{await s.promises.mkdir(h.dirname(vr),{recursive:!0}),await s.promises.writeFile(vr,gr)}catch(Er){console.warn("An error occurred while writing the file to cache:",Er)}}}async function Ot(Dt,...Qt){for(let Zt of Qt)try{let gr=await Dt.match(Zt);if(gr)return gr}catch{continue}}async function At(Dt,Qt,Zt=!0,gr={}){if(!a.env.allowLocalModels){if(gr.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!a.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,d.dispatchCallback)(gr.progress_callback,{status:"initiate",name:Dt,file:Qt});let vr;if(!vr&&a.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{vr=await caches.open("transformers-cache")}catch(Qo){console.warn("An error occurred while opening the browser cache:",Qo)}}if(!vr&&a.env.useFSCache&&(vr=new at(gr.cache_dir??a.env.cacheDir)),!vr&&a.env.useCustomCache){if(!a.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!a.env.customCache.match||!a.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");vr=a.env.customCache}const Er=gr.revision??"main";let wo=xt(Dt,Qt),Do=xt(a.env.localModelPath,wo),Js=xt(a.env.remoteHost,a.env.remotePathTemplate.replaceAll("{model}",Dt).replaceAll("{revision}",encodeURIComponent(Er)),Qt),In=Er==="main"?wo:xt(Dt,Er,Qt),Wo,Ir=vr instanceof at?In:Js,Yo=!1,Bu;vr&&(Bu=await Ot(vr,Do,Ir));const Ho=Bu!==void 0;if(Bu===void 0){if(a.env.allowLocalModels)if(c(wo,["http:","https:"])){if(gr.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${wo}.`);if(!a.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${wo}.`)}else try{Bu=await b(Do),Wo=Do}catch(Jr){console.warn(`Unable to load from local path "${Do}": "${Jr}"`)}if(Bu===void 0||Bu.status===404){if(gr.local_files_only||!a.env.allowRemoteModels){if(Zt)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${Do}".`);return null}if(Bu=await b(Js),Bu.status!==200)return nt(Bu.status,Js,Zt);Wo=Ir}Yo=vr&&typeof Response<"u"&&Bu instanceof Response&&Bu.status===200}(0,d.dispatchCallback)(gr.progress_callback,{status:"download",name:Dt,file:Qt});const tn={status:"progress",name:Dt,file:Qt};let To;return gr.progress_callback?Ho&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(To=new Uint8Array(await Bu.arrayBuffer()),(0,d.dispatchCallback)(gr.progress_callback,{...tn,progress:100,loaded:To.length,total:To.length})):To=await St(Bu,Qo=>{(0,d.dispatchCallback)(gr.progress_callback,{...tn,...Qo})}):To=new Uint8Array(await Bu.arrayBuffer()),Yo&&Wo&&await vr.match(Wo)===void 0&&await vr.put(Wo,new Response(To,{headers:Bu.headers})).catch(Qo=>{console.warn(`Unable to add response to browser cache: ${Qo}.`)}),(0,d.dispatchCallback)(gr.progress_callback,{status:"done",name:Dt,file:Qt}),To}async function Ct(Dt,Qt,Zt=!0,gr={}){let vr=await At(Dt,Qt,Zt,gr);if(vr===null)return{};let wo=new TextDecoder("utf-8").decode(vr);return JSON.parse(wo)}async function St(Dt,Qt){const Zt=Dt.headers.get("Content-Length");Zt===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let gr=parseInt(Zt??"0"),vr=new Uint8Array(gr),Er=0;const wo=Dt.body.getReader();async function Do(){const{done:Js,value:In}=await wo.read();if(Js)return;let Wo=Er+In.length;if(Wo>gr){gr=Wo;let Yo=new Uint8Array(gr);Yo.set(vr),vr=Yo}vr.set(In,Er),Er=Wo;const Ir=Er/gr*100;return Qt({progress:Ir,loaded:Er,total:gr}),Do()}return await Do(),vr}function xt(...Dt){return Dt=Dt.map((Qt,Zt)=>(Zt&&(Qt=Qt.replace(new RegExp("^/"),"")),Zt!==Dt.length-1&&(Qt=Qt.replace(new RegExp("/$"),"")),Qt)),Dt.join("/")}},"./src/utils/image.js":(e,o,i)=>{i.r(o),i.d(o,{RawImage:()=>Ot});var s=i("./src/utils/hub.js"),h=i("./src/env.js"),a=i("./src/utils/tensor.js"),d=i("?2b25");const et=typeof self<"u",$=et&&self.constructor.name==="DedicatedWorkerGlobalScope";let c,b,g;if(et)c=(At,Ct)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(At,Ct)},g=self.createImageBitmap,b=self.ImageData;else if(d)g=async At=>{const St=(await At.metadata()).channels,{data:xt,info:Dt}=await At.rotate().raw().toBuffer({resolveWithObject:!0}),Qt=new Ot(new Uint8ClampedArray(xt),Dt.width,Dt.height,Dt.channels);return St!==void 0&&St!==Dt.channels&&Qt.convert(St),Qt};else throw new Error("Unable to load image processing library.");const nt={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},at=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class Ot{constructor(Ct,St,xt,Dt){this.data=Ct,this.width=St,this.height=xt,this.channels=Dt}get size(){return[this.width,this.height]}static async read(Ct){if(Ct instanceof Ot)return Ct;if(typeof Ct=="string"||Ct instanceof URL)return await this.fromURL(Ct);throw new Error(`Unsupported input type: ${typeof Ct}`)}static fromCanvas(Ct){if(!et)throw new Error("fromCanvas() is only supported in browser environments.");const xt=Ct.getContext("2d").getImageData(0,0,Ct.width,Ct.height).data;return new Ot(xt,Ct.width,Ct.height,4)}static async fromURL(Ct){const St=await(0,s.getFile)(Ct);if(St.status!==200)throw new Error(`Unable to read image from "${Ct}" (${St.status} ${St.statusText})`);const xt=await St.blob();return this.fromBlob(xt)}static async fromBlob(Ct){if(et){const St=await g(Ct),xt=c(St.width,St.height).getContext("2d");return xt.drawImage(St,0,0),new this(xt.getImageData(0,0,St.width,St.height).data,St.width,St.height,4)}else{const St=d(await Ct.arrayBuffer());return await g(St)}}static fromTensor(Ct,St="CHW"){if(Ct.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${Ct.dims.length} dimensions.`);if(St==="CHW")Ct=Ct.transpose(1,2,0);else if(St!=="HWC")throw new Error(`Unsupported channel format: ${St}`);if(!(Ct.data instanceof Uint8ClampedArray||Ct.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${Ct.type}`);switch(Ct.dims[2]){case 1:case 2:case 3:case 4:return new Ot(Ct.data,Ct.dims[1],Ct.dims[0],Ct.dims[2]);default:throw new Error(`Unsupported number of channels: ${Ct.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const Ct=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let St=0,xt=0;St<this.data.length;St+=this.channels){const Dt=this.data[St],Qt=this.data[St+1],Zt=this.data[St+2];Ct[xt++]=Math.round(.2989*Dt+.587*Qt+.114*Zt)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(Ct,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const Ct=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let St=0,xt=0;St<this.data.length;++St)Ct[xt++]=this.data[St],Ct[xt++]=this.data[St],Ct[xt++]=this.data[St];break;case 4:for(let St=0,xt=0;St<this.data.length;St+=4)Ct[xt++]=this.data[St],Ct[xt++]=this.data[St+1],Ct[xt++]=this.data[St+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(Ct,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const Ct=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let St=0,xt=0;St<this.data.length;++St)Ct[xt++]=this.data[St],Ct[xt++]=this.data[St],Ct[xt++]=this.data[St],Ct[xt++]=255;break;case 3:for(let St=0,xt=0;St<this.data.length;St+=3)Ct[xt++]=this.data[St],Ct[xt++]=this.data[St+1],Ct[xt++]=this.data[St+2],Ct[xt++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(Ct,this.width,this.height,4)}async resize(Ct,St,{resample:xt=2}={}){let Dt=nt[xt]??xt;if(et){const Qt=this.channels,Zt=this.toCanvas(),gr=c(Ct,St).getContext("2d");return gr.drawImage(Zt,0,0,Ct,St),new Ot(gr.getImageData(0,0,Ct,St).data,Ct,St,4).convert(Qt)}else{let Qt=this.toSharp();switch(Dt){case"box":case"hamming":(Dt==="box"||Dt==="hamming")&&(console.warn(`Resampling method ${Dt} is not yet supported. Using bilinear instead.`),Dt="bilinear");case"nearest":case"bilinear":case"bicubic":Qt=Qt.affine([Ct/this.width,0,0,St/this.height],{interpolator:Dt});break;case"lanczos":Qt=Qt.resize({width:Ct,height:St,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${Dt} is not supported.`)}return await g(Qt)}}async pad([Ct,St,xt,Dt]){if(Ct=Math.max(Ct,0),St=Math.max(St,0),xt=Math.max(xt,0),Dt=Math.max(Dt,0),Ct===0&&St===0&&xt===0&&Dt===0)return this;if(et){const Qt=this.channels,Zt=this.toCanvas(),gr=this.width+Ct+St,vr=this.height+xt+Dt,Er=c(gr,vr).getContext("2d");return Er.drawImage(Zt,0,0,this.width,this.height,Ct,xt,gr,vr),new Ot(Er.getImageData(0,0,gr,vr).data,gr,vr,4).convert(Qt)}else{const Qt=this.toSharp().extend({left:Ct,right:St,top:xt,bottom:Dt});return await g(Qt)}}async crop([Ct,St,xt,Dt]){if(Ct=Math.max(Ct,0),St=Math.max(St,0),xt=Math.min(xt,this.width-1),Dt=Math.min(Dt,this.height-1),Ct===0&&St===0&&xt===this.width-1&&Dt===this.height-1)return this;const Qt=xt-Ct+1,Zt=Dt-St+1;if(et){const gr=this.channels,vr=this.toCanvas(),Er=c(Qt,Zt).getContext("2d");return Er.drawImage(vr,Ct,St,Qt,Zt,0,0,Qt,Zt),new Ot(Er.getImageData(0,0,Qt,Zt).data,Qt,Zt,4).convert(gr)}else{const gr=this.toSharp().extract({left:Ct,top:St,width:Qt,height:Zt});return await g(gr)}}async center_crop(Ct,St){if(this.width===Ct&&this.height===St)return this;const xt=(this.width-Ct)/2,Dt=(this.height-St)/2;if(et){const Qt=this.channels,Zt=this.toCanvas(),gr=c(Ct,St).getContext("2d");let vr=0,Er=0,wo=0,Do=0;return xt>=0?vr=xt:wo=-xt,Dt>=0?Er=Dt:Do=-Dt,gr.drawImage(Zt,vr,Er,Ct,St,wo,Do,Ct,St),new Ot(gr.getImageData(0,0,Ct,St).data,Ct,St,4).convert(Qt)}else{let Qt=this.toSharp();if(xt>=0&&Dt>=0)Qt=Qt.extract({left:Math.floor(xt),top:Math.floor(Dt),width:Ct,height:St});else if(xt<=0&&Dt<=0){const Zt=Math.floor(-Dt),gr=Math.floor(-xt);Qt=Qt.extend({top:Zt,left:gr,right:Ct-this.width-gr,bottom:St-this.height-Zt})}else{let Zt=[0,0],gr=0;Dt<0?(Zt[0]=Math.floor(-Dt),Zt[1]=St-this.height-Zt[0]):gr=Math.floor(Dt);let vr=[0,0],Er=0;xt<0?(vr[0]=Math.floor(-xt),vr[1]=Ct-this.width-vr[0]):Er=Math.floor(xt),Qt=Qt.extend({top:Zt[0],bottom:Zt[1],left:vr[0],right:vr[1]}).extract({left:Er,top:gr,width:Ct,height:St})}return await g(Qt)}}async toBlob(Ct="image/png",St=1){if(!et)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:Ct,quality:St})}toTensor(Ct="CHW"){let St=new a.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(Ct!=="HWC")if(Ct==="CHW")St=St.permute(2,0,1);else throw new Error(`Unsupported channel format: ${Ct}`);return St}toCanvas(){if(!et)throw new Error("toCanvas() is only supported in browser environments.");const Ct=this.clone().rgba(),St=c(Ct.width,Ct.height),xt=new b(Ct.data,Ct.width,Ct.height);return St.getContext("2d").putImageData(xt,0,0),St}_update(Ct,St,xt,Dt=null){return this.data=Ct,this.width=St,this.height=xt,Dt!==null&&(this.channels=Dt),this}clone(){return new Ot(this.data.slice(),this.width,this.height,this.channels)}convert(Ct){if(this.channels===Ct)return this;switch(Ct){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(Ct){if(et){if($)throw new Error("Unable to save an image from a Web Worker.");const St=Ct.split(".").pop().toLowerCase(),xt=at.get(St)??"image/png",Dt=await this.toBlob(xt),Qt=URL.createObjectURL(Dt),Zt=document.createElement("a");Zt.href=Qt,Zt.download=Ct,Zt.click(),Zt.remove()}else{if(h.env.useFS)return await this.toSharp().toFile(Ct);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(et)throw new Error("toSharp() is only supported in server-side environments.");return d(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}},"./src/utils/maths.js":(e,o,i)=>{i.r(o),i.d(o,{FFT:()=>At,bankers_round:()=>xt,cos_sim:()=>$,dot:()=>et,dynamic_time_warping:()=>Dt,interpolate_data:()=>s,log_softmax:()=>d,magnitude:()=>c,max:()=>g,medianFilter:()=>Ct,min:()=>b,permute_data:()=>h,round:()=>St,softmax:()=>a});function s(Qt,[Zt,gr,vr],[Er,wo],Do="bilinear",Js=!1){const In=wo/vr,Wo=Er/gr,Ir=new Qt.constructor(Er*wo*Zt),Yo=gr*vr,Bu=Er*wo;for(let Ho=0;Ho<Er;++Ho)for(let tn=0;tn<wo;++tn){const To=Ho*wo+tn,Qo=(tn+.5)/In-.5,Jr=(Ho+.5)/Wo-.5;let Lo=Math.floor(Qo),Du=Math.floor(Jr);const _u=Math.min(Lo+1,vr-1),du=Math.min(Du+1,gr-1);Lo=Math.max(Lo,0),Du=Math.max(Du,0);const wu=Qo-Lo,r_=Jr-Du,d_=(1-wu)*(1-r_),na=wu*(1-r_),Ko=(1-wu)*r_,vu=wu*r_,Cu=Du*vr,e_=du*vr,ar=Cu+Lo,Qs=Cu+_u,_a=e_+Lo,$o=e_+_u;for(let Eo=0;Eo<Zt;++Eo){const js=Eo*Yo;Ir[Eo*Bu+To]=d_*Qt[js+ar]+na*Qt[js+Qs]+Ko*Qt[js+_a]+vu*Qt[js+$o]}}return Ir}function h(Qt,Zt,gr){const vr=new Array(gr.length),Er=new Array(gr.length);for(let Js=gr.length-1,In=1;Js>=0;--Js)Er[Js]=In,vr[Js]=Zt[gr[Js]],In*=vr[Js];const wo=gr.map((Js,In)=>Er[gr.indexOf(In)]),Do=new Qt.constructor(Qt.length);for(let Js=0;Js<Qt.length;++Js){let In=0;for(let Wo=Zt.length-1,Ir=Js;Wo>=0;--Wo)In+=Ir%Zt[Wo]*wo[Wo],Ir=Math.floor(Ir/Zt[Wo]);Do[In]=Qt[Js]}return[Do,vr]}function a(Qt){const Zt=g(Qt)[0],gr=Qt.map(wo=>Math.exp(wo-Zt)),vr=gr.reduce((wo,Do)=>wo+Do,0);return gr.map(wo=>wo/vr)}function d(Qt){const Zt=g(Qt)[0];let gr=0;for(let wo=0;wo<Qt.length;++wo)gr+=Math.exp(Qt[wo]-Zt);const vr=Math.log(gr);return Qt.map(wo=>wo-Zt-vr)}function et(Qt,Zt){let gr=0;for(let vr=0;vr<Qt.length;++vr)gr+=Qt[vr]*Zt[vr];return gr}function $(Qt,Zt){const gr=et(Qt,Zt),vr=c(Qt),Er=c(Zt);return gr/(vr*Er)}function c(Qt){return Math.sqrt(Qt.reduce((Zt,gr)=>Zt+gr*gr,0))}function b(Qt){if(Qt.length===0)throw Error("Array must not be empty");let Zt=Qt[0],gr=0;for(let vr=1;vr<Qt.length;++vr)Qt[vr]<Zt&&(Zt=Qt[vr],gr=vr);return[Zt,gr]}function g(Qt){if(Qt.length===0)throw Error("Array must not be empty");let Zt=Qt[0],gr=0;for(let vr=1;vr<Qt.length;++vr)Qt[vr]>Zt&&(Zt=Qt[vr],gr=vr);return[Number(Zt),gr]}function nt(Qt){return Qt>0&&(Qt&Qt-1)===0}class at{constructor(Zt){if(this.size=Zt|0,this.size<=1||!nt(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=Zt<<1,this.table=new Float64Array(this.size*2);for(let vr=0;vr<this.table.length;vr+=2){const Er=Math.PI*vr/this.size;this.table[vr]=Math.cos(Er),this.table[vr+1]=-Math.sin(Er)}let gr=0;for(let vr=1;this.size>vr;vr<<=1)++gr;this._width=gr%2===0?gr-1:gr,this._bitrev=new Int32Array(1<<this._width);for(let vr=0;vr<this._bitrev.length;++vr){this._bitrev[vr]=0;for(let Er=0;Er<this._width;Er+=2){const wo=this._width-Er-2;this._bitrev[vr]|=(vr>>>Er&3)<<wo}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(Zt,gr){const vr=gr||new Array(Zt.length>>>1);for(let Er=0;Er<Zt.length;Er+=2)vr[Er>>>1]=Zt[Er];return vr}toComplexArray(Zt,gr){const vr=gr||this.createComplexArray();for(let Er=0;Er<vr.length;Er+=2)vr[Er]=Zt[Er>>>1],vr[Er+1]=0;return vr}transform(Zt,gr){if(Zt===gr)throw new Error("Input and output buffers must be different");this._transform4(Zt,gr,1)}realTransform(Zt,gr){if(Zt===gr)throw new Error("Input and output buffers must be different");this._realTransform4(Zt,gr,1)}inverseTransform(Zt,gr){if(Zt===gr)throw new Error("Input and output buffers must be different");this._transform4(Zt,gr,-1);for(let vr=0;vr<Zt.length;++vr)Zt[vr]/=this.size}_transform4(Zt,gr,vr){const Er=this._csize;let Do=1<<this._width,Js=Er/Do<<1,In,Wo;const Ir=this._bitrev;if(Js===4)for(In=0,Wo=0;In<Er;In+=Js,++Wo){const Bu=Ir[Wo];this._singleTransform2(gr,Zt,In,Bu,Do)}else for(In=0,Wo=0;In<Er;In+=Js,++Wo){const Bu=Ir[Wo];this._singleTransform4(gr,Zt,In,Bu,Do,vr)}const Yo=this.table;for(Do>>=2;Do>=2;Do>>=2){Js=Er/Do<<1;const Bu=Js>>>2;for(In=0;In<Er;In+=Js){const Ho=In+Bu-1;for(let tn=In,To=0;tn<Ho;tn+=2,To+=Do){const Qo=tn,Jr=Qo+Bu,Lo=Jr+Bu,Du=Lo+Bu,_u=Zt[Qo],du=Zt[Qo+1],wu=Zt[Jr],r_=Zt[Jr+1],d_=Zt[Lo],na=Zt[Lo+1],Ko=Zt[Du],vu=Zt[Du+1],Cu=Yo[To],e_=vr*Yo[To+1],ar=wu*Cu-r_*e_,Qs=wu*e_+r_*Cu,_a=Yo[2*To],$o=vr*Yo[2*To+1],Eo=d_*_a-na*$o,js=d_*$o+na*_a,Lr=Yo[3*To],rn=vr*Yo[3*To+1],Kr=Ko*Lr-vu*rn,Oo=Ko*rn+vu*Lr,Mo=_u+Eo,qs=du+js,au=_u-Eo,i_=du-js,$u=ar+Kr,m_=Qs+Oo,L_=vr*(ar-Kr),Z_=vr*(Qs-Oo);Zt[Qo]=Mo+$u,Zt[Qo+1]=qs+m_,Zt[Jr]=au+Z_,Zt[Jr+1]=i_-L_,Zt[Lo]=Mo-$u,Zt[Lo+1]=qs-m_,Zt[Du]=au-Z_,Zt[Du+1]=i_+L_}}}}_singleTransform2(Zt,gr,vr,Er,wo){const Do=Zt[Er],Js=Zt[Er+1],In=Zt[Er+wo],Wo=Zt[Er+wo+1];gr[vr]=Do+In,gr[vr+1]=Js+Wo,gr[vr+2]=Do-In,gr[vr+3]=Js-Wo}_singleTransform4(Zt,gr,vr,Er,wo,Do){const Js=wo*2,In=wo*3,Wo=Zt[Er],Ir=Zt[Er+1],Yo=Zt[Er+wo],Bu=Zt[Er+wo+1],Ho=Zt[Er+Js],tn=Zt[Er+Js+1],To=Zt[Er+In],Qo=Zt[Er+In+1],Jr=Wo+Ho,Lo=Ir+tn,Du=Wo-Ho,_u=Ir-tn,du=Yo+To,wu=Bu+Qo,r_=Do*(Yo-To),d_=Do*(Bu-Qo);gr[vr]=Jr+du,gr[vr+1]=Lo+wu,gr[vr+2]=Du+d_,gr[vr+3]=_u-r_,gr[vr+4]=Jr-du,gr[vr+5]=Lo-wu,gr[vr+6]=Du-d_,gr[vr+7]=_u+r_}_realTransform4(Zt,gr,vr){const Er=this._csize;let Do=1<<this._width,Js=Er/Do<<1,In,Wo;const Ir=this._bitrev;if(Js===4)for(In=0,Wo=0;In<Er;In+=Js,++Wo){const Ho=Ir[Wo];this._singleRealTransform2(gr,Zt,In,Ho>>>1,Do>>>1)}else for(In=0,Wo=0;In<Er;In+=Js,++Wo){const Ho=Ir[Wo];this._singleRealTransform4(gr,Zt,In,Ho>>>1,Do>>>1,vr)}const Yo=this.table;for(Do>>=2;Do>=2;Do>>=2){Js=Er/Do<<1;const Ho=Js>>>1,tn=Ho>>>1,To=tn>>>1;for(In=0;In<Er;In+=Js)for(let Qo=0,Jr=0;Qo<=To;Qo+=2,Jr+=Do){const Lo=In+Qo,Du=Lo+tn,_u=Du+tn,du=_u+tn,wu=Zt[Lo],r_=Zt[Lo+1],d_=Zt[Du],na=Zt[Du+1],Ko=Zt[_u],vu=Zt[_u+1],Cu=Zt[du],e_=Zt[du+1],ar=wu,Qs=r_,_a=Yo[Jr],$o=vr*Yo[Jr+1],Eo=d_*_a-na*$o,js=d_*$o+na*_a,Lr=Yo[2*Jr],rn=vr*Yo[2*Jr+1],Kr=Ko*Lr-vu*rn,Oo=Ko*rn+vu*Lr,Mo=Yo[3*Jr],qs=vr*Yo[3*Jr+1],au=Cu*Mo-e_*qs,i_=Cu*qs+e_*Mo,$u=ar+Kr,m_=Qs+Oo,L_=ar-Kr,Z_=Qs-Oo,Ty=Eo+au,ey=js+i_,yy=vr*(Eo-au),O_=vr*(js-i_);if(Zt[Lo]=$u+Ty,Zt[Lo+1]=m_+ey,Zt[Du]=L_+O_,Zt[Du+1]=Z_-yy,Qo===0){Zt[_u]=$u-Ty,Zt[_u+1]=m_-ey;continue}if(Qo===To)continue;const fy=In+tn-Qo,g_=In+Ho-Qo;Zt[fy]=L_-vr*O_,Zt[fy+1]=-Z_-vr*yy,Zt[g_]=$u-vr*Ty,Zt[g_+1]=-m_+vr*ey}}const Bu=Er>>>1;for(let Ho=2;Ho<Bu;Ho+=2)Zt[Er-Ho]=Zt[Ho],Zt[Er-Ho+1]=-Zt[Ho+1]}_singleRealTransform2(Zt,gr,vr,Er,wo){const Do=Zt[Er],Js=Zt[Er+wo];gr[vr]=Do+Js,gr[vr+1]=0,gr[vr+2]=Do-Js,gr[vr+3]=0}_singleRealTransform4(Zt,gr,vr,Er,wo,Do){const Js=wo*2,In=wo*3,Wo=Zt[Er],Ir=Zt[Er+wo],Yo=Zt[Er+Js],Bu=Zt[Er+In],Ho=Wo+Yo,tn=Wo-Yo,To=Ir+Bu,Qo=Do*(Ir-Bu);gr[vr]=Ho+To,gr[vr+1]=0,gr[vr+2]=tn,gr[vr+3]=-Qo,gr[vr+4]=Ho-To,gr[vr+5]=0,gr[vr+6]=tn,gr[vr+7]=Qo}}class Ot{constructor(Zt){const gr=2*(Zt-1),vr=2*(2*Zt-1),Er=2**Math.ceil(Math.log2(vr));this.bufferSize=Er,this._a=gr;const wo=new Float64Array(vr),Do=new Float64Array(Er);this._chirpBuffer=new Float64Array(Er),this._buffer1=new Float64Array(Er),this._buffer2=new Float64Array(Er),this._outBuffer1=new Float64Array(Er),this._outBuffer2=new Float64Array(Er);const Js=-2*Math.PI/Zt,In=Math.cos(Js),Wo=Math.sin(Js);for(let Ir=0;Ir<vr>>1;++Ir){const Yo=(Ir+1-Zt)**2/2,Bu=Math.sqrt(In**2+Wo**2)**Yo,Ho=Yo*Math.atan2(Wo,In),tn=2*Ir;wo[tn]=Bu*Math.cos(Ho),wo[tn+1]=Bu*Math.sin(Ho),Do[tn]=wo[tn],Do[tn+1]=-wo[tn+1]}this._slicedChirpBuffer=wo.subarray(gr,vr),this._f=new at(Er>>1),this._f.transform(this._chirpBuffer,Do)}_transform(Zt,gr,vr){const Er=this._buffer1,wo=this._buffer2,Do=this._outBuffer1,Js=this._outBuffer2,In=this._chirpBuffer,Wo=this._slicedChirpBuffer,Ir=this._a;if(vr)for(let Yo=0;Yo<Wo.length;Yo+=2){const Bu=Yo+1,Ho=Yo>>1,tn=gr[Ho];Er[Yo]=tn*Wo[Yo],Er[Bu]=tn*Wo[Bu]}else for(let Yo=0;Yo<Wo.length;Yo+=2){const Bu=Yo+1;Er[Yo]=gr[Yo]*Wo[Yo]-gr[Bu]*Wo[Bu],Er[Bu]=gr[Yo]*Wo[Bu]+gr[Bu]*Wo[Yo]}this._f.transform(Do,Er);for(let Yo=0;Yo<In.length;Yo+=2){const Bu=Yo+1;wo[Yo]=Do[Yo]*In[Yo]-Do[Bu]*In[Bu],wo[Bu]=Do[Yo]*In[Bu]+Do[Bu]*In[Yo]}this._f.inverseTransform(Js,wo);for(let Yo=0;Yo<Js.length;Yo+=2){const Bu=Js[Yo+Ir],Ho=Js[Yo+Ir+1],tn=Wo[Yo],To=Wo[Yo+1];Zt[Yo]=Bu*tn-Ho*To,Zt[Yo+1]=Bu*To+Ho*tn}}transform(Zt,gr){this._transform(Zt,gr,!1)}realTransform(Zt,gr){this._transform(Zt,gr,!0)}}class At{constructor(Zt){this.fft_length=Zt,this.isPowerOfTwo=nt(Zt),this.isPowerOfTwo?(this.fft=new at(Zt),this.outputBufferSize=2*Zt):(this.fft=new Ot(Zt),this.outputBufferSize=this.fft.bufferSize)}realTransform(Zt,gr){this.fft.realTransform(Zt,gr)}transform(Zt,gr){this.fft.transform(Zt,gr)}}function Ct(Qt,Zt){if(Zt%2===0||Zt<=0)throw new Error("Window size must be a positive odd number");const gr=new Qt.constructor(Qt.length),vr=new Qt.constructor(Zt),Er=Math.floor(Zt/2);for(let wo=0;wo<Qt.length;++wo){let Do=0;for(let Js=-Er;Js<=Er;++Js){let In=wo+Js;In<0?In=Math.abs(In):In>=Qt.length&&(In=2*(Qt.length-1)-In),vr[Do++]=Qt[In]}vr.sort(),gr[wo]=vr[Er]}return gr}function St(Qt,Zt){const gr=Math.pow(10,Zt);return Math.round(Qt*gr)/gr}function xt(Qt){const Zt=Math.round(Qt);return Math.abs(Qt)%1===.5?Zt%2===0?Zt:Zt-1:Zt}function Dt(Qt){const Zt=Qt.length,gr=Qt[0].length,vr=[Zt+1,gr+1],Er=Array.from({length:vr[0]},()=>Array(vr[1]).fill(1/0));Er[0][0]=0;const wo=Array.from({length:vr[0]},()=>Array(vr[1]).fill(-1));for(let Ir=1;Ir<vr[1];++Ir)for(let Yo=1;Yo<vr[0];++Yo){const Bu=Er[Yo-1][Ir-1],Ho=Er[Yo-1][Ir],tn=Er[Yo][Ir-1];let To,Qo;Bu<Ho&&Bu<tn?(To=Bu,Qo=0):Ho<Bu&&Ho<tn?(To=Ho,Qo=1):(To=tn,Qo=2),Er[Yo][Ir]=Qt[Yo-1][Ir-1]+To,wo[Yo][Ir]=Qo}for(let Ir=0;Ir<vr[1];++Ir)wo[0][Ir]=2;for(let Ir=0;Ir<vr[0];++Ir)wo[Ir][0]=1;let Do=Zt,Js=gr,In=[],Wo=[];for(;Do>0||Js>0;)switch(In.push(Do-1),Wo.push(Js-1),wo[Do][Js]){case 0:--Do,--Js;break;case 1:--Do;break;case 2:--Js;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${Do}, ${Js}]. Please file a bug report.`)}return In.reverse(),Wo.reverse(),[In,Wo]}},"./src/utils/tensor.js":(e,o,i)=>{i.r(o),i.d(o,{Tensor:()=>et,cat:()=>Qt,full:()=>Do,full_like:()=>Js,interpolate:()=>b,interpolate_4d:()=>g,layer_norm:()=>Ct,matmul:()=>nt,mean:()=>vr,mean_pooling:()=>At,ones:()=>In,ones_like:()=>Wo,permute:()=>c,quantize_embeddings:()=>Bu,rfft:()=>at,stack:()=>Zt,std_mean:()=>gr,topk:()=>Ot,zeros:()=>Ir,zeros_like:()=>Yo});var s=i("./src/utils/maths.js"),h=i("./src/backends/onnx.js"),a=i("./src/ops/registry.js");const d=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array});class et{get dims(){return this.ort_tensor.dims}set dims(tn){this.ort_tensor.dims=tn}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...tn){return(0,h.isONNXTensor)(tn[0])?this.ort_tensor=tn[0]:this.ort_tensor=new h.Tensor(tn[0],tn[1],tn[2]),new Proxy(this,{get:(To,Qo)=>{if(typeof Qo=="string"){let Jr=Number(Qo);if(Number.isInteger(Jr))return To._getitem(Jr)}return To[Qo]},set:(To,Qo,Jr)=>To[Qo]=Jr})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[tn,...To]=this.dims;if(To.length>0){const Qo=To.reduce((Jr,Lo)=>Jr*Lo);for(let Jr=0;Jr<tn;++Jr)yield this._subarray(Jr,Qo,To)}else yield*this.data}_getitem(tn){const[To,...Qo]=this.dims;if(tn=Dt(tn,To),Qo.length>0){const Jr=Qo.reduce((Lo,Du)=>Lo*Du);return this._subarray(tn,Jr,Qo)}else return new et(this.type,[this.data[tn]],Qo)}indexOf(tn){const To=this.data;for(let Qo=0;Qo<To.length;++Qo)if(To[Qo]==tn)return Qo;return-1}_subarray(tn,To,Qo){const Jr=tn*To,Lo=(tn+1)*To,Du="subarray"in this.data?this.data.subarray(Jr,Lo):this.data.slice(Jr,Lo);return new et(this.type,Du,Qo)}item(){const tn=this.data;if(tn.length!==1)throw new Error(`a Tensor with ${tn.length} elements cannot be converted to Scalar`);return tn[0]}tolist(){return $(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const tn=this.data;for(let To=0;To<tn.length;++To)tn[To]=1/(1+Math.exp(-tn[To]));return this}mul(tn){return this.clone().mul_(tn)}mul_(tn){const To=this.data;for(let Qo=0;Qo<To.length;++Qo)To[Qo]*=tn;return this}div(tn){return this.clone().div_(tn)}div_(tn){const To=this.data;for(let Qo=0;Qo<To.length;++Qo)To[Qo]/=tn;return this}add(tn){return this.clone().add_(tn)}add_(tn){const To=this.data;for(let Qo=0;Qo<To.length;++Qo)To[Qo]+=tn;return this}sub(tn){return this.clone().sub_(tn)}sub_(tn){const To=this.data;for(let Qo=0;Qo<To.length;++Qo)To[Qo]-=tn;return this}clone(){return new et(this.type,this.data.slice(),this.dims.slice())}slice(...tn){const To=[],Qo=[];for(let wu=0;wu<this.dims.length;++wu){let r_=tn[wu];if(r_==null)Qo.push([0,this.dims[wu]]),To.push(this.dims[wu]);else if(typeof r_=="number")r_=Dt(r_,this.dims[wu],wu),Qo.push([r_,r_+1]);else if(Array.isArray(r_)&&r_.length===2){let[d_,na]=r_;if(d_=d_===null?0:Dt(d_,this.dims[wu],wu,!1),na=na===null?this.dims[wu]:Dt(na,this.dims[wu],wu,!1),d_>na)throw new Error(`Invalid slice: ${r_}`);const Ko=[Math.max(d_,0),Math.min(na,this.dims[wu])];Qo.push(Ko),To.push(Ko[1]-Ko[0])}else throw new Error(`Invalid slice: ${r_}`)}const Jr=Qo.map(([wu,r_])=>r_-wu),Lo=Jr.reduce((wu,r_)=>wu*r_),Du=this.data,_u=new Du.constructor(Lo),du=this.stride();for(let wu=0;wu<Lo;++wu){let r_=0;for(let d_=Jr.length-1,na=wu;d_>=0;--d_){const Ko=Jr[d_];r_+=(na%Ko+Qo[d_][0])*du[d_],na=Math.floor(na/Ko)}_u[wu]=Du[r_]}return new et(this.type,_u,To)}permute(...tn){return c(this,tn)}transpose(...tn){return this.permute(...tn)}sum(tn=null,To=!1){return this.norm(1,tn,To)}norm(tn="fro",To=null,Qo=!1){if(tn==="fro")tn=2;else if(typeof tn=="string")throw Error(`Unsupported norm: ${tn}`);const Jr=this.data;if(To===null){let _u=Jr.reduce((du,wu)=>du+wu**tn,0)**(1/tn);return new et(this.type,[_u],[])}To=Dt(To,this.dims.length);const Lo=this.dims.slice();Lo[To]=1;const Du=new Jr.constructor(Jr.length/this.dims[To]);for(let _u=0;_u<Jr.length;++_u){let du=0;for(let wu=this.dims.length-1,r_=_u,d_=1;wu>=0;--wu){const na=this.dims[wu];if(wu!==To){const Ko=r_%na;du+=Ko*d_,d_*=Lo[wu]}r_=Math.floor(r_/na)}Du[du]+=Jr[_u]**tn}if(tn!==1)for(let _u=0;_u<Du.length;++_u)Du[_u]=Du[_u]**(1/tn);return Qo||Lo.splice(To,1),new et(this.type,Du,Lo)}normalize_(tn=2,To=1){To=Dt(To,this.dims.length);const Qo=this.norm(tn,To,!0),Jr=this.data,Lo=Qo.data;for(let Du=0;Du<Jr.length;++Du){let _u=0;for(let du=this.dims.length-1,wu=Du,r_=1;du>=0;--du){const d_=this.dims[du];if(du!==To){const na=wu%d_;_u+=na*r_,r_*=this.dims[du]}wu=Math.floor(wu/d_)}Jr[Du]/=Lo[_u]}return this}normalize(tn=2,To=1){return this.clone().normalize_(tn,To)}stride(){return Er(this.dims)}squeeze(tn=null){return new et(this.type,this.data,St(this.dims,tn))}squeeze_(tn=null){return this.dims=St(this.dims,tn),this}unsqueeze(tn=null){return new et(this.type,this.data,xt(this.dims,tn))}unsqueeze_(tn=null){return this.dims=xt(this.dims,tn),this}flatten_(tn=0,To=-1){To=(To+this.dims.length)%this.dims.length;let Qo=this.dims.slice(0,tn),Jr=this.dims.slice(tn,To+1),Lo=this.dims.slice(To+1);return this.dims=[...Qo,Jr.reduce((Du,_u)=>Du*_u,1),...Lo],this}flatten(tn=0,To=-1){return this.clone().flatten_(tn,To)}view(...tn){let To=-1;for(let Jr=0;Jr<tn.length;++Jr)if(tn[Jr]===-1){if(To!==-1)throw new Error("Only one dimension can be inferred");To=Jr}const Qo=this.data;if(To!==-1){const Jr=tn.reduce((Lo,Du,_u)=>_u!==To?Lo*Du:Lo,1);tn[To]=Qo.length/Jr}return new et(this.type,Qo,tn)}neg_(){const tn=this.data;for(let To=0;To<tn.length;++To)tn[To]=-tn[To];return this}neg(){return this.clone().neg_()}clamp_(tn,To){const Qo=this.data;for(let Jr=0;Jr<Qo.length;++Jr)Qo[Jr]=Math.min(Math.max(Qo[Jr],tn),To);return this}clamp(tn,To){return this.clone().clamp_(tn,To)}round_(){const tn=this.data;for(let To=0;To<tn.length;++To)tn[To]=Math.round(tn[To]);return this}round(){return this.clone().round_()}mean(tn=null,To=!1){return vr(this,tn,To)}to(tn){if(this.type===tn)return this;if(!d.hasOwnProperty(tn))throw new Error(`Unsupported type: ${tn}`);return new et(tn,d[tn].from(this.data),this.dims)}}function $(Ho,tn){const To=Ho.length,Qo=tn.reduce((Lo,Du)=>Lo*Du);if(To!==Qo)throw Error(`cannot reshape array of size ${To} into shape (${tn})`);let Jr=Ho;for(let Lo=tn.length-1;Lo>=0;Lo--)Jr=Jr.reduce((Du,_u)=>{let du=Du[Du.length-1];return du.length<tn[Lo]?du.push(_u):Du.push([_u]),Du},[[]]);return Jr[0]}function c(Ho,tn){const[To,Qo]=(0,s.permute_data)(Ho.data,Ho.dims,tn);return new et(Ho.type,To,Qo)}function b(Ho,[tn,To],Qo="bilinear",Jr=!1){const Lo=Ho.dims.at(-3)??1,Du=Ho.dims.at(-2),_u=Ho.dims.at(-1);let du=(0,s.interpolate_data)(Ho.data,[Lo,Du,_u],[tn,To],Qo,Jr);return new et(Ho.type,du,[Lo,tn,To])}async function g(Ho,{size:tn=null,mode:To="bilinear"}={}){if(Ho.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!tn)throw new Error("`interpolate_4d` requires a `size` argument.");let Qo;if(tn.length===2)Qo=[...Ho.dims.slice(0,2),...tn];else if(tn.length===3)Qo=[Ho.dims[0],...tn];else if(tn.length===4)Qo=tn;else throw new Error("`size` must be of length 2, 3, or 4.");let Jr;if(To==="bilinear")Jr=await a.TensorOpRegistry.bilinear_interpolate_4d;else if(To==="bicubic")Jr=await a.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${To}`);const Lo=new et("int64",new BigInt64Array(Qo.map(BigInt)),[Qo.length]);return await Jr({x:Ho,s:Lo})}async function nt(Ho,tn){return await(await a.TensorOpRegistry.matmul)({a:Ho,b:tn})}async function at(Ho,tn){return await(await a.TensorOpRegistry.rfft)({x:Ho,a:tn})}async function Ot(Ho,tn){const To=await a.TensorOpRegistry.top_k;return tn===null?tn=Ho.dims.at(-1):tn=Math.min(tn,Ho.dims.at(-1)),await To({x:Ho,k:new et("int64",[BigInt(tn)],[1])})}function At(Ho,tn){const To=Ho.data,Qo=tn.data,Jr=[Ho.dims[0],Ho.dims[2]],Lo=new To.constructor(Jr[0]*Jr[1]),[Du,_u,du]=Ho.dims;let wu=0;for(let r_=0;r_<Du;++r_){const d_=r_*du*_u;for(let na=0;na<du;++na){let Ko=0,vu=0;const Cu=r_*_u,e_=d_+na;for(let Qs=0;Qs<_u;++Qs){const _a=Number(Qo[Cu+Qs]);vu+=_a,Ko+=To[e_+Qs*du]*_a}const ar=Ko/vu;Lo[wu++]=ar}}return new et(Ho.type,Lo,Jr)}function Ct(Ho,tn,{eps:To=1e-5}={}){if(Ho.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[Qo,Jr]=Ho.dims;if(tn.length!==1&&tn[0]!==Jr)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[Lo,Du]=gr(Ho,1,0,!0),_u=Lo.data,du=Du.data,wu=Ho.data,r_=new wu.constructor(wu.length);for(let d_=0;d_<Qo;++d_){const na=d_*Jr;for(let Ko=0;Ko<Jr;++Ko){const vu=na+Ko;r_[vu]=(wu[vu]-du[d_])/(_u[d_]+To)}}return new et(Ho.type,r_,Ho.dims)}function St(Ho,tn){return Ho=Ho.slice(),tn===null?Ho=Ho.filter(To=>To!==1):typeof tn=="number"?Ho[tn]===1&&Ho.splice(tn,1):Array.isArray(tn)&&(Ho=Ho.filter((To,Qo)=>To!==1||!tn.includes(Qo))),Ho}function xt(Ho,tn){return tn=Dt(tn,Ho.length+1),Ho=Ho.slice(),Ho.splice(tn,0,1),Ho}function Dt(Ho,tn,To=null,Qo=!0){if(Qo&&(Ho<-tn||Ho>=tn))throw new Error(`IndexError: index ${Ho} is out of bounds for dimension${To===null?"":" "+To} with size ${tn}`);return Ho<0&&(Ho=(Ho%tn+tn)%tn),Ho}function Qt(Ho,tn=0){tn=Dt(tn,Ho[0].dims.length);const To=Ho[0].dims.slice();To[tn]=Ho.reduce((Du,_u)=>Du+_u.dims[tn],0);const Qo=To.reduce((Du,_u)=>Du*_u,1),Jr=new Ho[0].data.constructor(Qo),Lo=Ho[0].type;if(tn===0){let Du=0;for(const _u of Ho){const du=_u.data;Jr.set(du,Du),Du+=du.length}}else{let Du=0;for(let _u=0;_u<Ho.length;++_u){const{data:du,dims:wu}=Ho[_u];for(let r_=0;r_<du.length;++r_){let d_=0;for(let na=wu.length-1,Ko=r_,vu=1;na>=0;--na){const Cu=wu[na];let e_=Ko%Cu;na===tn&&(e_+=Du),d_+=e_*vu,vu*=To[na],Ko=Math.floor(Ko/Cu)}Jr[d_]=du[r_]}Du+=wu[tn]}}return new et(Lo,Jr,To)}function Zt(Ho,tn=0){return Qt(Ho.map(To=>To.unsqueeze(tn)),tn)}function gr(Ho,tn=null,To=1,Qo=!1){const Jr=Ho.data,Lo=Ho.dims;if(tn===null){const na=Jr.reduce((e_,ar)=>e_+ar,0)/Jr.length,Ko=Math.sqrt(Jr.reduce((e_,ar)=>e_+(ar-na)**2,0)/(Jr.length-To)),vu=new et(Ho.type,[na],[]);return[new et(Ho.type,[Ko],[]),vu]}tn=Dt(tn,Lo.length);const Du=vr(Ho,tn,Qo),_u=Du.data,du=Lo.slice();du[tn]=1;const wu=new Jr.constructor(Jr.length/Lo[tn]);for(let d_=0;d_<Jr.length;++d_){let na=0;for(let Ko=Lo.length-1,vu=d_,Cu=1;Ko>=0;--Ko){const e_=Lo[Ko];if(Ko!==tn){const ar=vu%e_;na+=ar*Cu,Cu*=du[Ko]}vu=Math.floor(vu/e_)}wu[na]+=(Jr[d_]-_u[na])**2}for(let d_=0;d_<wu.length;++d_)wu[d_]=Math.sqrt(wu[d_]/(Lo[tn]-To));return Qo||du.splice(tn,1),[new et(Ho.type,wu,du),Du]}function vr(Ho,tn=null,To=!1){const Qo=Ho.data;if(tn===null){const _u=Qo.reduce((du,wu)=>du+wu,0);return new et(Ho.type,[_u/Qo.length],[])}const Jr=Ho.dims;tn=Dt(tn,Jr.length);const Lo=Jr.slice();Lo[tn]=1;const Du=new Qo.constructor(Qo.length/Jr[tn]);for(let _u=0;_u<Qo.length;++_u){let du=0;for(let wu=Jr.length-1,r_=_u,d_=1;wu>=0;--wu){const na=Jr[wu];if(wu!==tn){const Ko=r_%na;du+=Ko*d_,d_*=Lo[wu]}r_=Math.floor(r_/na)}Du[du]+=Qo[_u]}if(Jr[tn]!==1)for(let _u=0;_u<Du.length;++_u)Du[_u]=Du[_u]/Jr[tn];return To||Lo.splice(tn,1),new et(Ho.type,Du,Lo)}function Er(Ho){const tn=new Array(Ho.length);for(let To=Ho.length-1,Qo=1;To>=0;--To)tn[To]=Qo,Qo*=Ho[To];return tn}function wo(Ho,tn,To,Qo){const Jr=Ho.reduce((Lo,Du)=>Lo*Du,1);return new et(To,new Qo(Jr).fill(tn),Ho)}function Do(Ho,tn){let To,Qo;if(typeof tn=="number")To="float32",Qo=Float32Array;else if(typeof tn=="bigint")To="int64",Qo=BigInt64Array;else throw new Error(`Unsupported data type: ${typeof tn}`);return wo(Ho,tn,To,Qo)}function Js(Ho,tn){return Do(Ho.dims,tn)}function In(Ho){return wo(Ho,1n,"int64",BigInt64Array)}function Wo(Ho){return In(Ho.dims)}function Ir(Ho){return wo(Ho,0n,"int64",BigInt64Array)}function Yo(Ho){return Ir(Ho.dims)}function Bu(Ho,tn){if(Ho.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(Ho.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(tn))throw new Error("The precision must be either 'binary' or 'ubinary'");const To=tn==="binary",Qo=To?"int8":"uint8",Jr=To?Int8Array:Uint8Array,Lo=Ho.data,Du=new Jr(Lo.length/8);for(let _u=0;_u<Lo.length;++_u){const du=Lo[_u]>0?1:0,wu=Math.floor(_u/8),r_=_u%8;Du[wu]|=du<<7-r_,To&&r_===0&&(Du[wu]-=128)}return new et(Qo,Du,[Ho.dims[0],Ho.dims[1]/8])}}},__webpack_module_cache__={};function __webpack_require__(e){var o=__webpack_module_cache__[e];if(o!==void 0)return o.exports;var i=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](i,i.exports,__webpack_require__),i.exports}__webpack_require__.m=__webpack_modules__;(()=>{var e=Object.getPrototypeOf?i=>Object.getPrototypeOf(i):i=>i.__proto__,o;__webpack_require__.t=function(i,s){if(s&1&&(i=this(i)),s&8||typeof i=="object"&&i&&(s&4&&i.__esModule||s&16&&typeof i.then=="function"))return i;var h=Object.create(null);__webpack_require__.r(h);var a={};o=o||[null,e({}),e([]),e(e)];for(var d=s&2&&i;typeof d=="object"&&!~o.indexOf(d);d=e(d))Object.getOwnPropertyNames(d).forEach(et=>a[et]=()=>i[et]);return a.default=()=>i,__webpack_require__.d(h,a),h}})();__webpack_require__.d=(e,o)=>{for(var i in o)__webpack_require__.o(o,i)&&!__webpack_require__.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:o[i]})};__webpack_require__.o=(e,o)=>Object.prototype.hasOwnProperty.call(e,o);__webpack_require__.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};(()=>{var e;if(typeof import.meta.url=="string"&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=e})();__webpack_require__.b=new URL("./",import.meta.url);var __webpack_exports__={};/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/__webpack_require__.r(__webpack_exports__);__webpack_require__.d(__webpack_exports__,{ASTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ASTFeatureExtractor,ASTForAudioClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ASTForAudioClassification,ASTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ASTModel,ASTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ASTPreTrainedModel,AlbertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForSequenceClassification,AlbertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertModel,AlbertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertPreTrainedModel,AlbertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AlbertTokenizer,AudioClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.AudioClassificationPipeline,AutoConfig:()=>_configs_js__WEBPACK_IMPORTED_MODULE_5__.AutoConfig,AutoModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModel,AutoModelForAudioClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioFrameClassification,AutoModelForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCTC,AutoModelForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageSegmentation,AutoModelForImageToImage:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForObjectDetection,AutoModelForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForVision2Seq,AutoModelForXVector:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.AutoProcessor,AutoTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.AutomaticSpeechRecognitionPipeline,BartForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BartForConditionalGeneration,BartForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BartForSequenceClassification,BartModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BartModel,BartPretrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BartPretrainedModel,BartTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BartTokenizer,BaseModelOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BaseModelOutput,BaseStreamer:()=>_generation_streamers_js__WEBPACK_IMPORTED_MODULE_10__.BaseStreamer,BeitFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.BeitFeatureExtractor,BeitForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BeitForImageClassification,BeitModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BeitModel,BeitPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BeitPreTrainedModel,BertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertForMaskedLM,BertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertForQuestionAnswering,BertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertForSequenceClassification,BertForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertForTokenClassification,BertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertModel,BertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertPreTrainedModel,BertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BertTokenizer,BitImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.BitImageProcessor,BlenderbotForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotForConditionalGeneration,BlenderbotModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotModel,BlenderbotPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BlenderbotTokenizer,BloomForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BloomForCausalLM,BloomModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BloomModel,BloomPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BloomPreTrainedModel,BloomTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BloomTokenizer,CLIPFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.CLIPFeatureExtractor,CLIPImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.CLIPImageProcessor,CLIPModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPModel,CLIPPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegForImageSegmentation,CLIPSegModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegModel,CLIPSegPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegPreTrainedModel,CLIPTextModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPTextModel,CLIPTextModelWithProjection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPTextModelWithProjection,CLIPTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CLIPTokenizer,CLIPVisionModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPVisionModel,CLIPVisionModelWithProjection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForSequenceClassification,CamembertForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForTokenClassification,CamembertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertModel,CamembertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertPreTrainedModel,CamembertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CamembertTokenizer,CausalLMOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutput,CausalLMOutputWithPast:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ClapFeatureExtractor,ClapModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ClapModel,ClapPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ClapPreTrainedModel,ClapTextModelWithProjection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ClapTextModelWithProjection,CodeGenForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenForCausalLM,CodeGenModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenModel,CodeGenPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenPreTrainedModel,CodeGenTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeGenTokenizer,CodeLlamaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeLlamaTokenizer,CohereForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CohereForCausalLM,CohereModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CohereModel,CoherePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CoherePreTrainedModel,CohereTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CohereTokenizer,ConvBertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForTokenClassification,ConvBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertModel,ConvBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertPreTrainedModel,ConvBertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.ConvBertTokenizer,ConvNextFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextForImageClassification,ConvNextImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ConvNextImageProcessor,ConvNextModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextModel,ConvNextPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2ForImageClassification,ConvNextV2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DPTFeatureExtractor,DPTForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DPTForDepthEstimation,DPTImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DPTImageProcessor,DPTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DPTModel,DPTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DPTPreTrainedModel,DebertaForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForSequenceClassification,DebertaForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForTokenClassification,DebertaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaModel,DebertaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaPreTrainedModel,DebertaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DebertaTokenizer,DebertaV2ForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForTokenClassification,DebertaV2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2Model,DebertaV2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DebertaV2Tokenizer,DecisionTransformerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DeiTFeatureExtractor,DeiTForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTForImageClassification,DeiTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTModel,DeiTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.DepthEstimationPipeline,DetrFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DetrFeatureExtractor,DetrForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForObjectDetection,DetrForSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForSegmentation,DetrModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrModel,DetrObjectDetectionOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrPreTrainedModel,DetrSegmentationOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrSegmentationOutput,Dinov2ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2ForImageClassification,Dinov2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2Model,Dinov2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2PreTrainedModel,DistilBertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForTokenClassification,DistilBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertModel,DistilBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertPreTrainedModel,DistilBertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DonutFeatureExtractor,DonutSwinModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DonutSwinModel,DonutSwinPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.EfficientNetImageProcessor,EfficientNetModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetModel,EfficientNetPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForSequenceClassification,ElectraForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForTokenClassification,ElectraModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraModel,ElectraPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraPreTrainedModel,ElectraTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.ElectraTokenizer,EosTokenCriteria:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.EosTokenCriteria,EsmForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForMaskedLM,EsmForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForSequenceClassification,EsmForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForTokenClassification,EsmModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmModel,EsmPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmPreTrainedModel,EsmTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.EsmTokenizer,FFT:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.FFT,FalconForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FalconForCausalLM,FalconModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FalconModel,FalconPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FalconPreTrainedModel,FalconTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.FalconTokenizer,FastViTForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTForImageClassification,FastViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTModel,FastViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.FeatureExtractionPipeline,FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.FeatureExtractor,FillMaskPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.FillMaskPipeline,Florence2ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Florence2PreTrainedModel,Florence2Processor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Florence2Processor,GLPNFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNForDepthEstimation,GLPNModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNModel,GLPNPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNPreTrainedModel,GPT2LMHeadModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2LMHeadModel,GPT2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2Model,GPT2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2PreTrainedModel,GPT2Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJForCausalLM,GPTJModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJModel,GPTJPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoForCausalLM,GPTNeoModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoModel,GPTNeoPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXForCausalLM,GPTNeoXModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2ForCausalLM,Gemma2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2Model,Gemma2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2PreTrainedModel,GemmaForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaForCausalLM,GemmaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaModel,GemmaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaPreTrainedModel,GemmaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GemmaTokenizer,Grok1Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Grok1Tokenizer,GroupViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GroupViTModel,GroupViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GroupViTPreTrainedModel,HerbertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.HerbertTokenizer,HieraForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HieraForImageClassification,HieraModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HieraModel,HieraPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HieraPreTrainedModel,HubertForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HubertForCTC,HubertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HubertForSequenceClassification,HubertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HubertModel,HubertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HubertPreTrainedModel,ImageClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ImageFeatureExtractor,ImageMattingOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ImageMattingOutput,ImageSegmentationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageSegmentationPipeline,ImageToImagePipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageToImagePipeline,ImageToTextPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageToTextPipeline,InterruptableStoppingCriteria:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.InterruptableStoppingCriteria,JAISLMHeadModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.JAISLMHeadModel,JAISModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.JAISModel,JAISPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.JAISPreTrainedModel,LlamaForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaForCausalLM,LlamaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaModel,LlamaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaPreTrainedModel,LlamaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.LlamaTokenizer,LlavaForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlavaForConditionalGeneration,LlavaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlavaPreTrainedModel,LongT5ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5ForConditionalGeneration,LongT5Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5Model,LongT5PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100ForConditionalGeneration,M2M100Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100Model,M2M100PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100PreTrainedModel,M2M100Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.M2M100Tokenizer,MBart50Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MBart50Tokenizer,MBartForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForCausalLM,MBartForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForConditionalGeneration,MBartForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForSequenceClassification,MBartModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartModel,MBartPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartPreTrainedModel,MBartTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MBartTokenizer,MPNetForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForSequenceClassification,MPNetForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForTokenClassification,MPNetModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetModel,MPNetPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetPreTrainedModel,MPNetTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MPNetTokenizer,MT5ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MT5ForConditionalGeneration,MT5Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MT5Model,MT5PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MT5PreTrainedModel,MarianMTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MarianMTModel,MarianModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MarianModel,MarianPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MarianPreTrainedModel,MarianTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MarianTokenizer,MaskFormerFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerForInstanceSegmentation,MaskFormerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerModel,MaskFormerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerPreTrainedModel,MaskedLMOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MaskedLMOutput,MaxLengthCriteria:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.MaxLengthCriteria,MistralForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MistralForCausalLM,MistralModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MistralModel,MistralPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MistralPreTrainedModel,MobileBertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForSequenceClassification,MobileBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertModel,MobileBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertPreTrainedModel,MobileBertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MobileBertTokenizer,MobileNetV1FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1ForImageClassification,MobileNetV1Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2ForImageClassification,MobileNetV2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3ForImageClassification,MobileNetV3Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4ForImageClassification,MobileNetV4Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTForImageClassification,MobileViTImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTImageProcessor,MobileViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTModel,MobileViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2ForImageClassification,MobileViTV2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2PreTrainedModel,ModelOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ModelOutput,Moondream1ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Moondream1ForConditionalGeneration,MptForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MptForCausalLM,MptModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MptModel,MptPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MptPreTrainedModel,MusicgenForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenForConditionalGeneration,MusicgenModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenModel,MusicgenPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenPreTrainedModel,NllbTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NllbTokenizer,NomicBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.NomicBertModel,NomicBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.NomicBertPreTrainedModel,NougatImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.NougatImageProcessor,NougatTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NougatTokenizer,OPTForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OPTForCausalLM,OPTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OPTModel,OPTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OPTPreTrainedModel,ObjectDetectionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ObjectDetectionPipeline,OpenELMForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMForCausalLM,OpenELMModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMModel,OpenELMPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTForObjectDetection,OwlViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTModel,OwlViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTPreTrainedModel,OwlViTProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.OwlViTProcessor,Owlv2ForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Owlv2ImageProcessor,Owlv2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2Model,Owlv2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2PreTrainedModel,Phi3ForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3ForCausalLM,Phi3Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3Model,Phi3PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3PreTrainedModel,PhiForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PhiForCausalLM,PhiModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PhiModel,PhiPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PhiPreTrainedModel,Pipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.Pipeline,PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PreTrainedModel,PreTrainedTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.PreTrainedTokenizer,PretrainedConfig:()=>_configs_js__WEBPACK_IMPORTED_MODULE_5__.PretrainedConfig,PretrainedMixin:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PretrainedMixin,Processor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Processor,PvtForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PvtForImageClassification,PvtImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.PvtImageProcessor,PvtModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PvtModel,PvtPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnoteModel,PyAnnotePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2ForCausalLM,Qwen2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2Model,Qwen2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Qwen2Tokenizer,RTDetrForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrForObjectDetection,RTDetrImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.RTDetrImageProcessor,RTDetrModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrModel,RTDetrObjectDetectionOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrPreTrainedModel,RawImage:()=>_utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage,ResNetForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetForImageClassification,ResNetModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetModel,ResNetPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForTokenClassification,RoFormerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerModel,RoFormerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerPreTrainedModel,RoFormerTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RoFormerTokenizer,RobertaForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForSequenceClassification,RobertaForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForTokenClassification,RobertaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaModel,RobertaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaPreTrainedModel,RobertaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RobertaTokenizer,SamImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SamImageProcessor,SamImageSegmentationOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SamImageSegmentationOutput,SamModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SamModel,SamPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SamPreTrainedModel,SamProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SamProcessor,SapiensFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SapiensFeatureExtractor,SapiensForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SegformerFeatureExtractor,SegformerForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerForSemanticSegmentation,SegformerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerModel,SegformerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Seq2SeqLMOutput,SequenceClassifierOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SequenceClassifierOutput,SiglipImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SiglipImageProcessor,SiglipModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipModel,SiglipPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipPreTrainedModel,SiglipTextModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipTextModel,SiglipTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SiglipTokenizer,SiglipVisionModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipVisionModel,SpeechT5FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5HifiGan,SpeechT5Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5Model,SpeechT5PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5PreTrainedModel,SpeechT5Processor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SpeechT5Processor,SpeechT5Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SqueezeBertTokenizer,StableLmForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmForCausalLM,StableLmModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmModel,StableLmPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2ForCausalLM,Starcoder2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2Model,Starcoder2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2PreTrainedModel,StoppingCriteria:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.StoppingCriteria,StoppingCriteriaList:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.StoppingCriteriaList,SummarizationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.SummarizationPipeline,Swin2SRForImageSuperResolution:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Swin2SRImageProcessor,Swin2SRModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRModel,Swin2SRPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRPreTrainedModel,SwinForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SwinForImageClassification,SwinModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SwinModel,SwinPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SwinPreTrainedModel,T5ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.T5ForConditionalGeneration,T5Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.T5Model,T5PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.T5PreTrainedModel,T5Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.T5Tokenizer,TableTransformerForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerForObjectDetection,TableTransformerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerPreTrainedModel,Tensor:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor,Text2TextGenerationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.Text2TextGenerationPipeline,TextClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextClassificationPipeline,TextGenerationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextGenerationPipeline,TextStreamer:()=>_generation_streamers_js__WEBPACK_IMPORTED_MODULE_10__.TextStreamer,TextToAudioPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextToAudioPipeline,TokenClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TokenClassificationPipeline,TokenClassifierOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TokenClassifierOutput,TokenizerModel:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.TokenizerModel,TrOCRForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TrOCRPreTrainedModel,TranslationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TranslationPipeline,UniSpeechForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechForSequenceClassification,UniSpeechModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechModel,UniSpeechPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatPreTrainedModel,ViTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTFeatureExtractor,ViTForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTForImageClassification,ViTImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTImageProcessor,ViTMAEModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMAEModel,ViTMAEPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNForImageClassification,ViTMSNModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNModel,ViTMSNPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNPreTrainedModel,ViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTModel,ViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitMatteForImageMatting,VitMatteImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.VitMatteImageProcessor,VitMattePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitMattePreTrainedModel,VitsModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitsModel,VitsModelOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitsModelOutput,VitsPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitsPreTrainedModel,VitsTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.VitsTokenizer,Wav2Vec2BertForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2PreTrainedModel,Wav2Vec2ProcessorWithLM:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForAudioFrameClassification,WavLMForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForCTC,WavLMForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForSequenceClassification,WavLMForXVector:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForXVector,WavLMModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMModel,WavLMPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperForConditionalGeneration,WhisperModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperModel,WhisperPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperPreTrainedModel,WhisperProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperProcessor,WhisperTextStreamer:()=>_generation_streamers_js__WEBPACK_IMPORTED_MODULE_10__.WhisperTextStreamer,WhisperTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTokenizer,XLMForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForQuestionAnswering,XLMForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForSequenceClassification,XLMForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForTokenClassification,XLMModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMModel,XLMPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForTokenClassification,XLMRobertaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMRobertaTokenizer,XLMTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMTokenizer,XLMWithLMHeadModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMWithLMHeadModel,XVectorOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XVectorOutput,YolosFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.YolosFeatureExtractor,YolosForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.YolosForObjectDetection,YolosModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.YolosModel,YolosObjectDetectionOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotObjectDetectionPipeline,bankers_round:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.bankers_round,cat:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.cat,cos_sim:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.cos_sim,dot:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dot,dynamic_time_warping:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dynamic_time_warping,env:()=>_env_js__WEBPACK_IMPORTED_MODULE_0__.env,full:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.full,full_like:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.full_like,getKeyValueShapes:()=>_configs_js__WEBPACK_IMPORTED_MODULE_5__.getKeyValueShapes,hamming:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.hamming,hanning:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.hanning,interpolate:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate,interpolate_4d:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate_4d,interpolate_data:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.interpolate_data,is_chinese_char:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.is_chinese_char,layer_norm:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.layer_norm,log_softmax:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.log_softmax,magnitude:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.magnitude,matmul:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.matmul,max:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.max,mean:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean,mean_pooling:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean_pooling,medianFilter:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.medianFilter,mel_filter_bank:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.mel_filter_bank,min:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.min,ones:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.ones,ones_like:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.ones_like,permute:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.permute,permute_data:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.permute_data,pipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.pipeline,quantize_embeddings:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.quantize_embeddings,read_audio:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.read_audio,rfft:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.rfft,round:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.round,softmax:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.softmax,spectrogram:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.spectrogram,stack:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.stack,std_mean:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.std_mean,topk:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.topk,window_function:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.window_function,zeros:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.zeros,zeros_like:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.zeros_like});var _env_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./src/env.js"),_pipelines_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./src/pipelines.js"),_models_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./src/models.js"),_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./src/tokenizers.js"),_processors_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./src/processors.js"),_configs_js__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./src/configs.js"),_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__("./src/utils/audio.js"),_utils_image_js__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__("./src/utils/image.js"),_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__("./src/utils/tensor.js"),_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__("./src/utils/maths.js"),_generation_streamers_js__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__("./src/generation/streamers.js"),_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__("./src/generation/stopping_criteria.js");__webpack_exports__.ASTFeatureExtractor;__webpack_exports__.ASTForAudioClassification;__webpack_exports__.ASTModel;__webpack_exports__.ASTPreTrainedModel;__webpack_exports__.AlbertForMaskedLM;__webpack_exports__.AlbertForQuestionAnswering;__webpack_exports__.AlbertForSequenceClassification;__webpack_exports__.AlbertModel;__webpack_exports__.AlbertPreTrainedModel;__webpack_exports__.AlbertTokenizer;__webpack_exports__.AudioClassificationPipeline;__webpack_exports__.AutoConfig;var __webpack_exports__AutoModel=__webpack_exports__.AutoModel;__webpack_exports__.AutoModelForAudioClassification;__webpack_exports__.AutoModelForAudioFrameClassification;__webpack_exports__.AutoModelForCTC;__webpack_exports__.AutoModelForCausalLM;__webpack_exports__.AutoModelForDepthEstimation;__webpack_exports__.AutoModelForDocumentQuestionAnswering;__webpack_exports__.AutoModelForImageClassification;__webpack_exports__.AutoModelForImageFeatureExtraction;__webpack_exports__.AutoModelForImageMatting;__webpack_exports__.AutoModelForImageSegmentation;__webpack_exports__.AutoModelForImageToImage;__webpack_exports__.AutoModelForMaskGeneration;__webpack_exports__.AutoModelForMaskedLM;__webpack_exports__.AutoModelForNormalEstimation;__webpack_exports__.AutoModelForObjectDetection;__webpack_exports__.AutoModelForQuestionAnswering;__webpack_exports__.AutoModelForSemanticSegmentation;__webpack_exports__.AutoModelForSeq2SeqLM;__webpack_exports__.AutoModelForSequenceClassification;__webpack_exports__.AutoModelForSpeechSeq2Seq;__webpack_exports__.AutoModelForTextToSpectrogram;__webpack_exports__.AutoModelForTextToWaveform;__webpack_exports__.AutoModelForTokenClassification;__webpack_exports__.AutoModelForUniversalSegmentation;__webpack_exports__.AutoModelForVision2Seq;__webpack_exports__.AutoModelForXVector;__webpack_exports__.AutoModelForZeroShotObjectDetection;var __webpack_exports__AutoProcessor=__webpack_exports__.AutoProcessor;__webpack_exports__.AutoTokenizer;__webpack_exports__.AutomaticSpeechRecognitionPipeline;__webpack_exports__.BartForConditionalGeneration;__webpack_exports__.BartForSequenceClassification;__webpack_exports__.BartModel;__webpack_exports__.BartPretrainedModel;__webpack_exports__.BartTokenizer;__webpack_exports__.BaseModelOutput;__webpack_exports__.BaseStreamer;__webpack_exports__.BeitFeatureExtractor;__webpack_exports__.BeitForImageClassification;__webpack_exports__.BeitModel;__webpack_exports__.BeitPreTrainedModel;__webpack_exports__.BertForMaskedLM;__webpack_exports__.BertForQuestionAnswering;__webpack_exports__.BertForSequenceClassification;__webpack_exports__.BertForTokenClassification;__webpack_exports__.BertModel;__webpack_exports__.BertPreTrainedModel;__webpack_exports__.BertTokenizer;__webpack_exports__.BitImageProcessor;__webpack_exports__.BlenderbotForConditionalGeneration;__webpack_exports__.BlenderbotModel;__webpack_exports__.BlenderbotPreTrainedModel;__webpack_exports__.BlenderbotSmallForConditionalGeneration;__webpack_exports__.BlenderbotSmallModel;__webpack_exports__.BlenderbotSmallPreTrainedModel;__webpack_exports__.BlenderbotSmallTokenizer;__webpack_exports__.BlenderbotTokenizer;__webpack_exports__.BloomForCausalLM;__webpack_exports__.BloomModel;__webpack_exports__.BloomPreTrainedModel;__webpack_exports__.BloomTokenizer;__webpack_exports__.CLIPFeatureExtractor;__webpack_exports__.CLIPImageProcessor;__webpack_exports__.CLIPModel;__webpack_exports__.CLIPPreTrainedModel;__webpack_exports__.CLIPSegForImageSegmentation;__webpack_exports__.CLIPSegModel;__webpack_exports__.CLIPSegPreTrainedModel;__webpack_exports__.CLIPTextModel;__webpack_exports__.CLIPTextModelWithProjection;__webpack_exports__.CLIPTokenizer;__webpack_exports__.CLIPVisionModel;__webpack_exports__.CLIPVisionModelWithProjection;__webpack_exports__.CamembertForMaskedLM;__webpack_exports__.CamembertForQuestionAnswering;__webpack_exports__.CamembertForSequenceClassification;__webpack_exports__.CamembertForTokenClassification;__webpack_exports__.CamembertModel;__webpack_exports__.CamembertPreTrainedModel;__webpack_exports__.CamembertTokenizer;__webpack_exports__.CausalLMOutput;__webpack_exports__.CausalLMOutputWithPast;__webpack_exports__.ChineseCLIPFeatureExtractor;__webpack_exports__.ChineseCLIPModel;__webpack_exports__.ChineseCLIPPreTrainedModel;__webpack_exports__.ClapAudioModelWithProjection;__webpack_exports__.ClapFeatureExtractor;__webpack_exports__.ClapModel;__webpack_exports__.ClapPreTrainedModel;__webpack_exports__.ClapTextModelWithProjection;__webpack_exports__.CodeGenForCausalLM;__webpack_exports__.CodeGenModel;__webpack_exports__.CodeGenPreTrainedModel;__webpack_exports__.CodeGenTokenizer;__webpack_exports__.CodeLlamaTokenizer;__webpack_exports__.CohereForCausalLM;__webpack_exports__.CohereModel;__webpack_exports__.CoherePreTrainedModel;__webpack_exports__.CohereTokenizer;__webpack_exports__.ConvBertForMaskedLM;__webpack_exports__.ConvBertForQuestionAnswering;__webpack_exports__.ConvBertForSequenceClassification;__webpack_exports__.ConvBertForTokenClassification;__webpack_exports__.ConvBertModel;__webpack_exports__.ConvBertPreTrainedModel;__webpack_exports__.ConvBertTokenizer;__webpack_exports__.ConvNextFeatureExtractor;__webpack_exports__.ConvNextForImageClassification;__webpack_exports__.ConvNextImageProcessor;__webpack_exports__.ConvNextModel;__webpack_exports__.ConvNextPreTrainedModel;__webpack_exports__.ConvNextV2ForImageClassification;__webpack_exports__.ConvNextV2Model;__webpack_exports__.ConvNextV2PreTrainedModel;__webpack_exports__.DPTFeatureExtractor;__webpack_exports__.DPTForDepthEstimation;__webpack_exports__.DPTImageProcessor;__webpack_exports__.DPTModel;__webpack_exports__.DPTPreTrainedModel;__webpack_exports__.DebertaForMaskedLM;__webpack_exports__.DebertaForQuestionAnswering;__webpack_exports__.DebertaForSequenceClassification;__webpack_exports__.DebertaForTokenClassification;__webpack_exports__.DebertaModel;__webpack_exports__.DebertaPreTrainedModel;__webpack_exports__.DebertaTokenizer;__webpack_exports__.DebertaV2ForMaskedLM;__webpack_exports__.DebertaV2ForQuestionAnswering;__webpack_exports__.DebertaV2ForSequenceClassification;__webpack_exports__.DebertaV2ForTokenClassification;__webpack_exports__.DebertaV2Model;__webpack_exports__.DebertaV2PreTrainedModel;__webpack_exports__.DebertaV2Tokenizer;__webpack_exports__.DecisionTransformerModel;__webpack_exports__.DecisionTransformerPreTrainedModel;__webpack_exports__.DeiTFeatureExtractor;__webpack_exports__.DeiTForImageClassification;__webpack_exports__.DeiTModel;__webpack_exports__.DeiTPreTrainedModel;__webpack_exports__.DepthAnythingForDepthEstimation;__webpack_exports__.DepthAnythingPreTrainedModel;__webpack_exports__.DepthEstimationPipeline;__webpack_exports__.DetrFeatureExtractor;__webpack_exports__.DetrForObjectDetection;__webpack_exports__.DetrForSegmentation;__webpack_exports__.DetrModel;__webpack_exports__.DetrObjectDetectionOutput;__webpack_exports__.DetrPreTrainedModel;__webpack_exports__.DetrSegmentationOutput;__webpack_exports__.Dinov2ForImageClassification;__webpack_exports__.Dinov2Model;__webpack_exports__.Dinov2PreTrainedModel;__webpack_exports__.DistilBertForMaskedLM;__webpack_exports__.DistilBertForQuestionAnswering;__webpack_exports__.DistilBertForSequenceClassification;__webpack_exports__.DistilBertForTokenClassification;__webpack_exports__.DistilBertModel;__webpack_exports__.DistilBertPreTrainedModel;__webpack_exports__.DistilBertTokenizer;__webpack_exports__.DocumentQuestionAnsweringPipeline;__webpack_exports__.DonutFeatureExtractor;__webpack_exports__.DonutSwinModel;__webpack_exports__.DonutSwinPreTrainedModel;__webpack_exports__.EfficientNetForImageClassification;__webpack_exports__.EfficientNetImageProcessor;__webpack_exports__.EfficientNetModel;__webpack_exports__.EfficientNetPreTrainedModel;__webpack_exports__.ElectraForMaskedLM;__webpack_exports__.ElectraForQuestionAnswering;__webpack_exports__.ElectraForSequenceClassification;__webpack_exports__.ElectraForTokenClassification;__webpack_exports__.ElectraModel;__webpack_exports__.ElectraPreTrainedModel;__webpack_exports__.ElectraTokenizer;__webpack_exports__.EosTokenCriteria;__webpack_exports__.EsmForMaskedLM;__webpack_exports__.EsmForSequenceClassification;__webpack_exports__.EsmForTokenClassification;__webpack_exports__.EsmModel;__webpack_exports__.EsmPreTrainedModel;__webpack_exports__.EsmTokenizer;__webpack_exports__.FFT;__webpack_exports__.FalconForCausalLM;__webpack_exports__.FalconModel;__webpack_exports__.FalconPreTrainedModel;__webpack_exports__.FalconTokenizer;__webpack_exports__.FastViTForImageClassification;__webpack_exports__.FastViTModel;__webpack_exports__.FastViTPreTrainedModel;__webpack_exports__.FeatureExtractionPipeline;__webpack_exports__.FeatureExtractor;__webpack_exports__.FillMaskPipeline;__webpack_exports__.Florence2ForConditionalGeneration;__webpack_exports__.Florence2PreTrainedModel;__webpack_exports__.Florence2Processor;__webpack_exports__.GLPNFeatureExtractor;__webpack_exports__.GLPNForDepthEstimation;__webpack_exports__.GLPNModel;__webpack_exports__.GLPNPreTrainedModel;__webpack_exports__.GPT2LMHeadModel;__webpack_exports__.GPT2Model;__webpack_exports__.GPT2PreTrainedModel;__webpack_exports__.GPT2Tokenizer;__webpack_exports__.GPTBigCodeForCausalLM;__webpack_exports__.GPTBigCodeModel;__webpack_exports__.GPTBigCodePreTrainedModel;__webpack_exports__.GPTJForCausalLM;__webpack_exports__.GPTJModel;__webpack_exports__.GPTJPreTrainedModel;__webpack_exports__.GPTNeoForCausalLM;__webpack_exports__.GPTNeoModel;__webpack_exports__.GPTNeoPreTrainedModel;__webpack_exports__.GPTNeoXForCausalLM;__webpack_exports__.GPTNeoXModel;__webpack_exports__.GPTNeoXPreTrainedModel;__webpack_exports__.GPTNeoXTokenizer;__webpack_exports__.Gemma2ForCausalLM;__webpack_exports__.Gemma2Model;__webpack_exports__.Gemma2PreTrainedModel;__webpack_exports__.GemmaForCausalLM;__webpack_exports__.GemmaModel;__webpack_exports__.GemmaPreTrainedModel;__webpack_exports__.GemmaTokenizer;__webpack_exports__.Grok1Tokenizer;__webpack_exports__.GroupViTModel;__webpack_exports__.GroupViTPreTrainedModel;__webpack_exports__.HerbertTokenizer;__webpack_exports__.HieraForImageClassification;__webpack_exports__.HieraModel;__webpack_exports__.HieraPreTrainedModel;__webpack_exports__.HubertForCTC;__webpack_exports__.HubertForSequenceClassification;__webpack_exports__.HubertModel;__webpack_exports__.HubertPreTrainedModel;__webpack_exports__.ImageClassificationPipeline;__webpack_exports__.ImageFeatureExtractionPipeline;__webpack_exports__.ImageFeatureExtractor;__webpack_exports__.ImageMattingOutput;__webpack_exports__.ImageSegmentationPipeline;__webpack_exports__.ImageToImagePipeline;__webpack_exports__.ImageToTextPipeline;__webpack_exports__.InterruptableStoppingCriteria;__webpack_exports__.JAISLMHeadModel;__webpack_exports__.JAISModel;__webpack_exports__.JAISPreTrainedModel;__webpack_exports__.LlamaForCausalLM;__webpack_exports__.LlamaModel;__webpack_exports__.LlamaPreTrainedModel;__webpack_exports__.LlamaTokenizer;__webpack_exports__.LlavaForConditionalGeneration;__webpack_exports__.LlavaPreTrainedModel;__webpack_exports__.LongT5ForConditionalGeneration;__webpack_exports__.LongT5Model;__webpack_exports__.LongT5PreTrainedModel;__webpack_exports__.M2M100ForConditionalGeneration;__webpack_exports__.M2M100Model;__webpack_exports__.M2M100PreTrainedModel;__webpack_exports__.M2M100Tokenizer;__webpack_exports__.MBart50Tokenizer;__webpack_exports__.MBartForCausalLM;__webpack_exports__.MBartForConditionalGeneration;__webpack_exports__.MBartForSequenceClassification;__webpack_exports__.MBartModel;__webpack_exports__.MBartPreTrainedModel;__webpack_exports__.MBartTokenizer;__webpack_exports__.MPNetForMaskedLM;__webpack_exports__.MPNetForQuestionAnswering;__webpack_exports__.MPNetForSequenceClassification;__webpack_exports__.MPNetForTokenClassification;__webpack_exports__.MPNetModel;__webpack_exports__.MPNetPreTrainedModel;__webpack_exports__.MPNetTokenizer;__webpack_exports__.MT5ForConditionalGeneration;__webpack_exports__.MT5Model;__webpack_exports__.MT5PreTrainedModel;__webpack_exports__.MarianMTModel;__webpack_exports__.MarianModel;__webpack_exports__.MarianPreTrainedModel;__webpack_exports__.MarianTokenizer;__webpack_exports__.MaskFormerFeatureExtractor;__webpack_exports__.MaskFormerForInstanceSegmentation;__webpack_exports__.MaskFormerModel;__webpack_exports__.MaskFormerPreTrainedModel;__webpack_exports__.MaskedLMOutput;__webpack_exports__.MaxLengthCriteria;__webpack_exports__.MistralForCausalLM;__webpack_exports__.MistralModel;__webpack_exports__.MistralPreTrainedModel;__webpack_exports__.MobileBertForMaskedLM;__webpack_exports__.MobileBertForQuestionAnswering;__webpack_exports__.MobileBertForSequenceClassification;__webpack_exports__.MobileBertModel;__webpack_exports__.MobileBertPreTrainedModel;__webpack_exports__.MobileBertTokenizer;__webpack_exports__.MobileNetV1FeatureExtractor;__webpack_exports__.MobileNetV1ForImageClassification;__webpack_exports__.MobileNetV1Model;__webpack_exports__.MobileNetV1PreTrainedModel;__webpack_exports__.MobileNetV2FeatureExtractor;__webpack_exports__.MobileNetV2ForImageClassification;__webpack_exports__.MobileNetV2Model;__webpack_exports__.MobileNetV2PreTrainedModel;__webpack_exports__.MobileNetV3FeatureExtractor;__webpack_exports__.MobileNetV3ForImageClassification;__webpack_exports__.MobileNetV3Model;__webpack_exports__.MobileNetV3PreTrainedModel;__webpack_exports__.MobileNetV4FeatureExtractor;__webpack_exports__.MobileNetV4ForImageClassification;__webpack_exports__.MobileNetV4Model;__webpack_exports__.MobileNetV4PreTrainedModel;__webpack_exports__.MobileViTFeatureExtractor;__webpack_exports__.MobileViTForImageClassification;__webpack_exports__.MobileViTImageProcessor;__webpack_exports__.MobileViTModel;__webpack_exports__.MobileViTPreTrainedModel;__webpack_exports__.MobileViTV2ForImageClassification;__webpack_exports__.MobileViTV2Model;__webpack_exports__.MobileViTV2PreTrainedModel;__webpack_exports__.ModelOutput;__webpack_exports__.Moondream1ForConditionalGeneration;__webpack_exports__.MptForCausalLM;__webpack_exports__.MptModel;__webpack_exports__.MptPreTrainedModel;__webpack_exports__.MusicgenForCausalLM;__webpack_exports__.MusicgenForConditionalGeneration;__webpack_exports__.MusicgenModel;__webpack_exports__.MusicgenPreTrainedModel;__webpack_exports__.NllbTokenizer;__webpack_exports__.NomicBertModel;__webpack_exports__.NomicBertPreTrainedModel;__webpack_exports__.NougatImageProcessor;__webpack_exports__.NougatTokenizer;__webpack_exports__.OPTForCausalLM;__webpack_exports__.OPTModel;__webpack_exports__.OPTPreTrainedModel;__webpack_exports__.ObjectDetectionPipeline;__webpack_exports__.OpenELMForCausalLM;__webpack_exports__.OpenELMModel;__webpack_exports__.OpenELMPreTrainedModel;__webpack_exports__.OwlViTFeatureExtractor;__webpack_exports__.OwlViTForObjectDetection;__webpack_exports__.OwlViTModel;__webpack_exports__.OwlViTPreTrainedModel;__webpack_exports__.OwlViTProcessor;__webpack_exports__.Owlv2ForObjectDetection;__webpack_exports__.Owlv2ImageProcessor;__webpack_exports__.Owlv2Model;__webpack_exports__.Owlv2PreTrainedModel;__webpack_exports__.Phi3ForCausalLM;__webpack_exports__.Phi3Model;__webpack_exports__.Phi3PreTrainedModel;__webpack_exports__.PhiForCausalLM;__webpack_exports__.PhiModel;__webpack_exports__.PhiPreTrainedModel;__webpack_exports__.Pipeline;__webpack_exports__.PreTrainedModel;__webpack_exports__.PreTrainedTokenizer;__webpack_exports__.PretrainedConfig;__webpack_exports__.PretrainedMixin;__webpack_exports__.Processor;__webpack_exports__.PvtForImageClassification;__webpack_exports__.PvtImageProcessor;__webpack_exports__.PvtModel;__webpack_exports__.PvtPreTrainedModel;__webpack_exports__.PyAnnoteFeatureExtractor;__webpack_exports__.PyAnnoteForAudioFrameClassification;__webpack_exports__.PyAnnoteModel;__webpack_exports__.PyAnnotePreTrainedModel;__webpack_exports__.PyAnnoteProcessor;__webpack_exports__.QuestionAnsweringModelOutput;__webpack_exports__.QuestionAnsweringPipeline;__webpack_exports__.Qwen2ForCausalLM;__webpack_exports__.Qwen2Model;__webpack_exports__.Qwen2PreTrainedModel;__webpack_exports__.Qwen2Tokenizer;__webpack_exports__.RTDetrForObjectDetection;__webpack_exports__.RTDetrImageProcessor;__webpack_exports__.RTDetrModel;__webpack_exports__.RTDetrObjectDetectionOutput;__webpack_exports__.RTDetrPreTrainedModel;var __webpack_exports__RawImage=__webpack_exports__.RawImage;__webpack_exports__.ResNetForImageClassification;__webpack_exports__.ResNetModel;__webpack_exports__.ResNetPreTrainedModel;__webpack_exports__.RoFormerForMaskedLM;__webpack_exports__.RoFormerForQuestionAnswering;__webpack_exports__.RoFormerForSequenceClassification;__webpack_exports__.RoFormerForTokenClassification;__webpack_exports__.RoFormerModel;__webpack_exports__.RoFormerPreTrainedModel;__webpack_exports__.RoFormerTokenizer;__webpack_exports__.RobertaForMaskedLM;__webpack_exports__.RobertaForQuestionAnswering;__webpack_exports__.RobertaForSequenceClassification;__webpack_exports__.RobertaForTokenClassification;__webpack_exports__.RobertaModel;__webpack_exports__.RobertaPreTrainedModel;__webpack_exports__.RobertaTokenizer;__webpack_exports__.SamImageProcessor;__webpack_exports__.SamImageSegmentationOutput;__webpack_exports__.SamModel;__webpack_exports__.SamPreTrainedModel;__webpack_exports__.SamProcessor;__webpack_exports__.SapiensFeatureExtractor;__webpack_exports__.SapiensForDepthEstimation;__webpack_exports__.SapiensForNormalEstimation;__webpack_exports__.SapiensForSemanticSegmentation;__webpack_exports__.SapiensPreTrainedModel;__webpack_exports__.SeamlessM4TFeatureExtractor;__webpack_exports__.SegformerFeatureExtractor;__webpack_exports__.SegformerForImageClassification;__webpack_exports__.SegformerForSemanticSegmentation;__webpack_exports__.SegformerModel;__webpack_exports__.SegformerPreTrainedModel;__webpack_exports__.Seq2SeqLMOutput;__webpack_exports__.SequenceClassifierOutput;__webpack_exports__.SiglipImageProcessor;__webpack_exports__.SiglipModel;__webpack_exports__.SiglipPreTrainedModel;__webpack_exports__.SiglipTextModel;__webpack_exports__.SiglipTokenizer;__webpack_exports__.SiglipVisionModel;__webpack_exports__.SpeechT5FeatureExtractor;__webpack_exports__.SpeechT5ForSpeechToText;__webpack_exports__.SpeechT5ForTextToSpeech;__webpack_exports__.SpeechT5HifiGan;__webpack_exports__.SpeechT5Model;__webpack_exports__.SpeechT5PreTrainedModel;__webpack_exports__.SpeechT5Processor;__webpack_exports__.SpeechT5Tokenizer;__webpack_exports__.SqueezeBertForMaskedLM;__webpack_exports__.SqueezeBertForQuestionAnswering;__webpack_exports__.SqueezeBertForSequenceClassification;__webpack_exports__.SqueezeBertModel;__webpack_exports__.SqueezeBertPreTrainedModel;__webpack_exports__.SqueezeBertTokenizer;__webpack_exports__.StableLmForCausalLM;__webpack_exports__.StableLmModel;__webpack_exports__.StableLmPreTrainedModel;__webpack_exports__.Starcoder2ForCausalLM;__webpack_exports__.Starcoder2Model;__webpack_exports__.Starcoder2PreTrainedModel;__webpack_exports__.StoppingCriteria;__webpack_exports__.StoppingCriteriaList;__webpack_exports__.SummarizationPipeline;__webpack_exports__.Swin2SRForImageSuperResolution;__webpack_exports__.Swin2SRImageProcessor;__webpack_exports__.Swin2SRModel;__webpack_exports__.Swin2SRPreTrainedModel;__webpack_exports__.SwinForImageClassification;__webpack_exports__.SwinModel;__webpack_exports__.SwinPreTrainedModel;__webpack_exports__.T5ForConditionalGeneration;__webpack_exports__.T5Model;__webpack_exports__.T5PreTrainedModel;__webpack_exports__.T5Tokenizer;__webpack_exports__.TableTransformerForObjectDetection;__webpack_exports__.TableTransformerModel;__webpack_exports__.TableTransformerObjectDetectionOutput;__webpack_exports__.TableTransformerPreTrainedModel;__webpack_exports__.Tensor;__webpack_exports__.Text2TextGenerationPipeline;__webpack_exports__.TextClassificationPipeline;__webpack_exports__.TextGenerationPipeline;__webpack_exports__.TextStreamer;__webpack_exports__.TextToAudioPipeline;__webpack_exports__.TokenClassificationPipeline;__webpack_exports__.TokenClassifierOutput;__webpack_exports__.TokenizerModel;__webpack_exports__.TrOCRForCausalLM;__webpack_exports__.TrOCRPreTrainedModel;__webpack_exports__.TranslationPipeline;__webpack_exports__.UniSpeechForCTC;__webpack_exports__.UniSpeechForSequenceClassification;__webpack_exports__.UniSpeechModel;__webpack_exports__.UniSpeechPreTrainedModel;__webpack_exports__.UniSpeechSatForAudioFrameClassification;__webpack_exports__.UniSpeechSatForCTC;__webpack_exports__.UniSpeechSatForSequenceClassification;__webpack_exports__.UniSpeechSatModel;__webpack_exports__.UniSpeechSatPreTrainedModel;__webpack_exports__.ViTFeatureExtractor;__webpack_exports__.ViTForImageClassification;__webpack_exports__.ViTImageProcessor;__webpack_exports__.ViTMAEModel;__webpack_exports__.ViTMAEPreTrainedModel;__webpack_exports__.ViTMSNForImageClassification;__webpack_exports__.ViTMSNModel;__webpack_exports__.ViTMSNPreTrainedModel;__webpack_exports__.ViTModel;__webpack_exports__.ViTPreTrainedModel;__webpack_exports__.VisionEncoderDecoderModel;__webpack_exports__.VitMatteForImageMatting;__webpack_exports__.VitMatteImageProcessor;__webpack_exports__.VitMattePreTrainedModel;__webpack_exports__.VitsModel;__webpack_exports__.VitsModelOutput;__webpack_exports__.VitsPreTrainedModel;__webpack_exports__.VitsTokenizer;__webpack_exports__.Wav2Vec2BertForCTC;__webpack_exports__.Wav2Vec2BertForSequenceClassification;__webpack_exports__.Wav2Vec2BertModel;__webpack_exports__.Wav2Vec2BertPreTrainedModel;__webpack_exports__.Wav2Vec2CTCTokenizer;__webpack_exports__.Wav2Vec2FeatureExtractor;__webpack_exports__.Wav2Vec2ForAudioFrameClassification;__webpack_exports__.Wav2Vec2ForCTC;__webpack_exports__.Wav2Vec2ForSequenceClassification;__webpack_exports__.Wav2Vec2Model;__webpack_exports__.Wav2Vec2PreTrainedModel;__webpack_exports__.Wav2Vec2ProcessorWithLM;__webpack_exports__.WavLMForAudioFrameClassification;__webpack_exports__.WavLMForCTC;__webpack_exports__.WavLMForSequenceClassification;__webpack_exports__.WavLMForXVector;__webpack_exports__.WavLMModel;__webpack_exports__.WavLMPreTrainedModel;__webpack_exports__.WeSpeakerFeatureExtractor;__webpack_exports__.WeSpeakerResNetModel;__webpack_exports__.WeSpeakerResNetPreTrainedModel;__webpack_exports__.WhisperFeatureExtractor;__webpack_exports__.WhisperForConditionalGeneration;__webpack_exports__.WhisperModel;__webpack_exports__.WhisperPreTrainedModel;__webpack_exports__.WhisperProcessor;__webpack_exports__.WhisperTextStreamer;__webpack_exports__.WhisperTokenizer;__webpack_exports__.XLMForQuestionAnswering;__webpack_exports__.XLMForSequenceClassification;__webpack_exports__.XLMForTokenClassification;__webpack_exports__.XLMModel;__webpack_exports__.XLMPreTrainedModel;__webpack_exports__.XLMRobertaForMaskedLM;__webpack_exports__.XLMRobertaForQuestionAnswering;__webpack_exports__.XLMRobertaForSequenceClassification;__webpack_exports__.XLMRobertaForTokenClassification;__webpack_exports__.XLMRobertaModel;__webpack_exports__.XLMRobertaPreTrainedModel;__webpack_exports__.XLMRobertaTokenizer;__webpack_exports__.XLMTokenizer;__webpack_exports__.XLMWithLMHeadModel;__webpack_exports__.XVectorOutput;__webpack_exports__.YolosFeatureExtractor;__webpack_exports__.YolosForObjectDetection;__webpack_exports__.YolosModel;__webpack_exports__.YolosObjectDetectionOutput;__webpack_exports__.YolosPreTrainedModel;__webpack_exports__.ZeroShotAudioClassificationPipeline;__webpack_exports__.ZeroShotClassificationPipeline;__webpack_exports__.ZeroShotImageClassificationPipeline;__webpack_exports__.ZeroShotObjectDetectionPipeline;__webpack_exports__.bankers_round;__webpack_exports__.cat;__webpack_exports__.cos_sim;__webpack_exports__.dot;__webpack_exports__.dynamic_time_warping;var __webpack_exports__env=__webpack_exports__.env;__webpack_exports__.full;__webpack_exports__.full_like;__webpack_exports__.getKeyValueShapes;__webpack_exports__.hamming;__webpack_exports__.hanning;__webpack_exports__.interpolate;__webpack_exports__.interpolate_4d;__webpack_exports__.interpolate_data;__webpack_exports__.is_chinese_char;__webpack_exports__.layer_norm;__webpack_exports__.log_softmax;__webpack_exports__.magnitude;__webpack_exports__.matmul;__webpack_exports__.max;__webpack_exports__.mean;__webpack_exports__.mean_pooling;__webpack_exports__.medianFilter;__webpack_exports__.mel_filter_bank;__webpack_exports__.min;__webpack_exports__.ones;__webpack_exports__.ones_like;__webpack_exports__.permute;__webpack_exports__.permute_data;__webpack_exports__.pipeline;__webpack_exports__.quantize_embeddings;__webpack_exports__.read_audio;__webpack_exports__.rfft;__webpack_exports__.round;__webpack_exports__.softmax;__webpack_exports__.spectrogram;__webpack_exports__.stack;__webpack_exports__.std_mean;__webpack_exports__.topk;__webpack_exports__.window_function;__webpack_exports__.zeros;__webpack_exports__.zeros_like;function commonjsRequire(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var jszip_min={exports:{}};/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/(function(e,o){(function(i){e.exports=i()})(function(){return function i(s,h,a){function d(c,b){if(!h[c]){if(!s[c]){var g=typeof commonjsRequire=="function"&&commonjsRequire;if(!b&&g)return g(c,!0);if(et)return et(c,!0);var nt=new Error("Cannot find module '"+c+"'");throw nt.code="MODULE_NOT_FOUND",nt}var at=h[c]={exports:{}};s[c][0].call(at.exports,function(Ot){var At=s[c][1][Ot];return d(At||Ot)},at,at.exports,i,s,h,a)}return h[c].exports}for(var et=typeof commonjsRequire=="function"&&commonjsRequire,$=0;$<a.length;$++)d(a[$]);return d}({1:[function(i,s,h){var a=i("./utils"),d=i("./support"),et="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";h.encode=function($){for(var c,b,g,nt,at,Ot,At,Ct=[],St=0,xt=$.length,Dt=xt,Qt=a.getTypeOf($)!=="string";St<$.length;)Dt=xt-St,g=Qt?(c=$[St++],b=St<xt?$[St++]:0,St<xt?$[St++]:0):(c=$.charCodeAt(St++),b=St<xt?$.charCodeAt(St++):0,St<xt?$.charCodeAt(St++):0),nt=c>>2,at=(3&c)<<4|b>>4,Ot=1<Dt?(15&b)<<2|g>>6:64,At=2<Dt?63&g:64,Ct.push(et.charAt(nt)+et.charAt(at)+et.charAt(Ot)+et.charAt(At));return Ct.join("")},h.decode=function($){var c,b,g,nt,at,Ot,At=0,Ct=0,St="data:";if($.substr(0,St.length)===St)throw new Error("Invalid base64 input, it looks like a data url.");var xt,Dt=3*($=$.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if($.charAt($.length-1)===et.charAt(64)&&Dt--,$.charAt($.length-2)===et.charAt(64)&&Dt--,Dt%1!=0)throw new Error("Invalid base64 input, bad content length.");for(xt=d.uint8array?new Uint8Array(0|Dt):new Array(0|Dt);At<$.length;)c=et.indexOf($.charAt(At++))<<2|(nt=et.indexOf($.charAt(At++)))>>4,b=(15&nt)<<4|(at=et.indexOf($.charAt(At++)))>>2,g=(3&at)<<6|(Ot=et.indexOf($.charAt(At++))),xt[Ct++]=c,at!==64&&(xt[Ct++]=b),Ot!==64&&(xt[Ct++]=g);return xt}},{"./support":30,"./utils":32}],2:[function(i,s,h){var a=i("./external"),d=i("./stream/DataWorker"),et=i("./stream/Crc32Probe"),$=i("./stream/DataLengthProbe");function c(b,g,nt,at,Ot){this.compressedSize=b,this.uncompressedSize=g,this.crc32=nt,this.compression=at,this.compressedContent=Ot}c.prototype={getContentWorker:function(){var b=new d(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new $("data_length")),g=this;return b.on("end",function(){if(this.streamInfo.data_length!==g.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),b},getCompressedWorker:function(){return new d(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},c.createWorkerFrom=function(b,g,nt){return b.pipe(new et).pipe(new $("uncompressedSize")).pipe(g.compressWorker(nt)).pipe(new $("compressedSize")).withStreamInfo("compression",g)},s.exports=c},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(i,s,h){var a=i("./stream/GenericWorker");h.STORE={magic:"\0\0",compressWorker:function(){return new a("STORE compression")},uncompressWorker:function(){return new a("STORE decompression")}},h.DEFLATE=i("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(i,s,h){var a=i("./utils"),d=function(){for(var et,$=[],c=0;c<256;c++){et=c;for(var b=0;b<8;b++)et=1&et?3988292384^et>>>1:et>>>1;$[c]=et}return $}();s.exports=function(et,$){return et!==void 0&&et.length?a.getTypeOf(et)!=="string"?function(c,b,g,nt){var at=d,Ot=nt+g;c^=-1;for(var At=nt;At<Ot;At++)c=c>>>8^at[255&(c^b[At])];return-1^c}(0|$,et,et.length,0):function(c,b,g,nt){var at=d,Ot=nt+g;c^=-1;for(var At=nt;At<Ot;At++)c=c>>>8^at[255&(c^b.charCodeAt(At))];return-1^c}(0|$,et,et.length,0):0}},{"./utils":32}],5:[function(i,s,h){h.base64=!1,h.binary=!1,h.dir=!1,h.createFolders=!0,h.date=null,h.compression=null,h.compressionOptions=null,h.comment=null,h.unixPermissions=null,h.dosPermissions=null},{}],6:[function(i,s,h){var a=null;a=typeof Promise<"u"?Promise:i("lie"),s.exports={Promise:a}},{lie:37}],7:[function(i,s,h){var a=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Uint32Array<"u",d=i("pako"),et=i("./utils"),$=i("./stream/GenericWorker"),c=a?"uint8array":"array";function b(g,nt){$.call(this,"FlateWorker/"+g),this._pako=null,this._pakoAction=g,this._pakoOptions=nt,this.meta={}}h.magic="\b\0",et.inherits(b,$),b.prototype.processChunk=function(g){this.meta=g.meta,this._pako===null&&this._createPako(),this._pako.push(et.transformTo(c,g.data),!1)},b.prototype.flush=function(){$.prototype.flush.call(this),this._pako===null&&this._createPako(),this._pako.push([],!0)},b.prototype.cleanUp=function(){$.prototype.cleanUp.call(this),this._pako=null},b.prototype._createPako=function(){this._pako=new d[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var g=this;this._pako.onData=function(nt){g.push({data:nt,meta:g.meta})}},h.compressWorker=function(g){return new b("Deflate",g)},h.uncompressWorker=function(){return new b("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(i,s,h){function a(at,Ot){var At,Ct="";for(At=0;At<Ot;At++)Ct+=String.fromCharCode(255&at),at>>>=8;return Ct}function d(at,Ot,At,Ct,St,xt){var Dt,Qt,Zt=at.file,gr=at.compression,vr=xt!==c.utf8encode,Er=et.transformTo("string",xt(Zt.name)),wo=et.transformTo("string",c.utf8encode(Zt.name)),Do=Zt.comment,Js=et.transformTo("string",xt(Do)),In=et.transformTo("string",c.utf8encode(Do)),Wo=wo.length!==Zt.name.length,Ir=In.length!==Do.length,Yo="",Bu="",Ho="",tn=Zt.dir,To=Zt.date,Qo={crc32:0,compressedSize:0,uncompressedSize:0};Ot&&!At||(Qo.crc32=at.crc32,Qo.compressedSize=at.compressedSize,Qo.uncompressedSize=at.uncompressedSize);var Jr=0;Ot&&(Jr|=8),vr||!Wo&&!Ir||(Jr|=2048);var Lo=0,Du=0;tn&&(Lo|=16),St==="UNIX"?(Du=798,Lo|=function(du,wu){var r_=du;return du||(r_=wu?16893:33204),(65535&r_)<<16}(Zt.unixPermissions,tn)):(Du=20,Lo|=function(du){return 63&(du||0)}(Zt.dosPermissions)),Dt=To.getUTCHours(),Dt<<=6,Dt|=To.getUTCMinutes(),Dt<<=5,Dt|=To.getUTCSeconds()/2,Qt=To.getUTCFullYear()-1980,Qt<<=4,Qt|=To.getUTCMonth()+1,Qt<<=5,Qt|=To.getUTCDate(),Wo&&(Bu=a(1,1)+a(b(Er),4)+wo,Yo+="up"+a(Bu.length,2)+Bu),Ir&&(Ho=a(1,1)+a(b(Js),4)+In,Yo+="uc"+a(Ho.length,2)+Ho);var _u="";return _u+=`
\0`,_u+=a(Jr,2),_u+=gr.magic,_u+=a(Dt,2),_u+=a(Qt,2),_u+=a(Qo.crc32,4),_u+=a(Qo.compressedSize,4),_u+=a(Qo.uncompressedSize,4),_u+=a(Er.length,2),_u+=a(Yo.length,2),{fileRecord:g.LOCAL_FILE_HEADER+_u+Er+Yo,dirRecord:g.CENTRAL_FILE_HEADER+a(Du,2)+_u+a(Js.length,2)+"\0\0\0\0"+a(Lo,4)+a(Ct,4)+Er+Yo+Js}}var et=i("../utils"),$=i("../stream/GenericWorker"),c=i("../utf8"),b=i("../crc32"),g=i("../signature");function nt(at,Ot,At,Ct){$.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=Ot,this.zipPlatform=At,this.encodeFileName=Ct,this.streamFiles=at,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}et.inherits(nt,$),nt.prototype.push=function(at){var Ot=at.meta.percent||0,At=this.entriesCount,Ct=this._sources.length;this.accumulate?this.contentBuffer.push(at):(this.bytesWritten+=at.data.length,$.prototype.push.call(this,{data:at.data,meta:{currentFile:this.currentFile,percent:At?(Ot+100*(At-Ct-1))/At:100}}))},nt.prototype.openedSource=function(at){this.currentSourceOffset=this.bytesWritten,this.currentFile=at.file.name;var Ot=this.streamFiles&&!at.file.dir;if(Ot){var At=d(at,Ot,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:At.fileRecord,meta:{percent:0}})}else this.accumulate=!0},nt.prototype.closedSource=function(at){this.accumulate=!1;var Ot=this.streamFiles&&!at.file.dir,At=d(at,Ot,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(At.dirRecord),Ot)this.push({data:function(Ct){return g.DATA_DESCRIPTOR+a(Ct.crc32,4)+a(Ct.compressedSize,4)+a(Ct.uncompressedSize,4)}(at),meta:{percent:100}});else for(this.push({data:At.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},nt.prototype.flush=function(){for(var at=this.bytesWritten,Ot=0;Ot<this.dirRecords.length;Ot++)this.push({data:this.dirRecords[Ot],meta:{percent:100}});var At=this.bytesWritten-at,Ct=function(St,xt,Dt,Qt,Zt){var gr=et.transformTo("string",Zt(Qt));return g.CENTRAL_DIRECTORY_END+"\0\0\0\0"+a(St,2)+a(St,2)+a(xt,4)+a(Dt,4)+a(gr.length,2)+gr}(this.dirRecords.length,At,at,this.zipComment,this.encodeFileName);this.push({data:Ct,meta:{percent:100}})},nt.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},nt.prototype.registerPrevious=function(at){this._sources.push(at);var Ot=this;return at.on("data",function(At){Ot.processChunk(At)}),at.on("end",function(){Ot.closedSource(Ot.previous.streamInfo),Ot._sources.length?Ot.prepareNextSource():Ot.end()}),at.on("error",function(At){Ot.error(At)}),this},nt.prototype.resume=function(){return!!$.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},nt.prototype.error=function(at){var Ot=this._sources;if(!$.prototype.error.call(this,at))return!1;for(var At=0;At<Ot.length;At++)try{Ot[At].error(at)}catch{}return!0},nt.prototype.lock=function(){$.prototype.lock.call(this);for(var at=this._sources,Ot=0;Ot<at.length;Ot++)at[Ot].lock()},s.exports=nt},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(i,s,h){var a=i("../compressions"),d=i("./ZipFileWorker");h.generateWorker=function(et,$,c){var b=new d($.streamFiles,c,$.platform,$.encodeFileName),g=0;try{et.forEach(function(nt,at){g++;var Ot=function(xt,Dt){var Qt=xt||Dt,Zt=a[Qt];if(!Zt)throw new Error(Qt+" is not a valid compression method !");return Zt}(at.options.compression,$.compression),At=at.options.compressionOptions||$.compressionOptions||{},Ct=at.dir,St=at.date;at._compressWorker(Ot,At).withStreamInfo("file",{name:nt,dir:Ct,date:St,comment:at.comment||"",unixPermissions:at.unixPermissions,dosPermissions:at.dosPermissions}).pipe(b)}),b.entriesCount=g}catch(nt){b.error(nt)}return b}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(i,s,h){function a(){if(!(this instanceof a))return new a;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var d=new a;for(var et in this)typeof this[et]!="function"&&(d[et]=this[et]);return d}}(a.prototype=i("./object")).loadAsync=i("./load"),a.support=i("./support"),a.defaults=i("./defaults"),a.version="3.10.1",a.loadAsync=function(d,et){return new a().loadAsync(d,et)},a.external=i("./external"),s.exports=a},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(i,s,h){var a=i("./utils"),d=i("./external"),et=i("./utf8"),$=i("./zipEntries"),c=i("./stream/Crc32Probe"),b=i("./nodejsUtils");function g(nt){return new d.Promise(function(at,Ot){var At=nt.decompressed.getContentWorker().pipe(new c);At.on("error",function(Ct){Ot(Ct)}).on("end",function(){At.streamInfo.crc32!==nt.decompressed.crc32?Ot(new Error("Corrupted zip : CRC32 mismatch")):at()}).resume()})}s.exports=function(nt,at){var Ot=this;return at=a.extend(at||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:et.utf8decode}),b.isNode&&b.isStream(nt)?d.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):a.prepareContent("the loaded zip file",nt,!0,at.optimizedBinaryString,at.base64).then(function(At){var Ct=new $(at);return Ct.load(At),Ct}).then(function(At){var Ct=[d.Promise.resolve(At)],St=At.files;if(at.checkCRC32)for(var xt=0;xt<St.length;xt++)Ct.push(g(St[xt]));return d.Promise.all(Ct)}).then(function(At){for(var Ct=At.shift(),St=Ct.files,xt=0;xt<St.length;xt++){var Dt=St[xt],Qt=Dt.fileNameStr,Zt=a.resolve(Dt.fileNameStr);Ot.file(Zt,Dt.decompressed,{binary:!0,optimizedBinaryString:!0,date:Dt.date,dir:Dt.dir,comment:Dt.fileCommentStr.length?Dt.fileCommentStr:null,unixPermissions:Dt.unixPermissions,dosPermissions:Dt.dosPermissions,createFolders:at.createFolders}),Dt.dir||(Ot.file(Zt).unsafeOriginalName=Qt)}return Ct.zipComment.length&&(Ot.comment=Ct.zipComment),Ot})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(i,s,h){var a=i("../utils"),d=i("../stream/GenericWorker");function et($,c){d.call(this,"Nodejs stream input adapter for "+$),this._upstreamEnded=!1,this._bindStream(c)}a.inherits(et,d),et.prototype._bindStream=function($){var c=this;(this._stream=$).pause(),$.on("data",function(b){c.push({data:b,meta:{percent:0}})}).on("error",function(b){c.isPaused?this.generatedError=b:c.error(b)}).on("end",function(){c.isPaused?c._upstreamEnded=!0:c.end()})},et.prototype.pause=function(){return!!d.prototype.pause.call(this)&&(this._stream.pause(),!0)},et.prototype.resume=function(){return!!d.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},s.exports=et},{"../stream/GenericWorker":28,"../utils":32}],13:[function(i,s,h){var a=i("readable-stream").Readable;function d(et,$,c){a.call(this,$),this._helper=et;var b=this;et.on("data",function(g,nt){b.push(g)||b._helper.pause(),c&&c(nt)}).on("error",function(g){b.emit("error",g)}).on("end",function(){b.push(null)})}i("../utils").inherits(d,a),d.prototype._read=function(){this._helper.resume()},s.exports=d},{"../utils":32,"readable-stream":16}],14:[function(i,s,h){s.exports={isNode:typeof Buffer<"u",newBufferFrom:function(a,d){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(a,d);if(typeof a=="number")throw new Error('The "data" argument must not be a number');return new Buffer(a,d)},allocBuffer:function(a){if(Buffer.alloc)return Buffer.alloc(a);var d=new Buffer(a);return d.fill(0),d},isBuffer:function(a){return Buffer.isBuffer(a)},isStream:function(a){return a&&typeof a.on=="function"&&typeof a.pause=="function"&&typeof a.resume=="function"}}},{}],15:[function(i,s,h){function a(Zt,gr,vr){var Er,wo=et.getTypeOf(gr),Do=et.extend(vr||{},b);Do.date=Do.date||new Date,Do.compression!==null&&(Do.compression=Do.compression.toUpperCase()),typeof Do.unixPermissions=="string"&&(Do.unixPermissions=parseInt(Do.unixPermissions,8)),Do.unixPermissions&&16384&Do.unixPermissions&&(Do.dir=!0),Do.dosPermissions&&16&Do.dosPermissions&&(Do.dir=!0),Do.dir&&(Zt=St(Zt)),Do.createFolders&&(Er=Ct(Zt))&&xt.call(this,Er,!0);var Js=wo==="string"&&Do.binary===!1&&Do.base64===!1;vr&&vr.binary!==void 0||(Do.binary=!Js),(gr instanceof g&&gr.uncompressedSize===0||Do.dir||!gr||gr.length===0)&&(Do.base64=!1,Do.binary=!0,gr="",Do.compression="STORE",wo="string");var In=null;In=gr instanceof g||gr instanceof $?gr:Ot.isNode&&Ot.isStream(gr)?new At(Zt,gr):et.prepareContent(Zt,gr,Do.binary,Do.optimizedBinaryString,Do.base64);var Wo=new nt(Zt,In,Do);this.files[Zt]=Wo}var d=i("./utf8"),et=i("./utils"),$=i("./stream/GenericWorker"),c=i("./stream/StreamHelper"),b=i("./defaults"),g=i("./compressedObject"),nt=i("./zipObject"),at=i("./generate"),Ot=i("./nodejsUtils"),At=i("./nodejs/NodejsStreamInputAdapter"),Ct=function(Zt){Zt.slice(-1)==="/"&&(Zt=Zt.substring(0,Zt.length-1));var gr=Zt.lastIndexOf("/");return 0<gr?Zt.substring(0,gr):""},St=function(Zt){return Zt.slice(-1)!=="/"&&(Zt+="/"),Zt},xt=function(Zt,gr){return gr=gr!==void 0?gr:b.createFolders,Zt=St(Zt),this.files[Zt]||a.call(this,Zt,null,{dir:!0,createFolders:gr}),this.files[Zt]};function Dt(Zt){return Object.prototype.toString.call(Zt)==="[object RegExp]"}var Qt={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(Zt){var gr,vr,Er;for(gr in this.files)Er=this.files[gr],(vr=gr.slice(this.root.length,gr.length))&&gr.slice(0,this.root.length)===this.root&&Zt(vr,Er)},filter:function(Zt){var gr=[];return this.forEach(function(vr,Er){Zt(vr,Er)&&gr.push(Er)}),gr},file:function(Zt,gr,vr){if(arguments.length!==1)return Zt=this.root+Zt,a.call(this,Zt,gr,vr),this;if(Dt(Zt)){var Er=Zt;return this.filter(function(Do,Js){return!Js.dir&&Er.test(Do)})}var wo=this.files[this.root+Zt];return wo&&!wo.dir?wo:null},folder:function(Zt){if(!Zt)return this;if(Dt(Zt))return this.filter(function(wo,Do){return Do.dir&&Zt.test(wo)});var gr=this.root+Zt,vr=xt.call(this,gr),Er=this.clone();return Er.root=vr.name,Er},remove:function(Zt){Zt=this.root+Zt;var gr=this.files[Zt];if(gr||(Zt.slice(-1)!=="/"&&(Zt+="/"),gr=this.files[Zt]),gr&&!gr.dir)delete this.files[Zt];else for(var vr=this.filter(function(wo,Do){return Do.name.slice(0,Zt.length)===Zt}),Er=0;Er<vr.length;Er++)delete this.files[vr[Er].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(Zt){var gr,vr={};try{if((vr=et.extend(Zt||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:d.utf8encode})).type=vr.type.toLowerCase(),vr.compression=vr.compression.toUpperCase(),vr.type==="binarystring"&&(vr.type="string"),!vr.type)throw new Error("No output type specified.");et.checkSupport(vr.type),vr.platform!=="darwin"&&vr.platform!=="freebsd"&&vr.platform!=="linux"&&vr.platform!=="sunos"||(vr.platform="UNIX"),vr.platform==="win32"&&(vr.platform="DOS");var Er=vr.comment||this.comment||"";gr=at.generateWorker(this,vr,Er)}catch(wo){(gr=new $("error")).error(wo)}return new c(gr,vr.type||"string",vr.mimeType)},generateAsync:function(Zt,gr){return this.generateInternalStream(Zt).accumulate(gr)},generateNodeStream:function(Zt,gr){return(Zt=Zt||{}).type||(Zt.type="nodebuffer"),this.generateInternalStream(Zt).toNodejsStream(gr)}};s.exports=Qt},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(i,s,h){s.exports=i("stream")},{stream:void 0}],17:[function(i,s,h){var a=i("./DataReader");function d(et){a.call(this,et);for(var $=0;$<this.data.length;$++)et[$]=255&et[$]}i("../utils").inherits(d,a),d.prototype.byteAt=function(et){return this.data[this.zero+et]},d.prototype.lastIndexOfSignature=function(et){for(var $=et.charCodeAt(0),c=et.charCodeAt(1),b=et.charCodeAt(2),g=et.charCodeAt(3),nt=this.length-4;0<=nt;--nt)if(this.data[nt]===$&&this.data[nt+1]===c&&this.data[nt+2]===b&&this.data[nt+3]===g)return nt-this.zero;return-1},d.prototype.readAndCheckSignature=function(et){var $=et.charCodeAt(0),c=et.charCodeAt(1),b=et.charCodeAt(2),g=et.charCodeAt(3),nt=this.readData(4);return $===nt[0]&&c===nt[1]&&b===nt[2]&&g===nt[3]},d.prototype.readData=function(et){if(this.checkOffset(et),et===0)return[];var $=this.data.slice(this.zero+this.index,this.zero+this.index+et);return this.index+=et,$},s.exports=d},{"../utils":32,"./DataReader":18}],18:[function(i,s,h){var a=i("../utils");function d(et){this.data=et,this.length=et.length,this.index=0,this.zero=0}d.prototype={checkOffset:function(et){this.checkIndex(this.index+et)},checkIndex:function(et){if(this.length<this.zero+et||et<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+et+"). Corrupted zip ?")},setIndex:function(et){this.checkIndex(et),this.index=et},skip:function(et){this.setIndex(this.index+et)},byteAt:function(){},readInt:function(et){var $,c=0;for(this.checkOffset(et),$=this.index+et-1;$>=this.index;$--)c=(c<<8)+this.byteAt($);return this.index+=et,c},readString:function(et){return a.transformTo("string",this.readData(et))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var et=this.readInt(4);return new Date(Date.UTC(1980+(et>>25&127),(et>>21&15)-1,et>>16&31,et>>11&31,et>>5&63,(31&et)<<1))}},s.exports=d},{"../utils":32}],19:[function(i,s,h){var a=i("./Uint8ArrayReader");function d(et){a.call(this,et)}i("../utils").inherits(d,a),d.prototype.readData=function(et){this.checkOffset(et);var $=this.data.slice(this.zero+this.index,this.zero+this.index+et);return this.index+=et,$},s.exports=d},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(i,s,h){var a=i("./DataReader");function d(et){a.call(this,et)}i("../utils").inherits(d,a),d.prototype.byteAt=function(et){return this.data.charCodeAt(this.zero+et)},d.prototype.lastIndexOfSignature=function(et){return this.data.lastIndexOf(et)-this.zero},d.prototype.readAndCheckSignature=function(et){return et===this.readData(4)},d.prototype.readData=function(et){this.checkOffset(et);var $=this.data.slice(this.zero+this.index,this.zero+this.index+et);return this.index+=et,$},s.exports=d},{"../utils":32,"./DataReader":18}],21:[function(i,s,h){var a=i("./ArrayReader");function d(et){a.call(this,et)}i("../utils").inherits(d,a),d.prototype.readData=function(et){if(this.checkOffset(et),et===0)return new Uint8Array(0);var $=this.data.subarray(this.zero+this.index,this.zero+this.index+et);return this.index+=et,$},s.exports=d},{"../utils":32,"./ArrayReader":17}],22:[function(i,s,h){var a=i("../utils"),d=i("../support"),et=i("./ArrayReader"),$=i("./StringReader"),c=i("./NodeBufferReader"),b=i("./Uint8ArrayReader");s.exports=function(g){var nt=a.getTypeOf(g);return a.checkSupport(nt),nt!=="string"||d.uint8array?nt==="nodebuffer"?new c(g):d.uint8array?new b(a.transformTo("uint8array",g)):new et(a.transformTo("array",g)):new $(g)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(i,s,h){h.LOCAL_FILE_HEADER="PK",h.CENTRAL_FILE_HEADER="PK",h.CENTRAL_DIRECTORY_END="PK",h.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK\x07",h.ZIP64_CENTRAL_DIRECTORY_END="PK",h.DATA_DESCRIPTOR="PK\x07\b"},{}],24:[function(i,s,h){var a=i("./GenericWorker"),d=i("../utils");function et($){a.call(this,"ConvertWorker to "+$),this.destType=$}d.inherits(et,a),et.prototype.processChunk=function($){this.push({data:d.transformTo(this.destType,$.data),meta:$.meta})},s.exports=et},{"../utils":32,"./GenericWorker":28}],25:[function(i,s,h){var a=i("./GenericWorker"),d=i("../crc32");function et(){a.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}i("../utils").inherits(et,a),et.prototype.processChunk=function($){this.streamInfo.crc32=d($.data,this.streamInfo.crc32||0),this.push($)},s.exports=et},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(i,s,h){var a=i("../utils"),d=i("./GenericWorker");function et($){d.call(this,"DataLengthProbe for "+$),this.propName=$,this.withStreamInfo($,0)}a.inherits(et,d),et.prototype.processChunk=function($){if($){var c=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=c+$.data.length}d.prototype.processChunk.call(this,$)},s.exports=et},{"../utils":32,"./GenericWorker":28}],27:[function(i,s,h){var a=i("../utils"),d=i("./GenericWorker");function et($){d.call(this,"DataWorker");var c=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,$.then(function(b){c.dataIsReady=!0,c.data=b,c.max=b&&b.length||0,c.type=a.getTypeOf(b),c.isPaused||c._tickAndRepeat()},function(b){c.error(b)})}a.inherits(et,d),et.prototype.cleanUp=function(){d.prototype.cleanUp.call(this),this.data=null},et.prototype.resume=function(){return!!d.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,a.delay(this._tickAndRepeat,[],this)),!0)},et.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(a.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},et.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var $=null,c=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":$=this.data.substring(this.index,c);break;case"uint8array":$=this.data.subarray(this.index,c);break;case"array":case"nodebuffer":$=this.data.slice(this.index,c)}return this.index=c,this.push({data:$,meta:{percent:this.max?this.index/this.max*100:0}})},s.exports=et},{"../utils":32,"./GenericWorker":28}],28:[function(i,s,h){function a(d){this.name=d||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}a.prototype={push:function(d){this.emit("data",d)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(d){this.emit("error",d)}return!0},error:function(d){return!this.isFinished&&(this.isPaused?this.generatedError=d:(this.isFinished=!0,this.emit("error",d),this.previous&&this.previous.error(d),this.cleanUp()),!0)},on:function(d,et){return this._listeners[d].push(et),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(d,et){if(this._listeners[d])for(var $=0;$<this._listeners[d].length;$++)this._listeners[d][$].call(this,et)},pipe:function(d){return d.registerPrevious(this)},registerPrevious:function(d){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=d.streamInfo,this.mergeStreamInfo(),this.previous=d;var et=this;return d.on("data",function($){et.processChunk($)}),d.on("end",function(){et.end()}),d.on("error",function($){et.error($)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var d=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),d=!0),this.previous&&this.previous.resume(),!d},flush:function(){},processChunk:function(d){this.push(d)},withStreamInfo:function(d,et){return this.extraStreamInfo[d]=et,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var d in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,d)&&(this.streamInfo[d]=this.extraStreamInfo[d])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var d="Worker "+this.name;return this.previous?this.previous+" -> "+d:d}},s.exports=a},{}],29:[function(i,s,h){var a=i("../utils"),d=i("./ConvertWorker"),et=i("./GenericWorker"),$=i("../base64"),c=i("../support"),b=i("../external"),g=null;if(c.nodestream)try{g=i("../nodejs/NodejsStreamOutputAdapter")}catch{}function nt(Ot,At){return new b.Promise(function(Ct,St){var xt=[],Dt=Ot._internalType,Qt=Ot._outputType,Zt=Ot._mimeType;Ot.on("data",function(gr,vr){xt.push(gr),At&&At(vr)}).on("error",function(gr){xt=[],St(gr)}).on("end",function(){try{var gr=function(vr,Er,wo){switch(vr){case"blob":return a.newBlob(a.transformTo("arraybuffer",Er),wo);case"base64":return $.encode(Er);default:return a.transformTo(vr,Er)}}(Qt,function(vr,Er){var wo,Do=0,Js=null,In=0;for(wo=0;wo<Er.length;wo++)In+=Er[wo].length;switch(vr){case"string":return Er.join("");case"array":return Array.prototype.concat.apply([],Er);case"uint8array":for(Js=new Uint8Array(In),wo=0;wo<Er.length;wo++)Js.set(Er[wo],Do),Do+=Er[wo].length;return Js;case"nodebuffer":return Buffer.concat(Er);default:throw new Error("concat : unsupported type '"+vr+"'")}}(Dt,xt),Zt);Ct(gr)}catch(vr){St(vr)}xt=[]}).resume()})}function at(Ot,At,Ct){var St=At;switch(At){case"blob":case"arraybuffer":St="uint8array";break;case"base64":St="string"}try{this._internalType=St,this._outputType=At,this._mimeType=Ct,a.checkSupport(St),this._worker=Ot.pipe(new d(St)),Ot.lock()}catch(xt){this._worker=new et("error"),this._worker.error(xt)}}at.prototype={accumulate:function(Ot){return nt(this,Ot)},on:function(Ot,At){var Ct=this;return Ot==="data"?this._worker.on(Ot,function(St){At.call(Ct,St.data,St.meta)}):this._worker.on(Ot,function(){a.delay(At,arguments,Ct)}),this},resume:function(){return a.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(Ot){if(a.checkSupport("nodestream"),this._outputType!=="nodebuffer")throw new Error(this._outputType+" is not supported by this method");return new g(this,{objectMode:this._outputType!=="nodebuffer"},Ot)}},s.exports=at},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(i,s,h){if(h.base64=!0,h.array=!0,h.string=!0,h.arraybuffer=typeof ArrayBuffer<"u"&&typeof Uint8Array<"u",h.nodebuffer=typeof Buffer<"u",h.uint8array=typeof Uint8Array<"u",typeof ArrayBuffer>"u")h.blob=!1;else{var a=new ArrayBuffer(0);try{h.blob=new Blob([a],{type:"application/zip"}).size===0}catch{try{var d=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);d.append(a),h.blob=d.getBlob("application/zip").size===0}catch{h.blob=!1}}}try{h.nodestream=!!i("readable-stream").Readable}catch{h.nodestream=!1}},{"readable-stream":16}],31:[function(i,s,h){for(var a=i("./utils"),d=i("./support"),et=i("./nodejsUtils"),$=i("./stream/GenericWorker"),c=new Array(256),b=0;b<256;b++)c[b]=252<=b?6:248<=b?5:240<=b?4:224<=b?3:192<=b?2:1;c[254]=c[254]=1;function g(){$.call(this,"utf-8 decode"),this.leftOver=null}function nt(){$.call(this,"utf-8 encode")}h.utf8encode=function(at){return d.nodebuffer?et.newBufferFrom(at,"utf-8"):function(Ot){var At,Ct,St,xt,Dt,Qt=Ot.length,Zt=0;for(xt=0;xt<Qt;xt++)(64512&(Ct=Ot.charCodeAt(xt)))==55296&&xt+1<Qt&&(64512&(St=Ot.charCodeAt(xt+1)))==56320&&(Ct=65536+(Ct-55296<<10)+(St-56320),xt++),Zt+=Ct<128?1:Ct<2048?2:Ct<65536?3:4;for(At=d.uint8array?new Uint8Array(Zt):new Array(Zt),xt=Dt=0;Dt<Zt;xt++)(64512&(Ct=Ot.charCodeAt(xt)))==55296&&xt+1<Qt&&(64512&(St=Ot.charCodeAt(xt+1)))==56320&&(Ct=65536+(Ct-55296<<10)+(St-56320),xt++),Ct<128?At[Dt++]=Ct:(Ct<2048?At[Dt++]=192|Ct>>>6:(Ct<65536?At[Dt++]=224|Ct>>>12:(At[Dt++]=240|Ct>>>18,At[Dt++]=128|Ct>>>12&63),At[Dt++]=128|Ct>>>6&63),At[Dt++]=128|63&Ct);return At}(at)},h.utf8decode=function(at){return d.nodebuffer?a.transformTo("nodebuffer",at).toString("utf-8"):function(Ot){var At,Ct,St,xt,Dt=Ot.length,Qt=new Array(2*Dt);for(At=Ct=0;At<Dt;)if((St=Ot[At++])<128)Qt[Ct++]=St;else if(4<(xt=c[St]))Qt[Ct++]=65533,At+=xt-1;else{for(St&=xt===2?31:xt===3?15:7;1<xt&&At<Dt;)St=St<<6|63&Ot[At++],xt--;1<xt?Qt[Ct++]=65533:St<65536?Qt[Ct++]=St:(St-=65536,Qt[Ct++]=55296|St>>10&1023,Qt[Ct++]=56320|1023&St)}return Qt.length!==Ct&&(Qt.subarray?Qt=Qt.subarray(0,Ct):Qt.length=Ct),a.applyFromCharCode(Qt)}(at=a.transformTo(d.uint8array?"uint8array":"array",at))},a.inherits(g,$),g.prototype.processChunk=function(at){var Ot=a.transformTo(d.uint8array?"uint8array":"array",at.data);if(this.leftOver&&this.leftOver.length){if(d.uint8array){var At=Ot;(Ot=new Uint8Array(At.length+this.leftOver.length)).set(this.leftOver,0),Ot.set(At,this.leftOver.length)}else Ot=this.leftOver.concat(Ot);this.leftOver=null}var Ct=function(xt,Dt){var Qt;for((Dt=Dt||xt.length)>xt.length&&(Dt=xt.length),Qt=Dt-1;0<=Qt&&(192&xt[Qt])==128;)Qt--;return Qt<0||Qt===0?Dt:Qt+c[xt[Qt]]>Dt?Qt:Dt}(Ot),St=Ot;Ct!==Ot.length&&(d.uint8array?(St=Ot.subarray(0,Ct),this.leftOver=Ot.subarray(Ct,Ot.length)):(St=Ot.slice(0,Ct),this.leftOver=Ot.slice(Ct,Ot.length))),this.push({data:h.utf8decode(St),meta:at.meta})},g.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:h.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},h.Utf8DecodeWorker=g,a.inherits(nt,$),nt.prototype.processChunk=function(at){this.push({data:h.utf8encode(at.data),meta:at.meta})},h.Utf8EncodeWorker=nt},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(i,s,h){var a=i("./support"),d=i("./base64"),et=i("./nodejsUtils"),$=i("./external");function c(At){return At}function b(At,Ct){for(var St=0;St<At.length;++St)Ct[St]=255&At.charCodeAt(St);return Ct}i("setimmediate"),h.newBlob=function(At,Ct){h.checkSupport("blob");try{return new Blob([At],{type:Ct})}catch{try{var St=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return St.append(At),St.getBlob(Ct)}catch{throw new Error("Bug : can't construct the Blob.")}}};var g={stringifyByChunk:function(At,Ct,St){var xt=[],Dt=0,Qt=At.length;if(Qt<=St)return String.fromCharCode.apply(null,At);for(;Dt<Qt;)Ct==="array"||Ct==="nodebuffer"?xt.push(String.fromCharCode.apply(null,At.slice(Dt,Math.min(Dt+St,Qt)))):xt.push(String.fromCharCode.apply(null,At.subarray(Dt,Math.min(Dt+St,Qt)))),Dt+=St;return xt.join("")},stringifyByChar:function(At){for(var Ct="",St=0;St<At.length;St++)Ct+=String.fromCharCode(At[St]);return Ct},applyCanBeUsed:{uint8array:function(){try{return a.uint8array&&String.fromCharCode.apply(null,new Uint8Array(1)).length===1}catch{return!1}}(),nodebuffer:function(){try{return a.nodebuffer&&String.fromCharCode.apply(null,et.allocBuffer(1)).length===1}catch{return!1}}()}};function nt(At){var Ct=65536,St=h.getTypeOf(At),xt=!0;if(St==="uint8array"?xt=g.applyCanBeUsed.uint8array:St==="nodebuffer"&&(xt=g.applyCanBeUsed.nodebuffer),xt)for(;1<Ct;)try{return g.stringifyByChunk(At,St,Ct)}catch{Ct=Math.floor(Ct/2)}return g.stringifyByChar(At)}function at(At,Ct){for(var St=0;St<At.length;St++)Ct[St]=At[St];return Ct}h.applyFromCharCode=nt;var Ot={};Ot.string={string:c,array:function(At){return b(At,new Array(At.length))},arraybuffer:function(At){return Ot.string.uint8array(At).buffer},uint8array:function(At){return b(At,new Uint8Array(At.length))},nodebuffer:function(At){return b(At,et.allocBuffer(At.length))}},Ot.array={string:nt,array:c,arraybuffer:function(At){return new Uint8Array(At).buffer},uint8array:function(At){return new Uint8Array(At)},nodebuffer:function(At){return et.newBufferFrom(At)}},Ot.arraybuffer={string:function(At){return nt(new Uint8Array(At))},array:function(At){return at(new Uint8Array(At),new Array(At.byteLength))},arraybuffer:c,uint8array:function(At){return new Uint8Array(At)},nodebuffer:function(At){return et.newBufferFrom(new Uint8Array(At))}},Ot.uint8array={string:nt,array:function(At){return at(At,new Array(At.length))},arraybuffer:function(At){return At.buffer},uint8array:c,nodebuffer:function(At){return et.newBufferFrom(At)}},Ot.nodebuffer={string:nt,array:function(At){return at(At,new Array(At.length))},arraybuffer:function(At){return Ot.nodebuffer.uint8array(At).buffer},uint8array:function(At){return at(At,new Uint8Array(At.length))},nodebuffer:c},h.transformTo=function(At,Ct){if(Ct=Ct||"",!At)return Ct;h.checkSupport(At);var St=h.getTypeOf(Ct);return Ot[St][At](Ct)},h.resolve=function(At){for(var Ct=At.split("/"),St=[],xt=0;xt<Ct.length;xt++){var Dt=Ct[xt];Dt==="."||Dt===""&&xt!==0&&xt!==Ct.length-1||(Dt===".."?St.pop():St.push(Dt))}return St.join("/")},h.getTypeOf=function(At){return typeof At=="string"?"string":Object.prototype.toString.call(At)==="[object Array]"?"array":a.nodebuffer&&et.isBuffer(At)?"nodebuffer":a.uint8array&&At instanceof Uint8Array?"uint8array":a.arraybuffer&&At instanceof ArrayBuffer?"arraybuffer":void 0},h.checkSupport=function(At){if(!a[At.toLowerCase()])throw new Error(At+" is not supported by this platform")},h.MAX_VALUE_16BITS=65535,h.MAX_VALUE_32BITS=-1,h.pretty=function(At){var Ct,St,xt="";for(St=0;St<(At||"").length;St++)xt+="\\x"+((Ct=At.charCodeAt(St))<16?"0":"")+Ct.toString(16).toUpperCase();return xt},h.delay=function(At,Ct,St){setImmediate(function(){At.apply(St||null,Ct||[])})},h.inherits=function(At,Ct){function St(){}St.prototype=Ct.prototype,At.prototype=new St},h.extend=function(){var At,Ct,St={};for(At=0;At<arguments.length;At++)for(Ct in arguments[At])Object.prototype.hasOwnProperty.call(arguments[At],Ct)&&St[Ct]===void 0&&(St[Ct]=arguments[At][Ct]);return St},h.prepareContent=function(At,Ct,St,xt,Dt){return $.Promise.resolve(Ct).then(function(Qt){return a.blob&&(Qt instanceof Blob||["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(Qt))!==-1)&&typeof FileReader<"u"?new $.Promise(function(Zt,gr){var vr=new FileReader;vr.onload=function(Er){Zt(Er.target.result)},vr.onerror=function(Er){gr(Er.target.error)},vr.readAsArrayBuffer(Qt)}):Qt}).then(function(Qt){var Zt=h.getTypeOf(Qt);return Zt?(Zt==="arraybuffer"?Qt=h.transformTo("uint8array",Qt):Zt==="string"&&(Dt?Qt=d.decode(Qt):St&&xt!==!0&&(Qt=function(gr){return b(gr,a.uint8array?new Uint8Array(gr.length):new Array(gr.length))}(Qt))),Qt):$.Promise.reject(new Error("Can't read the data of '"+At+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(i,s,h){var a=i("./reader/readerFor"),d=i("./utils"),et=i("./signature"),$=i("./zipEntry"),c=i("./support");function b(g){this.files=[],this.loadOptions=g}b.prototype={checkSignature:function(g){if(!this.reader.readAndCheckSignature(g)){this.reader.index-=4;var nt=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+d.pretty(nt)+", expected "+d.pretty(g)+")")}},isSignature:function(g,nt){var at=this.reader.index;this.reader.setIndex(g);var Ot=this.reader.readString(4)===nt;return this.reader.setIndex(at),Ot},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var g=this.reader.readData(this.zipCommentLength),nt=c.uint8array?"uint8array":"array",at=d.transformTo(nt,g);this.zipComment=this.loadOptions.decodeFileName(at)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var g,nt,at,Ot=this.zip64EndOfCentralSize-44;0<Ot;)g=this.reader.readInt(2),nt=this.reader.readInt(4),at=this.reader.readData(nt),this.zip64ExtensibleData[g]={id:g,length:nt,value:at}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var g,nt;for(g=0;g<this.files.length;g++)nt=this.files[g],this.reader.setIndex(nt.localHeaderOffset),this.checkSignature(et.LOCAL_FILE_HEADER),nt.readLocalPart(this.reader),nt.handleUTF8(),nt.processAttributes()},readCentralDir:function(){var g;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(et.CENTRAL_FILE_HEADER);)(g=new $({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(g);if(this.centralDirRecords!==this.files.length&&this.centralDirRecords!==0&&this.files.length===0)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var g=this.reader.lastIndexOfSignature(et.CENTRAL_DIRECTORY_END);if(g<0)throw this.isSignature(0,et.LOCAL_FILE_HEADER)?new Error("Corrupted zip: can't find end of central directory"):new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");this.reader.setIndex(g);var nt=g;if(this.checkSignature(et.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===d.MAX_VALUE_16BITS||this.diskWithCentralDirStart===d.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===d.MAX_VALUE_16BITS||this.centralDirRecords===d.MAX_VALUE_16BITS||this.centralDirSize===d.MAX_VALUE_32BITS||this.centralDirOffset===d.MAX_VALUE_32BITS){if(this.zip64=!0,(g=this.reader.lastIndexOfSignature(et.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(g),this.checkSignature(et.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,et.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(et.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(et.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var at=this.centralDirOffset+this.centralDirSize;this.zip64&&(at+=20,at+=12+this.zip64EndOfCentralSize);var Ot=nt-at;if(0<Ot)this.isSignature(nt,et.CENTRAL_FILE_HEADER)||(this.reader.zero=Ot);else if(Ot<0)throw new Error("Corrupted zip: missing "+Math.abs(Ot)+" bytes.")},prepareReader:function(g){this.reader=a(g)},load:function(g){this.prepareReader(g),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},s.exports=b},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(i,s,h){var a=i("./reader/readerFor"),d=i("./utils"),et=i("./compressedObject"),$=i("./crc32"),c=i("./utf8"),b=i("./compressions"),g=i("./support");function nt(at,Ot){this.options=at,this.loadOptions=Ot}nt.prototype={isEncrypted:function(){return(1&this.bitFlag)==1},useUTF8:function(){return(2048&this.bitFlag)==2048},readLocalPart:function(at){var Ot,At;if(at.skip(22),this.fileNameLength=at.readInt(2),At=at.readInt(2),this.fileName=at.readData(this.fileNameLength),at.skip(At),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if((Ot=function(Ct){for(var St in b)if(Object.prototype.hasOwnProperty.call(b,St)&&b[St].magic===Ct)return b[St];return null}(this.compressionMethod))===null)throw new Error("Corrupted zip : compression "+d.pretty(this.compressionMethod)+" unknown (inner file : "+d.transformTo("string",this.fileName)+")");this.decompressed=new et(this.compressedSize,this.uncompressedSize,this.crc32,Ot,at.readData(this.compressedSize))},readCentralPart:function(at){this.versionMadeBy=at.readInt(2),at.skip(2),this.bitFlag=at.readInt(2),this.compressionMethod=at.readString(2),this.date=at.readDate(),this.crc32=at.readInt(4),this.compressedSize=at.readInt(4),this.uncompressedSize=at.readInt(4);var Ot=at.readInt(2);if(this.extraFieldsLength=at.readInt(2),this.fileCommentLength=at.readInt(2),this.diskNumberStart=at.readInt(2),this.internalFileAttributes=at.readInt(2),this.externalFileAttributes=at.readInt(4),this.localHeaderOffset=at.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");at.skip(Ot),this.readExtraFields(at),this.parseZIP64ExtraField(at),this.fileComment=at.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var at=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),at==0&&(this.dosPermissions=63&this.externalFileAttributes),at==3&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||this.fileNameStr.slice(-1)!=="/"||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var at=a(this.extraFields[1].value);this.uncompressedSize===d.MAX_VALUE_32BITS&&(this.uncompressedSize=at.readInt(8)),this.compressedSize===d.MAX_VALUE_32BITS&&(this.compressedSize=at.readInt(8)),this.localHeaderOffset===d.MAX_VALUE_32BITS&&(this.localHeaderOffset=at.readInt(8)),this.diskNumberStart===d.MAX_VALUE_32BITS&&(this.diskNumberStart=at.readInt(4))}},readExtraFields:function(at){var Ot,At,Ct,St=at.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});at.index+4<St;)Ot=at.readInt(2),At=at.readInt(2),Ct=at.readData(At),this.extraFields[Ot]={id:Ot,length:At,value:Ct};at.setIndex(St)},handleUTF8:function(){var at=g.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=c.utf8decode(this.fileName),this.fileCommentStr=c.utf8decode(this.fileComment);else{var Ot=this.findExtraFieldUnicodePath();if(Ot!==null)this.fileNameStr=Ot;else{var At=d.transformTo(at,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(At)}var Ct=this.findExtraFieldUnicodeComment();if(Ct!==null)this.fileCommentStr=Ct;else{var St=d.transformTo(at,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(St)}}},findExtraFieldUnicodePath:function(){var at=this.extraFields[28789];if(at){var Ot=a(at.value);return Ot.readInt(1)!==1||$(this.fileName)!==Ot.readInt(4)?null:c.utf8decode(Ot.readData(at.length-5))}return null},findExtraFieldUnicodeComment:function(){var at=this.extraFields[25461];if(at){var Ot=a(at.value);return Ot.readInt(1)!==1||$(this.fileComment)!==Ot.readInt(4)?null:c.utf8decode(Ot.readData(at.length-5))}return null}},s.exports=nt},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(i,s,h){function a(Ot,At,Ct){this.name=Ot,this.dir=Ct.dir,this.date=Ct.date,this.comment=Ct.comment,this.unixPermissions=Ct.unixPermissions,this.dosPermissions=Ct.dosPermissions,this._data=At,this._dataBinary=Ct.binary,this.options={compression:Ct.compression,compressionOptions:Ct.compressionOptions}}var d=i("./stream/StreamHelper"),et=i("./stream/DataWorker"),$=i("./utf8"),c=i("./compressedObject"),b=i("./stream/GenericWorker");a.prototype={internalStream:function(Ot){var At=null,Ct="string";try{if(!Ot)throw new Error("No output type specified.");var St=(Ct=Ot.toLowerCase())==="string"||Ct==="text";Ct!=="binarystring"&&Ct!=="text"||(Ct="string"),At=this._decompressWorker();var xt=!this._dataBinary;xt&&!St&&(At=At.pipe(new $.Utf8EncodeWorker)),!xt&&St&&(At=At.pipe(new $.Utf8DecodeWorker))}catch(Dt){(At=new b("error")).error(Dt)}return new d(At,Ct,"")},async:function(Ot,At){return this.internalStream(Ot).accumulate(At)},nodeStream:function(Ot,At){return this.internalStream(Ot||"nodebuffer").toNodejsStream(At)},_compressWorker:function(Ot,At){if(this._data instanceof c&&this._data.compression.magic===Ot.magic)return this._data.getCompressedWorker();var Ct=this._decompressWorker();return this._dataBinary||(Ct=Ct.pipe(new $.Utf8EncodeWorker)),c.createWorkerFrom(Ct,Ot,At)},_decompressWorker:function(){return this._data instanceof c?this._data.getContentWorker():this._data instanceof b?this._data:new et(this._data)}};for(var g=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],nt=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},at=0;at<g.length;at++)a.prototype[g[at]]=nt;s.exports=a},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(i,s,h){(function(a){var d,et,$=a.MutationObserver||a.WebKitMutationObserver;if($){var c=0,b=new $(Ot),g=a.document.createTextNode("");b.observe(g,{characterData:!0}),d=function(){g.data=c=++c%2}}else if(a.setImmediate||a.MessageChannel===void 0)d="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var At=a.document.createElement("script");At.onreadystatechange=function(){Ot(),At.onreadystatechange=null,At.parentNode.removeChild(At),At=null},a.document.documentElement.appendChild(At)}:function(){setTimeout(Ot,0)};else{var nt=new a.MessageChannel;nt.port1.onmessage=Ot,d=function(){nt.port2.postMessage(0)}}var at=[];function Ot(){var At,Ct;et=!0;for(var St=at.length;St;){for(Ct=at,at=[],At=-1;++At<St;)Ct[At]();St=at.length}et=!1}s.exports=function(At){at.push(At)!==1||et||d()}}).call(this,typeof commonjsGlobal<"u"?commonjsGlobal:typeof self<"u"?self:typeof window<"u"?window:{})},{}],37:[function(i,s,h){var a=i("immediate");function d(){}var et={},$=["REJECTED"],c=["FULFILLED"],b=["PENDING"];function g(St){if(typeof St!="function")throw new TypeError("resolver must be a function");this.state=b,this.queue=[],this.outcome=void 0,St!==d&&At(this,St)}function nt(St,xt,Dt){this.promise=St,typeof xt=="function"&&(this.onFulfilled=xt,this.callFulfilled=this.otherCallFulfilled),typeof Dt=="function"&&(this.onRejected=Dt,this.callRejected=this.otherCallRejected)}function at(St,xt,Dt){a(function(){var Qt;try{Qt=xt(Dt)}catch(Zt){return et.reject(St,Zt)}Qt===St?et.reject(St,new TypeError("Cannot resolve promise with itself")):et.resolve(St,Qt)})}function Ot(St){var xt=St&&St.then;if(St&&(typeof St=="object"||typeof St=="function")&&typeof xt=="function")return function(){xt.apply(St,arguments)}}function At(St,xt){var Dt=!1;function Qt(vr){Dt||(Dt=!0,et.reject(St,vr))}function Zt(vr){Dt||(Dt=!0,et.resolve(St,vr))}var gr=Ct(function(){xt(Zt,Qt)});gr.status==="error"&&Qt(gr.value)}function Ct(St,xt){var Dt={};try{Dt.value=St(xt),Dt.status="success"}catch(Qt){Dt.status="error",Dt.value=Qt}return Dt}(s.exports=g).prototype.finally=function(St){if(typeof St!="function")return this;var xt=this.constructor;return this.then(function(Dt){return xt.resolve(St()).then(function(){return Dt})},function(Dt){return xt.resolve(St()).then(function(){throw Dt})})},g.prototype.catch=function(St){return this.then(null,St)},g.prototype.then=function(St,xt){if(typeof St!="function"&&this.state===c||typeof xt!="function"&&this.state===$)return this;var Dt=new this.constructor(d);return this.state!==b?at(Dt,this.state===c?St:xt,this.outcome):this.queue.push(new nt(Dt,St,xt)),Dt},nt.prototype.callFulfilled=function(St){et.resolve(this.promise,St)},nt.prototype.otherCallFulfilled=function(St){at(this.promise,this.onFulfilled,St)},nt.prototype.callRejected=function(St){et.reject(this.promise,St)},nt.prototype.otherCallRejected=function(St){at(this.promise,this.onRejected,St)},et.resolve=function(St,xt){var Dt=Ct(Ot,xt);if(Dt.status==="error")return et.reject(St,Dt.value);var Qt=Dt.value;if(Qt)At(St,Qt);else{St.state=c,St.outcome=xt;for(var Zt=-1,gr=St.queue.length;++Zt<gr;)St.queue[Zt].callFulfilled(xt)}return St},et.reject=function(St,xt){St.state=$,St.outcome=xt;for(var Dt=-1,Qt=St.queue.length;++Dt<Qt;)St.queue[Dt].callRejected(xt);return St},g.resolve=function(St){return St instanceof this?St:et.resolve(new this(d),St)},g.reject=function(St){var xt=new this(d);return et.reject(xt,St)},g.all=function(St){var xt=this;if(Object.prototype.toString.call(St)!=="[object Array]")return this.reject(new TypeError("must be an array"));var Dt=St.length,Qt=!1;if(!Dt)return this.resolve([]);for(var Zt=new Array(Dt),gr=0,vr=-1,Er=new this(d);++vr<Dt;)wo(St[vr],vr);return Er;function wo(Do,Js){xt.resolve(Do).then(function(In){Zt[Js]=In,++gr!==Dt||Qt||(Qt=!0,et.resolve(Er,Zt))},function(In){Qt||(Qt=!0,et.reject(Er,In))})}},g.race=function(St){var xt=this;if(Object.prototype.toString.call(St)!=="[object Array]")return this.reject(new TypeError("must be an array"));var Dt=St.length,Qt=!1;if(!Dt)return this.resolve([]);for(var Zt=-1,gr=new this(d);++Zt<Dt;)vr=St[Zt],xt.resolve(vr).then(function(Er){Qt||(Qt=!0,et.resolve(gr,Er))},function(Er){Qt||(Qt=!0,et.reject(gr,Er))});var vr;return gr}},{immediate:36}],38:[function(i,s,h){var a={};(0,i("./lib/utils/common").assign)(a,i("./lib/deflate"),i("./lib/inflate"),i("./lib/zlib/constants")),s.exports=a},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(i,s,h){var a=i("./zlib/deflate"),d=i("./utils/common"),et=i("./utils/strings"),$=i("./zlib/messages"),c=i("./zlib/zstream"),b=Object.prototype.toString,g=0,nt=-1,at=0,Ot=8;function At(St){if(!(this instanceof At))return new At(St);this.options=d.assign({level:nt,method:Ot,chunkSize:16384,windowBits:15,memLevel:8,strategy:at,to:""},St||{});var xt=this.options;xt.raw&&0<xt.windowBits?xt.windowBits=-xt.windowBits:xt.gzip&&0<xt.windowBits&&xt.windowBits<16&&(xt.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new c,this.strm.avail_out=0;var Dt=a.deflateInit2(this.strm,xt.level,xt.method,xt.windowBits,xt.memLevel,xt.strategy);if(Dt!==g)throw new Error($[Dt]);if(xt.header&&a.deflateSetHeader(this.strm,xt.header),xt.dictionary){var Qt;if(Qt=typeof xt.dictionary=="string"?et.string2buf(xt.dictionary):b.call(xt.dictionary)==="[object ArrayBuffer]"?new Uint8Array(xt.dictionary):xt.dictionary,(Dt=a.deflateSetDictionary(this.strm,Qt))!==g)throw new Error($[Dt]);this._dict_set=!0}}function Ct(St,xt){var Dt=new At(xt);if(Dt.push(St,!0),Dt.err)throw Dt.msg||$[Dt.err];return Dt.result}At.prototype.push=function(St,xt){var Dt,Qt,Zt=this.strm,gr=this.options.chunkSize;if(this.ended)return!1;Qt=xt===~~xt?xt:xt===!0?4:0,typeof St=="string"?Zt.input=et.string2buf(St):b.call(St)==="[object ArrayBuffer]"?Zt.input=new Uint8Array(St):Zt.input=St,Zt.next_in=0,Zt.avail_in=Zt.input.length;do{if(Zt.avail_out===0&&(Zt.output=new d.Buf8(gr),Zt.next_out=0,Zt.avail_out=gr),(Dt=a.deflate(Zt,Qt))!==1&&Dt!==g)return this.onEnd(Dt),!(this.ended=!0);Zt.avail_out!==0&&(Zt.avail_in!==0||Qt!==4&&Qt!==2)||(this.options.to==="string"?this.onData(et.buf2binstring(d.shrinkBuf(Zt.output,Zt.next_out))):this.onData(d.shrinkBuf(Zt.output,Zt.next_out)))}while((0<Zt.avail_in||Zt.avail_out===0)&&Dt!==1);return Qt===4?(Dt=a.deflateEnd(this.strm),this.onEnd(Dt),this.ended=!0,Dt===g):Qt!==2||(this.onEnd(g),!(Zt.avail_out=0))},At.prototype.onData=function(St){this.chunks.push(St)},At.prototype.onEnd=function(St){St===g&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=d.flattenChunks(this.chunks)),this.chunks=[],this.err=St,this.msg=this.strm.msg},h.Deflate=At,h.deflate=Ct,h.deflateRaw=function(St,xt){return(xt=xt||{}).raw=!0,Ct(St,xt)},h.gzip=function(St,xt){return(xt=xt||{}).gzip=!0,Ct(St,xt)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(i,s,h){var a=i("./zlib/inflate"),d=i("./utils/common"),et=i("./utils/strings"),$=i("./zlib/constants"),c=i("./zlib/messages"),b=i("./zlib/zstream"),g=i("./zlib/gzheader"),nt=Object.prototype.toString;function at(At){if(!(this instanceof at))return new at(At);this.options=d.assign({chunkSize:16384,windowBits:0,to:""},At||{});var Ct=this.options;Ct.raw&&0<=Ct.windowBits&&Ct.windowBits<16&&(Ct.windowBits=-Ct.windowBits,Ct.windowBits===0&&(Ct.windowBits=-15)),!(0<=Ct.windowBits&&Ct.windowBits<16)||At&&At.windowBits||(Ct.windowBits+=32),15<Ct.windowBits&&Ct.windowBits<48&&!(15&Ct.windowBits)&&(Ct.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new b,this.strm.avail_out=0;var St=a.inflateInit2(this.strm,Ct.windowBits);if(St!==$.Z_OK)throw new Error(c[St]);this.header=new g,a.inflateGetHeader(this.strm,this.header)}function Ot(At,Ct){var St=new at(Ct);if(St.push(At,!0),St.err)throw St.msg||c[St.err];return St.result}at.prototype.push=function(At,Ct){var St,xt,Dt,Qt,Zt,gr,vr=this.strm,Er=this.options.chunkSize,wo=this.options.dictionary,Do=!1;if(this.ended)return!1;xt=Ct===~~Ct?Ct:Ct===!0?$.Z_FINISH:$.Z_NO_FLUSH,typeof At=="string"?vr.input=et.binstring2buf(At):nt.call(At)==="[object ArrayBuffer]"?vr.input=new Uint8Array(At):vr.input=At,vr.next_in=0,vr.avail_in=vr.input.length;do{if(vr.avail_out===0&&(vr.output=new d.Buf8(Er),vr.next_out=0,vr.avail_out=Er),(St=a.inflate(vr,$.Z_NO_FLUSH))===$.Z_NEED_DICT&&wo&&(gr=typeof wo=="string"?et.string2buf(wo):nt.call(wo)==="[object ArrayBuffer]"?new Uint8Array(wo):wo,St=a.inflateSetDictionary(this.strm,gr)),St===$.Z_BUF_ERROR&&Do===!0&&(St=$.Z_OK,Do=!1),St!==$.Z_STREAM_END&&St!==$.Z_OK)return this.onEnd(St),!(this.ended=!0);vr.next_out&&(vr.avail_out!==0&&St!==$.Z_STREAM_END&&(vr.avail_in!==0||xt!==$.Z_FINISH&&xt!==$.Z_SYNC_FLUSH)||(this.options.to==="string"?(Dt=et.utf8border(vr.output,vr.next_out),Qt=vr.next_out-Dt,Zt=et.buf2string(vr.output,Dt),vr.next_out=Qt,vr.avail_out=Er-Qt,Qt&&d.arraySet(vr.output,vr.output,Dt,Qt,0),this.onData(Zt)):this.onData(d.shrinkBuf(vr.output,vr.next_out)))),vr.avail_in===0&&vr.avail_out===0&&(Do=!0)}while((0<vr.avail_in||vr.avail_out===0)&&St!==$.Z_STREAM_END);return St===$.Z_STREAM_END&&(xt=$.Z_FINISH),xt===$.Z_FINISH?(St=a.inflateEnd(this.strm),this.onEnd(St),this.ended=!0,St===$.Z_OK):xt!==$.Z_SYNC_FLUSH||(this.onEnd($.Z_OK),!(vr.avail_out=0))},at.prototype.onData=function(At){this.chunks.push(At)},at.prototype.onEnd=function(At){At===$.Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=d.flattenChunks(this.chunks)),this.chunks=[],this.err=At,this.msg=this.strm.msg},h.Inflate=at,h.inflate=Ot,h.inflateRaw=function(At,Ct){return(Ct=Ct||{}).raw=!0,Ot(At,Ct)},h.ungzip=Ot},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(i,s,h){var a=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Int32Array<"u";h.assign=function($){for(var c=Array.prototype.slice.call(arguments,1);c.length;){var b=c.shift();if(b){if(typeof b!="object")throw new TypeError(b+"must be non-object");for(var g in b)b.hasOwnProperty(g)&&($[g]=b[g])}}return $},h.shrinkBuf=function($,c){return $.length===c?$:$.subarray?$.subarray(0,c):($.length=c,$)};var d={arraySet:function($,c,b,g,nt){if(c.subarray&&$.subarray)$.set(c.subarray(b,b+g),nt);else for(var at=0;at<g;at++)$[nt+at]=c[b+at]},flattenChunks:function($){var c,b,g,nt,at,Ot;for(c=g=0,b=$.length;c<b;c++)g+=$[c].length;for(Ot=new Uint8Array(g),c=nt=0,b=$.length;c<b;c++)at=$[c],Ot.set(at,nt),nt+=at.length;return Ot}},et={arraySet:function($,c,b,g,nt){for(var at=0;at<g;at++)$[nt+at]=c[b+at]},flattenChunks:function($){return[].concat.apply([],$)}};h.setTyped=function($){$?(h.Buf8=Uint8Array,h.Buf16=Uint16Array,h.Buf32=Int32Array,h.assign(h,d)):(h.Buf8=Array,h.Buf16=Array,h.Buf32=Array,h.assign(h,et))},h.setTyped(a)},{}],42:[function(i,s,h){var a=i("./common"),d=!0,et=!0;try{String.fromCharCode.apply(null,[0])}catch{d=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{et=!1}for(var $=new a.Buf8(256),c=0;c<256;c++)$[c]=252<=c?6:248<=c?5:240<=c?4:224<=c?3:192<=c?2:1;function b(g,nt){if(nt<65537&&(g.subarray&&et||!g.subarray&&d))return String.fromCharCode.apply(null,a.shrinkBuf(g,nt));for(var at="",Ot=0;Ot<nt;Ot++)at+=String.fromCharCode(g[Ot]);return at}$[254]=$[254]=1,h.string2buf=function(g){var nt,at,Ot,At,Ct,St=g.length,xt=0;for(At=0;At<St;At++)(64512&(at=g.charCodeAt(At)))==55296&&At+1<St&&(64512&(Ot=g.charCodeAt(At+1)))==56320&&(at=65536+(at-55296<<10)+(Ot-56320),At++),xt+=at<128?1:at<2048?2:at<65536?3:4;for(nt=new a.Buf8(xt),At=Ct=0;Ct<xt;At++)(64512&(at=g.charCodeAt(At)))==55296&&At+1<St&&(64512&(Ot=g.charCodeAt(At+1)))==56320&&(at=65536+(at-55296<<10)+(Ot-56320),At++),at<128?nt[Ct++]=at:(at<2048?nt[Ct++]=192|at>>>6:(at<65536?nt[Ct++]=224|at>>>12:(nt[Ct++]=240|at>>>18,nt[Ct++]=128|at>>>12&63),nt[Ct++]=128|at>>>6&63),nt[Ct++]=128|63&at);return nt},h.buf2binstring=function(g){return b(g,g.length)},h.binstring2buf=function(g){for(var nt=new a.Buf8(g.length),at=0,Ot=nt.length;at<Ot;at++)nt[at]=g.charCodeAt(at);return nt},h.buf2string=function(g,nt){var at,Ot,At,Ct,St=nt||g.length,xt=new Array(2*St);for(at=Ot=0;at<St;)if((At=g[at++])<128)xt[Ot++]=At;else if(4<(Ct=$[At]))xt[Ot++]=65533,at+=Ct-1;else{for(At&=Ct===2?31:Ct===3?15:7;1<Ct&&at<St;)At=At<<6|63&g[at++],Ct--;1<Ct?xt[Ot++]=65533:At<65536?xt[Ot++]=At:(At-=65536,xt[Ot++]=55296|At>>10&1023,xt[Ot++]=56320|1023&At)}return b(xt,Ot)},h.utf8border=function(g,nt){var at;for((nt=nt||g.length)>g.length&&(nt=g.length),at=nt-1;0<=at&&(192&g[at])==128;)at--;return at<0||at===0?nt:at+$[g[at]]>nt?at:nt}},{"./common":41}],43:[function(i,s,h){s.exports=function(a,d,et,$){for(var c=65535&a|0,b=a>>>16&65535|0,g=0;et!==0;){for(et-=g=2e3<et?2e3:et;b=b+(c=c+d[$++]|0)|0,--g;);c%=65521,b%=65521}return c|b<<16|0}},{}],44:[function(i,s,h){s.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(i,s,h){var a=function(){for(var d,et=[],$=0;$<256;$++){d=$;for(var c=0;c<8;c++)d=1&d?3988292384^d>>>1:d>>>1;et[$]=d}return et}();s.exports=function(d,et,$,c){var b=a,g=c+$;d^=-1;for(var nt=c;nt<g;nt++)d=d>>>8^b[255&(d^et[nt])];return-1^d}},{}],46:[function(i,s,h){var a,d=i("../utils/common"),et=i("./trees"),$=i("./adler32"),c=i("./crc32"),b=i("./messages"),g=0,nt=4,at=0,Ot=-2,At=-1,Ct=4,St=2,xt=8,Dt=9,Qt=286,Zt=30,gr=19,vr=2*Qt+1,Er=15,wo=3,Do=258,Js=Do+wo+1,In=42,Wo=113,Ir=1,Yo=2,Bu=3,Ho=4;function tn(ar,Qs){return ar.msg=b[Qs],Qs}function To(ar){return(ar<<1)-(4<ar?9:0)}function Qo(ar){for(var Qs=ar.length;0<=--Qs;)ar[Qs]=0}function Jr(ar){var Qs=ar.state,_a=Qs.pending;_a>ar.avail_out&&(_a=ar.avail_out),_a!==0&&(d.arraySet(ar.output,Qs.pending_buf,Qs.pending_out,_a,ar.next_out),ar.next_out+=_a,Qs.pending_out+=_a,ar.total_out+=_a,ar.avail_out-=_a,Qs.pending-=_a,Qs.pending===0&&(Qs.pending_out=0))}function Lo(ar,Qs){et._tr_flush_block(ar,0<=ar.block_start?ar.block_start:-1,ar.strstart-ar.block_start,Qs),ar.block_start=ar.strstart,Jr(ar.strm)}function Du(ar,Qs){ar.pending_buf[ar.pending++]=Qs}function _u(ar,Qs){ar.pending_buf[ar.pending++]=Qs>>>8&255,ar.pending_buf[ar.pending++]=255&Qs}function du(ar,Qs){var _a,$o,Eo=ar.max_chain_length,js=ar.strstart,Lr=ar.prev_length,rn=ar.nice_match,Kr=ar.strstart>ar.w_size-Js?ar.strstart-(ar.w_size-Js):0,Oo=ar.window,Mo=ar.w_mask,qs=ar.prev,au=ar.strstart+Do,i_=Oo[js+Lr-1],$u=Oo[js+Lr];ar.prev_length>=ar.good_match&&(Eo>>=2),rn>ar.lookahead&&(rn=ar.lookahead);do if(Oo[(_a=Qs)+Lr]===$u&&Oo[_a+Lr-1]===i_&&Oo[_a]===Oo[js]&&Oo[++_a]===Oo[js+1]){js+=2,_a++;do;while(Oo[++js]===Oo[++_a]&&Oo[++js]===Oo[++_a]&&Oo[++js]===Oo[++_a]&&Oo[++js]===Oo[++_a]&&Oo[++js]===Oo[++_a]&&Oo[++js]===Oo[++_a]&&Oo[++js]===Oo[++_a]&&Oo[++js]===Oo[++_a]&&js<au);if($o=Do-(au-js),js=au-Do,Lr<$o){if(ar.match_start=Qs,rn<=(Lr=$o))break;i_=Oo[js+Lr-1],$u=Oo[js+Lr]}}while((Qs=qs[Qs&Mo])>Kr&&--Eo!=0);return Lr<=ar.lookahead?Lr:ar.lookahead}function wu(ar){var Qs,_a,$o,Eo,js,Lr,rn,Kr,Oo,Mo,qs=ar.w_size;do{if(Eo=ar.window_size-ar.lookahead-ar.strstart,ar.strstart>=qs+(qs-Js)){for(d.arraySet(ar.window,ar.window,qs,qs,0),ar.match_start-=qs,ar.strstart-=qs,ar.block_start-=qs,Qs=_a=ar.hash_size;$o=ar.head[--Qs],ar.head[Qs]=qs<=$o?$o-qs:0,--_a;);for(Qs=_a=qs;$o=ar.prev[--Qs],ar.prev[Qs]=qs<=$o?$o-qs:0,--_a;);Eo+=qs}if(ar.strm.avail_in===0)break;if(Lr=ar.strm,rn=ar.window,Kr=ar.strstart+ar.lookahead,Oo=Eo,Mo=void 0,Mo=Lr.avail_in,Oo<Mo&&(Mo=Oo),_a=Mo===0?0:(Lr.avail_in-=Mo,d.arraySet(rn,Lr.input,Lr.next_in,Mo,Kr),Lr.state.wrap===1?Lr.adler=$(Lr.adler,rn,Mo,Kr):Lr.state.wrap===2&&(Lr.adler=c(Lr.adler,rn,Mo,Kr)),Lr.next_in+=Mo,Lr.total_in+=Mo,Mo),ar.lookahead+=_a,ar.lookahead+ar.insert>=wo)for(js=ar.strstart-ar.insert,ar.ins_h=ar.window[js],ar.ins_h=(ar.ins_h<<ar.hash_shift^ar.window[js+1])&ar.hash_mask;ar.insert&&(ar.ins_h=(ar.ins_h<<ar.hash_shift^ar.window[js+wo-1])&ar.hash_mask,ar.prev[js&ar.w_mask]=ar.head[ar.ins_h],ar.head[ar.ins_h]=js,js++,ar.insert--,!(ar.lookahead+ar.insert<wo)););}while(ar.lookahead<Js&&ar.strm.avail_in!==0)}function r_(ar,Qs){for(var _a,$o;;){if(ar.lookahead<Js){if(wu(ar),ar.lookahead<Js&&Qs===g)return Ir;if(ar.lookahead===0)break}if(_a=0,ar.lookahead>=wo&&(ar.ins_h=(ar.ins_h<<ar.hash_shift^ar.window[ar.strstart+wo-1])&ar.hash_mask,_a=ar.prev[ar.strstart&ar.w_mask]=ar.head[ar.ins_h],ar.head[ar.ins_h]=ar.strstart),_a!==0&&ar.strstart-_a<=ar.w_size-Js&&(ar.match_length=du(ar,_a)),ar.match_length>=wo)if($o=et._tr_tally(ar,ar.strstart-ar.match_start,ar.match_length-wo),ar.lookahead-=ar.match_length,ar.match_length<=ar.max_lazy_match&&ar.lookahead>=wo){for(ar.match_length--;ar.strstart++,ar.ins_h=(ar.ins_h<<ar.hash_shift^ar.window[ar.strstart+wo-1])&ar.hash_mask,_a=ar.prev[ar.strstart&ar.w_mask]=ar.head[ar.ins_h],ar.head[ar.ins_h]=ar.strstart,--ar.match_length!=0;);ar.strstart++}else ar.strstart+=ar.match_length,ar.match_length=0,ar.ins_h=ar.window[ar.strstart],ar.ins_h=(ar.ins_h<<ar.hash_shift^ar.window[ar.strstart+1])&ar.hash_mask;else $o=et._tr_tally(ar,0,ar.window[ar.strstart]),ar.lookahead--,ar.strstart++;if($o&&(Lo(ar,!1),ar.strm.avail_out===0))return Ir}return ar.insert=ar.strstart<wo-1?ar.strstart:wo-1,Qs===nt?(Lo(ar,!0),ar.strm.avail_out===0?Bu:Ho):ar.last_lit&&(Lo(ar,!1),ar.strm.avail_out===0)?Ir:Yo}function d_(ar,Qs){for(var _a,$o,Eo;;){if(ar.lookahead<Js){if(wu(ar),ar.lookahead<Js&&Qs===g)return Ir;if(ar.lookahead===0)break}if(_a=0,ar.lookahead>=wo&&(ar.ins_h=(ar.ins_h<<ar.hash_shift^ar.window[ar.strstart+wo-1])&ar.hash_mask,_a=ar.prev[ar.strstart&ar.w_mask]=ar.head[ar.ins_h],ar.head[ar.ins_h]=ar.strstart),ar.prev_length=ar.match_length,ar.prev_match=ar.match_start,ar.match_length=wo-1,_a!==0&&ar.prev_length<ar.max_lazy_match&&ar.strstart-_a<=ar.w_size-Js&&(ar.match_length=du(ar,_a),ar.match_length<=5&&(ar.strategy===1||ar.match_length===wo&&4096<ar.strstart-ar.match_start)&&(ar.match_length=wo-1)),ar.prev_length>=wo&&ar.match_length<=ar.prev_length){for(Eo=ar.strstart+ar.lookahead-wo,$o=et._tr_tally(ar,ar.strstart-1-ar.prev_match,ar.prev_length-wo),ar.lookahead-=ar.prev_length-1,ar.prev_length-=2;++ar.strstart<=Eo&&(ar.ins_h=(ar.ins_h<<ar.hash_shift^ar.window[ar.strstart+wo-1])&ar.hash_mask,_a=ar.prev[ar.strstart&ar.w_mask]=ar.head[ar.ins_h],ar.head[ar.ins_h]=ar.strstart),--ar.prev_length!=0;);if(ar.match_available=0,ar.match_length=wo-1,ar.strstart++,$o&&(Lo(ar,!1),ar.strm.avail_out===0))return Ir}else if(ar.match_available){if(($o=et._tr_tally(ar,0,ar.window[ar.strstart-1]))&&Lo(ar,!1),ar.strstart++,ar.lookahead--,ar.strm.avail_out===0)return Ir}else ar.match_available=1,ar.strstart++,ar.lookahead--}return ar.match_available&&($o=et._tr_tally(ar,0,ar.window[ar.strstart-1]),ar.match_available=0),ar.insert=ar.strstart<wo-1?ar.strstart:wo-1,Qs===nt?(Lo(ar,!0),ar.strm.avail_out===0?Bu:Ho):ar.last_lit&&(Lo(ar,!1),ar.strm.avail_out===0)?Ir:Yo}function na(ar,Qs,_a,$o,Eo){this.good_length=ar,this.max_lazy=Qs,this.nice_length=_a,this.max_chain=$o,this.func=Eo}function Ko(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=xt,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*vr),this.dyn_dtree=new d.Buf16(2*(2*Zt+1)),this.bl_tree=new d.Buf16(2*(2*gr+1)),Qo(this.dyn_ltree),Qo(this.dyn_dtree),Qo(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(Er+1),this.heap=new d.Buf16(2*Qt+1),Qo(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*Qt+1),Qo(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function vu(ar){var Qs;return ar&&ar.state?(ar.total_in=ar.total_out=0,ar.data_type=St,(Qs=ar.state).pending=0,Qs.pending_out=0,Qs.wrap<0&&(Qs.wrap=-Qs.wrap),Qs.status=Qs.wrap?In:Wo,ar.adler=Qs.wrap===2?0:1,Qs.last_flush=g,et._tr_init(Qs),at):tn(ar,Ot)}function Cu(ar){var Qs=vu(ar);return Qs===at&&function(_a){_a.window_size=2*_a.w_size,Qo(_a.head),_a.max_lazy_match=a[_a.level].max_lazy,_a.good_match=a[_a.level].good_length,_a.nice_match=a[_a.level].nice_length,_a.max_chain_length=a[_a.level].max_chain,_a.strstart=0,_a.block_start=0,_a.lookahead=0,_a.insert=0,_a.match_length=_a.prev_length=wo-1,_a.match_available=0,_a.ins_h=0}(ar.state),Qs}function e_(ar,Qs,_a,$o,Eo,js){if(!ar)return Ot;var Lr=1;if(Qs===At&&(Qs=6),$o<0?(Lr=0,$o=-$o):15<$o&&(Lr=2,$o-=16),Eo<1||Dt<Eo||_a!==xt||$o<8||15<$o||Qs<0||9<Qs||js<0||Ct<js)return tn(ar,Ot);$o===8&&($o=9);var rn=new Ko;return(ar.state=rn).strm=ar,rn.wrap=Lr,rn.gzhead=null,rn.w_bits=$o,rn.w_size=1<<rn.w_bits,rn.w_mask=rn.w_size-1,rn.hash_bits=Eo+7,rn.hash_size=1<<rn.hash_bits,rn.hash_mask=rn.hash_size-1,rn.hash_shift=~~((rn.hash_bits+wo-1)/wo),rn.window=new d.Buf8(2*rn.w_size),rn.head=new d.Buf16(rn.hash_size),rn.prev=new d.Buf16(rn.w_size),rn.lit_bufsize=1<<Eo+6,rn.pending_buf_size=4*rn.lit_bufsize,rn.pending_buf=new d.Buf8(rn.pending_buf_size),rn.d_buf=1*rn.lit_bufsize,rn.l_buf=3*rn.lit_bufsize,rn.level=Qs,rn.strategy=js,rn.method=_a,Cu(ar)}a=[new na(0,0,0,0,function(ar,Qs){var _a=65535;for(_a>ar.pending_buf_size-5&&(_a=ar.pending_buf_size-5);;){if(ar.lookahead<=1){if(wu(ar),ar.lookahead===0&&Qs===g)return Ir;if(ar.lookahead===0)break}ar.strstart+=ar.lookahead,ar.lookahead=0;var $o=ar.block_start+_a;if((ar.strstart===0||ar.strstart>=$o)&&(ar.lookahead=ar.strstart-$o,ar.strstart=$o,Lo(ar,!1),ar.strm.avail_out===0)||ar.strstart-ar.block_start>=ar.w_size-Js&&(Lo(ar,!1),ar.strm.avail_out===0))return Ir}return ar.insert=0,Qs===nt?(Lo(ar,!0),ar.strm.avail_out===0?Bu:Ho):(ar.strstart>ar.block_start&&(Lo(ar,!1),ar.strm.avail_out),Ir)}),new na(4,4,8,4,r_),new na(4,5,16,8,r_),new na(4,6,32,32,r_),new na(4,4,16,16,d_),new na(8,16,32,32,d_),new na(8,16,128,128,d_),new na(8,32,128,256,d_),new na(32,128,258,1024,d_),new na(32,258,258,4096,d_)],h.deflateInit=function(ar,Qs){return e_(ar,Qs,xt,15,8,0)},h.deflateInit2=e_,h.deflateReset=Cu,h.deflateResetKeep=vu,h.deflateSetHeader=function(ar,Qs){return ar&&ar.state?ar.state.wrap!==2?Ot:(ar.state.gzhead=Qs,at):Ot},h.deflate=function(ar,Qs){var _a,$o,Eo,js;if(!ar||!ar.state||5<Qs||Qs<0)return ar?tn(ar,Ot):Ot;if($o=ar.state,!ar.output||!ar.input&&ar.avail_in!==0||$o.status===666&&Qs!==nt)return tn(ar,ar.avail_out===0?-5:Ot);if($o.strm=ar,_a=$o.last_flush,$o.last_flush=Qs,$o.status===In)if($o.wrap===2)ar.adler=0,Du($o,31),Du($o,139),Du($o,8),$o.gzhead?(Du($o,($o.gzhead.text?1:0)+($o.gzhead.hcrc?2:0)+($o.gzhead.extra?4:0)+($o.gzhead.name?8:0)+($o.gzhead.comment?16:0)),Du($o,255&$o.gzhead.time),Du($o,$o.gzhead.time>>8&255),Du($o,$o.gzhead.time>>16&255),Du($o,$o.gzhead.time>>24&255),Du($o,$o.level===9?2:2<=$o.strategy||$o.level<2?4:0),Du($o,255&$o.gzhead.os),$o.gzhead.extra&&$o.gzhead.extra.length&&(Du($o,255&$o.gzhead.extra.length),Du($o,$o.gzhead.extra.length>>8&255)),$o.gzhead.hcrc&&(ar.adler=c(ar.adler,$o.pending_buf,$o.pending,0)),$o.gzindex=0,$o.status=69):(Du($o,0),Du($o,0),Du($o,0),Du($o,0),Du($o,0),Du($o,$o.level===9?2:2<=$o.strategy||$o.level<2?4:0),Du($o,3),$o.status=Wo);else{var Lr=xt+($o.w_bits-8<<4)<<8;Lr|=(2<=$o.strategy||$o.level<2?0:$o.level<6?1:$o.level===6?2:3)<<6,$o.strstart!==0&&(Lr|=32),Lr+=31-Lr%31,$o.status=Wo,_u($o,Lr),$o.strstart!==0&&(_u($o,ar.adler>>>16),_u($o,65535&ar.adler)),ar.adler=1}if($o.status===69)if($o.gzhead.extra){for(Eo=$o.pending;$o.gzindex<(65535&$o.gzhead.extra.length)&&($o.pending!==$o.pending_buf_size||($o.gzhead.hcrc&&$o.pending>Eo&&(ar.adler=c(ar.adler,$o.pending_buf,$o.pending-Eo,Eo)),Jr(ar),Eo=$o.pending,$o.pending!==$o.pending_buf_size));)Du($o,255&$o.gzhead.extra[$o.gzindex]),$o.gzindex++;$o.gzhead.hcrc&&$o.pending>Eo&&(ar.adler=c(ar.adler,$o.pending_buf,$o.pending-Eo,Eo)),$o.gzindex===$o.gzhead.extra.length&&($o.gzindex=0,$o.status=73)}else $o.status=73;if($o.status===73)if($o.gzhead.name){Eo=$o.pending;do{if($o.pending===$o.pending_buf_size&&($o.gzhead.hcrc&&$o.pending>Eo&&(ar.adler=c(ar.adler,$o.pending_buf,$o.pending-Eo,Eo)),Jr(ar),Eo=$o.pending,$o.pending===$o.pending_buf_size)){js=1;break}js=$o.gzindex<$o.gzhead.name.length?255&$o.gzhead.name.charCodeAt($o.gzindex++):0,Du($o,js)}while(js!==0);$o.gzhead.hcrc&&$o.pending>Eo&&(ar.adler=c(ar.adler,$o.pending_buf,$o.pending-Eo,Eo)),js===0&&($o.gzindex=0,$o.status=91)}else $o.status=91;if($o.status===91)if($o.gzhead.comment){Eo=$o.pending;do{if($o.pending===$o.pending_buf_size&&($o.gzhead.hcrc&&$o.pending>Eo&&(ar.adler=c(ar.adler,$o.pending_buf,$o.pending-Eo,Eo)),Jr(ar),Eo=$o.pending,$o.pending===$o.pending_buf_size)){js=1;break}js=$o.gzindex<$o.gzhead.comment.length?255&$o.gzhead.comment.charCodeAt($o.gzindex++):0,Du($o,js)}while(js!==0);$o.gzhead.hcrc&&$o.pending>Eo&&(ar.adler=c(ar.adler,$o.pending_buf,$o.pending-Eo,Eo)),js===0&&($o.status=103)}else $o.status=103;if($o.status===103&&($o.gzhead.hcrc?($o.pending+2>$o.pending_buf_size&&Jr(ar),$o.pending+2<=$o.pending_buf_size&&(Du($o,255&ar.adler),Du($o,ar.adler>>8&255),ar.adler=0,$o.status=Wo)):$o.status=Wo),$o.pending!==0){if(Jr(ar),ar.avail_out===0)return $o.last_flush=-1,at}else if(ar.avail_in===0&&To(Qs)<=To(_a)&&Qs!==nt)return tn(ar,-5);if($o.status===666&&ar.avail_in!==0)return tn(ar,-5);if(ar.avail_in!==0||$o.lookahead!==0||Qs!==g&&$o.status!==666){var rn=$o.strategy===2?function(Kr,Oo){for(var Mo;;){if(Kr.lookahead===0&&(wu(Kr),Kr.lookahead===0)){if(Oo===g)return Ir;break}if(Kr.match_length=0,Mo=et._tr_tally(Kr,0,Kr.window[Kr.strstart]),Kr.lookahead--,Kr.strstart++,Mo&&(Lo(Kr,!1),Kr.strm.avail_out===0))return Ir}return Kr.insert=0,Oo===nt?(Lo(Kr,!0),Kr.strm.avail_out===0?Bu:Ho):Kr.last_lit&&(Lo(Kr,!1),Kr.strm.avail_out===0)?Ir:Yo}($o,Qs):$o.strategy===3?function(Kr,Oo){for(var Mo,qs,au,i_,$u=Kr.window;;){if(Kr.lookahead<=Do){if(wu(Kr),Kr.lookahead<=Do&&Oo===g)return Ir;if(Kr.lookahead===0)break}if(Kr.match_length=0,Kr.lookahead>=wo&&0<Kr.strstart&&(qs=$u[au=Kr.strstart-1])===$u[++au]&&qs===$u[++au]&&qs===$u[++au]){i_=Kr.strstart+Do;do;while(qs===$u[++au]&&qs===$u[++au]&&qs===$u[++au]&&qs===$u[++au]&&qs===$u[++au]&&qs===$u[++au]&&qs===$u[++au]&&qs===$u[++au]&&au<i_);Kr.match_length=Do-(i_-au),Kr.match_length>Kr.lookahead&&(Kr.match_length=Kr.lookahead)}if(Kr.match_length>=wo?(Mo=et._tr_tally(Kr,1,Kr.match_length-wo),Kr.lookahead-=Kr.match_length,Kr.strstart+=Kr.match_length,Kr.match_length=0):(Mo=et._tr_tally(Kr,0,Kr.window[Kr.strstart]),Kr.lookahead--,Kr.strstart++),Mo&&(Lo(Kr,!1),Kr.strm.avail_out===0))return Ir}return Kr.insert=0,Oo===nt?(Lo(Kr,!0),Kr.strm.avail_out===0?Bu:Ho):Kr.last_lit&&(Lo(Kr,!1),Kr.strm.avail_out===0)?Ir:Yo}($o,Qs):a[$o.level].func($o,Qs);if(rn!==Bu&&rn!==Ho||($o.status=666),rn===Ir||rn===Bu)return ar.avail_out===0&&($o.last_flush=-1),at;if(rn===Yo&&(Qs===1?et._tr_align($o):Qs!==5&&(et._tr_stored_block($o,0,0,!1),Qs===3&&(Qo($o.head),$o.lookahead===0&&($o.strstart=0,$o.block_start=0,$o.insert=0))),Jr(ar),ar.avail_out===0))return $o.last_flush=-1,at}return Qs!==nt?at:$o.wrap<=0?1:($o.wrap===2?(Du($o,255&ar.adler),Du($o,ar.adler>>8&255),Du($o,ar.adler>>16&255),Du($o,ar.adler>>24&255),Du($o,255&ar.total_in),Du($o,ar.total_in>>8&255),Du($o,ar.total_in>>16&255),Du($o,ar.total_in>>24&255)):(_u($o,ar.adler>>>16),_u($o,65535&ar.adler)),Jr(ar),0<$o.wrap&&($o.wrap=-$o.wrap),$o.pending!==0?at:1)},h.deflateEnd=function(ar){var Qs;return ar&&ar.state?(Qs=ar.state.status)!==In&&Qs!==69&&Qs!==73&&Qs!==91&&Qs!==103&&Qs!==Wo&&Qs!==666?tn(ar,Ot):(ar.state=null,Qs===Wo?tn(ar,-3):at):Ot},h.deflateSetDictionary=function(ar,Qs){var _a,$o,Eo,js,Lr,rn,Kr,Oo,Mo=Qs.length;if(!ar||!ar.state||(js=(_a=ar.state).wrap)===2||js===1&&_a.status!==In||_a.lookahead)return Ot;for(js===1&&(ar.adler=$(ar.adler,Qs,Mo,0)),_a.wrap=0,Mo>=_a.w_size&&(js===0&&(Qo(_a.head),_a.strstart=0,_a.block_start=0,_a.insert=0),Oo=new d.Buf8(_a.w_size),d.arraySet(Oo,Qs,Mo-_a.w_size,_a.w_size,0),Qs=Oo,Mo=_a.w_size),Lr=ar.avail_in,rn=ar.next_in,Kr=ar.input,ar.avail_in=Mo,ar.next_in=0,ar.input=Qs,wu(_a);_a.lookahead>=wo;){for($o=_a.strstart,Eo=_a.lookahead-(wo-1);_a.ins_h=(_a.ins_h<<_a.hash_shift^_a.window[$o+wo-1])&_a.hash_mask,_a.prev[$o&_a.w_mask]=_a.head[_a.ins_h],_a.head[_a.ins_h]=$o,$o++,--Eo;);_a.strstart=$o,_a.lookahead=wo-1,wu(_a)}return _a.strstart+=_a.lookahead,_a.block_start=_a.strstart,_a.insert=_a.lookahead,_a.lookahead=0,_a.match_length=_a.prev_length=wo-1,_a.match_available=0,ar.next_in=rn,ar.input=Kr,ar.avail_in=Lr,_a.wrap=js,at},h.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(i,s,h){s.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(i,s,h){s.exports=function(a,d){var et,$,c,b,g,nt,at,Ot,At,Ct,St,xt,Dt,Qt,Zt,gr,vr,Er,wo,Do,Js,In,Wo,Ir,Yo;et=a.state,$=a.next_in,Ir=a.input,c=$+(a.avail_in-5),b=a.next_out,Yo=a.output,g=b-(d-a.avail_out),nt=b+(a.avail_out-257),at=et.dmax,Ot=et.wsize,At=et.whave,Ct=et.wnext,St=et.window,xt=et.hold,Dt=et.bits,Qt=et.lencode,Zt=et.distcode,gr=(1<<et.lenbits)-1,vr=(1<<et.distbits)-1;e:do{Dt<15&&(xt+=Ir[$++]<<Dt,Dt+=8,xt+=Ir[$++]<<Dt,Dt+=8),Er=Qt[xt&gr];t:for(;;){if(xt>>>=wo=Er>>>24,Dt-=wo,(wo=Er>>>16&255)===0)Yo[b++]=65535&Er;else{if(!(16&wo)){if(!(64&wo)){Er=Qt[(65535&Er)+(xt&(1<<wo)-1)];continue t}if(32&wo){et.mode=12;break e}a.msg="invalid literal/length code",et.mode=30;break e}Do=65535&Er,(wo&=15)&&(Dt<wo&&(xt+=Ir[$++]<<Dt,Dt+=8),Do+=xt&(1<<wo)-1,xt>>>=wo,Dt-=wo),Dt<15&&(xt+=Ir[$++]<<Dt,Dt+=8,xt+=Ir[$++]<<Dt,Dt+=8),Er=Zt[xt&vr];r:for(;;){if(xt>>>=wo=Er>>>24,Dt-=wo,!(16&(wo=Er>>>16&255))){if(!(64&wo)){Er=Zt[(65535&Er)+(xt&(1<<wo)-1)];continue r}a.msg="invalid distance code",et.mode=30;break e}if(Js=65535&Er,Dt<(wo&=15)&&(xt+=Ir[$++]<<Dt,(Dt+=8)<wo&&(xt+=Ir[$++]<<Dt,Dt+=8)),at<(Js+=xt&(1<<wo)-1)){a.msg="invalid distance too far back",et.mode=30;break e}if(xt>>>=wo,Dt-=wo,(wo=b-g)<Js){if(At<(wo=Js-wo)&&et.sane){a.msg="invalid distance too far back",et.mode=30;break e}if(Wo=St,(In=0)===Ct){if(In+=Ot-wo,wo<Do){for(Do-=wo;Yo[b++]=St[In++],--wo;);In=b-Js,Wo=Yo}}else if(Ct<wo){if(In+=Ot+Ct-wo,(wo-=Ct)<Do){for(Do-=wo;Yo[b++]=St[In++],--wo;);if(In=0,Ct<Do){for(Do-=wo=Ct;Yo[b++]=St[In++],--wo;);In=b-Js,Wo=Yo}}}else if(In+=Ct-wo,wo<Do){for(Do-=wo;Yo[b++]=St[In++],--wo;);In=b-Js,Wo=Yo}for(;2<Do;)Yo[b++]=Wo[In++],Yo[b++]=Wo[In++],Yo[b++]=Wo[In++],Do-=3;Do&&(Yo[b++]=Wo[In++],1<Do&&(Yo[b++]=Wo[In++]))}else{for(In=b-Js;Yo[b++]=Yo[In++],Yo[b++]=Yo[In++],Yo[b++]=Yo[In++],2<(Do-=3););Do&&(Yo[b++]=Yo[In++],1<Do&&(Yo[b++]=Yo[In++]))}break}}break}}while($<c&&b<nt);$-=Do=Dt>>3,xt&=(1<<(Dt-=Do<<3))-1,a.next_in=$,a.next_out=b,a.avail_in=$<c?c-$+5:5-($-c),a.avail_out=b<nt?nt-b+257:257-(b-nt),et.hold=xt,et.bits=Dt}},{}],49:[function(i,s,h){var a=i("../utils/common"),d=i("./adler32"),et=i("./crc32"),$=i("./inffast"),c=i("./inftrees"),b=1,g=2,nt=0,at=-2,Ot=1,At=852,Ct=592;function St(In){return(In>>>24&255)+(In>>>8&65280)+((65280&In)<<8)+((255&In)<<24)}function xt(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new a.Buf16(320),this.work=new a.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function Dt(In){var Wo;return In&&In.state?(Wo=In.state,In.total_in=In.total_out=Wo.total=0,In.msg="",Wo.wrap&&(In.adler=1&Wo.wrap),Wo.mode=Ot,Wo.last=0,Wo.havedict=0,Wo.dmax=32768,Wo.head=null,Wo.hold=0,Wo.bits=0,Wo.lencode=Wo.lendyn=new a.Buf32(At),Wo.distcode=Wo.distdyn=new a.Buf32(Ct),Wo.sane=1,Wo.back=-1,nt):at}function Qt(In){var Wo;return In&&In.state?((Wo=In.state).wsize=0,Wo.whave=0,Wo.wnext=0,Dt(In)):at}function Zt(In,Wo){var Ir,Yo;return In&&In.state?(Yo=In.state,Wo<0?(Ir=0,Wo=-Wo):(Ir=1+(Wo>>4),Wo<48&&(Wo&=15)),Wo&&(Wo<8||15<Wo)?at:(Yo.window!==null&&Yo.wbits!==Wo&&(Yo.window=null),Yo.wrap=Ir,Yo.wbits=Wo,Qt(In))):at}function gr(In,Wo){var Ir,Yo;return In?(Yo=new xt,(In.state=Yo).window=null,(Ir=Zt(In,Wo))!==nt&&(In.state=null),Ir):at}var vr,Er,wo=!0;function Do(In){if(wo){var Wo;for(vr=new a.Buf32(512),Er=new a.Buf32(32),Wo=0;Wo<144;)In.lens[Wo++]=8;for(;Wo<256;)In.lens[Wo++]=9;for(;Wo<280;)In.lens[Wo++]=7;for(;Wo<288;)In.lens[Wo++]=8;for(c(b,In.lens,0,288,vr,0,In.work,{bits:9}),Wo=0;Wo<32;)In.lens[Wo++]=5;c(g,In.lens,0,32,Er,0,In.work,{bits:5}),wo=!1}In.lencode=vr,In.lenbits=9,In.distcode=Er,In.distbits=5}function Js(In,Wo,Ir,Yo){var Bu,Ho=In.state;return Ho.window===null&&(Ho.wsize=1<<Ho.wbits,Ho.wnext=0,Ho.whave=0,Ho.window=new a.Buf8(Ho.wsize)),Yo>=Ho.wsize?(a.arraySet(Ho.window,Wo,Ir-Ho.wsize,Ho.wsize,0),Ho.wnext=0,Ho.whave=Ho.wsize):(Yo<(Bu=Ho.wsize-Ho.wnext)&&(Bu=Yo),a.arraySet(Ho.window,Wo,Ir-Yo,Bu,Ho.wnext),(Yo-=Bu)?(a.arraySet(Ho.window,Wo,Ir-Yo,Yo,0),Ho.wnext=Yo,Ho.whave=Ho.wsize):(Ho.wnext+=Bu,Ho.wnext===Ho.wsize&&(Ho.wnext=0),Ho.whave<Ho.wsize&&(Ho.whave+=Bu))),0}h.inflateReset=Qt,h.inflateReset2=Zt,h.inflateResetKeep=Dt,h.inflateInit=function(In){return gr(In,15)},h.inflateInit2=gr,h.inflate=function(In,Wo){var Ir,Yo,Bu,Ho,tn,To,Qo,Jr,Lo,Du,_u,du,wu,r_,d_,na,Ko,vu,Cu,e_,ar,Qs,_a,$o,Eo=0,js=new a.Buf8(4),Lr=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!In||!In.state||!In.output||!In.input&&In.avail_in!==0)return at;(Ir=In.state).mode===12&&(Ir.mode=13),tn=In.next_out,Bu=In.output,Qo=In.avail_out,Ho=In.next_in,Yo=In.input,To=In.avail_in,Jr=Ir.hold,Lo=Ir.bits,Du=To,_u=Qo,Qs=nt;e:for(;;)switch(Ir.mode){case Ot:if(Ir.wrap===0){Ir.mode=13;break}for(;Lo<16;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(2&Ir.wrap&&Jr===35615){js[Ir.check=0]=255&Jr,js[1]=Jr>>>8&255,Ir.check=et(Ir.check,js,2,0),Lo=Jr=0,Ir.mode=2;break}if(Ir.flags=0,Ir.head&&(Ir.head.done=!1),!(1&Ir.wrap)||(((255&Jr)<<8)+(Jr>>8))%31){In.msg="incorrect header check",Ir.mode=30;break}if((15&Jr)!=8){In.msg="unknown compression method",Ir.mode=30;break}if(Lo-=4,ar=8+(15&(Jr>>>=4)),Ir.wbits===0)Ir.wbits=ar;else if(ar>Ir.wbits){In.msg="invalid window size",Ir.mode=30;break}Ir.dmax=1<<ar,In.adler=Ir.check=1,Ir.mode=512&Jr?10:12,Lo=Jr=0;break;case 2:for(;Lo<16;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(Ir.flags=Jr,(255&Ir.flags)!=8){In.msg="unknown compression method",Ir.mode=30;break}if(57344&Ir.flags){In.msg="unknown header flags set",Ir.mode=30;break}Ir.head&&(Ir.head.text=Jr>>8&1),512&Ir.flags&&(js[0]=255&Jr,js[1]=Jr>>>8&255,Ir.check=et(Ir.check,js,2,0)),Lo=Jr=0,Ir.mode=3;case 3:for(;Lo<32;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Ir.head&&(Ir.head.time=Jr),512&Ir.flags&&(js[0]=255&Jr,js[1]=Jr>>>8&255,js[2]=Jr>>>16&255,js[3]=Jr>>>24&255,Ir.check=et(Ir.check,js,4,0)),Lo=Jr=0,Ir.mode=4;case 4:for(;Lo<16;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Ir.head&&(Ir.head.xflags=255&Jr,Ir.head.os=Jr>>8),512&Ir.flags&&(js[0]=255&Jr,js[1]=Jr>>>8&255,Ir.check=et(Ir.check,js,2,0)),Lo=Jr=0,Ir.mode=5;case 5:if(1024&Ir.flags){for(;Lo<16;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Ir.length=Jr,Ir.head&&(Ir.head.extra_len=Jr),512&Ir.flags&&(js[0]=255&Jr,js[1]=Jr>>>8&255,Ir.check=et(Ir.check,js,2,0)),Lo=Jr=0}else Ir.head&&(Ir.head.extra=null);Ir.mode=6;case 6:if(1024&Ir.flags&&(To<(du=Ir.length)&&(du=To),du&&(Ir.head&&(ar=Ir.head.extra_len-Ir.length,Ir.head.extra||(Ir.head.extra=new Array(Ir.head.extra_len)),a.arraySet(Ir.head.extra,Yo,Ho,du,ar)),512&Ir.flags&&(Ir.check=et(Ir.check,Yo,du,Ho)),To-=du,Ho+=du,Ir.length-=du),Ir.length))break e;Ir.length=0,Ir.mode=7;case 7:if(2048&Ir.flags){if(To===0)break e;for(du=0;ar=Yo[Ho+du++],Ir.head&&ar&&Ir.length<65536&&(Ir.head.name+=String.fromCharCode(ar)),ar&&du<To;);if(512&Ir.flags&&(Ir.check=et(Ir.check,Yo,du,Ho)),To-=du,Ho+=du,ar)break e}else Ir.head&&(Ir.head.name=null);Ir.length=0,Ir.mode=8;case 8:if(4096&Ir.flags){if(To===0)break e;for(du=0;ar=Yo[Ho+du++],Ir.head&&ar&&Ir.length<65536&&(Ir.head.comment+=String.fromCharCode(ar)),ar&&du<To;);if(512&Ir.flags&&(Ir.check=et(Ir.check,Yo,du,Ho)),To-=du,Ho+=du,ar)break e}else Ir.head&&(Ir.head.comment=null);Ir.mode=9;case 9:if(512&Ir.flags){for(;Lo<16;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(Jr!==(65535&Ir.check)){In.msg="header crc mismatch",Ir.mode=30;break}Lo=Jr=0}Ir.head&&(Ir.head.hcrc=Ir.flags>>9&1,Ir.head.done=!0),In.adler=Ir.check=0,Ir.mode=12;break;case 10:for(;Lo<32;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}In.adler=Ir.check=St(Jr),Lo=Jr=0,Ir.mode=11;case 11:if(Ir.havedict===0)return In.next_out=tn,In.avail_out=Qo,In.next_in=Ho,In.avail_in=To,Ir.hold=Jr,Ir.bits=Lo,2;In.adler=Ir.check=1,Ir.mode=12;case 12:if(Wo===5||Wo===6)break e;case 13:if(Ir.last){Jr>>>=7&Lo,Lo-=7&Lo,Ir.mode=27;break}for(;Lo<3;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}switch(Ir.last=1&Jr,Lo-=1,3&(Jr>>>=1)){case 0:Ir.mode=14;break;case 1:if(Do(Ir),Ir.mode=20,Wo!==6)break;Jr>>>=2,Lo-=2;break e;case 2:Ir.mode=17;break;case 3:In.msg="invalid block type",Ir.mode=30}Jr>>>=2,Lo-=2;break;case 14:for(Jr>>>=7&Lo,Lo-=7&Lo;Lo<32;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if((65535&Jr)!=(Jr>>>16^65535)){In.msg="invalid stored block lengths",Ir.mode=30;break}if(Ir.length=65535&Jr,Lo=Jr=0,Ir.mode=15,Wo===6)break e;case 15:Ir.mode=16;case 16:if(du=Ir.length){if(To<du&&(du=To),Qo<du&&(du=Qo),du===0)break e;a.arraySet(Bu,Yo,Ho,du,tn),To-=du,Ho+=du,Qo-=du,tn+=du,Ir.length-=du;break}Ir.mode=12;break;case 17:for(;Lo<14;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(Ir.nlen=257+(31&Jr),Jr>>>=5,Lo-=5,Ir.ndist=1+(31&Jr),Jr>>>=5,Lo-=5,Ir.ncode=4+(15&Jr),Jr>>>=4,Lo-=4,286<Ir.nlen||30<Ir.ndist){In.msg="too many length or distance symbols",Ir.mode=30;break}Ir.have=0,Ir.mode=18;case 18:for(;Ir.have<Ir.ncode;){for(;Lo<3;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Ir.lens[Lr[Ir.have++]]=7&Jr,Jr>>>=3,Lo-=3}for(;Ir.have<19;)Ir.lens[Lr[Ir.have++]]=0;if(Ir.lencode=Ir.lendyn,Ir.lenbits=7,_a={bits:Ir.lenbits},Qs=c(0,Ir.lens,0,19,Ir.lencode,0,Ir.work,_a),Ir.lenbits=_a.bits,Qs){In.msg="invalid code lengths set",Ir.mode=30;break}Ir.have=0,Ir.mode=19;case 19:for(;Ir.have<Ir.nlen+Ir.ndist;){for(;na=(Eo=Ir.lencode[Jr&(1<<Ir.lenbits)-1])>>>16&255,Ko=65535&Eo,!((d_=Eo>>>24)<=Lo);){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(Ko<16)Jr>>>=d_,Lo-=d_,Ir.lens[Ir.have++]=Ko;else{if(Ko===16){for($o=d_+2;Lo<$o;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(Jr>>>=d_,Lo-=d_,Ir.have===0){In.msg="invalid bit length repeat",Ir.mode=30;break}ar=Ir.lens[Ir.have-1],du=3+(3&Jr),Jr>>>=2,Lo-=2}else if(Ko===17){for($o=d_+3;Lo<$o;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Lo-=d_,ar=0,du=3+(7&(Jr>>>=d_)),Jr>>>=3,Lo-=3}else{for($o=d_+7;Lo<$o;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Lo-=d_,ar=0,du=11+(127&(Jr>>>=d_)),Jr>>>=7,Lo-=7}if(Ir.have+du>Ir.nlen+Ir.ndist){In.msg="invalid bit length repeat",Ir.mode=30;break}for(;du--;)Ir.lens[Ir.have++]=ar}}if(Ir.mode===30)break;if(Ir.lens[256]===0){In.msg="invalid code -- missing end-of-block",Ir.mode=30;break}if(Ir.lenbits=9,_a={bits:Ir.lenbits},Qs=c(b,Ir.lens,0,Ir.nlen,Ir.lencode,0,Ir.work,_a),Ir.lenbits=_a.bits,Qs){In.msg="invalid literal/lengths set",Ir.mode=30;break}if(Ir.distbits=6,Ir.distcode=Ir.distdyn,_a={bits:Ir.distbits},Qs=c(g,Ir.lens,Ir.nlen,Ir.ndist,Ir.distcode,0,Ir.work,_a),Ir.distbits=_a.bits,Qs){In.msg="invalid distances set",Ir.mode=30;break}if(Ir.mode=20,Wo===6)break e;case 20:Ir.mode=21;case 21:if(6<=To&&258<=Qo){In.next_out=tn,In.avail_out=Qo,In.next_in=Ho,In.avail_in=To,Ir.hold=Jr,Ir.bits=Lo,$(In,_u),tn=In.next_out,Bu=In.output,Qo=In.avail_out,Ho=In.next_in,Yo=In.input,To=In.avail_in,Jr=Ir.hold,Lo=Ir.bits,Ir.mode===12&&(Ir.back=-1);break}for(Ir.back=0;na=(Eo=Ir.lencode[Jr&(1<<Ir.lenbits)-1])>>>16&255,Ko=65535&Eo,!((d_=Eo>>>24)<=Lo);){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(na&&!(240&na)){for(vu=d_,Cu=na,e_=Ko;na=(Eo=Ir.lencode[e_+((Jr&(1<<vu+Cu)-1)>>vu)])>>>16&255,Ko=65535&Eo,!(vu+(d_=Eo>>>24)<=Lo);){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Jr>>>=vu,Lo-=vu,Ir.back+=vu}if(Jr>>>=d_,Lo-=d_,Ir.back+=d_,Ir.length=Ko,na===0){Ir.mode=26;break}if(32&na){Ir.back=-1,Ir.mode=12;break}if(64&na){In.msg="invalid literal/length code",Ir.mode=30;break}Ir.extra=15&na,Ir.mode=22;case 22:if(Ir.extra){for($o=Ir.extra;Lo<$o;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Ir.length+=Jr&(1<<Ir.extra)-1,Jr>>>=Ir.extra,Lo-=Ir.extra,Ir.back+=Ir.extra}Ir.was=Ir.length,Ir.mode=23;case 23:for(;na=(Eo=Ir.distcode[Jr&(1<<Ir.distbits)-1])>>>16&255,Ko=65535&Eo,!((d_=Eo>>>24)<=Lo);){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(!(240&na)){for(vu=d_,Cu=na,e_=Ko;na=(Eo=Ir.distcode[e_+((Jr&(1<<vu+Cu)-1)>>vu)])>>>16&255,Ko=65535&Eo,!(vu+(d_=Eo>>>24)<=Lo);){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Jr>>>=vu,Lo-=vu,Ir.back+=vu}if(Jr>>>=d_,Lo-=d_,Ir.back+=d_,64&na){In.msg="invalid distance code",Ir.mode=30;break}Ir.offset=Ko,Ir.extra=15&na,Ir.mode=24;case 24:if(Ir.extra){for($o=Ir.extra;Lo<$o;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}Ir.offset+=Jr&(1<<Ir.extra)-1,Jr>>>=Ir.extra,Lo-=Ir.extra,Ir.back+=Ir.extra}if(Ir.offset>Ir.dmax){In.msg="invalid distance too far back",Ir.mode=30;break}Ir.mode=25;case 25:if(Qo===0)break e;if(du=_u-Qo,Ir.offset>du){if((du=Ir.offset-du)>Ir.whave&&Ir.sane){In.msg="invalid distance too far back",Ir.mode=30;break}wu=du>Ir.wnext?(du-=Ir.wnext,Ir.wsize-du):Ir.wnext-du,du>Ir.length&&(du=Ir.length),r_=Ir.window}else r_=Bu,wu=tn-Ir.offset,du=Ir.length;for(Qo<du&&(du=Qo),Qo-=du,Ir.length-=du;Bu[tn++]=r_[wu++],--du;);Ir.length===0&&(Ir.mode=21);break;case 26:if(Qo===0)break e;Bu[tn++]=Ir.length,Qo--,Ir.mode=21;break;case 27:if(Ir.wrap){for(;Lo<32;){if(To===0)break e;To--,Jr|=Yo[Ho++]<<Lo,Lo+=8}if(_u-=Qo,In.total_out+=_u,Ir.total+=_u,_u&&(In.adler=Ir.check=Ir.flags?et(Ir.check,Bu,_u,tn-_u):d(Ir.check,Bu,_u,tn-_u)),_u=Qo,(Ir.flags?Jr:St(Jr))!==Ir.check){In.msg="incorrect data check",Ir.mode=30;break}Lo=Jr=0}Ir.mode=28;case 28:if(Ir.wrap&&Ir.flags){for(;Lo<32;){if(To===0)break e;To--,Jr+=Yo[Ho++]<<Lo,Lo+=8}if(Jr!==(4294967295&Ir.total)){In.msg="incorrect length check",Ir.mode=30;break}Lo=Jr=0}Ir.mode=29;case 29:Qs=1;break e;case 30:Qs=-3;break e;case 31:return-4;case 32:default:return at}return In.next_out=tn,In.avail_out=Qo,In.next_in=Ho,In.avail_in=To,Ir.hold=Jr,Ir.bits=Lo,(Ir.wsize||_u!==In.avail_out&&Ir.mode<30&&(Ir.mode<27||Wo!==4))&&Js(In,In.output,In.next_out,_u-In.avail_out)?(Ir.mode=31,-4):(Du-=In.avail_in,_u-=In.avail_out,In.total_in+=Du,In.total_out+=_u,Ir.total+=_u,Ir.wrap&&_u&&(In.adler=Ir.check=Ir.flags?et(Ir.check,Bu,_u,In.next_out-_u):d(Ir.check,Bu,_u,In.next_out-_u)),In.data_type=Ir.bits+(Ir.last?64:0)+(Ir.mode===12?128:0)+(Ir.mode===20||Ir.mode===15?256:0),(Du==0&&_u===0||Wo===4)&&Qs===nt&&(Qs=-5),Qs)},h.inflateEnd=function(In){if(!In||!In.state)return at;var Wo=In.state;return Wo.window&&(Wo.window=null),In.state=null,nt},h.inflateGetHeader=function(In,Wo){var Ir;return In&&In.state&&2&(Ir=In.state).wrap?((Ir.head=Wo).done=!1,nt):at},h.inflateSetDictionary=function(In,Wo){var Ir,Yo=Wo.length;return In&&In.state?(Ir=In.state).wrap!==0&&Ir.mode!==11?at:Ir.mode===11&&d(1,Wo,Yo,0)!==Ir.check?-3:Js(In,Wo,Yo,Yo)?(Ir.mode=31,-4):(Ir.havedict=1,nt):at},h.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(i,s,h){var a=i("../utils/common"),d=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],et=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],$=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],c=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];s.exports=function(b,g,nt,at,Ot,At,Ct,St){var xt,Dt,Qt,Zt,gr,vr,Er,wo,Do,Js=St.bits,In=0,Wo=0,Ir=0,Yo=0,Bu=0,Ho=0,tn=0,To=0,Qo=0,Jr=0,Lo=null,Du=0,_u=new a.Buf16(16),du=new a.Buf16(16),wu=null,r_=0;for(In=0;In<=15;In++)_u[In]=0;for(Wo=0;Wo<at;Wo++)_u[g[nt+Wo]]++;for(Bu=Js,Yo=15;1<=Yo&&_u[Yo]===0;Yo--);if(Yo<Bu&&(Bu=Yo),Yo===0)return Ot[At++]=20971520,Ot[At++]=20971520,St.bits=1,0;for(Ir=1;Ir<Yo&&_u[Ir]===0;Ir++);for(Bu<Ir&&(Bu=Ir),In=To=1;In<=15;In++)if(To<<=1,(To-=_u[In])<0)return-1;if(0<To&&(b===0||Yo!==1))return-1;for(du[1]=0,In=1;In<15;In++)du[In+1]=du[In]+_u[In];for(Wo=0;Wo<at;Wo++)g[nt+Wo]!==0&&(Ct[du[g[nt+Wo]]++]=Wo);if(vr=b===0?(Lo=wu=Ct,19):b===1?(Lo=d,Du-=257,wu=et,r_-=257,256):(Lo=$,wu=c,-1),In=Ir,gr=At,tn=Wo=Jr=0,Qt=-1,Zt=(Qo=1<<(Ho=Bu))-1,b===1&&852<Qo||b===2&&592<Qo)return 1;for(;;){for(Er=In-tn,Do=Ct[Wo]<vr?(wo=0,Ct[Wo]):Ct[Wo]>vr?(wo=wu[r_+Ct[Wo]],Lo[Du+Ct[Wo]]):(wo=96,0),xt=1<<In-tn,Ir=Dt=1<<Ho;Ot[gr+(Jr>>tn)+(Dt-=xt)]=Er<<24|wo<<16|Do|0,Dt!==0;);for(xt=1<<In-1;Jr&xt;)xt>>=1;if(xt!==0?(Jr&=xt-1,Jr+=xt):Jr=0,Wo++,--_u[In]==0){if(In===Yo)break;In=g[nt+Ct[Wo]]}if(Bu<In&&(Jr&Zt)!==Qt){for(tn===0&&(tn=Bu),gr+=Ir,To=1<<(Ho=In-tn);Ho+tn<Yo&&!((To-=_u[Ho+tn])<=0);)Ho++,To<<=1;if(Qo+=1<<Ho,b===1&&852<Qo||b===2&&592<Qo)return 1;Ot[Qt=Jr&Zt]=Bu<<24|Ho<<16|gr-At|0}}return Jr!==0&&(Ot[gr+Jr]=In-tn<<24|64<<16|0),St.bits=Bu,0}},{"../utils/common":41}],51:[function(i,s,h){s.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(i,s,h){var a=i("../utils/common"),d=0,et=1;function $(Eo){for(var js=Eo.length;0<=--js;)Eo[js]=0}var c=0,b=29,g=256,nt=g+1+b,at=30,Ot=19,At=2*nt+1,Ct=15,St=16,xt=7,Dt=256,Qt=16,Zt=17,gr=18,vr=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],Er=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],wo=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],Do=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],Js=new Array(2*(nt+2));$(Js);var In=new Array(2*at);$(In);var Wo=new Array(512);$(Wo);var Ir=new Array(256);$(Ir);var Yo=new Array(b);$(Yo);var Bu,Ho,tn,To=new Array(at);function Qo(Eo,js,Lr,rn,Kr){this.static_tree=Eo,this.extra_bits=js,this.extra_base=Lr,this.elems=rn,this.max_length=Kr,this.has_stree=Eo&&Eo.length}function Jr(Eo,js){this.dyn_tree=Eo,this.max_code=0,this.stat_desc=js}function Lo(Eo){return Eo<256?Wo[Eo]:Wo[256+(Eo>>>7)]}function Du(Eo,js){Eo.pending_buf[Eo.pending++]=255&js,Eo.pending_buf[Eo.pending++]=js>>>8&255}function _u(Eo,js,Lr){Eo.bi_valid>St-Lr?(Eo.bi_buf|=js<<Eo.bi_valid&65535,Du(Eo,Eo.bi_buf),Eo.bi_buf=js>>St-Eo.bi_valid,Eo.bi_valid+=Lr-St):(Eo.bi_buf|=js<<Eo.bi_valid&65535,Eo.bi_valid+=Lr)}function du(Eo,js,Lr){_u(Eo,Lr[2*js],Lr[2*js+1])}function wu(Eo,js){for(var Lr=0;Lr|=1&Eo,Eo>>>=1,Lr<<=1,0<--js;);return Lr>>>1}function r_(Eo,js,Lr){var rn,Kr,Oo=new Array(Ct+1),Mo=0;for(rn=1;rn<=Ct;rn++)Oo[rn]=Mo=Mo+Lr[rn-1]<<1;for(Kr=0;Kr<=js;Kr++){var qs=Eo[2*Kr+1];qs!==0&&(Eo[2*Kr]=wu(Oo[qs]++,qs))}}function d_(Eo){var js;for(js=0;js<nt;js++)Eo.dyn_ltree[2*js]=0;for(js=0;js<at;js++)Eo.dyn_dtree[2*js]=0;for(js=0;js<Ot;js++)Eo.bl_tree[2*js]=0;Eo.dyn_ltree[2*Dt]=1,Eo.opt_len=Eo.static_len=0,Eo.last_lit=Eo.matches=0}function na(Eo){8<Eo.bi_valid?Du(Eo,Eo.bi_buf):0<Eo.bi_valid&&(Eo.pending_buf[Eo.pending++]=Eo.bi_buf),Eo.bi_buf=0,Eo.bi_valid=0}function Ko(Eo,js,Lr,rn){var Kr=2*js,Oo=2*Lr;return Eo[Kr]<Eo[Oo]||Eo[Kr]===Eo[Oo]&&rn[js]<=rn[Lr]}function vu(Eo,js,Lr){for(var rn=Eo.heap[Lr],Kr=Lr<<1;Kr<=Eo.heap_len&&(Kr<Eo.heap_len&&Ko(js,Eo.heap[Kr+1],Eo.heap[Kr],Eo.depth)&&Kr++,!Ko(js,rn,Eo.heap[Kr],Eo.depth));)Eo.heap[Lr]=Eo.heap[Kr],Lr=Kr,Kr<<=1;Eo.heap[Lr]=rn}function Cu(Eo,js,Lr){var rn,Kr,Oo,Mo,qs=0;if(Eo.last_lit!==0)for(;rn=Eo.pending_buf[Eo.d_buf+2*qs]<<8|Eo.pending_buf[Eo.d_buf+2*qs+1],Kr=Eo.pending_buf[Eo.l_buf+qs],qs++,rn===0?du(Eo,Kr,js):(du(Eo,(Oo=Ir[Kr])+g+1,js),(Mo=vr[Oo])!==0&&_u(Eo,Kr-=Yo[Oo],Mo),du(Eo,Oo=Lo(--rn),Lr),(Mo=Er[Oo])!==0&&_u(Eo,rn-=To[Oo],Mo)),qs<Eo.last_lit;);du(Eo,Dt,js)}function e_(Eo,js){var Lr,rn,Kr,Oo=js.dyn_tree,Mo=js.stat_desc.static_tree,qs=js.stat_desc.has_stree,au=js.stat_desc.elems,i_=-1;for(Eo.heap_len=0,Eo.heap_max=At,Lr=0;Lr<au;Lr++)Oo[2*Lr]!==0?(Eo.heap[++Eo.heap_len]=i_=Lr,Eo.depth[Lr]=0):Oo[2*Lr+1]=0;for(;Eo.heap_len<2;)Oo[2*(Kr=Eo.heap[++Eo.heap_len]=i_<2?++i_:0)]=1,Eo.depth[Kr]=0,Eo.opt_len--,qs&&(Eo.static_len-=Mo[2*Kr+1]);for(js.max_code=i_,Lr=Eo.heap_len>>1;1<=Lr;Lr--)vu(Eo,Oo,Lr);for(Kr=au;Lr=Eo.heap[1],Eo.heap[1]=Eo.heap[Eo.heap_len--],vu(Eo,Oo,1),rn=Eo.heap[1],Eo.heap[--Eo.heap_max]=Lr,Eo.heap[--Eo.heap_max]=rn,Oo[2*Kr]=Oo[2*Lr]+Oo[2*rn],Eo.depth[Kr]=(Eo.depth[Lr]>=Eo.depth[rn]?Eo.depth[Lr]:Eo.depth[rn])+1,Oo[2*Lr+1]=Oo[2*rn+1]=Kr,Eo.heap[1]=Kr++,vu(Eo,Oo,1),2<=Eo.heap_len;);Eo.heap[--Eo.heap_max]=Eo.heap[1],function($u,m_){var L_,Z_,Ty,ey,yy,O_,fy=m_.dyn_tree,g_=m_.max_code,jo=m_.stat_desc.static_tree,Xs=m_.stat_desc.has_stree,_d=m_.stat_desc.extra_bits,w_=m_.stat_desc.extra_base,mu=m_.stat_desc.max_length,y_=0;for(ey=0;ey<=Ct;ey++)$u.bl_count[ey]=0;for(fy[2*$u.heap[$u.heap_max]+1]=0,L_=$u.heap_max+1;L_<At;L_++)mu<(ey=fy[2*fy[2*(Z_=$u.heap[L_])+1]+1]+1)&&(ey=mu,y_++),fy[2*Z_+1]=ey,g_<Z_||($u.bl_count[ey]++,yy=0,w_<=Z_&&(yy=_d[Z_-w_]),O_=fy[2*Z_],$u.opt_len+=O_*(ey+yy),Xs&&($u.static_len+=O_*(jo[2*Z_+1]+yy)));if(y_!==0){do{for(ey=mu-1;$u.bl_count[ey]===0;)ey--;$u.bl_count[ey]--,$u.bl_count[ey+1]+=2,$u.bl_count[mu]--,y_-=2}while(0<y_);for(ey=mu;ey!==0;ey--)for(Z_=$u.bl_count[ey];Z_!==0;)g_<(Ty=$u.heap[--L_])||(fy[2*Ty+1]!==ey&&($u.opt_len+=(ey-fy[2*Ty+1])*fy[2*Ty],fy[2*Ty+1]=ey),Z_--)}}(Eo,js),r_(Oo,i_,Eo.bl_count)}function ar(Eo,js,Lr){var rn,Kr,Oo=-1,Mo=js[1],qs=0,au=7,i_=4;for(Mo===0&&(au=138,i_=3),js[2*(Lr+1)+1]=65535,rn=0;rn<=Lr;rn++)Kr=Mo,Mo=js[2*(rn+1)+1],++qs<au&&Kr===Mo||(qs<i_?Eo.bl_tree[2*Kr]+=qs:Kr!==0?(Kr!==Oo&&Eo.bl_tree[2*Kr]++,Eo.bl_tree[2*Qt]++):qs<=10?Eo.bl_tree[2*Zt]++:Eo.bl_tree[2*gr]++,Oo=Kr,i_=(qs=0)===Mo?(au=138,3):Kr===Mo?(au=6,3):(au=7,4))}function Qs(Eo,js,Lr){var rn,Kr,Oo=-1,Mo=js[1],qs=0,au=7,i_=4;for(Mo===0&&(au=138,i_=3),rn=0;rn<=Lr;rn++)if(Kr=Mo,Mo=js[2*(rn+1)+1],!(++qs<au&&Kr===Mo)){if(qs<i_)for(;du(Eo,Kr,Eo.bl_tree),--qs!=0;);else Kr!==0?(Kr!==Oo&&(du(Eo,Kr,Eo.bl_tree),qs--),du(Eo,Qt,Eo.bl_tree),_u(Eo,qs-3,2)):qs<=10?(du(Eo,Zt,Eo.bl_tree),_u(Eo,qs-3,3)):(du(Eo,gr,Eo.bl_tree),_u(Eo,qs-11,7));Oo=Kr,i_=(qs=0)===Mo?(au=138,3):Kr===Mo?(au=6,3):(au=7,4)}}$(To);var _a=!1;function $o(Eo,js,Lr,rn){_u(Eo,(c<<1)+(rn?1:0),3),function(Kr,Oo,Mo,qs){na(Kr),Du(Kr,Mo),Du(Kr,~Mo),a.arraySet(Kr.pending_buf,Kr.window,Oo,Mo,Kr.pending),Kr.pending+=Mo}(Eo,js,Lr)}h._tr_init=function(Eo){_a||(function(){var js,Lr,rn,Kr,Oo,Mo=new Array(Ct+1);for(Kr=rn=0;Kr<b-1;Kr++)for(Yo[Kr]=rn,js=0;js<1<<vr[Kr];js++)Ir[rn++]=Kr;for(Ir[rn-1]=Kr,Kr=Oo=0;Kr<16;Kr++)for(To[Kr]=Oo,js=0;js<1<<Er[Kr];js++)Wo[Oo++]=Kr;for(Oo>>=7;Kr<at;Kr++)for(To[Kr]=Oo<<7,js=0;js<1<<Er[Kr]-7;js++)Wo[256+Oo++]=Kr;for(Lr=0;Lr<=Ct;Lr++)Mo[Lr]=0;for(js=0;js<=143;)Js[2*js+1]=8,js++,Mo[8]++;for(;js<=255;)Js[2*js+1]=9,js++,Mo[9]++;for(;js<=279;)Js[2*js+1]=7,js++,Mo[7]++;for(;js<=287;)Js[2*js+1]=8,js++,Mo[8]++;for(r_(Js,nt+1,Mo),js=0;js<at;js++)In[2*js+1]=5,In[2*js]=wu(js,5);Bu=new Qo(Js,vr,g+1,nt,Ct),Ho=new Qo(In,Er,0,at,Ct),tn=new Qo(new Array(0),wo,0,Ot,xt)}(),_a=!0),Eo.l_desc=new Jr(Eo.dyn_ltree,Bu),Eo.d_desc=new Jr(Eo.dyn_dtree,Ho),Eo.bl_desc=new Jr(Eo.bl_tree,tn),Eo.bi_buf=0,Eo.bi_valid=0,d_(Eo)},h._tr_stored_block=$o,h._tr_flush_block=function(Eo,js,Lr,rn){var Kr,Oo,Mo=0;0<Eo.level?(Eo.strm.data_type===2&&(Eo.strm.data_type=function(qs){var au,i_=4093624447;for(au=0;au<=31;au++,i_>>>=1)if(1&i_&&qs.dyn_ltree[2*au]!==0)return d;if(qs.dyn_ltree[18]!==0||qs.dyn_ltree[20]!==0||qs.dyn_ltree[26]!==0)return et;for(au=32;au<g;au++)if(qs.dyn_ltree[2*au]!==0)return et;return d}(Eo)),e_(Eo,Eo.l_desc),e_(Eo,Eo.d_desc),Mo=function(qs){var au;for(ar(qs,qs.dyn_ltree,qs.l_desc.max_code),ar(qs,qs.dyn_dtree,qs.d_desc.max_code),e_(qs,qs.bl_desc),au=Ot-1;3<=au&&qs.bl_tree[2*Do[au]+1]===0;au--);return qs.opt_len+=3*(au+1)+5+5+4,au}(Eo),Kr=Eo.opt_len+3+7>>>3,(Oo=Eo.static_len+3+7>>>3)<=Kr&&(Kr=Oo)):Kr=Oo=Lr+5,Lr+4<=Kr&&js!==-1?$o(Eo,js,Lr,rn):Eo.strategy===4||Oo===Kr?(_u(Eo,2+(rn?1:0),3),Cu(Eo,Js,In)):(_u(Eo,4+(rn?1:0),3),function(qs,au,i_,$u){var m_;for(_u(qs,au-257,5),_u(qs,i_-1,5),_u(qs,$u-4,4),m_=0;m_<$u;m_++)_u(qs,qs.bl_tree[2*Do[m_]+1],3);Qs(qs,qs.dyn_ltree,au-1),Qs(qs,qs.dyn_dtree,i_-1)}(Eo,Eo.l_desc.max_code+1,Eo.d_desc.max_code+1,Mo+1),Cu(Eo,Eo.dyn_ltree,Eo.dyn_dtree)),d_(Eo),rn&&na(Eo)},h._tr_tally=function(Eo,js,Lr){return Eo.pending_buf[Eo.d_buf+2*Eo.last_lit]=js>>>8&255,Eo.pending_buf[Eo.d_buf+2*Eo.last_lit+1]=255&js,Eo.pending_buf[Eo.l_buf+Eo.last_lit]=255&Lr,Eo.last_lit++,js===0?Eo.dyn_ltree[2*Lr]++:(Eo.matches++,js--,Eo.dyn_ltree[2*(Ir[Lr]+g+1)]++,Eo.dyn_dtree[2*Lo(js)]++),Eo.last_lit===Eo.lit_bufsize-1},h._tr_align=function(Eo){_u(Eo,2,3),du(Eo,Dt,Js),function(js){js.bi_valid===16?(Du(js,js.bi_buf),js.bi_buf=0,js.bi_valid=0):8<=js.bi_valid&&(js.pending_buf[js.pending++]=255&js.bi_buf,js.bi_buf>>=8,js.bi_valid-=8)}(Eo)}},{"../utils/common":41}],53:[function(i,s,h){s.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(i,s,h){(function(a){(function(d,et){if(!d.setImmediate){var $,c,b,g,nt=1,at={},Ot=!1,At=d.document,Ct=Object.getPrototypeOf&&Object.getPrototypeOf(d);Ct=Ct&&Ct.setTimeout?Ct:d,$={}.toString.call(d.process)==="[object process]"?function(Qt){process.nextTick(function(){xt(Qt)})}:function(){if(d.postMessage&&!d.importScripts){var Qt=!0,Zt=d.onmessage;return d.onmessage=function(){Qt=!1},d.postMessage("","*"),d.onmessage=Zt,Qt}}()?(g="setImmediate$"+Math.random()+"$",d.addEventListener?d.addEventListener("message",Dt,!1):d.attachEvent("onmessage",Dt),function(Qt){d.postMessage(g+Qt,"*")}):d.MessageChannel?((b=new MessageChannel).port1.onmessage=function(Qt){xt(Qt.data)},function(Qt){b.port2.postMessage(Qt)}):At&&"onreadystatechange"in At.createElement("script")?(c=At.documentElement,function(Qt){var Zt=At.createElement("script");Zt.onreadystatechange=function(){xt(Qt),Zt.onreadystatechange=null,c.removeChild(Zt),Zt=null},c.appendChild(Zt)}):function(Qt){setTimeout(xt,0,Qt)},Ct.setImmediate=function(Qt){typeof Qt!="function"&&(Qt=new Function(""+Qt));for(var Zt=new Array(arguments.length-1),gr=0;gr<Zt.length;gr++)Zt[gr]=arguments[gr+1];var vr={callback:Qt,args:Zt};return at[nt]=vr,$(nt),nt++},Ct.clearImmediate=St}function St(Qt){delete at[Qt]}function xt(Qt){if(Ot)setTimeout(xt,0,Qt);else{var Zt=at[Qt];if(Zt){Ot=!0;try{(function(gr){var vr=gr.callback,Er=gr.args;switch(Er.length){case 0:vr();break;case 1:vr(Er[0]);break;case 2:vr(Er[0],Er[1]);break;case 3:vr(Er[0],Er[1],Er[2]);break;default:vr.apply(et,Er)}})(Zt)}finally{St(Qt),Ot=!1}}}}function Dt(Qt){Qt.source===d&&typeof Qt.data=="string"&&Qt.data.indexOf(g)===0&&xt(+Qt.data.slice(g.length))}})(typeof self>"u"?a===void 0?this:a:self)}).call(this,typeof commonjsGlobal<"u"?commonjsGlobal:typeof self<"u"?self:typeof window<"u"?window:{})},{}]},{},[10])(10)})})(jszip_min);var jszip_minExports=jszip_min.exports;const JSZip=getDefaultExportFromCjs(jszip_minExports);var FileSaver_min={exports:{}};(function(e,o){(function(i,s){s()})(commonjsGlobal,function(){function i(c,b){return typeof b>"u"?b={autoBom:!1}:typeof b!="object"&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(c.type)?new Blob(["\uFEFF",c],{type:c.type}):c}function s(c,b,g){var nt=new XMLHttpRequest;nt.open("GET",c),nt.responseType="blob",nt.onload=function(){$(nt.response,b,g)},nt.onerror=function(){console.error("could not download file")},nt.send()}function h(c){var b=new XMLHttpRequest;b.open("HEAD",c,!1);try{b.send()}catch{}return 200<=b.status&&299>=b.status}function a(c){try{c.dispatchEvent(new MouseEvent("click"))}catch{var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),c.dispatchEvent(b)}}var d=typeof window=="object"&&window.window===window?window:typeof self=="object"&&self.self===self?self:typeof commonjsGlobal=="object"&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,et=d.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),$=d.saveAs||(typeof window!="object"||window!==d?function(){}:"download"in HTMLAnchorElement.prototype&&!et?function(c,b,g){var nt=d.URL||d.webkitURL,at=document.createElement("a");b=b||c.name||"download",at.download=b,at.rel="noopener",typeof c=="string"?(at.href=c,at.origin===location.origin?a(at):h(at.href)?s(c,b,g):a(at,at.target="_blank")):(at.href=nt.createObjectURL(c),setTimeout(function(){nt.revokeObjectURL(at.href)},4e4),setTimeout(function(){a(at)},0))}:"msSaveOrOpenBlob"in navigator?function(c,b,g){if(b=b||c.name||"download",typeof c!="string")navigator.msSaveOrOpenBlob(i(c,g),b);else if(h(c))s(c,b,g);else{var nt=document.createElement("a");nt.href=c,nt.target="_blank",setTimeout(function(){a(nt)})}}:function(c,b,g,nt){if(nt=nt||open("","_blank"),nt&&(nt.document.title=nt.document.body.innerText="downloading..."),typeof c=="string")return s(c,b,g);var at=c.type==="application/octet-stream",Ot=/constructor/i.test(d.HTMLElement)||d.safari,At=/CriOS\/[\d]+/.test(navigator.userAgent);if((At||at&&Ot||et)&&typeof FileReader<"u"){var Ct=new FileReader;Ct.onloadend=function(){var Dt=Ct.result;Dt=At?Dt:Dt.replace(/^data:[^;]*;/,"data:attachment/file;"),nt?nt.location.href=Dt:location=Dt,nt=null},Ct.readAsDataURL(c)}else{var St=d.URL||d.webkitURL,xt=St.createObjectURL(c);nt?nt.location=xt:location.href=xt,nt=null,setTimeout(function(){St.revokeObjectURL(xt)},4e4)}});d.saveAs=$.saveAs=$,e.exports=$})})(FileSaver_min);var FileSaver_minExports=FileSaver_min.exports,dexie_min={exports:{}};(function(e,o){(function(i,s){e.exports=s()})(commonjsGlobal,function(){var i=function(lt,wt){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(zt,Dr){zt.__proto__=Dr}||function(zt,Dr){for(var Zr in Dr)Object.prototype.hasOwnProperty.call(Dr,Zr)&&(zt[Zr]=Dr[Zr])})(lt,wt)},s=function(){return(s=Object.assign||function(lt){for(var wt,zt=1,Dr=arguments.length;zt<Dr;zt++)for(var Zr in wt=arguments[zt])Object.prototype.hasOwnProperty.call(wt,Zr)&&(lt[Zr]=wt[Zr]);return lt}).apply(this,arguments)};function h(lt,wt,zt){for(var Dr,Zr=0,vo=wt.length;Zr<vo;Zr++)!Dr&&Zr in wt||((Dr=Dr||Array.prototype.slice.call(wt,0,Zr))[Zr]=wt[Zr]);return lt.concat(Dr||Array.prototype.slice.call(wt))}var a=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:commonjsGlobal,d=Object.keys,et=Array.isArray;function $(lt,wt){return typeof wt!="object"||d(wt).forEach(function(zt){lt[zt]=wt[zt]}),lt}typeof Promise>"u"||a.Promise||(a.Promise=Promise);var c=Object.getPrototypeOf,b={}.hasOwnProperty;function g(lt,wt){return b.call(lt,wt)}function nt(lt,wt){typeof wt=="function"&&(wt=wt(c(lt))),(typeof Reflect>"u"?d:Reflect.ownKeys)(wt).forEach(function(zt){Ot(lt,zt,wt[zt])})}var at=Object.defineProperty;function Ot(lt,wt,zt,Dr){at(lt,wt,$(zt&&g(zt,"get")&&typeof zt.get=="function"?{get:zt.get,set:zt.set,configurable:!0}:{value:zt,configurable:!0,writable:!0},Dr))}function At(lt){return{from:function(wt){return lt.prototype=Object.create(wt.prototype),Ot(lt.prototype,"constructor",lt),{extend:nt.bind(null,lt.prototype)}}}}var Ct=Object.getOwnPropertyDescriptor,St=[].slice;function xt(lt,wt,zt){return St.call(lt,wt,zt)}function Dt(lt,wt){return wt(lt)}function Qt(lt){if(!lt)throw new Error("Assertion Failed")}function Zt(lt){a.setImmediate?setImmediate(lt):setTimeout(lt,0)}function gr(lt,wt){if(typeof wt=="string"&&g(lt,wt))return lt[wt];if(!wt)return lt;if(typeof wt!="string"){for(var zt=[],Dr=0,Zr=wt.length;Dr<Zr;++Dr){var vo=gr(lt,wt[Dr]);zt.push(vo)}return zt}var qo=wt.indexOf(".");if(qo!==-1){var ga=lt[wt.substr(0,qo)];return ga==null?void 0:gr(ga,wt.substr(qo+1))}}function vr(lt,wt,zt){if(lt&&wt!==void 0&&!("isFrozen"in Object&&Object.isFrozen(lt)))if(typeof wt!="string"&&"length"in wt){Qt(typeof zt!="string"&&"length"in zt);for(var Dr=0,Zr=wt.length;Dr<Zr;++Dr)vr(lt,wt[Dr],zt[Dr])}else{var vo,qo,ga=wt.indexOf(".");ga!==-1?(vo=wt.substr(0,ga),(qo=wt.substr(ga+1))===""?zt===void 0?et(lt)&&!isNaN(parseInt(vo))?lt.splice(vo,1):delete lt[vo]:lt[vo]=zt:vr(ga=!(ga=lt[vo])||!g(lt,vo)?lt[vo]={}:ga,qo,zt)):zt===void 0?et(lt)&&!isNaN(parseInt(wt))?lt.splice(wt,1):delete lt[wt]:lt[wt]=zt}}function Er(lt){var wt,zt={};for(wt in lt)g(lt,wt)&&(zt[wt]=lt[wt]);return zt}var wo=[].concat;function Do(lt){return wo.apply([],lt)}var ba="BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Do([8,16,32,64].map(function(lt){return["Int","Uint","Float"].map(function(wt){return wt+lt+"Array"})}))).filter(function(lt){return a[lt]}),Js=new Set(ba.map(function(lt){return a[lt]})),In=null;function Wo(lt){return In=new WeakMap,lt=function wt(zt){if(!zt||typeof zt!="object")return zt;var Dr=In.get(zt);if(Dr)return Dr;if(et(zt)){Dr=[],In.set(zt,Dr);for(var Zr=0,vo=zt.length;Zr<vo;++Zr)Dr.push(wt(zt[Zr]))}else if(Js.has(zt.constructor))Dr=zt;else{var qo,ga=c(zt);for(qo in Dr=ga===Object.prototype?{}:Object.create(ga),In.set(zt,Dr),zt)g(zt,qo)&&(Dr[qo]=wt(zt[qo]))}return Dr}(lt),In=null,lt}var Ir={}.toString;function Yo(lt){return Ir.call(lt).slice(8,-1)}var Bu=typeof Symbol<"u"?Symbol.iterator:"@@iterator",Ho=typeof Bu=="symbol"?function(lt){var wt;return lt!=null&&(wt=lt[Bu])&&wt.apply(lt)}:function(){return null};function tn(lt,wt){return wt=lt.indexOf(wt),0<=wt&&lt.splice(wt,1),0<=wt}var To={};function Qo(lt){var wt,zt,Dr,Zr;if(arguments.length===1){if(et(lt))return lt.slice();if(this===To&&typeof lt=="string")return[lt];if(Zr=Ho(lt)){for(zt=[];!(Dr=Zr.next()).done;)zt.push(Dr.value);return zt}if(lt==null)return[lt];if(typeof(wt=lt.length)!="number")return[lt];for(zt=new Array(wt);wt--;)zt[wt]=lt[wt];return zt}for(wt=arguments.length,zt=new Array(wt);wt--;)zt[wt]=arguments[wt];return zt}var Jr=typeof Symbol<"u"?function(lt){return lt[Symbol.toStringTag]==="AsyncFunction"}:function(){return!1},qs=["Unknown","Constraint","Data","TransactionInactive","ReadOnly","Version","NotFound","InvalidState","InvalidAccess","Abort","Timeout","QuotaExceeded","Syntax","DataClone"],Z0=["Modify","Bulk","OpenFailed","VersionChange","Schema","Upgrade","InvalidTable","MissingAPI","NoSuchDatabase","InvalidArgument","SubTransaction","Unsupported","Internal","DatabaseClosed","PrematureCommit","ForeignAwait"].concat(qs),Lo={VersionChanged:"Database version changed by other database connection",DatabaseClosed:"Database has been closed",Abort:"Transaction aborted",TransactionInactive:"Transaction has already completed or failed",MissingAPI:"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"};function Du(lt,wt){this.name=lt,this.message=wt}function _u(lt,wt){return lt+". Errors: "+Object.keys(wt).map(function(zt){return wt[zt].toString()}).filter(function(zt,Dr,Zr){return Zr.indexOf(zt)===Dr}).join(`
`)}function du(lt,wt,zt,Dr){this.failures=wt,this.failedKeys=Dr,this.successCount=zt,this.message=_u(lt,wt)}function wu(lt,wt){this.name="BulkError",this.failures=Object.keys(wt).map(function(zt){return wt[zt]}),this.failuresByPos=wt,this.message=_u(lt,this.failures)}At(Du).from(Error).extend({toString:function(){return this.name+": "+this.message}}),At(du).from(Du),At(wu).from(Du);var r_=Z0.reduce(function(lt,wt){return lt[wt]=wt+"Error",lt},{}),d_=Du,na=Z0.reduce(function(lt,wt){var zt=wt+"Error";function Dr(Zr,vo){this.name=zt,Zr?typeof Zr=="string"?(this.message="".concat(Zr).concat(vo?`
 `+vo:""),this.inner=vo||null):typeof Zr=="object"&&(this.message="".concat(Zr.name," ").concat(Zr.message),this.inner=Zr):(this.message=Lo[wt]||zt,this.inner=null)}return At(Dr).from(d_),lt[wt]=Dr,lt},{});na.Syntax=SyntaxError,na.Type=TypeError,na.Range=RangeError;var Ko=qs.reduce(function(lt,wt){return lt[wt+"Error"]=na[wt],lt},{}),vu=Z0.reduce(function(lt,wt){return["Syntax","Type","Range"].indexOf(wt)===-1&&(lt[wt+"Error"]=na[wt]),lt},{});function Cu(){}function e_(lt){return lt}function ar(lt,wt){return lt==null||lt===e_?wt:function(zt){return wt(lt(zt))}}function Qs(lt,wt){return function(){lt.apply(this,arguments),wt.apply(this,arguments)}}function _a(lt,wt){return lt===Cu?wt:function(){var zt=lt.apply(this,arguments);zt!==void 0&&(arguments[0]=zt);var Dr=this.onsuccess,Zr=this.onerror;this.onsuccess=null,this.onerror=null;var vo=wt.apply(this,arguments);return Dr&&(this.onsuccess=this.onsuccess?Qs(Dr,this.onsuccess):Dr),Zr&&(this.onerror=this.onerror?Qs(Zr,this.onerror):Zr),vo!==void 0?vo:zt}}function $o(lt,wt){return lt===Cu?wt:function(){lt.apply(this,arguments);var zt=this.onsuccess,Dr=this.onerror;this.onsuccess=this.onerror=null,wt.apply(this,arguments),zt&&(this.onsuccess=this.onsuccess?Qs(zt,this.onsuccess):zt),Dr&&(this.onerror=this.onerror?Qs(Dr,this.onerror):Dr)}}function Eo(lt,wt){return lt===Cu?wt:function(zt){var Dr=lt.apply(this,arguments);$(zt,Dr);var Zr=this.onsuccess,vo=this.onerror;return this.onsuccess=null,this.onerror=null,zt=wt.apply(this,arguments),Zr&&(this.onsuccess=this.onsuccess?Qs(Zr,this.onsuccess):Zr),vo&&(this.onerror=this.onerror?Qs(vo,this.onerror):vo),Dr===void 0?zt===void 0?void 0:zt:$(Dr,zt)}}function js(lt,wt){return lt===Cu?wt:function(){return wt.apply(this,arguments)!==!1&&lt.apply(this,arguments)}}function Lr(lt,wt){return lt===Cu?wt:function(){var zt=lt.apply(this,arguments);if(zt&&typeof zt.then=="function"){for(var Dr=this,Zr=arguments.length,vo=new Array(Zr);Zr--;)vo[Zr]=arguments[Zr];return zt.then(function(){return wt.apply(Dr,vo)})}return wt.apply(this,arguments)}}vu.ModifyError=du,vu.DexieError=Du,vu.BulkError=wu;var rn=typeof location<"u"&&/^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);function Kr(lt){rn=lt}var Oo={},Mo=100,ba=typeof Promise>"u"?[]:function(){var lt=Promise.resolve();if(typeof crypto>"u"||!crypto.subtle)return[lt,c(lt),lt];var wt=crypto.subtle.digest("SHA-512",new Uint8Array([0]));return[wt,c(wt),lt]}(),qs=ba[0],Z0=ba[1],ba=ba[2],Z0=Z0&&Z0.then,au=qs&&qs.constructor,i_=!!ba,$u=function(lt,wt){fy.push([lt,wt]),L_&&(queueMicrotask(B_),L_=!1)},m_=!0,L_=!0,Z_=[],Ty=[],ey=e_,yy={id:"global",global:!0,ref:0,unhandleds:[],onunhandled:Cu,pgp:!1,env:{},finalize:Cu},O_=yy,fy=[],g_=0,jo=[];function Xs(lt){if(typeof this!="object")throw new TypeError("Promises must be constructed via new");this._listeners=[],this._lib=!1;var wt=this._PSD=O_;if(typeof lt!="function"){if(lt!==Oo)throw new TypeError("Not a function");return this._state=arguments[1],this._value=arguments[2],void(this._state===!1&&mu(this,this._value))}this._state=null,this._value=null,++wt.ref,function zt(Dr,Zr){try{Zr(function(vo){if(Dr._state===null){if(vo===Dr)throw new TypeError("A promise cannot be resolved with itself.");var qo=Dr._lib&&P_();vo&&typeof vo.then=="function"?zt(Dr,function(ga,fu){vo instanceof Xs?vo._then(ga,fu):vo.then(ga,fu)}):(Dr._state=!0,Dr._value=vo,y_(Dr)),qo&&N_()}},mu.bind(null,Dr))}catch(vo){mu(Dr,vo)}}(this,lt)}var _d={get:function(){var lt=O_,wt=Ry;function zt(Dr,Zr){var vo=this,qo=!lt.global&&(lt!==O_||wt!==Ry),ga=qo&&!Sy(),fu=new Xs(function(uu,Su){k_(vo,new w_(xw(Dr,lt,qo,ga),xw(Zr,lt,qo,ga),uu,Su,lt))});return this._consoleTask&&(fu._consoleTask=this._consoleTask),fu}return zt.prototype=Oo,zt},set:function(lt){Ot(this,"then",lt&&lt.prototype===Oo?_d:{get:function(){return lt},set:_d.set})}};function w_(lt,wt,zt,Dr,Zr){this.onFulfilled=typeof lt=="function"?lt:null,this.onRejected=typeof wt=="function"?wt:null,this.resolve=zt,this.reject=Dr,this.psd=Zr}function mu(lt,wt){var zt,Dr;Ty.push(wt),lt._state===null&&(zt=lt._lib&&P_(),wt=ey(wt),lt._state=!1,lt._value=wt,Dr=lt,Z_.some(function(Zr){return Zr._value===Dr._value})||Z_.push(Dr),y_(lt),zt&&N_())}function y_(lt){var wt=lt._listeners;lt._listeners=[];for(var zt=0,Dr=wt.length;zt<Dr;++zt)k_(lt,wt[zt]);var Zr=lt._PSD;--Zr.ref||Zr.finalize(),g_===0&&(++g_,$u(function(){--g_==0&&q_()},[]))}function k_(lt,wt){if(lt._state!==null){var zt=lt._state?wt.onFulfilled:wt.onRejected;if(zt===null)return(lt._state?wt.resolve:wt.reject)(lt._value);++wt.psd.ref,++g_,$u(S_,[zt,lt,wt])}else lt._listeners.push(wt)}function S_(lt,wt,zt){try{var Dr,Zr=wt._value;!wt._state&&Ty.length&&(Ty=[]),Dr=rn&&wt._consoleTask?wt._consoleTask.run(function(){return lt(Zr)}):lt(Zr),wt._state||Ty.indexOf(Zr)!==-1||function(vo){for(var qo=Z_.length;qo;)if(Z_[--qo]._value===vo._value)return Z_.splice(qo,1)}(wt),zt.resolve(Dr)}catch(vo){zt.reject(vo)}finally{--g_==0&&q_(),--zt.psd.ref||zt.psd.finalize()}}function B_(){N0(yy,function(){P_()&&N_()})}function P_(){var lt=m_;return L_=m_=!1,lt}function N_(){var lt,wt,zt;do for(;0<fy.length;)for(lt=fy,fy=[],zt=lt.length,wt=0;wt<zt;++wt){var Dr=lt[wt];Dr[0].apply(null,Dr[1])}while(0<fy.length);L_=m_=!0}function q_(){var lt=Z_;Z_=[],lt.forEach(function(Dr){Dr._PSD.onunhandled.call(null,Dr._value,Dr)});for(var wt=jo.slice(0),zt=wt.length;zt;)wt[--zt]()}function H_(lt){return new Xs(Oo,!1,lt)}function j_(lt,wt){var zt=O_;return function(){var Dr=P_(),Zr=O_;try{return A0(zt,!0),lt.apply(this,arguments)}catch(vo){wt&&wt(vo)}finally{A0(Zr,!1),Dr&&N_()}}}nt(Xs.prototype,{then:_d,_then:function(lt,wt){k_(this,new w_(null,null,lt,wt,O_))},catch:function(lt){if(arguments.length===1)return this.then(null,lt);var wt=lt,zt=arguments[1];return typeof wt=="function"?this.then(null,function(Dr){return(Dr instanceof wt?zt:H_)(Dr)}):this.then(null,function(Dr){return(Dr&&Dr.name===wt?zt:H_)(Dr)})},finally:function(lt){return this.then(function(wt){return Xs.resolve(lt()).then(function(){return wt})},function(wt){return Xs.resolve(lt()).then(function(){return H_(wt)})})},timeout:function(lt,wt){var zt=this;return lt<1/0?new Xs(function(Dr,Zr){var vo=setTimeout(function(){return Zr(new na.Timeout(wt))},lt);zt.then(Dr,Zr).finally(clearTimeout.bind(null,vo))}):this}}),typeof Symbol<"u"&&Symbol.toStringTag&&Ot(Xs.prototype,Symbol.toStringTag,"Dexie.Promise"),yy.env=G0(),nt(Xs,{all:function(){var lt=Qo.apply(null,arguments).map(K0);return new Xs(function(wt,zt){lt.length===0&&wt([]);var Dr=lt.length;lt.forEach(function(Zr,vo){return Xs.resolve(Zr).then(function(qo){lt[vo]=qo,--Dr||wt(lt)},zt)})})},resolve:function(lt){return lt instanceof Xs?lt:lt&&typeof lt.then=="function"?new Xs(function(wt,zt){lt.then(wt,zt)}):new Xs(Oo,!0,lt)},reject:H_,race:function(){var lt=Qo.apply(null,arguments).map(K0);return new Xs(function(wt,zt){lt.map(function(Dr){return Xs.resolve(Dr).then(wt,zt)})})},PSD:{get:function(){return O_},set:function(lt){return O_=lt}},totalEchoes:{get:function(){return Ry}},newPSD:hy,usePSD:N0,scheduler:{get:function(){return $u},set:function(lt){$u=lt}},rejectionMapper:{get:function(){return ey},set:function(lt){ey=lt}},follow:function(lt,wt){return new Xs(function(zt,Dr){return hy(function(Zr,vo){var qo=O_;qo.unhandleds=[],qo.onunhandled=vo,qo.finalize=Qs(function(){var ga,fu=this;ga=function(){fu.unhandleds.length===0?Zr():vo(fu.unhandleds[0])},jo.push(function uu(){ga(),jo.splice(jo.indexOf(uu),1)}),++g_,$u(function(){--g_==0&&q_()},[])},qo.finalize),lt()},wt,zt,Dr)})}}),au&&(au.allSettled&&Ot(Xs,"allSettled",function(){var lt=Qo.apply(null,arguments).map(K0);return new Xs(function(wt){lt.length===0&&wt([]);var zt=lt.length,Dr=new Array(zt);lt.forEach(function(Zr,vo){return Xs.resolve(Zr).then(function(qo){return Dr[vo]={status:"fulfilled",value:qo}},function(qo){return Dr[vo]={status:"rejected",reason:qo}}).then(function(){return--zt||wt(Dr)})})})}),au.any&&typeof AggregateError<"u"&&Ot(Xs,"any",function(){var lt=Qo.apply(null,arguments).map(K0);return new Xs(function(wt,zt){lt.length===0&&zt(new AggregateError([]));var Dr=lt.length,Zr=new Array(Dr);lt.forEach(function(vo,qo){return Xs.resolve(vo).then(function(ga){return wt(ga)},function(ga){Zr[qo]=ga,--Dr||zt(new AggregateError(Zr))})})})}));var pu={awaits:0,echoes:0,id:0},T_=0,E_=[],iy=0,Ry=0,Zy=0;function hy(lt,wt,zt,Dr){var Zr=O_,vo=Object.create(Zr);return vo.parent=Zr,vo.ref=0,vo.global=!1,vo.id=++Zy,yy.env,vo.env=i_?{Promise:Xs,PromiseProp:{value:Xs,configurable:!0,writable:!0},all:Xs.all,race:Xs.race,allSettled:Xs.allSettled,any:Xs.any,resolve:Xs.resolve,reject:Xs.reject}:{},wt&&$(vo,wt),++Zr.ref,vo.finalize=function(){--this.parent.ref||this.parent.finalize()},Dr=N0(vo,lt,zt,Dr),vo.ref===0&&vo.finalize(),Dr}function Ay(){return pu.id||(pu.id=++T_),++pu.awaits,pu.echoes+=Mo,pu.id}function Sy(){return!!pu.awaits&&(--pu.awaits==0&&(pu.id=0),pu.echoes=pu.awaits*Mo,!0)}function K0(lt){return pu.echoes&&lt&&lt.constructor===au?(Ay(),lt.then(function(wt){return Sy(),wt},function(wt){return Sy(),i0(wt)})):lt}function n0(){var lt=E_[E_.length-1];E_.pop(),A0(lt,!1)}function A0(lt,wt){var zt,Dr=O_;(wt?!pu.echoes||iy++&&lt===O_:!iy||--iy&&lt===O_)||queueMicrotask(wt?function(Zr){++Ry,pu.echoes&&--pu.echoes!=0||(pu.echoes=pu.awaits=pu.id=0),E_.push(O_),A0(Zr,!0)}.bind(null,lt):n0),lt!==O_&&(O_=lt,Dr===yy&&(yy.env=G0()),i_&&(zt=yy.env.Promise,wt=lt.env,(Dr.global||lt.global)&&(Object.defineProperty(a,"Promise",wt.PromiseProp),zt.all=wt.all,zt.race=wt.race,zt.resolve=wt.resolve,zt.reject=wt.reject,wt.allSettled&&(zt.allSettled=wt.allSettled),wt.any&&(zt.any=wt.any))))}function G0(){var lt=a.Promise;return i_?{Promise:lt,PromiseProp:Object.getOwnPropertyDescriptor(a,"Promise"),all:lt.all,race:lt.race,allSettled:lt.allSettled,any:lt.any,resolve:lt.resolve,reject:lt.reject}:{}}function N0(lt,wt,zt,Dr,Zr){var vo=O_;try{return A0(lt,!0),wt(zt,Dr,Zr)}finally{A0(vo,!1)}}function xw(lt,wt,zt,Dr){return typeof lt!="function"?lt:function(){var Zr=O_;zt&&Ay(),A0(wt,!0);try{return lt.apply(this,arguments)}finally{A0(Zr,!1),Dr&&queueMicrotask(Sy)}}}function uw(lt){Promise===au&&pu.echoes===0?iy===0?lt():enqueueNativeMicroTask(lt):setTimeout(lt,0)}(""+Z0).indexOf("[native code]")===-1&&(Ay=Sy=Cu);var i0=Xs.reject,q0="",M0="Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",Cw="String expected.",P0=[],F0="__dbnames",X0="readonly",Y0="readwrite";function U0(lt,wt){return lt?wt?function(){return lt.apply(this,arguments)&&wt.apply(this,arguments)}:lt:wt}var _w={type:3,lower:-1/0,lowerOpen:!1,upper:[[]],upperOpen:!1};function tw(lt){return typeof lt!="string"||/\./.test(lt)?function(wt){return wt}:function(wt){return wt[lt]===void 0&&lt in wt&&delete(wt=Wo(wt))[lt],wt}}function ly(){throw na.Type()}function by(lt,wt){try{var zt=Tw(lt),Dr=Tw(wt);if(zt!==Dr)return zt==="Array"?1:Dr==="Array"?-1:zt==="binary"?1:Dr==="binary"?-1:zt==="string"?1:Dr==="string"?-1:zt==="Date"?1:Dr!=="Date"?NaN:-1;switch(zt){case"number":case"Date":case"string":return wt<lt?1:lt<wt?-1:0;case"binary":return function(Zr,vo){for(var qo=Zr.length,ga=vo.length,fu=qo<ga?qo:ga,uu=0;uu<fu;++uu)if(Zr[uu]!==vo[uu])return Zr[uu]<vo[uu]?-1:1;return qo===ga?0:qo<ga?-1:1}(Ew(lt),Ew(wt));case"Array":return function(Zr,vo){for(var qo=Zr.length,ga=vo.length,fu=qo<ga?qo:ga,uu=0;uu<fu;++uu){var Su=by(Zr[uu],vo[uu]);if(Su!==0)return Su}return qo===ga?0:qo<ga?-1:1}(lt,wt)}}catch{}return NaN}function Tw(lt){var wt=typeof lt;return wt!="object"?wt:ArrayBuffer.isView(lt)?"binary":(lt=Yo(lt),lt==="ArrayBuffer"?"binary":lt)}function Ew(lt){return lt instanceof Uint8Array?lt:ArrayBuffer.isView(lt)?new Uint8Array(lt.buffer,lt.byteOffset,lt.byteLength):new Uint8Array(lt)}var yw=(Yy.prototype._trans=function(lt,wt,zt){var Dr=this._tx||O_.trans,Zr=this.name,vo=rn&&typeof console<"u"&&console.createTask&&console.createTask("Dexie: ".concat(lt==="readonly"?"read":"write"," ").concat(this.name));function qo(uu,Su,tu){if(!tu.schema[Zr])throw new na.NotFound("Table "+Zr+" not part of transaction");return wt(tu.idbtrans,tu)}var ga=P_();try{var fu=Dr&&Dr.db._novip===this.db._novip?Dr===O_.trans?Dr._promise(lt,qo,zt):hy(function(){return Dr._promise(lt,qo,zt)},{trans:Dr,transless:O_.transless||O_}):function uu(Su,tu,Ou,hu){if(Su.idbdb&&(Su._state.openComplete||O_.letThrough||Su._vip)){var yu=Su._createTransaction(tu,Ou,Su._dbSchema);try{yu.create(),Su._state.PR1398_maxLoop=3}catch(Au){return Au.name===r_.InvalidState&&Su.isOpen()&&0<--Su._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),Su.close({disableAutoOpen:!1}),Su.open().then(function(){return uu(Su,tu,Ou,hu)})):i0(Au)}return yu._promise(tu,function(Au,bu){return hy(function(){return O_.trans=yu,hu(Au,bu,yu)})}).then(function(Au){if(tu==="readwrite")try{yu.idbtrans.commit()}catch{}return tu==="readonly"?Au:yu._completion.then(function(){return Au})})}if(Su._state.openComplete)return i0(new na.DatabaseClosed(Su._state.dbOpenError));if(!Su._state.isBeingOpened){if(!Su._state.autoOpen)return i0(new na.DatabaseClosed);Su.open().catch(Cu)}return Su._state.dbReadyPromise.then(function(){return uu(Su,tu,Ou,hu)})}(this.db,lt,[this.name],qo);return vo&&(fu._consoleTask=vo,fu=fu.catch(function(uu){return console.trace(uu),i0(uu)})),fu}finally{ga&&N_()}},Yy.prototype.get=function(lt,wt){var zt=this;return lt&&lt.constructor===Object?this.where(lt).first(wt):lt==null?i0(new na.Type("Invalid argument to Table.get()")):this._trans("readonly",function(Dr){return zt.core.get({trans:Dr,key:lt}).then(function(Zr){return zt.hook.reading.fire(Zr)})}).then(wt)},Yy.prototype.where=function(lt){if(typeof lt=="string")return new this.db.WhereClause(this,lt);if(et(lt))return new this.db.WhereClause(this,"[".concat(lt.join("+"),"]"));var wt=d(lt);if(wt.length===1)return this.where(wt[0]).equals(lt[wt[0]]);var zt=this.schema.indexes.concat(this.schema.primKey).filter(function(fu){if(fu.compound&&wt.every(function(Su){return 0<=fu.keyPath.indexOf(Su)})){for(var uu=0;uu<wt.length;++uu)if(wt.indexOf(fu.keyPath[uu])===-1)return!1;return!0}return!1}).sort(function(fu,uu){return fu.keyPath.length-uu.keyPath.length})[0];if(zt&&this.db._maxKey!==q0){var qo=zt.keyPath.slice(0,wt.length);return this.where(qo).equals(qo.map(function(uu){return lt[uu]}))}!zt&&rn&&console.warn("The query ".concat(JSON.stringify(lt)," on ").concat(this.name," would benefit from a ")+"compound index [".concat(wt.join("+"),"]"));var Dr=this.schema.idxByName,Zr=this.db._deps.indexedDB;function vo(fu,uu){return Zr.cmp(fu,uu)===0}var ga=wt.reduce(function(Ou,uu){var Su=Ou[0],tu=Ou[1],Ou=Dr[uu],hu=lt[uu];return[Su||Ou,Su||!Ou?U0(tu,Ou&&Ou.multi?function(yu){return yu=gr(yu,uu),et(yu)&&yu.some(function(Au){return vo(hu,Au)})}:function(yu){return vo(hu,gr(yu,uu))}):tu]},[null,null]),qo=ga[0],ga=ga[1];return qo?this.where(qo.name).equals(lt[qo.keyPath]).filter(ga):zt?this.filter(ga):this.where(wt).equals("")},Yy.prototype.filter=function(lt){return this.toCollection().and(lt)},Yy.prototype.count=function(lt){return this.toCollection().count(lt)},Yy.prototype.offset=function(lt){return this.toCollection().offset(lt)},Yy.prototype.limit=function(lt){return this.toCollection().limit(lt)},Yy.prototype.each=function(lt){return this.toCollection().each(lt)},Yy.prototype.toArray=function(lt){return this.toCollection().toArray(lt)},Yy.prototype.toCollection=function(){return new this.db.Collection(new this.db.WhereClause(this))},Yy.prototype.orderBy=function(lt){return new this.db.Collection(new this.db.WhereClause(this,et(lt)?"[".concat(lt.join("+"),"]"):lt))},Yy.prototype.reverse=function(){return this.toCollection().reverse()},Yy.prototype.mapToClass=function(lt){var wt,zt=this.db,Dr=this.name;function Zr(){return wt!==null&&wt.apply(this,arguments)||this}(this.schema.mappedClass=lt).prototype instanceof ly&&(function(fu,uu){if(typeof uu!="function"&&uu!==null)throw new TypeError("Class extends value "+String(uu)+" is not a constructor or null");function Su(){this.constructor=fu}i(fu,uu),fu.prototype=uu===null?Object.create(uu):(Su.prototype=uu.prototype,new Su)}(Zr,wt=lt),Object.defineProperty(Zr.prototype,"db",{get:function(){return zt},enumerable:!1,configurable:!0}),Zr.prototype.table=function(){return Dr},lt=Zr);for(var vo=new Set,qo=lt.prototype;qo;qo=c(qo))Object.getOwnPropertyNames(qo).forEach(function(fu){return vo.add(fu)});function ga(fu){if(!fu)return fu;var uu,Su=Object.create(lt.prototype);for(uu in fu)if(!vo.has(uu))try{Su[uu]=fu[uu]}catch{}return Su}return this.schema.readHook&&this.hook.reading.unsubscribe(this.schema.readHook),this.schema.readHook=ga,this.hook("reading",ga),lt},Yy.prototype.defineClass=function(){return this.mapToClass(function(lt){$(this,lt)})},Yy.prototype.add=function(lt,wt){var zt=this,Dr=this.schema.primKey,Zr=Dr.auto,vo=Dr.keyPath,qo=lt;return vo&&Zr&&(qo=tw(vo)(lt)),this._trans("readwrite",function(ga){return zt.core.mutate({trans:ga,type:"add",keys:wt!=null?[wt]:null,values:[qo]})}).then(function(ga){return ga.numFailures?Xs.reject(ga.failures[0]):ga.lastResult}).then(function(ga){if(vo)try{vr(lt,vo,ga)}catch{}return ga})},Yy.prototype.update=function(lt,wt){return typeof lt!="object"||et(lt)?this.where(":id").equals(lt).modify(wt):(lt=gr(lt,this.schema.primKey.keyPath),lt===void 0?i0(new na.InvalidArgument("Given object does not contain its primary key")):this.where(":id").equals(lt).modify(wt))},Yy.prototype.put=function(lt,wt){var zt=this,Dr=this.schema.primKey,Zr=Dr.auto,vo=Dr.keyPath,qo=lt;return vo&&Zr&&(qo=tw(vo)(lt)),this._trans("readwrite",function(ga){return zt.core.mutate({trans:ga,type:"put",values:[qo],keys:wt!=null?[wt]:null})}).then(function(ga){return ga.numFailures?Xs.reject(ga.failures[0]):ga.lastResult}).then(function(ga){if(vo)try{vr(lt,vo,ga)}catch{}return ga})},Yy.prototype.delete=function(lt){var wt=this;return this._trans("readwrite",function(zt){return wt.core.mutate({trans:zt,type:"delete",keys:[lt]})}).then(function(zt){return zt.numFailures?Xs.reject(zt.failures[0]):void 0})},Yy.prototype.clear=function(){var lt=this;return this._trans("readwrite",function(wt){return lt.core.mutate({trans:wt,type:"deleteRange",range:_w})}).then(function(wt){return wt.numFailures?Xs.reject(wt.failures[0]):void 0})},Yy.prototype.bulkGet=function(lt){var wt=this;return this._trans("readonly",function(zt){return wt.core.getMany({keys:lt,trans:zt}).then(function(Dr){return Dr.map(function(Zr){return wt.hook.reading.fire(Zr)})})})},Yy.prototype.bulkAdd=function(lt,wt,zt){var Dr=this,Zr=Array.isArray(wt)?wt:void 0,vo=(zt=zt||(Zr?void 0:wt))?zt.allKeys:void 0;return this._trans("readwrite",function(qo){var uu=Dr.schema.primKey,ga=uu.auto,uu=uu.keyPath;if(uu&&Zr)throw new na.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");if(Zr&&Zr.length!==lt.length)throw new na.InvalidArgument("Arguments objects and keys must have the same length");var fu=lt.length,uu=uu&&ga?lt.map(tw(uu)):lt;return Dr.core.mutate({trans:qo,type:"add",keys:Zr,values:uu,wantResults:vo}).then(function(yu){var tu=yu.numFailures,Ou=yu.results,hu=yu.lastResult,yu=yu.failures;if(tu===0)return vo?Ou:hu;throw new wu("".concat(Dr.name,".bulkAdd(): ").concat(tu," of ").concat(fu," operations failed"),yu)})})},Yy.prototype.bulkPut=function(lt,wt,zt){var Dr=this,Zr=Array.isArray(wt)?wt:void 0,vo=(zt=zt||(Zr?void 0:wt))?zt.allKeys:void 0;return this._trans("readwrite",function(qo){var uu=Dr.schema.primKey,ga=uu.auto,uu=uu.keyPath;if(uu&&Zr)throw new na.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");if(Zr&&Zr.length!==lt.length)throw new na.InvalidArgument("Arguments objects and keys must have the same length");var fu=lt.length,uu=uu&&ga?lt.map(tw(uu)):lt;return Dr.core.mutate({trans:qo,type:"put",keys:Zr,values:uu,wantResults:vo}).then(function(yu){var tu=yu.numFailures,Ou=yu.results,hu=yu.lastResult,yu=yu.failures;if(tu===0)return vo?Ou:hu;throw new wu("".concat(Dr.name,".bulkPut(): ").concat(tu," of ").concat(fu," operations failed"),yu)})})},Yy.prototype.bulkUpdate=function(lt){var wt=this,zt=this.core,Dr=lt.map(function(qo){return qo.key}),Zr=lt.map(function(qo){return qo.changes}),vo=[];return this._trans("readwrite",function(qo){return zt.getMany({trans:qo,keys:Dr,cache:"clone"}).then(function(ga){var fu=[],uu=[];lt.forEach(function(tu,Ou){var hu=tu.key,yu=tu.changes,Au=ga[Ou];if(Au){for(var bu=0,Gu=Object.keys(yu);bu<Gu.length;bu++){var t_=Gu[bu],o_=yu[t_];if(t_===wt.schema.primKey.keyPath){if(by(o_,hu)!==0)throw new na.Constraint("Cannot update primary key in bulkUpdate()")}else vr(Au,t_,o_)}vo.push(Ou),fu.push(hu),uu.push(Au)}});var Su=fu.length;return zt.mutate({trans:qo,type:"put",keys:fu,values:uu,updates:{keys:Dr,changeSpecs:Zr}}).then(function(tu){var Ou=tu.numFailures,hu=tu.failures;if(Ou===0)return Su;for(var yu=0,Au=Object.keys(hu);yu<Au.length;yu++){var bu,Gu=Au[yu],t_=vo[Number(Gu)];t_!=null&&(bu=hu[Gu],delete hu[Gu],hu[t_]=bu)}throw new wu("".concat(wt.name,".bulkUpdate(): ").concat(Ou," of ").concat(Su," operations failed"),hu)})})})},Yy.prototype.bulkDelete=function(lt){var wt=this,zt=lt.length;return this._trans("readwrite",function(Dr){return wt.core.mutate({trans:Dr,type:"delete",keys:lt})}).then(function(qo){var Zr=qo.numFailures,vo=qo.lastResult,qo=qo.failures;if(Zr===0)return vo;throw new wu("".concat(wt.name,".bulkDelete(): ").concat(Zr," of ").concat(zt," operations failed"),qo)})},Yy);function Yy(){}function rw(lt){function wt(qo,ga){if(ga){for(var fu=arguments.length,uu=new Array(fu-1);--fu;)uu[fu-1]=arguments[fu];return zt[qo].subscribe.apply(null,uu),lt}if(typeof qo=="string")return zt[qo]}var zt={};wt.addEventType=vo;for(var Dr=1,Zr=arguments.length;Dr<Zr;++Dr)vo(arguments[Dr]);return wt;function vo(qo,ga,fu){if(typeof qo!="object"){var uu;ga=ga||js;var Su={subscribers:[],fire:fu=fu||Cu,subscribe:function(tu){Su.subscribers.indexOf(tu)===-1&&(Su.subscribers.push(tu),Su.fire=ga(Su.fire,tu))},unsubscribe:function(tu){Su.subscribers=Su.subscribers.filter(function(Ou){return Ou!==tu}),Su.fire=Su.subscribers.reduce(ga,fu)}};return zt[qo]=wt[qo]=Su}d(uu=qo).forEach(function(tu){var Ou=uu[tu];if(et(Ou))vo(tu,uu[tu][0],uu[tu][1]);else{if(Ou!=="asap")throw new na.InvalidArgument("Invalid event config");var hu=vo(tu,e_,function(){for(var yu=arguments.length,Au=new Array(yu);yu--;)Au[yu]=arguments[yu];hu.subscribers.forEach(function(bu){Zt(function(){bu.apply(null,Au)})})})}})}}function nw(lt,wt){return At(wt).from({prototype:lt}),wt}function ow(lt,wt){return!(lt.filter||lt.algorithm||lt.or)&&(wt?lt.justLimit:!lt.replayFilter)}function Jy(lt,wt){lt.filter=U0(lt.filter,wt)}function R0(lt,wt,zt){var Dr=lt.replayFilter;lt.replayFilter=Dr?function(){return U0(Dr(),wt())}:wt,lt.justLimit=zt&&!Dr}function xu(lt,wt){if(lt.isPrimKey)return wt.primaryKey;var zt=wt.getIndexByKeyPath(lt.index);if(!zt)throw new na.Schema("KeyPath "+lt.index+" on object store "+wt.name+" is not indexed");return zt}function wr(lt,wt,zt){var Dr=xu(lt,wt.schema);return wt.openCursor({trans:zt,values:!lt.keysOnly,reverse:lt.dir==="prev",unique:!!lt.unique,query:{index:Dr,range:lt.range}})}function Po(lt,wt,zt,Dr){var Zr=lt.replayFilter?U0(lt.filter,lt.replayFilter()):lt.filter;if(lt.or){var vo={},qo=function(ga,fu,uu){var Su,tu;Zr&&!Zr(fu,uu,function(Ou){return fu.stop(Ou)},function(Ou){return fu.fail(Ou)})||((tu=""+(Su=fu.primaryKey))=="[object ArrayBuffer]"&&(tu=""+new Uint8Array(Su)),g(vo,tu)||(vo[tu]=!0,wt(ga,fu,uu)))};return Promise.all([lt.or._iterate(qo,zt),Zs(wr(lt,Dr,zt),lt.algorithm,qo,!lt.keysOnly&&lt.valueMapper)])}return Zs(wr(lt,Dr,zt),U0(lt.algorithm,Zr),wt,!lt.keysOnly&&lt.valueMapper)}function Zs(lt,wt,zt,Dr){var Zr=j_(Dr?function(vo,qo,ga){return zt(Dr(vo),qo,ga)}:zt);return lt.then(function(vo){if(vo)return vo.start(function(){var qo=function(){return vo.continue()};wt&&!wt(vo,function(ga){return qo=ga},function(ga){vo.stop(ga),qo=Cu},function(ga){vo.fail(ga),qo=Cu})||Zr(vo.value,vo,function(ga){return qo=ga}),qo()})})}var ba=Symbol(),Iu=(a_.prototype.execute=function(lt){if(this.add!==void 0){var wt=this.add;if(et(wt))return h(h([],et(lt)?lt:[],!0),wt).sort();if(typeof wt=="number")return(Number(lt)||0)+wt;if(typeof wt=="bigint")try{return BigInt(lt)+wt}catch{return BigInt(0)+wt}throw new TypeError("Invalid term ".concat(wt))}if(this.remove!==void 0){var zt=this.remove;if(et(zt))return et(lt)?lt.filter(function(Dr){return!zt.includes(Dr)}).sort():[];if(typeof zt=="number")return Number(lt)-zt;if(typeof zt=="bigint")try{return BigInt(lt)-zt}catch{return BigInt(0)-zt}throw new TypeError("Invalid subtrahend ".concat(zt))}return wt=(wt=this.replacePrefix)===null||wt===void 0?void 0:wt[0],wt&&typeof lt=="string"&&lt.startsWith(wt)?this.replacePrefix[1]+lt.substring(wt.length):lt},a_);function a_(lt){Object.assign(this,lt)}var D_=(b_.prototype._read=function(lt,wt){var zt=this._ctx;return zt.error?zt.table._trans(null,i0.bind(null,zt.error)):zt.table._trans("readonly",lt).then(wt)},b_.prototype._write=function(lt){var wt=this._ctx;return wt.error?wt.table._trans(null,i0.bind(null,wt.error)):wt.table._trans("readwrite",lt,"locked")},b_.prototype._addAlgorithm=function(lt){var wt=this._ctx;wt.algorithm=U0(wt.algorithm,lt)},b_.prototype._iterate=function(lt,wt){return Po(this._ctx,lt,wt,this._ctx.table.core)},b_.prototype.clone=function(lt){var wt=Object.create(this.constructor.prototype),zt=Object.create(this._ctx);return lt&&$(zt,lt),wt._ctx=zt,wt},b_.prototype.raw=function(){return this._ctx.valueMapper=null,this},b_.prototype.each=function(lt){var wt=this._ctx;return this._read(function(zt){return Po(wt,lt,zt,wt.table.core)})},b_.prototype.count=function(lt){var wt=this;return this._read(function(zt){var Dr=wt._ctx,Zr=Dr.table.core;if(ow(Dr,!0))return Zr.count({trans:zt,query:{index:xu(Dr,Zr.schema),range:Dr.range}}).then(function(qo){return Math.min(qo,Dr.limit)});var vo=0;return Po(Dr,function(){return++vo,!1},zt,Zr).then(function(){return vo})}).then(lt)},b_.prototype.sortBy=function(lt,wt){var zt=lt.split(".").reverse(),Dr=zt[0],Zr=zt.length-1;function vo(fu,uu){return uu?vo(fu[zt[uu]],uu-1):fu[Dr]}var qo=this._ctx.dir==="next"?1:-1;function ga(fu,uu){return fu=vo(fu,Zr),uu=vo(uu,Zr),fu<uu?-qo:uu<fu?qo:0}return this.toArray(function(fu){return fu.sort(ga)}).then(wt)},b_.prototype.toArray=function(lt){var wt=this;return this._read(function(zt){var Dr=wt._ctx;if(Dr.dir==="next"&&ow(Dr,!0)&&0<Dr.limit){var Zr=Dr.valueMapper,vo=xu(Dr,Dr.table.core.schema);return Dr.table.core.query({trans:zt,limit:Dr.limit,values:!0,query:{index:vo,range:Dr.range}}).then(function(ga){return ga=ga.result,Zr?ga.map(Zr):ga})}var qo=[];return Po(Dr,function(ga){return qo.push(ga)},zt,Dr.table.core).then(function(){return qo})},lt)},b_.prototype.offset=function(lt){var wt=this._ctx;return lt<=0||(wt.offset+=lt,ow(wt)?R0(wt,function(){var zt=lt;return function(Dr,Zr){return zt===0||(zt===1?--zt:Zr(function(){Dr.advance(zt),zt=0}),!1)}}):R0(wt,function(){var zt=lt;return function(){return--zt<0}})),this},b_.prototype.limit=function(lt){return this._ctx.limit=Math.min(this._ctx.limit,lt),R0(this._ctx,function(){var wt=lt;return function(zt,Dr,Zr){return--wt<=0&&Dr(Zr),0<=wt}},!0),this},b_.prototype.until=function(lt,wt){return Jy(this._ctx,function(zt,Dr,Zr){return!lt(zt.value)||(Dr(Zr),wt)}),this},b_.prototype.first=function(lt){return this.limit(1).toArray(function(wt){return wt[0]}).then(lt)},b_.prototype.last=function(lt){return this.reverse().first(lt)},b_.prototype.filter=function(lt){var wt;return Jy(this._ctx,function(zt){return lt(zt.value)}),(wt=this._ctx).isMatch=U0(wt.isMatch,lt),this},b_.prototype.and=function(lt){return this.filter(lt)},b_.prototype.or=function(lt){return new this.db.WhereClause(this._ctx.table,lt,this)},b_.prototype.reverse=function(){return this._ctx.dir=this._ctx.dir==="prev"?"next":"prev",this._ondirectionchange&&this._ondirectionchange(this._ctx.dir),this},b_.prototype.desc=function(){return this.reverse()},b_.prototype.eachKey=function(lt){var wt=this._ctx;return wt.keysOnly=!wt.isMatch,this.each(function(zt,Dr){lt(Dr.key,Dr)})},b_.prototype.eachUniqueKey=function(lt){return this._ctx.unique="unique",this.eachKey(lt)},b_.prototype.eachPrimaryKey=function(lt){var wt=this._ctx;return wt.keysOnly=!wt.isMatch,this.each(function(zt,Dr){lt(Dr.primaryKey,Dr)})},b_.prototype.keys=function(lt){var wt=this._ctx;wt.keysOnly=!wt.isMatch;var zt=[];return this.each(function(Dr,Zr){zt.push(Zr.key)}).then(function(){return zt}).then(lt)},b_.prototype.primaryKeys=function(lt){var wt=this._ctx;if(wt.dir==="next"&&ow(wt,!0)&&0<wt.limit)return this._read(function(Dr){var Zr=xu(wt,wt.table.core.schema);return wt.table.core.query({trans:Dr,values:!1,limit:wt.limit,query:{index:Zr,range:wt.range}})}).then(function(Dr){return Dr.result}).then(lt);wt.keysOnly=!wt.isMatch;var zt=[];return this.each(function(Dr,Zr){zt.push(Zr.primaryKey)}).then(function(){return zt}).then(lt)},b_.prototype.uniqueKeys=function(lt){return this._ctx.unique="unique",this.keys(lt)},b_.prototype.firstKey=function(lt){return this.limit(1).keys(function(wt){return wt[0]}).then(lt)},b_.prototype.lastKey=function(lt){return this.reverse().firstKey(lt)},b_.prototype.distinct=function(){var lt=this._ctx,lt=lt.index&&lt.table.schema.idxByName[lt.index];if(!lt||!lt.multi)return this;var wt={};return Jy(this._ctx,function(Zr){var Dr=Zr.primaryKey.toString(),Zr=g(wt,Dr);return wt[Dr]=!0,!Zr}),this},b_.prototype.modify=function(lt){var wt=this,zt=this._ctx;return this._write(function(Dr){var Zr,vo,qo;qo=typeof lt=="function"?lt:(Zr=d(lt),vo=Zr.length,function(bu){for(var Gu=!1,t_=0;t_<vo;++t_){var o_=Zr[t_],__=lt[o_],p_=gr(bu,o_);__ instanceof Iu?(vr(bu,o_,__.execute(p_)),Gu=!0):p_!==__&&(vr(bu,o_,__),Gu=!0)}return Gu});function ga(bu,o_){var t_=o_.failures,o_=o_.numFailures;yu+=bu-o_;for(var __=0,p_=d(t_);__<p_.length;__++){var V_=p_[__];hu.push(t_[V_])}}var fu=zt.table.core,uu=fu.schema.primaryKey,Su=uu.outbound,tu=uu.extractKey,Ou=wt.db._options.modifyChunkSize||200,hu=[],yu=0,Au=[];return wt.clone().primaryKeys().then(function(bu){function Gu(o_){var __=Math.min(Ou,bu.length-o_);return fu.getMany({trans:Dr,keys:bu.slice(o_,o_+__),cache:"immutable"}).then(function(p_){for(var V_=[],I_=[],W_=Su?[]:null,K_=[],A_=0;A_<__;++A_){var my=p_[A_],vy={value:Wo(my),primKey:bu[o_+A_]};qo.call(vy,vy.value,vy)!==!1&&(vy.value==null?K_.push(bu[o_+A_]):Su||by(tu(my),tu(vy.value))===0?(I_.push(vy.value),Su&&W_.push(bu[o_+A_])):(K_.push(bu[o_+A_]),V_.push(vy.value)))}return Promise.resolve(0<V_.length&&fu.mutate({trans:Dr,type:"add",values:V_}).then(function(Dy){for(var Fy in Dy.failures)K_.splice(parseInt(Fy),1);ga(V_.length,Dy)})).then(function(){return(0<I_.length||t_&&typeof lt=="object")&&fu.mutate({trans:Dr,type:"put",keys:W_,values:I_,criteria:t_,changeSpec:typeof lt!="function"&&lt,isAdditionalChunk:0<o_}).then(function(Dy){return ga(I_.length,Dy)})}).then(function(){return(0<K_.length||t_&&lt===z_)&&fu.mutate({trans:Dr,type:"delete",keys:K_,criteria:t_,isAdditionalChunk:0<o_}).then(function(Dy){return ga(K_.length,Dy)})}).then(function(){return bu.length>o_+__&&Gu(o_+Ou)})})}var t_=ow(zt)&&zt.limit===1/0&&(typeof lt!="function"||lt===z_)&&{index:zt.index,range:zt.range};return Gu(0).then(function(){if(0<hu.length)throw new du("Error modifying one or more objects",hu,yu,Au);return bu.length})})})},b_.prototype.delete=function(){var lt=this._ctx,wt=lt.range;return ow(lt)&&(lt.isPrimKey||wt.type===3)?this._write(function(zt){var Dr=lt.table.core.schema.primaryKey,Zr=wt;return lt.table.core.count({trans:zt,query:{index:Dr,range:Zr}}).then(function(vo){return lt.table.core.mutate({trans:zt,type:"deleteRange",range:Zr}).then(function(qo){var ga=qo.failures;if(qo.lastResult,qo.results,qo=qo.numFailures,qo)throw new du("Could not delete some values",Object.keys(ga).map(function(fu){return ga[fu]}),vo-qo);return vo-qo})})}):this.modify(z_)},b_);function b_(){}var z_=function(lt,wt){return wt.value=null};function C_(lt,wt){return lt<wt?-1:lt===wt?0:1}function Cy(lt,wt){return wt<lt?-1:lt===wt?0:1}function ay(lt,wt,zt){return lt=lt instanceof h0?new lt.Collection(lt):lt,lt._ctx.error=new(zt||TypeError)(wt),lt}function wy(lt){return new lt.Collection(lt,function(){return L0("")}).limit(0)}function sy(lt,wt,zt,Dr){var Zr,vo,qo,ga,fu,uu,Su,tu=zt.length;if(!zt.every(function(yu){return typeof yu=="string"}))return ay(lt,Cw);function Ou(yu){Zr=yu==="next"?function(bu){return bu.toUpperCase()}:function(bu){return bu.toLowerCase()},vo=yu==="next"?function(bu){return bu.toLowerCase()}:function(bu){return bu.toUpperCase()},qo=yu==="next"?C_:Cy;var Au=zt.map(function(bu){return{lower:vo(bu),upper:Zr(bu)}}).sort(function(bu,Gu){return qo(bu.lower,Gu.lower)});ga=Au.map(function(bu){return bu.upper}),fu=Au.map(function(bu){return bu.lower}),Su=(uu=yu)==="next"?"":Dr}Ou("next"),lt=new lt.Collection(lt,function(){return Ey(ga[0],fu[tu-1]+Dr)}),lt._ondirectionchange=function(yu){Ou(yu)};var hu=0;return lt._addAlgorithm(function(yu,Au,bu){var Gu=yu.key;if(typeof Gu!="string")return!1;var t_=vo(Gu);if(wt(t_,fu,hu))return!0;for(var o_=null,__=hu;__<tu;++__){var p_=function(V_,I_,W_,K_,A_,my){for(var vy=Math.min(V_.length,K_.length),Dy=-1,Fy=0;Fy<vy;++Fy){var aw=I_[Fy];if(aw!==K_[Fy])return A_(V_[Fy],W_[Fy])<0?V_.substr(0,Fy)+W_[Fy]+W_.substr(Fy+1):A_(V_[Fy],K_[Fy])<0?V_.substr(0,Fy)+K_[Fy]+W_.substr(Fy+1):0<=Dy?V_.substr(0,Dy)+I_[Dy]+W_.substr(Dy+1):null;A_(V_[Fy],aw)<0&&(Dy=Fy)}return vy<K_.length&&my==="next"?V_+W_.substr(V_.length):vy<V_.length&&my==="prev"?V_.substr(0,W_.length):Dy<0?null:V_.substr(0,Dy)+K_[Dy]+W_.substr(Dy+1)}(Gu,t_,ga[__],fu[__],qo,uu);p_===null&&o_===null?hu=__+1:(o_===null||0<qo(o_,p_))&&(o_=p_)}return Au(o_!==null?function(){yu.continue(o_+Su)}:bu),!1}),lt}function Ey(lt,wt,zt,Dr){return{type:2,lower:lt,upper:wt,lowerOpen:zt,upperOpen:Dr}}function L0(lt){return{type:1,lower:lt,upper:lt}}var h0=(Object.defineProperty(Uu.prototype,"Collection",{get:function(){return this._ctx.table.db.Collection},enumerable:!1,configurable:!0}),Uu.prototype.between=function(lt,wt,zt,Dr){zt=zt!==!1,Dr=Dr===!0;try{return 0<this._cmp(lt,wt)||this._cmp(lt,wt)===0&&(zt||Dr)&&(!zt||!Dr)?wy(this):new this.Collection(this,function(){return Ey(lt,wt,!zt,!Dr)})}catch{return ay(this,M0)}},Uu.prototype.equals=function(lt){return lt==null?ay(this,M0):new this.Collection(this,function(){return L0(lt)})},Uu.prototype.above=function(lt){return lt==null?ay(this,M0):new this.Collection(this,function(){return Ey(lt,void 0,!0)})},Uu.prototype.aboveOrEqual=function(lt){return lt==null?ay(this,M0):new this.Collection(this,function(){return Ey(lt,void 0,!1)})},Uu.prototype.below=function(lt){return lt==null?ay(this,M0):new this.Collection(this,function(){return Ey(void 0,lt,!1,!0)})},Uu.prototype.belowOrEqual=function(lt){return lt==null?ay(this,M0):new this.Collection(this,function(){return Ey(void 0,lt)})},Uu.prototype.startsWith=function(lt){return typeof lt!="string"?ay(this,Cw):this.between(lt,lt+q0,!0,!0)},Uu.prototype.startsWithIgnoreCase=function(lt){return lt===""?this.startsWith(lt):sy(this,function(wt,zt){return wt.indexOf(zt[0])===0},[lt],q0)},Uu.prototype.equalsIgnoreCase=function(lt){return sy(this,function(wt,zt){return wt===zt[0]},[lt],"")},Uu.prototype.anyOfIgnoreCase=function(){var lt=Qo.apply(To,arguments);return lt.length===0?wy(this):sy(this,function(wt,zt){return zt.indexOf(wt)!==-1},lt,"")},Uu.prototype.startsWithAnyOfIgnoreCase=function(){var lt=Qo.apply(To,arguments);return lt.length===0?wy(this):sy(this,function(wt,zt){return zt.some(function(Dr){return wt.indexOf(Dr)===0})},lt,q0)},Uu.prototype.anyOf=function(){var lt=this,wt=Qo.apply(To,arguments),zt=this._cmp;try{wt.sort(zt)}catch{return ay(this,M0)}if(wt.length===0)return wy(this);var Dr=new this.Collection(this,function(){return Ey(wt[0],wt[wt.length-1])});Dr._ondirectionchange=function(vo){zt=vo==="next"?lt._ascending:lt._descending,wt.sort(zt)};var Zr=0;return Dr._addAlgorithm(function(vo,qo,ga){for(var fu=vo.key;0<zt(fu,wt[Zr]);)if(++Zr===wt.length)return qo(ga),!1;return zt(fu,wt[Zr])===0||(qo(function(){vo.continue(wt[Zr])}),!1)}),Dr},Uu.prototype.notEqual=function(lt){return this.inAnyRange([[-1/0,lt],[lt,this.db._maxKey]],{includeLowers:!1,includeUppers:!1})},Uu.prototype.noneOf=function(){var lt=Qo.apply(To,arguments);if(lt.length===0)return new this.Collection(this);try{lt.sort(this._ascending)}catch{return ay(this,M0)}var wt=lt.reduce(function(zt,Dr){return zt?zt.concat([[zt[zt.length-1][1],Dr]]):[[-1/0,Dr]]},null);return wt.push([lt[lt.length-1],this.db._maxKey]),this.inAnyRange(wt,{includeLowers:!1,includeUppers:!1})},Uu.prototype.inAnyRange=function(Gu,wt){var zt=this,Dr=this._cmp,Zr=this._ascending,vo=this._descending,qo=this._min,ga=this._max;if(Gu.length===0)return wy(this);if(!Gu.every(function(t_){return t_[0]!==void 0&&t_[1]!==void 0&&Zr(t_[0],t_[1])<=0}))return ay(this,"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower",na.InvalidArgument);var fu=!wt||wt.includeLowers!==!1,uu=wt&&wt.includeUppers===!0,Su,tu=Zr;function Ou(t_,o_){return tu(t_[0],o_[0])}try{(Su=Gu.reduce(function(t_,o_){for(var __=0,p_=t_.length;__<p_;++__){var V_=t_[__];if(Dr(o_[0],V_[1])<0&&0<Dr(o_[1],V_[0])){V_[0]=qo(V_[0],o_[0]),V_[1]=ga(V_[1],o_[1]);break}}return __===p_&&t_.push(o_),t_},[])).sort(Ou)}catch{return ay(this,M0)}var hu=0,yu=uu?function(t_){return 0<Zr(t_,Su[hu][1])}:function(t_){return 0<=Zr(t_,Su[hu][1])},Au=fu?function(t_){return 0<vo(t_,Su[hu][0])}:function(t_){return 0<=vo(t_,Su[hu][0])},bu=yu,Gu=new this.Collection(this,function(){return Ey(Su[0][0],Su[Su.length-1][1],!fu,!uu)});return Gu._ondirectionchange=function(t_){tu=t_==="next"?(bu=yu,Zr):(bu=Au,vo),Su.sort(Ou)},Gu._addAlgorithm(function(t_,o_,__){for(var p_,V_=t_.key;bu(V_);)if(++hu===Su.length)return o_(__),!1;return!yu(p_=V_)&&!Au(p_)||(zt._cmp(V_,Su[hu][1])===0||zt._cmp(V_,Su[hu][0])===0||o_(function(){tu===Zr?t_.continue(Su[hu][0]):t_.continue(Su[hu][1])}),!1)}),Gu},Uu.prototype.startsWithAnyOf=function(){var lt=Qo.apply(To,arguments);return lt.every(function(wt){return typeof wt=="string"})?lt.length===0?wy(this):this.inAnyRange(lt.map(function(wt){return[wt,wt+q0]})):ay(this,"startsWithAnyOf() only works with strings")},Uu);function Uu(){}function g0(lt){return j_(function(wt){return Iy(wt),lt(wt.target.error),!1})}function Iy(lt){lt.stopPropagation&&lt.stopPropagation(),lt.preventDefault&&lt.preventDefault()}var _0="storagemutated",ry="x-storagemutated-1",J_=rw(null,_0),k0=(e0.prototype._lock=function(){return Qt(!O_.global),++this._reculock,this._reculock!==1||O_.global||(O_.lockOwnerFor=this),this},e0.prototype._unlock=function(){if(Qt(!O_.global),--this._reculock==0)for(O_.global||(O_.lockOwnerFor=null);0<this._blockedFuncs.length&&!this._locked();){var lt=this._blockedFuncs.shift();try{N0(lt[1],lt[0])}catch{}}return this},e0.prototype._locked=function(){return this._reculock&&O_.lockOwnerFor!==this},e0.prototype.create=function(lt){var wt=this;if(!this.mode)return this;var zt=this.db.idbdb,Dr=this.db._state.dbOpenError;if(Qt(!this.idbtrans),!lt&&!zt)switch(Dr&&Dr.name){case"DatabaseClosedError":throw new na.DatabaseClosed(Dr);case"MissingAPIError":throw new na.MissingAPI(Dr.message,Dr);default:throw new na.OpenFailed(Dr)}if(!this.active)throw new na.TransactionInactive;return Qt(this._completion._state===null),(lt=this.idbtrans=lt||(this.db.core||zt).transaction(this.storeNames,this.mode,{durability:this.chromeTransactionDurability})).onerror=j_(function(Zr){Iy(Zr),wt._reject(lt.error)}),lt.onabort=j_(function(Zr){Iy(Zr),wt.active&&wt._reject(new na.Abort(lt.error)),wt.active=!1,wt.on("abort").fire(Zr)}),lt.oncomplete=j_(function(){wt.active=!1,wt._resolve(),"mutatedParts"in lt&&J_.storagemutated.fire(lt.mutatedParts)}),this},e0.prototype._promise=function(lt,wt,zt){var Dr=this;if(lt==="readwrite"&&this.mode!=="readwrite")return i0(new na.ReadOnly("Transaction is readonly"));if(!this.active)return i0(new na.TransactionInactive);if(this._locked())return new Xs(function(vo,qo){Dr._blockedFuncs.push([function(){Dr._promise(lt,wt,zt).then(vo,qo)},O_])});if(zt)return hy(function(){var vo=new Xs(function(qo,ga){Dr._lock();var fu=wt(qo,ga,Dr);fu&&fu.then&&fu.then(qo,ga)});return vo.finally(function(){return Dr._unlock()}),vo._lib=!0,vo});var Zr=new Xs(function(vo,qo){var ga=wt(vo,qo,Dr);ga&&ga.then&&ga.then(vo,qo)});return Zr._lib=!0,Zr},e0.prototype._root=function(){return this.parent?this.parent._root():this},e0.prototype.waitFor=function(lt){var wt,zt=this._root(),Dr=Xs.resolve(lt);zt._waitingFor?zt._waitingFor=zt._waitingFor.then(function(){return Dr}):(zt._waitingFor=Dr,zt._waitingQueue=[],wt=zt.idbtrans.objectStore(zt.storeNames[0]),function vo(){for(++zt._spinCount;zt._waitingQueue.length;)zt._waitingQueue.shift()();zt._waitingFor&&(wt.get(-1/0).onsuccess=vo)}());var Zr=zt._waitingFor;return new Xs(function(vo,qo){Dr.then(function(ga){return zt._waitingQueue.push(j_(vo.bind(null,ga)))},function(ga){return zt._waitingQueue.push(j_(qo.bind(null,ga)))}).finally(function(){zt._waitingFor===Zr&&(zt._waitingFor=null)})})},e0.prototype.abort=function(){this.active&&(this.active=!1,this.idbtrans&&this.idbtrans.abort(),this._reject(new na.Abort))},e0.prototype.table=function(lt){var wt=this._memoizedTables||(this._memoizedTables={});if(g(wt,lt))return wt[lt];var zt=this.schema[lt];if(!zt)throw new na.NotFound("Table "+lt+" not part of transaction");return zt=new this.db.Table(lt,zt,this),zt.core=this.db.core.table(lt),wt[lt]=zt},e0);function e0(){}function jy(lt,wt,zt,Dr,Zr,vo,qo){return{name:lt,keyPath:wt,unique:zt,multi:Dr,auto:Zr,compound:vo,src:(zt&&!qo?"&":"")+(Dr?"*":"")+(Zr?"++":"")+zy(wt)}}function zy(lt){return typeof lt=="string"?lt:lt?"["+[].join.call(lt,"+")+"]":""}function U_(lt,wt,zt){return{name:lt,primKey:wt,indexes:zt,mappedClass:null,idxByName:(Dr=function(Zr){return[Zr.name,Zr]},zt.reduce(function(Zr,vo,qo){return qo=Dr(vo,qo),qo&&(Zr[qo[0]]=qo[1]),Zr},{}))};var Dr}var _y=function(lt){try{return lt.only([[]]),_y=function(){return[[]]},[[]]}catch{return _y=function(){return q0},q0}};function Ky(lt){return lt==null?function(){}:typeof lt=="string"?(wt=lt).split(".").length===1?function(zt){return zt[wt]}:function(zt){return gr(zt,wt)}:function(zt){return gr(zt,lt)};var wt}function s0(lt){return[].slice.call(lt)}var S0=0;function X_(lt){return lt==null?":id":typeof lt=="string"?lt:"[".concat(lt.join("+"),"]")}function $w(lt,wt,fu){function Dr(bu){if(bu.type===3)return null;if(bu.type===4)throw new Error("Cannot convert never type to IDBKeyRange");var hu=bu.lower,yu=bu.upper,Au=bu.lowerOpen,bu=bu.upperOpen;return hu===void 0?yu===void 0?null:wt.upperBound(yu,!!bu):yu===void 0?wt.lowerBound(hu,!!Au):wt.bound(hu,yu,!!Au,!!bu)}function Zr(Ou){var hu,yu=Ou.name;return{name:yu,schema:Ou,mutate:function(Au){var bu=Au.trans,Gu=Au.type,t_=Au.keys,o_=Au.values,__=Au.range;return new Promise(function(p_,V_){p_=j_(p_);var I_=bu.objectStore(yu),W_=I_.keyPath==null,K_=Gu==="put"||Gu==="add";if(!K_&&Gu!=="delete"&&Gu!=="deleteRange")throw new Error("Invalid operation type: "+Gu);var A_,my=(t_||o_||{length:1}).length;if(t_&&o_&&t_.length!==o_.length)throw new Error("Given keys array must have same length as given values array.");if(my===0)return p_({numFailures:0,failures:{},results:[],lastResult:void 0});function vy(x0){++aw,Iy(x0)}var Dy=[],Fy=[],aw=0;if(Gu==="deleteRange"){if(__.type===4)return p_({numFailures:aw,failures:Fy,results:[],lastResult:void 0});__.type===3?Dy.push(A_=I_.clear()):Dy.push(A_=I_.delete(Dr(__)))}else{var W_=K_?W_?[o_,t_]:[o_,null]:[t_,null],Oy=W_[0],C0=W_[1];if(K_)for(var I0=0;I0<my;++I0)Dy.push(A_=C0&&C0[I0]!==void 0?I_[Gu](Oy[I0],C0[I0]):I_[Gu](Oy[I0])),A_.onerror=vy;else for(I0=0;I0<my;++I0)Dy.push(A_=I_[Gu](Oy[I0])),A_.onerror=vy}function Hw(x0){x0=x0.target.result,Dy.forEach(function(Sw,Fw){return Sw.error!=null&&(Fy[Fw]=Sw.error)}),p_({numFailures:aw,failures:Fy,results:Gu==="delete"?t_:Dy.map(function(Sw){return Sw.result}),lastResult:x0})}A_.onerror=function(x0){vy(x0),Hw(x0)},A_.onsuccess=Hw})},getMany:function(Au){var bu=Au.trans,Gu=Au.keys;return new Promise(function(t_,o_){t_=j_(t_);for(var __,p_=bu.objectStore(yu),V_=Gu.length,I_=new Array(V_),W_=0,K_=0,A_=function(Dy){Dy=Dy.target,I_[Dy._pos]=Dy.result,++K_===W_&&t_(I_)},my=g0(o_),vy=0;vy<V_;++vy)Gu[vy]!=null&&((__=p_.get(Gu[vy]))._pos=vy,__.onsuccess=A_,__.onerror=my,++W_);W_===0&&t_(I_)})},get:function(Au){var bu=Au.trans,Gu=Au.key;return new Promise(function(t_,o_){t_=j_(t_);var __=bu.objectStore(yu).get(Gu);__.onsuccess=function(p_){return t_(p_.target.result)},__.onerror=g0(o_)})},query:(hu=uu,function(Au){return new Promise(function(bu,Gu){bu=j_(bu);var t_,o_,__,W_=Au.trans,p_=Au.values,V_=Au.limit,A_=Au.query,I_=V_===1/0?void 0:V_,K_=A_.index,A_=A_.range,W_=W_.objectStore(yu),K_=K_.isPrimaryKey?W_:W_.index(K_.name),A_=Dr(A_);if(V_===0)return bu({result:[]});hu?((I_=p_?K_.getAll(A_,I_):K_.getAllKeys(A_,I_)).onsuccess=function(my){return bu({result:my.target.result})},I_.onerror=g0(Gu)):(t_=0,o_=!p_&&"openKeyCursor"in K_?K_.openKeyCursor(A_):K_.openCursor(A_),__=[],o_.onsuccess=function(my){var vy=o_.result;return vy?(__.push(p_?vy.value:vy.primaryKey),++t_===V_?bu({result:__}):void vy.continue()):bu({result:__})},o_.onerror=g0(Gu))})}),openCursor:function(Au){var bu=Au.trans,Gu=Au.values,t_=Au.query,o_=Au.reverse,__=Au.unique;return new Promise(function(p_,V_){p_=j_(p_);var K_=t_.index,I_=t_.range,W_=bu.objectStore(yu),W_=K_.isPrimaryKey?W_:W_.index(K_.name),K_=o_?__?"prevunique":"prev":__?"nextunique":"next",A_=!Gu&&"openKeyCursor"in W_?W_.openKeyCursor(Dr(I_),K_):W_.openCursor(Dr(I_),K_);A_.onerror=g0(V_),A_.onsuccess=j_(function(my){var vy,Dy,Fy,aw,Oy=A_.result;Oy?(Oy.___id=++S0,Oy.done=!1,vy=Oy.continue.bind(Oy),Dy=(Dy=Oy.continuePrimaryKey)&&Dy.bind(Oy),Fy=Oy.advance.bind(Oy),aw=function(){throw new Error("Cursor not stopped")},Oy.trans=bu,Oy.stop=Oy.continue=Oy.continuePrimaryKey=Oy.advance=function(){throw new Error("Cursor not started")},Oy.fail=j_(V_),Oy.next=function(){var C0=this,I0=1;return this.start(function(){return I0--?C0.continue():C0.stop()}).then(function(){return C0})},Oy.start=function(C0){function I0(){if(A_.result)try{C0()}catch(x0){Oy.fail(x0)}else Oy.done=!0,Oy.start=function(){throw new Error("Cursor behind last entry")},Oy.stop()}var Hw=new Promise(function(x0,Sw){x0=j_(x0),A_.onerror=g0(Sw),Oy.fail=Sw,Oy.stop=function(Fw){Oy.stop=Oy.continue=Oy.continuePrimaryKey=Oy.advance=aw,x0(Fw)}});return A_.onsuccess=j_(function(x0){A_.onsuccess=I0,I0()}),Oy.continue=vy,Oy.continuePrimaryKey=Dy,Oy.advance=Fy,I0(),Hw},p_(Oy)):p_(null)},V_)})},count:function(Au){var bu=Au.query,Gu=Au.trans,t_=bu.index,o_=bu.range;return new Promise(function(__,p_){var V_=Gu.objectStore(yu),I_=t_.isPrimaryKey?V_:V_.index(t_.name),V_=Dr(o_),I_=V_?I_.count(V_):I_.count();I_.onsuccess=j_(function(W_){return __(W_.target.result)}),I_.onerror=g0(p_)})}}}var vo,qo,ga,Su=(qo=fu,ga=s0((vo=lt).objectStoreNames),{schema:{name:vo.name,tables:ga.map(function(Ou){return qo.objectStore(Ou)}).map(function(Ou){var hu=Ou.keyPath,bu=Ou.autoIncrement,yu=et(hu),Au={},bu={name:Ou.name,primaryKey:{name:null,isPrimaryKey:!0,outbound:hu==null,compound:yu,keyPath:hu,autoIncrement:bu,unique:!0,extractKey:Ky(hu)},indexes:s0(Ou.indexNames).map(function(Gu){return Ou.index(Gu)}).map(function(__){var t_=__.name,o_=__.unique,p_=__.multiEntry,__=__.keyPath,p_={name:t_,compound:et(__),keyPath:__,unique:o_,multiEntry:p_,extractKey:Ky(__)};return Au[X_(__)]=p_}),getIndexByKeyPath:function(Gu){return Au[X_(Gu)]}};return Au[":id"]=bu.primaryKey,hu!=null&&(Au[X_(hu)]=bu.primaryKey),bu})},hasGetAll:0<ga.length&&"getAll"in qo.objectStore(ga[0])&&!(typeof navigator<"u"&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604)}),fu=Su.schema,uu=Su.hasGetAll,Su=fu.tables.map(Zr),tu={};return Su.forEach(function(Ou){return tu[Ou.name]=Ou}),{stack:"dbcore",transaction:lt.transaction.bind(lt),table:function(Ou){if(!tu[Ou])throw new Error("Table '".concat(Ou,"' not found"));return tu[Ou]},MIN_KEY:-1/0,MAX_KEY:_y(wt),schema:fu}}function v_(lt,wt,zt,Dr){var Zr=zt.IDBKeyRange;return zt.indexedDB,{dbcore:(Dr=$w(wt,Zr,Dr),lt.dbcore.reduce(function(vo,qo){return qo=qo.create,s(s({},vo),qo(vo))},Dr))}}function Xr(lt,Dr){var zt=Dr.db,Dr=v_(lt._middlewares,zt,lt._deps,Dr);lt.core=Dr.dbcore,lt.tables.forEach(function(Zr){var vo=Zr.name;lt.core.schema.tables.some(function(qo){return qo.name===vo})&&(Zr.core=lt.core.table(vo),lt[vo]instanceof lt.Table&&(lt[vo].core=Zr.core))})}function Xo(lt,wt,zt,Dr){zt.forEach(function(Zr){var vo=Dr[Zr];wt.forEach(function(qo){var ga=function fu(uu,Su){return Ct(uu,Su)||(uu=c(uu))&&fu(uu,Su)}(qo,Zr);(!ga||"value"in ga&&ga.value===void 0)&&(qo===lt.Transaction.prototype||qo instanceof lt.Transaction?Ot(qo,Zr,{get:function(){return this.table(Zr)},set:function(fu){at(this,Zr,{value:fu,writable:!0,configurable:!0,enumerable:!0})}}):qo[Zr]=new lt.Table(Zr,vo))})})}function ru(lt,wt){wt.forEach(function(zt){for(var Dr in zt)zt[Dr]instanceof lt.Table&&delete zt[Dr]})}function Pu(lt,wt){return lt._cfg.version-wt._cfg.version}function Nu(lt,wt,zt,Dr){var Zr=lt._dbSchema;zt.objectStoreNames.contains("$meta")&&!Zr.$meta&&(Zr.$meta=U_("$meta",e1("")[0],[]),lt._storeNames.push("$meta"));var vo=lt._createTransaction("readwrite",lt._storeNames,Zr);vo.create(zt),vo._completion.catch(Dr);var qo=vo._reject.bind(vo),ga=O_.transless||O_;hy(function(){return O_.trans=vo,O_.transless=ga,wt!==0?(Xr(lt,zt),uu=wt,((fu=vo).storeNames.includes("$meta")?fu.table("$meta").get("version").then(function(Su){return Su??uu}):Xs.resolve(uu)).then(function(Su){return Ou=Su,hu=vo,yu=zt,Au=[],Su=(tu=lt)._versions,bu=tu._dbSchema=v0(0,tu.idbdb,yu),(Su=Su.filter(function(Gu){return Gu._cfg.version>=Ou})).length!==0?(Su.forEach(function(Gu){Au.push(function(){var t_=bu,o_=Gu._cfg.dbschema;B0(tu,t_,yu),B0(tu,o_,yu),bu=tu._dbSchema=o_;var __=oy(t_,o_);__.add.forEach(function(K_){Qy(yu,K_[0],K_[1].primKey,K_[1].indexes)}),__.change.forEach(function(K_){if(K_.recreate)throw new na.Upgrade("Not yet support for changing primary key");var A_=yu.objectStore(K_.name);K_.add.forEach(function(my){return y0(A_,my)}),K_.change.forEach(function(my){A_.deleteIndex(my.name),y0(A_,my)}),K_.del.forEach(function(my){return A_.deleteIndex(my)})});var p_=Gu._cfg.contentUpgrade;if(p_&&Gu._cfg.version>Ou){Xr(tu,yu),hu._memoizedTables={};var V_=Er(o_);__.del.forEach(function(K_){V_[K_]=t_[K_]}),ru(tu,[tu.Transaction.prototype]),Xo(tu,[tu.Transaction.prototype],d(V_),V_),hu.schema=V_;var I_,W_=Jr(p_);return W_&&Ay(),__=Xs.follow(function(){var K_;(I_=p_(hu))&&W_&&(K_=Sy.bind(null,null),I_.then(K_,K_))}),I_&&typeof I_.then=="function"?Xs.resolve(I_):__.then(function(){return I_})}}),Au.push(function(t_){var o_,__,p_=Gu._cfg.dbschema;o_=p_,__=t_,[].slice.call(__.db.objectStoreNames).forEach(function(V_){return o_[V_]==null&&__.db.deleteObjectStore(V_)}),ru(tu,[tu.Transaction.prototype]),Xo(tu,[tu.Transaction.prototype],tu._storeNames,tu._dbSchema),hu.schema=tu._dbSchema}),Au.push(function(t_){tu.idbdb.objectStoreNames.contains("$meta")&&(Math.ceil(tu.idbdb.version/10)===Gu._cfg.version?(tu.idbdb.deleteObjectStore("$meta"),delete tu._dbSchema.$meta,tu._storeNames=tu._storeNames.filter(function(o_){return o_!=="$meta"})):t_.objectStore("$meta").put(Gu._cfg.version,"version"))})}),function Gu(){return Au.length?Xs.resolve(Au.shift()(hu.idbtrans)).then(Gu):Xs.resolve()}().then(function(){p0(bu,yu)})):Xs.resolve();var tu,Ou,hu,yu,Au,bu}).catch(qo)):(d(Zr).forEach(function(Su){Qy(zt,Su,Zr[Su].primKey,Zr[Su].indexes)}),Xr(lt,zt),void Xs.follow(function(){return lt.on.populate.fire(vo)}).catch(qo));var fu,uu})}function n_(lt,wt){p0(lt._dbSchema,wt),wt.db.version%10!=0||wt.objectStoreNames.contains("$meta")||wt.db.createObjectStore("$meta").add(Math.ceil(wt.db.version/10-1),"version");var zt=v0(0,lt.idbdb,wt);B0(lt,lt._dbSchema,wt);for(var Dr=0,Zr=oy(zt,lt._dbSchema).change;Dr<Zr.length;Dr++){var vo=function(qo){if(qo.change.length||qo.recreate)return console.warn("Unable to patch indexes of table ".concat(qo.name," because it has changes on the type of index or primary key.")),{value:void 0};var ga=wt.objectStore(qo.name);qo.add.forEach(function(fu){rn&&console.debug("Dexie upgrade patch: Creating missing index ".concat(qo.name,".").concat(fu.src)),y0(ga,fu)})}(Zr[Dr]);if(typeof vo=="object")return vo.value}}function oy(lt,wt){var zt,Dr={del:[],add:[],change:[]};for(zt in lt)wt[zt]||Dr.del.push(zt);for(zt in wt){var Zr=lt[zt],vo=wt[zt];if(Zr){var qo={name:zt,def:vo,recreate:!1,del:[],add:[],change:[]};if(""+(Zr.primKey.keyPath||"")!=""+(vo.primKey.keyPath||"")||Zr.primKey.auto!==vo.primKey.auto)qo.recreate=!0,Dr.change.push(qo);else{var ga=Zr.idxByName,fu=vo.idxByName,uu=void 0;for(uu in ga)fu[uu]||qo.del.push(uu);for(uu in fu){var Su=ga[uu],tu=fu[uu];Su?Su.src!==tu.src&&qo.change.push(tu):qo.add.push(tu)}(0<qo.del.length||0<qo.add.length||0<qo.change.length)&&Dr.change.push(qo)}}else Dr.add.push([zt,vo])}return Dr}function Qy(lt,wt,zt,Dr){var Zr=lt.db.createObjectStore(wt,zt.keyPath?{keyPath:zt.keyPath,autoIncrement:zt.auto}:{autoIncrement:zt.auto});return Dr.forEach(function(vo){return y0(Zr,vo)}),Zr}function p0(lt,wt){d(lt).forEach(function(zt){wt.db.objectStoreNames.contains(zt)||(rn&&console.debug("Dexie: Creating missing table",zt),Qy(wt,zt,lt[zt].primKey,lt[zt].indexes))})}function y0(lt,wt){lt.createIndex(wt.name,wt.keyPath,{unique:wt.unique,multiEntry:wt.multi})}function v0(lt,wt,zt){var Dr={};return xt(wt.objectStoreNames,0).forEach(function(Zr){for(var vo=zt.objectStore(Zr),qo=jy(zy(uu=vo.keyPath),uu||"",!0,!1,!!vo.autoIncrement,uu&&typeof uu!="string",!0),ga=[],fu=0;fu<vo.indexNames.length;++fu){var Su=vo.index(vo.indexNames[fu]),uu=Su.keyPath,Su=jy(Su.name,uu,!!Su.unique,!!Su.multiEntry,!1,uu&&typeof uu!="string",!1);ga.push(Su)}Dr[Zr]=U_(Zr,qo,ga)}),Dr}function B0(lt,wt,zt){for(var Dr=zt.db.objectStoreNames,Zr=0;Zr<Dr.length;++Zr){var vo=Dr[Zr],qo=zt.objectStore(vo);lt._hasGetAll="getAll"in qo;for(var ga=0;ga<qo.indexNames.length;++ga){var fu=qo.indexNames[ga],uu=qo.index(fu).keyPath,Su=typeof uu=="string"?uu:"["+xt(uu).join("+")+"]";!wt[vo]||(uu=wt[vo].idxByName[Su])&&(uu.name=fu,delete wt[vo].idxByName[Su],wt[vo].idxByName[fu]=uu)}}typeof navigator<"u"&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&a.WorkerGlobalScope&&a instanceof a.WorkerGlobalScope&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604&&(lt._hasGetAll=!1)}function e1(lt){return lt.split(",").map(function(wt,zt){var Dr=(wt=wt.trim()).replace(/([&*]|\+\+)/g,""),Zr=/^\[/.test(Dr)?Dr.match(/^\[(.*)\]$/)[1].split("+"):Dr;return jy(Dr,Zr||null,/\&/.test(wt),/\*/.test(wt),/\+\+/.test(wt),et(Zr),zt===0)})}var h_=($y.prototype._parseStoresSpec=function(lt,wt){d(lt).forEach(function(zt){if(lt[zt]!==null){var Dr=e1(lt[zt]),Zr=Dr.shift();if(Zr.unique=!0,Zr.multi)throw new na.Schema("Primary key cannot be multi-valued");Dr.forEach(function(vo){if(vo.auto)throw new na.Schema("Only primary key can be marked as autoIncrement (++)");if(!vo.keyPath)throw new na.Schema("Index must have a name and cannot be an empty string")}),wt[zt]=U_(zt,Zr,Dr)}})},$y.prototype.stores=function(zt){var wt=this.db;this._cfg.storesSource=this._cfg.storesSource?$(this._cfg.storesSource,zt):zt;var zt=wt._versions,Dr={},Zr={};return zt.forEach(function(vo){$(Dr,vo._cfg.storesSource),Zr=vo._cfg.dbschema={},vo._parseStoresSpec(Dr,Zr)}),wt._dbSchema=Zr,ru(wt,[wt._allTables,wt,wt.Transaction.prototype]),Xo(wt,[wt._allTables,wt,wt.Transaction.prototype,this._cfg.tables],d(Zr),Zr),wt._storeNames=d(Zr),this},$y.prototype.upgrade=function(lt){return this._cfg.contentUpgrade=Lr(this._cfg.contentUpgrade||Cu,lt),this},$y);function $y(){}function c0(lt,wt){var zt=lt._dbNamesDB;return zt||(zt=lt._dbNamesDB=new mw(F0,{addons:[],indexedDB:lt,IDBKeyRange:wt})).version(1).stores({dbnames:"name"}),zt.table("dbnames")}function iw(lt){return lt&&typeof lt.databases=="function"}function Iw(lt){return hy(function(){return O_.letThrough=!0,lt()})}function _1(lt){return!("from"in lt)}var j0=function(lt,wt){if(!this){var zt=new j0;return lt&&"d"in lt&&$(zt,lt),zt}$(this,arguments.length?{d:1,from:lt,to:1<arguments.length?wt:lt}:{d:0})};function Dw(lt,wt,zt){var Dr=by(wt,zt);if(!isNaN(Dr)){if(0<Dr)throw RangeError();if(_1(lt))return $(lt,{from:wt,to:zt,d:1});var Zr=lt.l,Dr=lt.r;if(by(zt,lt.from)<0)return Zr?Dw(Zr,wt,zt):lt.l={from:wt,to:zt,d:1,l:null,r:null},P1(lt);if(0<by(wt,lt.to))return Dr?Dw(Dr,wt,zt):lt.r={from:wt,to:zt,d:1,l:null,r:null},P1(lt);by(wt,lt.from)<0&&(lt.from=wt,lt.l=null,lt.d=Dr?Dr.d+1:1),0<by(zt,lt.to)&&(lt.to=zt,lt.r=null,lt.d=lt.l?lt.l.d+1:1),zt=!lt.r,Zr&&!lt.l&&Nw(lt,Zr),Dr&&zt&&Nw(lt,Dr)}}function Nw(lt,wt){_1(wt)||function zt(Dr,fu){var vo=fu.from,qo=fu.to,ga=fu.l,fu=fu.r;Dw(Dr,vo,qo),ga&&zt(Dr,ga),fu&&zt(Dr,fu)}(lt,wt)}function M1(lt,wt){var zt=Uw(wt),Dr=zt.next();if(Dr.done)return!1;for(var Zr=Dr.value,vo=Uw(lt),qo=vo.next(Zr.from),ga=qo.value;!Dr.done&&!qo.done;){if(by(ga.from,Zr.to)<=0&&0<=by(ga.to,Zr.from))return!0;by(Zr.from,ga.from)<0?Zr=(Dr=zt.next(ga.from)).value:ga=(qo=vo.next(Zr.from)).value}return!1}function Uw(lt){var wt=_1(lt)?null:{s:0,n:lt};return{next:function(zt){for(var Dr=0<arguments.length;wt;)switch(wt.s){case 0:if(wt.s=1,Dr)for(;wt.n.l&&by(zt,wt.n.from)<0;)wt={up:wt,n:wt.n.l,s:1};else for(;wt.n.l;)wt={up:wt,n:wt.n.l,s:1};case 1:if(wt.s=2,!Dr||by(zt,wt.n.to)<=0)return{value:wt.n,done:!1};case 2:if(wt.n.r){wt.s=3,wt={up:wt,n:wt.n.r,s:0};continue}case 3:wt=wt.up}return{done:!0}}}}function P1(lt){var wt,zt,Dr=(((wt=lt.r)===null||wt===void 0?void 0:wt.d)||0)-(((zt=lt.l)===null||zt===void 0?void 0:zt.d)||0),Zr=1<Dr?"r":Dr<-1?"l":"";Zr&&(wt=Zr=="r"?"l":"r",zt=s({},lt),Dr=lt[Zr],lt.from=Dr.from,lt.to=Dr.to,lt[Zr]=Dr[Zr],zt[Zr]=Dr[wt],(lt[wt]=zt).d=sw(zt)),lt.d=sw(lt)}function sw(zt){var wt=zt.r,zt=zt.l;return(wt?zt?Math.max(wt.d,zt.d):wt.d:zt?zt.d:0)+1}function Ww(lt,wt){return d(wt).forEach(function(zt){lt[zt]?Nw(lt[zt],wt[zt]):lt[zt]=function Dr(Zr){var vo,qo,ga={};for(vo in Zr)g(Zr,vo)&&(qo=Zr[vo],ga[vo]=!qo||typeof qo!="object"||Js.has(qo.constructor)?qo:Dr(qo));return ga}(wt[zt])}),lt}function m1(lt,wt){return lt.all||wt.all||Object.keys(lt).some(function(zt){return wt[zt]&&M1(wt[zt],lt[zt])})}nt(j0.prototype,((Z0={add:function(lt){return Nw(this,lt),this},addKey:function(lt){return Dw(this,lt,lt),this},addKeys:function(lt){var wt=this;return lt.forEach(function(zt){return Dw(wt,zt,zt)}),this},hasKey:function(lt){var wt=Uw(this).next(lt).value;return wt&&by(wt.from,lt)<=0&&0<=by(wt.to,lt)}})[Bu]=function(){return Uw(this)},Z0));var Mw={},t1={},g1=!1;function r1(lt){Ww(t1,lt),g1||(g1=!0,setTimeout(function(){g1=!1,n1(t1,!(t1={}))},0))}function n1(lt,wt){wt===void 0&&(wt=!1);var zt=new Set;if(lt.all)for(var Dr=0,Zr=Object.values(Mw);Dr<Zr.length;Dr++)k1(qo=Zr[Dr],lt,zt,wt);else for(var vo in lt){var qo,ga=/^idb\:\/\/(.*)\/(.*)\//.exec(vo);ga&&(vo=ga[1],ga=ga[2],(qo=Mw["idb://".concat(vo,"/").concat(ga)])&&k1(qo,lt,zt,wt))}zt.forEach(function(fu){return fu()})}function k1(lt,wt,zt,Dr){for(var Zr=[],vo=0,qo=Object.entries(lt.queries.query);vo<qo.length;vo++){for(var ga=qo[vo],fu=ga[0],uu=[],Su=0,tu=ga[1];Su<tu.length;Su++){var Ou=tu[Su];m1(wt,Ou.obsSet)?Ou.subscribers.forEach(function(bu){return zt.add(bu)}):Dr&&uu.push(Ou)}Dr&&Zr.push([fu,uu])}if(Dr)for(var hu=0,yu=Zr;hu<yu.length;hu++){var Au=yu[hu],fu=Au[0],uu=Au[1];lt.queries.query[fu]=uu}}function Q1(lt){var wt=lt._state,zt=lt._deps.indexedDB;if(wt.isBeingOpened||lt.idbdb)return wt.dbReadyPromise.then(function(){return wt.dbOpenError?i0(wt.dbOpenError):lt});wt.isBeingOpened=!0,wt.dbOpenError=null,wt.openComplete=!1;var Dr=wt.openCanceller,Zr=Math.round(10*lt.verno),vo=!1;function qo(){if(wt.openCanceller!==Dr)throw new na.DatabaseClosed("db.open() was cancelled")}function ga(){return new Xs(function(Ou,hu){if(qo(),!zt)throw new na.MissingAPI;var yu=lt.name,Au=wt.autoSchema||!Zr?zt.open(yu):zt.open(yu,Zr);if(!Au)throw new na.MissingAPI;Au.onerror=g0(hu),Au.onblocked=j_(lt._fireOnBlocked),Au.onupgradeneeded=j_(function(bu){var Gu;Su=Au.transaction,wt.autoSchema&&!lt._options.allowEmptyDB?(Au.onerror=Iy,Su.abort(),Au.result.close(),(Gu=zt.deleteDatabase(yu)).onsuccess=Gu.onerror=j_(function(){hu(new na.NoSuchDatabase("Database ".concat(yu," doesnt exist")))})):(Su.onerror=g0(hu),bu=bu.oldVersion>Math.pow(2,62)?0:bu.oldVersion,tu=bu<1,lt.idbdb=Au.result,vo&&n_(lt,Su),Nu(lt,bu/10,Su,hu))},hu),Au.onsuccess=j_(function(){Su=null;var bu,Gu,t_,o_,__,p_=lt.idbdb=Au.result,V_=xt(p_.objectStoreNames);if(0<V_.length)try{var I_=p_.transaction((o_=V_).length===1?o_[0]:o_,"readonly");if(wt.autoSchema)Gu=p_,t_=I_,(bu=lt).verno=Gu.version/10,t_=bu._dbSchema=v0(0,Gu,t_),bu._storeNames=xt(Gu.objectStoreNames,0),Xo(bu,[bu._allTables],d(t_),t_);else if(B0(lt,lt._dbSchema,I_),((__=oy(v0(0,(__=lt).idbdb,I_),__._dbSchema)).add.length||__.change.some(function(W_){return W_.add.length||W_.change.length}))&&!vo)return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."),p_.close(),Zr=p_.version+1,vo=!0,Ou(ga());Xr(lt,I_)}catch{}P0.push(lt),p_.onversionchange=j_(function(W_){wt.vcFired=!0,lt.on("versionchange").fire(W_)}),p_.onclose=j_(function(W_){lt.on("close").fire(W_)}),tu&&(__=lt._deps,I_=yu,p_=__.indexedDB,__=__.IDBKeyRange,iw(p_)||I_===F0||c0(p_,__).put({name:I_}).catch(Cu)),Ou()},hu)}).catch(function(Ou){switch(Ou?.name){case"UnknownError":if(0<wt.PR1398_maxLoop)return wt.PR1398_maxLoop--,console.warn("Dexie: Workaround for Chrome UnknownError on open()"),ga();break;case"VersionError":if(0<Zr)return Zr=0,ga()}return Xs.reject(Ou)})}var fu,uu=wt.dbReadyResolve,Su=null,tu=!1;return Xs.race([Dr,(typeof navigator>"u"?Xs.resolve():!navigator.userAgentData&&/Safari\//.test(navigator.userAgent)&&!/Chrom(e|ium)\//.test(navigator.userAgent)&&indexedDB.databases?new Promise(function(Ou){function hu(){return indexedDB.databases().finally(Ou)}fu=setInterval(hu,100),hu()}).finally(function(){return clearInterval(fu)}):Promise.resolve()).then(ga)]).then(function(){return qo(),wt.onReadyBeingFired=[],Xs.resolve(Iw(function(){return lt.on.ready.fire(lt.vip)})).then(function Ou(){if(0<wt.onReadyBeingFired.length){var hu=wt.onReadyBeingFired.reduce(Lr,Cu);return wt.onReadyBeingFired=[],Xs.resolve(Iw(function(){return hu(lt.vip)})).then(Ou)}})}).finally(function(){wt.openCanceller===Dr&&(wt.onReadyBeingFired=null,wt.isBeingOpened=!1)}).catch(function(Ou){wt.dbOpenError=Ou;try{Su&&Su.abort()}catch{}return Dr===wt.openCanceller&&lt._close(),i0(Ou)}).finally(function(){wt.openComplete=!0,uu()}).then(function(){var Ou;return tu&&(Ou={},lt.tables.forEach(function(hu){hu.schema.indexes.forEach(function(yu){yu.name&&(Ou["idb://".concat(lt.name,"/").concat(hu.name,"/").concat(yu.name)]=new j0(-1/0,[[[]]]))}),Ou["idb://".concat(lt.name,"/").concat(hu.name,"/")]=Ou["idb://".concat(lt.name,"/").concat(hu.name,"/:dels")]=new j0(-1/0,[[[]]])}),J_(_0).fire(Ou),n1(Ou,!0)),lt})}function o1(lt){function wt(vo){return lt.next(vo)}var zt=Zr(wt),Dr=Zr(function(vo){return lt.throw(vo)});function Zr(vo){return function(fu){var ga=vo(fu),fu=ga.value;return ga.done?fu:fu&&typeof fu.then=="function"?fu.then(zt,Dr):et(fu)?Promise.all(fu).then(zt,Dr):zt(fu)}}return Zr(wt)()}function y1(lt,wt,zt){for(var Dr=et(lt)?lt.slice():[lt],Zr=0;Zr<zt;++Zr)Dr.push(wt);return Dr}var cw={stack:"dbcore",name:"VirtualIndexMiddleware",level:1,create:function(lt){return s(s({},lt),{table:function(wt){var zt=lt.table(wt),Dr=zt.schema,Zr={},vo=[];function qo(tu,Ou,hu){var yu=X_(tu),Au=Zr[yu]=Zr[yu]||[],bu=tu==null?0:typeof tu=="string"?1:tu.length,Gu=0<Ou,Gu=s(s({},hu),{name:Gu?"".concat(yu,"(virtual-from:").concat(hu.name,")"):hu.name,lowLevelIndex:hu,isVirtual:Gu,keyTail:Ou,keyLength:bu,extractKey:Ky(tu),unique:!Gu&&hu.unique});return Au.push(Gu),Gu.isPrimaryKey||vo.push(Gu),1<bu&&qo(bu===2?tu[0]:tu.slice(0,bu-1),Ou+1,hu),Au.sort(function(t_,o_){return t_.keyTail-o_.keyTail}),Gu}wt=qo(Dr.primaryKey.keyPath,0,Dr.primaryKey),Zr[":id"]=[wt];for(var ga=0,fu=Dr.indexes;ga<fu.length;ga++){var uu=fu[ga];qo(uu.keyPath,0,uu)}function Su(tu){var Ou,hu=tu.query.index;return hu.isVirtual?s(s({},tu),{query:{index:hu.lowLevelIndex,range:(Ou=tu.query.range,hu=hu.keyTail,{type:Ou.type===1?2:Ou.type,lower:y1(Ou.lower,Ou.lowerOpen?lt.MAX_KEY:lt.MIN_KEY,hu),lowerOpen:!0,upper:y1(Ou.upper,Ou.upperOpen?lt.MIN_KEY:lt.MAX_KEY,hu),upperOpen:!0})}}):tu}return s(s({},zt),{schema:s(s({},Dr),{primaryKey:wt,indexes:vo,getIndexByKeyPath:function(tu){return(tu=Zr[X_(tu)])&&tu[0]}}),count:function(tu){return zt.count(Su(tu))},query:function(tu){return zt.query(Su(tu))},openCursor:function(tu){var Ou=tu.query.index,hu=Ou.keyTail,yu=Ou.isVirtual,Au=Ou.keyLength;return yu?zt.openCursor(Su(tu)).then(function(Gu){return Gu&&bu(Gu)}):zt.openCursor(tu);function bu(Gu){return Object.create(Gu,{continue:{value:function(t_){t_!=null?Gu.continue(y1(t_,tu.reverse?lt.MAX_KEY:lt.MIN_KEY,hu)):tu.unique?Gu.continue(Gu.key.slice(0,Au).concat(tu.reverse?lt.MIN_KEY:lt.MAX_KEY,hu)):Gu.continue()}},continuePrimaryKey:{value:function(t_,o_){Gu.continuePrimaryKey(y1(t_,lt.MAX_KEY,hu),o_)}},primaryKey:{get:function(){return Gu.primaryKey}},key:{get:function(){var t_=Gu.key;return Au===1?t_[0]:t_.slice(0,Au)}},value:{get:function(){return Gu.value}}})}}})}})}};function i1(lt,wt,zt,Dr){return zt=zt||{},Dr=Dr||"",d(lt).forEach(function(Zr){var vo,qo,ga;g(wt,Zr)?(vo=lt[Zr],qo=wt[Zr],typeof vo=="object"&&typeof qo=="object"&&vo&&qo?(ga=Yo(vo))!==Yo(qo)?zt[Dr+Zr]=wt[Zr]:ga==="Object"?i1(vo,qo,zt,Dr+Zr+"."):vo!==qo&&(zt[Dr+Zr]=wt[Zr]):vo!==qo&&(zt[Dr+Zr]=wt[Zr])):zt[Dr+Zr]=void 0}),d(wt).forEach(function(Zr){g(lt,Zr)||(zt[Dr+Zr]=wt[Zr])}),zt}function Vw(lt,wt){return wt.type==="delete"?wt.keys:wt.keys||wt.values.map(lt.extractKey)}var S1={stack:"dbcore",name:"HooksMiddleware",level:2,create:function(lt){return s(s({},lt),{table:function(wt){var zt=lt.table(wt),Dr=zt.schema.primaryKey;return s(s({},zt),{mutate:function(Zr){var vo=O_.trans,qo=vo.table(wt).hook,ga=qo.deleting,fu=qo.creating,uu=qo.updating;switch(Zr.type){case"add":if(fu.fire===Cu)break;return vo._promise("readwrite",function(){return Su(Zr)},!0);case"put":if(fu.fire===Cu&&uu.fire===Cu)break;return vo._promise("readwrite",function(){return Su(Zr)},!0);case"delete":if(ga.fire===Cu)break;return vo._promise("readwrite",function(){return Su(Zr)},!0);case"deleteRange":if(ga.fire===Cu)break;return vo._promise("readwrite",function(){return function tu(Ou,hu,yu){return zt.query({trans:Ou,values:!1,query:{index:Dr,range:hu},limit:yu}).then(function(Au){var bu=Au.result;return Su({type:"delete",keys:bu,trans:Ou}).then(function(Gu){return 0<Gu.numFailures?Promise.reject(Gu.failures[0]):bu.length<yu?{failures:[],numFailures:0,lastResult:void 0}:tu(Ou,s(s({},hu),{lower:bu[bu.length-1],lowerOpen:!0}),yu)})})}(Zr.trans,Zr.range,1e4)},!0)}return zt.mutate(Zr);function Su(tu){var Ou,hu,yu,Au=O_.trans,bu=tu.keys||Vw(Dr,tu);if(!bu)throw new Error("Keys missing");return(tu=tu.type==="add"||tu.type==="put"?s(s({},tu),{keys:bu}):s({},tu)).type!=="delete"&&(tu.values=h([],tu.values)),tu.keys&&(tu.keys=h([],tu.keys)),Ou=zt,yu=bu,((hu=tu).type==="add"?Promise.resolve([]):Ou.getMany({trans:hu.trans,keys:yu,cache:"immutable"})).then(function(Gu){var t_=bu.map(function(o_,__){var p_,V_,I_,W_=Gu[__],K_={onerror:null,onsuccess:null};return tu.type==="delete"?ga.fire.call(K_,o_,W_,Au):tu.type==="add"||W_===void 0?(p_=fu.fire.call(K_,o_,tu.values[__],Au),o_==null&&p_!=null&&(tu.keys[__]=o_=p_,Dr.outbound||vr(tu.values[__],Dr.keyPath,o_))):(p_=i1(W_,tu.values[__]),(V_=uu.fire.call(K_,p_,o_,W_,Au))&&(I_=tu.values[__],Object.keys(V_).forEach(function(A_){g(I_,A_)?I_[A_]=V_[A_]:vr(I_,A_,V_[A_])}))),K_});return zt.mutate(tu).then(function(o_){for(var __=o_.failures,p_=o_.results,V_=o_.numFailures,o_=o_.lastResult,I_=0;I_<bu.length;++I_){var W_=(p_||bu)[I_],K_=t_[I_];W_==null?K_.onerror&&K_.onerror(__[I_]):K_.onsuccess&&K_.onsuccess(tu.type==="put"&&Gu[I_]?tu.values[I_]:W_)}return{failures:__,results:p_,numFailures:V_,lastResult:o_}}).catch(function(o_){return t_.forEach(function(__){return __.onerror&&__.onerror(o_)}),Promise.reject(o_)})})}}})}})}};function Q0(lt,wt,zt){try{if(!wt||wt.keys.length<lt.length)return null;for(var Dr=[],Zr=0,vo=0;Zr<wt.keys.length&&vo<lt.length;++Zr)by(wt.keys[Zr],lt[vo])===0&&(Dr.push(zt?Wo(wt.values[Zr]):wt.values[Zr]),++vo);return Dr.length===lt.length?Dr:null}catch{return null}}var Z1={stack:"dbcore",level:-1,create:function(lt){return{table:function(wt){var zt=lt.table(wt);return s(s({},zt),{getMany:function(Dr){if(!Dr.cache)return zt.getMany(Dr);var Zr=Q0(Dr.keys,Dr.trans._cache,Dr.cache==="clone");return Zr?Xs.resolve(Zr):zt.getMany(Dr).then(function(vo){return Dr.trans._cache={keys:Dr.keys,values:Dr.cache==="clone"?Wo(vo):vo},vo})},mutate:function(Dr){return Dr.type!=="add"&&(Dr.trans._cache=null),zt.mutate(Dr)}})}}}};function O1(lt,wt){return lt.trans.mode==="readonly"&&!!lt.subscr&&!lt.trans.explicit&&lt.trans.db._options.cache!=="disabled"&&!wt.schema.primaryKey.outbound}function b1(lt,wt){switch(lt){case"query":return wt.values&&!wt.unique;case"get":case"getMany":case"count":case"openCursor":return!1}}var J1={stack:"dbcore",level:0,name:"Observability",create:function(lt){var wt=lt.schema.name,zt=new j0(lt.MIN_KEY,lt.MAX_KEY);return s(s({},lt),{transaction:function(Dr,Zr,vo){if(O_.subscr&&Zr!=="readonly")throw new na.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(O_.querier));return lt.transaction(Dr,Zr,vo)},table:function(Dr){var Zr=lt.table(Dr),vo=Zr.schema,qo=vo.primaryKey,tu=vo.indexes,ga=qo.extractKey,fu=qo.outbound,uu=qo.autoIncrement&&tu.filter(function(hu){return hu.compound&&hu.keyPath.includes(qo.keyPath)}),Su=s(s({},Zr),{mutate:function(hu){function yu(A_){return A_="idb://".concat(wt,"/").concat(Dr,"/").concat(A_),o_[A_]||(o_[A_]=new j0)}var Au,bu,Gu,t_=hu.trans,o_=hu.mutatedParts||(hu.mutatedParts={}),__=yu(""),p_=yu(":dels"),V_=hu.type,K_=hu.type==="deleteRange"?[hu.range]:hu.type==="delete"?[hu.keys]:hu.values.length<50?[Vw(qo,hu).filter(function(A_){return A_}),hu.values]:[],I_=K_[0],W_=K_[1],K_=hu.trans._cache;return et(I_)?(__.addKeys(I_),(K_=V_==="delete"||I_.length===W_.length?Q0(I_,K_):null)||p_.addKeys(I_),(K_||W_)&&(Au=yu,bu=K_,Gu=W_,vo.indexes.forEach(function(A_){var my=Au(A_.name||"");function vy(Fy){return Fy!=null?A_.extractKey(Fy):null}function Dy(Fy){return A_.multiEntry&&et(Fy)?Fy.forEach(function(aw){return my.addKey(aw)}):my.addKey(Fy)}(bu||Gu).forEach(function(Fy,C0){var Oy=bu&&vy(bu[C0]),C0=Gu&&vy(Gu[C0]);by(Oy,C0)!==0&&(Oy!=null&&Dy(Oy),C0!=null&&Dy(C0))})}))):I_?(W_={from:I_.lower,to:I_.upper},p_.add(W_),__.add(W_)):(__.add(zt),p_.add(zt),vo.indexes.forEach(function(A_){return yu(A_.name).add(zt)})),Zr.mutate(hu).then(function(A_){return!I_||hu.type!=="add"&&hu.type!=="put"||(__.addKeys(A_.results),uu&&uu.forEach(function(my){var vy=hu.values.map(function(Fy){return my.extractKey(Fy)}),Dy=my.keyPath.findIndex(function(Fy){return Fy===qo.keyPath});A_.results.forEach(function(Fy){return vy[Dy]=Fy}),yu(my.name).addKeys(vy)})),t_.mutatedParts=Ww(t_.mutatedParts||{},o_),A_})}}),tu=function(yu){var Au=yu.query,yu=Au.index,Au=Au.range;return[yu,new j0((yu=Au.lower)!==null&&yu!==void 0?yu:lt.MIN_KEY,(Au=Au.upper)!==null&&Au!==void 0?Au:lt.MAX_KEY)]},Ou={get:function(hu){return[qo,new j0(hu.key)]},getMany:function(hu){return[qo,new j0().addKeys(hu.keys)]},count:tu,query:tu,openCursor:tu};return d(Ou).forEach(function(hu){Su[hu]=function(yu){var Au=O_.subscr,bu=!!Au,Gu=O1(O_,Zr)&&b1(hu,yu)?yu.obsSet={}:Au;if(bu){var t_=function(W_){return W_="idb://".concat(wt,"/").concat(Dr,"/").concat(W_),Gu[W_]||(Gu[W_]=new j0)},o_=t_(""),__=t_(":dels"),Au=Ou[hu](yu),bu=Au[0],Au=Au[1];if((hu==="query"&&bu.isPrimaryKey&&!yu.values?__:t_(bu.name||"")).add(Au),!bu.isPrimaryKey){if(hu!=="count"){var p_=hu==="query"&&fu&&yu.values&&Zr.query(s(s({},yu),{values:!1}));return Zr[hu].apply(this,arguments).then(function(W_){if(hu==="query"){if(fu&&yu.values)return p_.then(function(vy){return vy=vy.result,o_.addKeys(vy),W_});var K_=yu.values?W_.result.map(ga):W_.result;(yu.values?o_:__).addKeys(K_)}else if(hu==="openCursor"){var A_=W_,my=yu.values;return A_&&Object.create(A_,{key:{get:function(){return __.addKey(A_.primaryKey),A_.key}},primaryKey:{get:function(){var vy=A_.primaryKey;return __.addKey(vy),vy}},value:{get:function(){return my&&o_.addKey(A_.primaryKey),A_.value}}})}return W_})}__.add(zt)}}return Zr[hu].apply(this,arguments)}}),Su}})}};function A1(lt,wt,zt){if(zt.numFailures===0)return wt;if(wt.type==="deleteRange")return null;var Dr=wt.keys?wt.keys.length:"values"in wt&&wt.values?wt.values.length:1;return zt.numFailures===Dr?null:(wt=s({},wt),et(wt.keys)&&(wt.keys=wt.keys.filter(function(Zr,vo){return!(vo in zt.failures)})),"values"in wt&&et(wt.values)&&(wt.values=wt.values.filter(function(Zr,vo){return!(vo in zt.failures)})),wt)}function s1(lt,wt){return zt=lt,((Dr=wt).lower===void 0||(Dr.lowerOpen?0<by(zt,Dr.lower):0<=by(zt,Dr.lower)))&&(lt=lt,(wt=wt).upper===void 0||(wt.upperOpen?by(lt,wt.upper)<0:by(lt,wt.upper)<=0));var zt,Dr}function C1(lt,wt,Ou,Dr,Zr,vo){if(!Ou||Ou.length===0)return lt;var qo=wt.query.index,ga=qo.multiEntry,fu=wt.query.range,uu=Dr.schema.primaryKey.extractKey,Su=qo.extractKey,tu=(qo.lowLevelIndex||qo).extractKey,Ou=Ou.reduce(function(hu,yu){var Au=hu,bu=[];if(yu.type==="add"||yu.type==="put")for(var Gu=new j0,t_=yu.values.length-1;0<=t_;--t_){var o_,__=yu.values[t_],p_=uu(__);Gu.hasKey(p_)||(o_=Su(__),(ga&&et(o_)?o_.some(function(K_){return s1(K_,fu)}):s1(o_,fu))&&(Gu.addKey(p_),bu.push(__)))}switch(yu.type){case"add":Au=hu.concat(wt.values?bu:bu.map(function(A_){return uu(A_)}));break;case"put":var V_=new j0().addKeys(yu.values.map(function(A_){return uu(A_)})),Au=hu.filter(function(A_){return!V_.hasKey(wt.values?uu(A_):A_)}).concat(wt.values?bu:bu.map(function(A_){return uu(A_)}));break;case"delete":var I_=new j0().addKeys(yu.keys);Au=hu.filter(function(A_){return!I_.hasKey(wt.values?uu(A_):A_)});break;case"deleteRange":var W_=yu.range;Au=hu.filter(function(A_){return!s1(uu(A_),W_)})}return Au},lt);return Ou===lt?lt:(Ou.sort(function(hu,yu){return by(tu(hu),tu(yu))||by(uu(hu),uu(yu))}),wt.limit&&wt.limit<1/0&&(Ou.length>wt.limit?Ou.length=wt.limit:lt.length===wt.limit&&Ou.length<wt.limit&&(Zr.dirty=!0)),vo?Object.freeze(Ou):Ou)}function I1(lt,wt){return by(lt.lower,wt.lower)===0&&by(lt.upper,wt.upper)===0&&!!lt.lowerOpen==!!wt.lowerOpen&&!!lt.upperOpen==!!wt.upperOpen}function D1(lt,wt){return function(zt,Dr,Zr,vo){if(zt===void 0)return Dr!==void 0?-1:0;if(Dr===void 0)return 1;if((Dr=by(zt,Dr))===0){if(Zr&&vo)return 0;if(Zr)return 1;if(vo)return-1}return Dr}(lt.lower,wt.lower,lt.lowerOpen,wt.lowerOpen)<=0&&0<=function(zt,Dr,Zr,vo){if(zt===void 0)return Dr!==void 0?1:0;if(Dr===void 0)return-1;if((Dr=by(zt,Dr))===0){if(Zr&&vo)return 0;if(Zr)return-1;if(vo)return 1}return Dr}(lt.upper,wt.upper,lt.upperOpen,wt.upperOpen)}function ev(lt,wt,zt,Dr){lt.subscribers.add(zt),Dr.addEventListener("abort",function(){var Zr,vo;lt.subscribers.delete(zt),lt.subscribers.size===0&&(Zr=lt,vo=wt,setTimeout(function(){Zr.subscribers.size===0&&tn(vo,Zr)},3e3))})}var dw={stack:"dbcore",level:0,name:"Cache",create:function(lt){var wt=lt.schema.name;return s(s({},lt),{transaction:function(zt,Dr,Zr){var vo,qo,ga=lt.transaction(zt,Dr,Zr);return Dr==="readwrite"&&(qo=(vo=new AbortController).signal,Zr=function(fu){return function(){if(vo.abort(),Dr==="readwrite"){for(var uu=new Set,Su=0,tu=zt;Su<tu.length;Su++){var Ou=tu[Su],hu=Mw["idb://".concat(wt,"/").concat(Ou)];if(hu){var yu=lt.table(Ou),Au=hu.optimisticOps.filter(function(my){return my.trans===ga});if(ga._explicit&&fu&&ga.mutatedParts)for(var bu=0,Gu=Object.values(hu.queries.query);bu<Gu.length;bu++)for(var t_=0,o_=(V_=Gu[bu]).slice();t_<o_.length;t_++)m1((I_=o_[t_]).obsSet,ga.mutatedParts)&&(tn(V_,I_),I_.subscribers.forEach(function(my){return uu.add(my)}));else if(0<Au.length){hu.optimisticOps=hu.optimisticOps.filter(function(my){return my.trans!==ga});for(var __=0,p_=Object.values(hu.queries.query);__<p_.length;__++)for(var V_,I_,W_,K_=0,A_=(V_=p_[__]).slice();K_<A_.length;K_++)(I_=A_[K_]).res!=null&&ga.mutatedParts&&(fu&&!I_.dirty?(W_=Object.isFrozen(I_.res),W_=C1(I_.res,I_.req,Au,yu,I_,W_),I_.dirty?(tn(V_,I_),I_.subscribers.forEach(function(my){return uu.add(my)})):W_!==I_.res&&(I_.res=W_,I_.promise=Xs.resolve({result:W_}))):(I_.dirty&&tn(V_,I_),I_.subscribers.forEach(function(my){return uu.add(my)})))}}}uu.forEach(function(my){return my()})}}},ga.addEventListener("abort",Zr(!1),{signal:qo}),ga.addEventListener("error",Zr(!1),{signal:qo}),ga.addEventListener("complete",Zr(!0),{signal:qo})),ga},table:function(zt){var Dr=lt.table(zt),Zr=Dr.schema.primaryKey;return s(s({},Dr),{mutate:function(vo){var qo=O_.trans;if(Zr.outbound||qo.db._options.cache==="disabled"||qo.explicit)return Dr.mutate(vo);var ga=Mw["idb://".concat(wt,"/").concat(zt)];return ga?(qo=Dr.mutate(vo),vo.type!=="add"&&vo.type!=="put"||!(50<=vo.values.length||Vw(Zr,vo).some(function(fu){return fu==null}))?(ga.optimisticOps.push(vo),vo.mutatedParts&&r1(vo.mutatedParts),qo.then(function(fu){0<fu.numFailures&&(tn(ga.optimisticOps,vo),(fu=A1(0,vo,fu))&&ga.optimisticOps.push(fu),vo.mutatedParts&&r1(vo.mutatedParts))}),qo.catch(function(){tn(ga.optimisticOps,vo),vo.mutatedParts&&r1(vo.mutatedParts)})):qo.then(function(fu){var uu=A1(0,s(s({},vo),{values:vo.values.map(function(hu,tu){var Ou,hu=(Ou=Zr.keyPath)!==null&&Ou!==void 0&&Ou.includes(".")?Wo(hu):s({},hu);return vr(hu,Zr.keyPath,fu.results[tu]),hu})}),fu);ga.optimisticOps.push(uu),queueMicrotask(function(){return vo.mutatedParts&&r1(vo.mutatedParts)})}),qo):Dr.mutate(vo)},query:function(vo){if(!O1(O_,Dr)||!b1("query",vo))return Dr.query(vo);var qo=((uu=O_.trans)===null||uu===void 0?void 0:uu.db._options.cache)==="immutable",tu=O_,ga=tu.requery,fu=tu.signal,uu=function(yu,Au,bu,Gu){var t_=Mw["idb://".concat(yu,"/").concat(Au)];if(!t_)return[];if(!(Au=t_.queries[bu]))return[null,!1,t_,null];var o_=Au[(Gu.query?Gu.query.index.name:null)||""];if(!o_)return[null,!1,t_,null];switch(bu){case"query":var __=o_.find(function(p_){return p_.req.limit===Gu.limit&&p_.req.values===Gu.values&&I1(p_.req.query.range,Gu.query.range)});return __?[__,!0,t_,o_]:[o_.find(function(p_){return("limit"in p_.req?p_.req.limit:1/0)>=Gu.limit&&(!Gu.values||p_.req.values)&&D1(p_.req.query.range,Gu.query.range)}),!1,t_,o_];case"count":return __=o_.find(function(p_){return I1(p_.req.query.range,Gu.query.range)}),[__,!!__,t_,o_]}}(wt,zt,"query",vo),Su=uu[0],tu=uu[1],Ou=uu[2],hu=uu[3];return Su&&tu?Su.obsSet=vo.obsSet:(tu=Dr.query(vo).then(function(yu){var Au=yu.result;if(Su&&(Su.res=Au),qo){for(var bu=0,Gu=Au.length;bu<Gu;++bu)Object.freeze(Au[bu]);Object.freeze(Au)}else yu.result=Wo(Au);return yu}).catch(function(yu){return hu&&Su&&tn(hu,Su),Promise.reject(yu)}),Su={obsSet:vo.obsSet,promise:tu,subscribers:new Set,type:"query",req:vo,dirty:!1},hu?hu.push(Su):(hu=[Su],(Ou=Ou||(Mw["idb://".concat(wt,"/").concat(zt)]={queries:{query:{},count:{}},objs:new Map,optimisticOps:[],unsignaledParts:{}})).queries.query[vo.query.index.name||""]=hu)),ev(Su,hu,ga,fu),Su.promise.then(function(yu){return{result:C1(yu.result,vo,Ou?.optimisticOps,Dr,Su,qo)}})}})}})}};function Kw(lt,wt){return new Proxy(lt,{get:function(zt,Dr,Zr){return Dr==="db"?wt:Reflect.get(zt,Dr,Zr)}})}var mw=(m0.prototype.version=function(lt){if(isNaN(lt)||lt<.1)throw new na.Type("Given version is not a positive number");if(lt=Math.round(10*lt)/10,this.idbdb||this._state.isBeingOpened)throw new na.Schema("Cannot add version when database is open");this.verno=Math.max(this.verno,lt);var wt=this._versions,zt=wt.filter(function(Dr){return Dr._cfg.version===lt})[0];return zt||(zt=new this.Version(lt),wt.push(zt),wt.sort(Pu),zt.stores({}),this._state.autoSchema=!1,zt)},m0.prototype._whenReady=function(lt){var wt=this;return this.idbdb&&(this._state.openComplete||O_.letThrough||this._vip)?lt():new Xs(function(zt,Dr){if(wt._state.openComplete)return Dr(new na.DatabaseClosed(wt._state.dbOpenError));if(!wt._state.isBeingOpened){if(!wt._state.autoOpen)return void Dr(new na.DatabaseClosed);wt.open().catch(Cu)}wt._state.dbReadyPromise.then(zt,Dr)}).then(lt)},m0.prototype.use=function(lt){var wt=lt.stack,zt=lt.create,Dr=lt.level,Zr=lt.name;return Zr&&this.unuse({stack:wt,name:Zr}),lt=this._middlewares[wt]||(this._middlewares[wt]=[]),lt.push({stack:wt,create:zt,level:Dr??10,name:Zr}),lt.sort(function(vo,qo){return vo.level-qo.level}),this},m0.prototype.unuse=function(lt){var wt=lt.stack,zt=lt.name,Dr=lt.create;return wt&&this._middlewares[wt]&&(this._middlewares[wt]=this._middlewares[wt].filter(function(Zr){return Dr?Zr.create!==Dr:!!zt&&Zr.name!==zt})),this},m0.prototype.open=function(){var lt=this;return N0(yy,function(){return Q1(lt)})},m0.prototype._close=function(){var lt=this._state,wt=P0.indexOf(this);if(0<=wt&&P0.splice(wt,1),this.idbdb){try{this.idbdb.close()}catch{}this.idbdb=null}lt.isBeingOpened||(lt.dbReadyPromise=new Xs(function(zt){lt.dbReadyResolve=zt}),lt.openCanceller=new Xs(function(zt,Dr){lt.cancelOpen=Dr}))},m0.prototype.close=function(zt){var wt=(zt===void 0?{disableAutoOpen:!0}:zt).disableAutoOpen,zt=this._state;wt?(zt.isBeingOpened&&zt.cancelOpen(new na.DatabaseClosed),this._close(),zt.autoOpen=!1,zt.dbOpenError=new na.DatabaseClosed):(this._close(),zt.autoOpen=this._options.autoOpen||zt.isBeingOpened,zt.openComplete=!1,zt.dbOpenError=null)},m0.prototype.delete=function(lt){var wt=this;lt===void 0&&(lt={disableAutoOpen:!0});var zt=0<arguments.length&&typeof arguments[0]!="object",Dr=this._state;return new Xs(function(Zr,vo){function qo(){wt.close(lt);var ga=wt._deps.indexedDB.deleteDatabase(wt.name);ga.onsuccess=j_(function(){var fu,uu,Su;fu=wt._deps,uu=wt.name,Su=fu.indexedDB,fu=fu.IDBKeyRange,iw(Su)||uu===F0||c0(Su,fu).delete(uu).catch(Cu),Zr()}),ga.onerror=g0(vo),ga.onblocked=wt._fireOnBlocked}if(zt)throw new na.InvalidArgument("Invalid closeOptions argument to db.delete()");Dr.isBeingOpened?Dr.dbReadyPromise.then(qo):qo()})},m0.prototype.backendDB=function(){return this.idbdb},m0.prototype.isOpen=function(){return this.idbdb!==null},m0.prototype.hasBeenClosed=function(){var lt=this._state.dbOpenError;return lt&&lt.name==="DatabaseClosed"},m0.prototype.hasFailed=function(){return this._state.dbOpenError!==null},m0.prototype.dynamicallyOpened=function(){return this._state.autoSchema},Object.defineProperty(m0.prototype,"tables",{get:function(){var lt=this;return d(this._allTables).map(function(wt){return lt._allTables[wt]})},enumerable:!1,configurable:!0}),m0.prototype.transaction=function(){var lt=function(wt,zt,Dr){var Zr=arguments.length;if(Zr<2)throw new na.InvalidArgument("Too few arguments");for(var vo=new Array(Zr-1);--Zr;)vo[Zr-1]=arguments[Zr];return Dr=vo.pop(),[wt,Do(vo),Dr]}.apply(this,arguments);return this._transaction.apply(this,lt)},m0.prototype._transaction=function(lt,wt,zt){var Dr=this,Zr=O_.trans;Zr&&Zr.db===this&&lt.indexOf("!")===-1||(Zr=null);var vo,qo,ga=lt.indexOf("?")!==-1;lt=lt.replace("!","").replace("?","");try{if(qo=wt.map(function(uu){if(uu=uu instanceof Dr.Table?uu.name:uu,typeof uu!="string")throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");return uu}),lt=="r"||lt===X0)vo=X0;else{if(lt!="rw"&&lt!=Y0)throw new na.InvalidArgument("Invalid transaction mode: "+lt);vo=Y0}if(Zr){if(Zr.mode===X0&&vo===Y0){if(!ga)throw new na.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");Zr=null}Zr&&qo.forEach(function(uu){if(Zr&&Zr.storeNames.indexOf(uu)===-1){if(!ga)throw new na.SubTransaction("Table "+uu+" not included in parent transaction.");Zr=null}}),ga&&Zr&&!Zr.active&&(Zr=null)}}catch(uu){return Zr?Zr._promise(null,function(Su,tu){tu(uu)}):i0(uu)}var fu=function uu(Su,tu,Ou,hu,yu){return Xs.resolve().then(function(){var Au=O_.transless||O_,bu=Su._createTransaction(tu,Ou,Su._dbSchema,hu);if(bu.explicit=!0,Au={trans:bu,transless:Au},hu)bu.idbtrans=hu.idbtrans;else try{bu.create(),bu.idbtrans._explicit=!0,Su._state.PR1398_maxLoop=3}catch(o_){return o_.name===r_.InvalidState&&Su.isOpen()&&0<--Su._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),Su.close({disableAutoOpen:!1}),Su.open().then(function(){return uu(Su,tu,Ou,null,yu)})):i0(o_)}var Gu,t_=Jr(yu);return t_&&Ay(),Au=Xs.follow(function(){var o_;(Gu=yu.call(bu,bu))&&(t_?(o_=Sy.bind(null,null),Gu.then(o_,o_)):typeof Gu.next=="function"&&typeof Gu.throw=="function"&&(Gu=o1(Gu)))},Au),(Gu&&typeof Gu.then=="function"?Xs.resolve(Gu).then(function(o_){return bu.active?o_:i0(new na.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))}):Au.then(function(){return Gu})).then(function(o_){return hu&&bu._resolve(),bu._completion.then(function(){return o_})}).catch(function(o_){return bu._reject(o_),i0(o_)})})}.bind(null,this,vo,qo,Zr,zt);return Zr?Zr._promise(vo,fu,"lock"):O_.trans?N0(O_.transless,function(){return Dr._whenReady(fu)}):this._whenReady(fu)},m0.prototype.table=function(lt){if(!g(this._allTables,lt))throw new na.InvalidTable("Table ".concat(lt," does not exist"));return this._allTables[lt]},m0);function m0(lt,wt){var zt=this;this._middlewares={},this.verno=0;var Dr=m0.dependencies;this._options=wt=s({addons:m0.addons,autoOpen:!0,indexedDB:Dr.indexedDB,IDBKeyRange:Dr.IDBKeyRange,cache:"cloned"},wt),this._deps={indexedDB:wt.indexedDB,IDBKeyRange:wt.IDBKeyRange},Dr=wt.addons,this._dbSchema={},this._versions=[],this._storeNames=[],this._allTables={},this.idbdb=null,this._novip=this;var Zr,vo,qo,ga,fu,uu={dbOpenError:null,isBeingOpened:!1,onReadyBeingFired:null,openComplete:!1,dbReadyResolve:Cu,dbReadyPromise:null,cancelOpen:Cu,openCanceller:null,autoSchema:!0,PR1398_maxLoop:3,autoOpen:wt.autoOpen};uu.dbReadyPromise=new Xs(function(tu){uu.dbReadyResolve=tu}),uu.openCanceller=new Xs(function(tu,Ou){uu.cancelOpen=Ou}),this._state=uu,this.name=lt,this.on=rw(this,"populate","blocked","versionchange","close",{ready:[Lr,Cu]}),this.on.ready.subscribe=Dt(this.on.ready.subscribe,function(tu){return function(Ou,hu){m0.vip(function(){var yu,Au=zt._state;Au.openComplete?(Au.dbOpenError||Xs.resolve().then(Ou),hu&&tu(Ou)):Au.onReadyBeingFired?(Au.onReadyBeingFired.push(Ou),hu&&tu(Ou)):(tu(Ou),yu=zt,hu||tu(function bu(){yu.on.ready.unsubscribe(Ou),yu.on.ready.unsubscribe(bu)}))})}}),this.Collection=(Zr=this,nw(D_.prototype,function(Gu,bu){this.db=Zr;var hu=_w,yu=null;if(bu)try{hu=bu()}catch(t_){yu=t_}var Au=Gu._ctx,bu=Au.table,Gu=bu.hook.reading.fire;this._ctx={table:bu,index:Au.index,isPrimKey:!Au.index||bu.schema.primKey.keyPath&&Au.index===bu.schema.primKey.name,range:hu,keysOnly:!1,dir:"next",unique:"",algorithm:null,filter:null,replayFilter:null,justLimit:!0,isMatch:null,offset:0,limit:1/0,error:yu,or:Au.or,valueMapper:Gu!==e_?Gu:null}})),this.Table=(vo=this,nw(yw.prototype,function(tu,Ou,hu){this.db=vo,this._tx=hu,this.name=tu,this.schema=Ou,this.hook=vo._allTables[tu]?vo._allTables[tu].hook:rw(null,{creating:[_a,Cu],reading:[ar,e_],updating:[Eo,Cu],deleting:[$o,Cu]})})),this.Transaction=(qo=this,nw(k0.prototype,function(tu,Ou,hu,yu,Au){var bu=this;this.db=qo,this.mode=tu,this.storeNames=Ou,this.schema=hu,this.chromeTransactionDurability=yu,this.idbtrans=null,this.on=rw(this,"complete","error","abort"),this.parent=Au||null,this.active=!0,this._reculock=0,this._blockedFuncs=[],this._resolve=null,this._reject=null,this._waitingFor=null,this._waitingQueue=null,this._spinCount=0,this._completion=new Xs(function(Gu,t_){bu._resolve=Gu,bu._reject=t_}),this._completion.then(function(){bu.active=!1,bu.on.complete.fire()},function(Gu){var t_=bu.active;return bu.active=!1,bu.on.error.fire(Gu),bu.parent?bu.parent._reject(Gu):t_&&bu.idbtrans&&bu.idbtrans.abort(),i0(Gu)})})),this.Version=(ga=this,nw(h_.prototype,function(tu){this.db=ga,this._cfg={version:tu,storesSource:null,dbschema:{},tables:{},contentUpgrade:null}})),this.WhereClause=(fu=this,nw(h0.prototype,function(tu,Ou,hu){if(this.db=fu,this._ctx={table:tu,index:Ou===":id"?null:Ou,or:hu},this._cmp=this._ascending=by,this._descending=function(yu,Au){return by(Au,yu)},this._max=function(yu,Au){return 0<by(yu,Au)?yu:Au},this._min=function(yu,Au){return by(yu,Au)<0?yu:Au},this._IDBKeyRange=fu._deps.IDBKeyRange,!this._IDBKeyRange)throw new na.MissingAPI})),this.on("versionchange",function(tu){0<tu.newVersion?console.warn("Another connection wants to upgrade database '".concat(zt.name,"'. Closing db now to resume the upgrade.")):console.warn("Another connection wants to delete database '".concat(zt.name,"'. Closing db now to resume the delete request.")),zt.close({disableAutoOpen:!1})}),this.on("blocked",function(tu){!tu.newVersion||tu.newVersion<tu.oldVersion?console.warn("Dexie.delete('".concat(zt.name,"') was blocked")):console.warn("Upgrade '".concat(zt.name,"' blocked by other connection holding version ").concat(tu.oldVersion/10))}),this._maxKey=_y(wt.IDBKeyRange),this._createTransaction=function(tu,Ou,hu,yu){return new zt.Transaction(tu,Ou,hu,zt._options.chromeTransactionDurability,yu)},this._fireOnBlocked=function(tu){zt.on("blocked").fire(tu),P0.filter(function(Ou){return Ou.name===zt.name&&Ou!==zt&&!Ou._state.vcFired}).map(function(Ou){return Ou.on("versionchange").fire(tu)})},this.use(Z1),this.use(dw),this.use(J1),this.use(cw),this.use(S1);var Su=new Proxy(this,{get:function(tu,Ou,hu){if(Ou==="_vip")return!0;if(Ou==="table")return function(Au){return Kw(zt.table(Au),Su)};var yu=Reflect.get(tu,Ou,hu);return yu instanceof yw?Kw(yu,Su):Ou==="tables"?yu.map(function(Au){return Kw(Au,Su)}):Ou==="_createTransaction"?function(){return Kw(yu.apply(this,arguments),Su)}:yu}});this.vip=Su,Dr.forEach(function(tu){return tu(zt)})}var Gw,Z0=typeof Symbol<"u"&&"observable"in Symbol?Symbol.observable:"@@observable",tv=(a1.prototype.subscribe=function(lt,wt,zt){return this._subscribe(lt&&typeof lt!="function"?lt:{next:lt,error:wt,complete:zt})},a1.prototype[Z0]=function(){return this},a1);function a1(lt){this._subscribe=lt}try{Gw={indexedDB:a.indexedDB||a.mozIndexedDB||a.webkitIndexedDB||a.msIndexedDB,IDBKeyRange:a.IDBKeyRange||a.webkitIDBKeyRange}}catch{Gw={indexedDB:null,IDBKeyRange:null}}function F1(lt){var wt,zt=!1,Dr=new tv(function(Zr){var vo=Jr(lt),qo,ga=!1,fu={},uu={},Su={get closed(){return ga},unsubscribe:function(){ga||(ga=!0,qo&&qo.abort(),tu&&J_.storagemutated.unsubscribe(hu))}};Zr.start&&Zr.start(Su);var tu=!1,Ou=function(){return uw(yu)},hu=function(Au){Ww(fu,Au),m1(uu,fu)&&Ou()},yu=function(){var Au,bu,Gu;!ga&&Gw.indexedDB&&(fu={},Au={},qo&&qo.abort(),qo=new AbortController,Gu=function(t_){var o_=P_();try{vo&&Ay();var __=hy(lt,t_);return __=vo?__.finally(Sy):__}finally{o_&&N_()}}(bu={subscr:Au,signal:qo.signal,requery:Ou,querier:lt,trans:null}),Promise.resolve(Gu).then(function(t_){zt=!0,wt=t_,ga||bu.signal.aborted||(fu={},function(o_){for(var __ in o_)if(g(o_,__))return;return 1}(uu=Au)||tu||(J_(_0,hu),tu=!0),uw(function(){return!ga&&Zr.next&&Zr.next(t_)}))},function(t_){zt=!1,["DatabaseClosedError","AbortError"].includes(t_?.name)||ga||uw(function(){ga||Zr.error&&Zr.error(t_)})}))};return setTimeout(Ou,0),Su});return Dr.hasValue=function(){return zt},Dr.getValue=function(){return wt},Dr}var Pw=mw;function l1(lt){var wt=gw;try{gw=!0,J_.storagemutated.fire(lt),n1(lt,!0)}finally{gw=wt}}nt(Pw,s(s({},vu),{delete:function(lt){return new Pw(lt,{addons:[]}).delete()},exists:function(lt){return new Pw(lt,{addons:[]}).open().then(function(wt){return wt.close(),!0}).catch("NoSuchDatabaseError",function(){return!1})},getDatabaseNames:function(lt){try{return wt=Pw.dependencies,zt=wt.indexedDB,wt=wt.IDBKeyRange,(iw(zt)?Promise.resolve(zt.databases()).then(function(Dr){return Dr.map(function(Zr){return Zr.name}).filter(function(Zr){return Zr!==F0})}):c0(zt,wt).toCollection().primaryKeys()).then(lt)}catch{return i0(new na.MissingAPI)}var wt,zt},defineClass:function(){return function(lt){$(this,lt)}},ignoreTransaction:function(lt){return O_.trans?N0(O_.transless,lt):lt()},vip:Iw,async:function(lt){return function(){try{var wt=o1(lt.apply(this,arguments));return wt&&typeof wt.then=="function"?wt:Xs.resolve(wt)}catch(zt){return i0(zt)}}},spawn:function(lt,wt,zt){try{var Dr=o1(lt.apply(zt,wt||[]));return Dr&&typeof Dr.then=="function"?Dr:Xs.resolve(Dr)}catch(Zr){return i0(Zr)}},currentTransaction:{get:function(){return O_.trans||null}},waitFor:function(lt,wt){return wt=Xs.resolve(typeof lt=="function"?Pw.ignoreTransaction(lt):lt).timeout(wt||6e4),O_.trans?O_.trans.waitFor(wt):wt},Promise:Xs,debug:{get:function(){return rn},set:function(lt){Kr(lt)}},derive:At,extend:$,props:nt,override:Dt,Events:rw,on:J_,liveQuery:F1,extendObservabilitySet:Ww,getByKeyPath:gr,setByKeyPath:vr,delByKeyPath:function(lt,wt){typeof wt=="string"?vr(lt,wt,void 0):"length"in wt&&[].map.call(wt,function(zt){vr(lt,zt,void 0)})},shallowClone:Er,deepClone:Wo,getObjectDiff:i1,cmp:by,asap:Zt,minKey:-1/0,addons:[],connections:P0,errnames:r_,dependencies:Gw,cache:Mw,semVer:"4.0.8",version:"4.0.8".split(".").map(function(lt){return parseInt(lt)}).reduce(function(lt,wt,zt){return lt+wt/Math.pow(10,2*zt)})})),Pw.maxKey=_y(Pw.dependencies.IDBKeyRange),typeof dispatchEvent<"u"&&typeof addEventListener<"u"&&(J_(_0,function(lt){gw||(lt=new CustomEvent(ry,{detail:lt}),gw=!0,dispatchEvent(lt),gw=!1)}),addEventListener(ry,function(lt){lt=lt.detail,gw||l1(lt)}));var kw,gw=!1,w1=function(){};return typeof BroadcastChannel<"u"&&((w1=function(){(kw=new BroadcastChannel(ry)).onmessage=function(lt){return lt.data&&l1(lt.data)}})(),typeof kw.unref=="function"&&kw.unref(),J_(_0,function(lt){gw||kw.postMessage(lt)})),typeof addEventListener<"u"&&(addEventListener("pagehide",function(lt){if(!mw.disableBfCache&&lt.persisted){rn&&console.debug("Dexie: handling persisted pagehide"),kw?.close();for(var wt=0,zt=P0;wt<zt.length;wt++)zt[wt].close({disableAutoOpen:!1})}}),addEventListener("pageshow",function(lt){!mw.disableBfCache&&lt.persisted&&(rn&&console.debug("Dexie: handling persisted pageshow"),w1(),l1({all:new j0(-1/0,[[]])}))})),Xs.rejectionMapper=function(lt,wt){return!lt||lt instanceof Du||lt instanceof TypeError||lt instanceof SyntaxError||!lt.name||!Ko[lt.name]?lt:(wt=new Ko[lt.name](wt||lt.message,lt),"stack"in lt&&Ot(wt,"stack",{get:function(){return this.inner.stack}}),wt)},Kr(rn),s(mw,Object.freeze({__proto__:null,Dexie:mw,liveQuery:F1,Entity:ly,cmp:by,PropModSymbol:ba,PropModification:Iu,replacePrefix:function(lt,wt){return new Iu({replacePrefix:[lt,wt]})},add:function(lt){return new Iu({add:lt})},remove:function(lt){return new Iu({remove:lt})},default:mw,RangeSet:j0,mergeRanges:Nw,rangesOverlap:M1}),{default:mw}),mw})})(dexie_min);var dexie_minExports=dexie_min.exports;const _Dexie=getDefaultExportFromCjs(dexie_minExports),DexieSymbol=Symbol.for("Dexie"),Dexie=globalThis[DexieSymbol]||(globalThis[DexieSymbol]=_Dexie);if(_Dexie.semVer!==Dexie.semVer)throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);const{liveQuery,mergeRanges,rangesOverlap,RangeSet,cmp,Entity,PropModSymbol,PropModification,replacePrefix,add,remove}=Dexie,db$1=new Dexie("BackgroundRemoverDb");db$1.version(1).stores({images:"++id, file, processedFile"});function useObservable(e,o,i){var s,h;typeof e=="function"?(s=o||[],h=i):(s=[],h=o);var a=React.useRef({hasResult:!1,result:h,error:null}),d=React.useReducer(function(c){return c+1},0);d[0];var et=d[1],$=React.useMemo(function(){var c=typeof e=="function"?e():e;if(!c||typeof c.subscribe!="function")throw e===c?new TypeError("Given argument to useObservable() was neither a valid observable nor a function."):new TypeError("Observable factory given to useObservable() did not return a valid observable.");if(!a.current.hasResult&&typeof window<"u"&&(typeof c.hasValue!="function"||c.hasValue()))if(typeof c.getValue=="function")a.current.result=c.getValue(),a.current.hasResult=!0;else{var b=c.subscribe(function(g){a.current.result=g,a.current.hasResult=!0});typeof b=="function"?b():b.unsubscribe()}return c},s);if(React.useDebugValue(a.current.result),React.useEffect(function(){var c=$.subscribe(function(b){var g=a.current;(g.error!==null||g.result!==b)&&(g.error=null,g.result=b,g.hasResult=!0,et())},function(b){var g=a.current;g.error!==b&&(g.error=b,et())});return typeof c=="function"?c:c.unsubscribe.bind(c)},s),a.current.error)throw a.current.error;return a.current.result}function useLiveQuery(e,o,i){return useObservable(function(){return liveQuery(e)},[],i)}function Images(){const e=useLiveQuery(()=>db$1.images.reverse().toArray());return jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsxs("h2",{children:["Images: ",e?.length]}),jsxRuntimeExports.jsx("div",{className:"gap-2 grid grid-cols-4",children:e?.map(o=>o.file.type.includes("video")?jsxRuntimeExports.jsx(Video,{video:o},o.id):jsxRuntimeExports.jsx(ImageSpot,{image:o},o.id))})]})}function Video({video:e}){e.processedFile instanceof File;const o=URL.createObjectURL(e.file);return jsxRuntimeExports.jsx("div",{className:"",children:jsxRuntimeExports.jsx("video",{className:"rounded-lg aspect-square object-cover",loop:!0,muted:!0,autoPlay:!0,src:o})})}function ImageSpot({image:e}){const o=e.processedFile instanceof File,i=URL.createObjectURL(e.file),s=o?URL.createObjectURL(e.processedFile):"";return jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsxs("div",{className:"grid gap-2",children:[jsxRuntimeExports.jsx("img",{className:"rounded-lg h w-full aspect-square object-cover col-start-1 row-start-1",src:i,alt:e.name}),jsxRuntimeExports.jsx("img",{className:`rounded-lg h w-full bg-checkered aspect-square object-cover col-start-1 row-start-1 mask ${o?"":"processing"}`,src:s})]},e.id),jsxRuntimeExports.jsxs("div",{className:"controls",children:[jsxRuntimeExports.jsx("button",{onClick:()=>db$1.images.delete(e.id),children:"Delete"}),jsxRuntimeExports.jsx("a",{href:s,download:e.processedFile?.name,children:"Download"})]})]})}const model_id="Xenova/modnet";__webpack_exports__env.backends.onnx.wasm.proxy=!1;const model=await __webpack_exports__AutoModel.from_pretrained(model_id,{device:"webgpu"}),processor=await __webpack_exports__AutoProcessor.from_pretrained(model_id);async function processImage(e){const o=await __webpack_exports__RawImage.fromURL(URL.createObjectURL(e)),{pixel_values:i}=await processor(o),{output:s}=await model({input:i}),h=(await __webpack_exports__RawImage.fromTensor(s[0].mul(255).to("uint8")).resize(o.width,o.height)).data,a=document.createElement("canvas");a.width=o.width,a.height=o.height;const d=a.getContext("2d");if(!d)throw new Error("Could not get 2d context");d.drawImage(o.toCanvas(),0,0);const et=d.getImageData(0,0,o.width,o.height);for(let nt=0;nt<h.length;++nt)et.data[4*nt+3]=h[nt];d.putImageData(et,0,0);const $=await new Promise((nt,at)=>a.toBlob(Ot=>Ot?nt(Ot):at(),"image/png")),[c,b]=e.name.split(".");return new File([$],`${c}-bg-blasted.png`,{type:"image/png"})}async function processImages(){console.log("Processing images...");const e=db$1.images.where("processedFile").equals("null").reverse();console.log("imagesToProcess",await e.toArray());for(const o of await e.toArray()){console.log("Processing image",o.id);const i=await processImage(o.file);await db$1.images.update(o.id,{processedFile:i})}console.log("Processing images done")}/*!
 * ONNX Runtime Web v1.20.0-dev.20240908-de7a02beef
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var zd=Object.create,nn=Object.defineProperty,Wd=Object.getOwnPropertyDescriptor,Hd=Object.getOwnPropertyNames,qd=Object.getPrototypeOf,jd=Object.prototype.hasOwnProperty,ko=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(o,i)=>(typeof require<"u"?require:o)[i]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),O=(e,o)=>()=>(e&&(o=e(e=0)),o),mt=(e,o)=>()=>(o||e((o={exports:{}}).exports,o),o.exports),Or=(e,o)=>{for(var i in o)nn(e,i,{get:o[i],enumerable:!0})},Za=(e,o,i,s)=>{if(o&&typeof o=="object"||typeof o=="function")for(let h of Hd(o))!jd.call(e,h)&&h!==i&&nn(e,h,{get:()=>o[h],enumerable:!(s=Wd(o,h))||s.enumerable});return e},rr=(e,o,i)=>(i=e!=null?zd(qd(e)):{},Za(!e||!e.__esModule?nn(i,"default",{value:e,enumerable:!0}):i,e)),on=e=>Za(nn({},"__esModule",{value:!0}),e),an,$e,nr,Xd,sn,un=O(()=>{an=new Map,$e=[],nr=(e,o,i)=>{if(o&&typeof o.init=="function"&&typeof o.createInferenceSessionHandler=="function"){let s=an.get(e);if(s===void 0)an.set(e,{backend:o,priority:i});else{if(s.priority>i)return;if(s.priority===i&&s.backend!==o)throw new Error(`cannot register backend "${e}" using priority ${i}`)}if(i>=0){let h=$e.indexOf(e);h!==-1&&$e.splice(h,1);for(let a=0;a<$e.length;a++)if(an.get($e[a]).priority<=i){$e.splice(a,0,e);return}$e.push(e)}return}throw new TypeError("not a valid backend")},Xd=async e=>{let o=an.get(e);if(!o)return"backend not found.";if(o.initialized)return o.backend;if(o.aborted)return o.error;{let i=!!o.initPromise;try{return i||(o.initPromise=o.backend.init(e)),await o.initPromise,o.initialized=!0,o.backend}catch(s){return i||(o.error=`${s}`,o.aborted=!0),o.error}finally{delete o.initPromise}}},sn=async e=>{let o=e.executionProviders||[],i=o.map($=>typeof $=="string"?$:$.name),s=i.length===0?$e:i,h,a=[],d=new Set;for(let $ of s){let c=await Xd($);typeof c=="string"?a.push({name:$,err:c}):(h||(h=c),h===c&&d.add($))}if(!h)throw new Error(`no available backend found. ERR: ${a.map($=>`[${$.name}] ${$.err}`).join(", ")}`);for(let{name:$,err:c}of a)i.includes($)&&console.warn(`removing requested execution provider "${$}" from session options because it is not available: ${c}`);let et=o.filter($=>d.has(typeof $=="string"?$:$.name));return[h,new Proxy(e,{get:($,c)=>c==="executionProviders"?et:Reflect.get($,c)})]}}),Qa=O(()=>{un()}),ts,es=O(()=>{ts="1.20.0-dev.20240827-5d54dc1462"}),rs,Rt,Bo=O(()=>{es(),rs="warning",Rt={wasm:{},webgl:{},webgpu:{},versions:{common:ts},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);rs=e}},get logLevel(){return rs}},Object.defineProperty(Rt,"logLevel",{enumerable:!0})}),z,ns=O(()=>{Bo(),z=Rt}),os,is,as=O(()=>{os=(e,o)=>{let i=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);i.width=e.dims[3],i.height=e.dims[2];let s=i.getContext("2d");if(s!=null){let h,a;o?.tensorLayout!==void 0&&o.tensorLayout==="NHWC"?(h=e.dims[2],a=e.dims[3]):(h=e.dims[3],a=e.dims[2]);let d=o?.format!==void 0?o.format:"RGB",et=o?.norm,$,c;et===void 0||et.mean===void 0?$=[255,255,255,255]:typeof et.mean=="number"?$=[et.mean,et.mean,et.mean,et.mean]:($=[et.mean[0],et.mean[1],et.mean[2],0],et.mean[3]!==void 0&&($[3]=et.mean[3])),et===void 0||et.bias===void 0?c=[0,0,0,0]:typeof et.bias=="number"?c=[et.bias,et.bias,et.bias,et.bias]:(c=[et.bias[0],et.bias[1],et.bias[2],0],et.bias[3]!==void 0&&(c[3]=et.bias[3]));let b=a*h,g=0,nt=b,at=b*2,Ot=-1;d==="RGBA"?(g=0,nt=b,at=b*2,Ot=b*3):d==="RGB"?(g=0,nt=b,at=b*2):d==="RBG"&&(g=0,at=b,nt=b*2);for(let At=0;At<a;At++)for(let Ct=0;Ct<h;Ct++){let St=(e.data[g++]-c[0])*$[0],xt=(e.data[nt++]-c[1])*$[1],Dt=(e.data[at++]-c[2])*$[2],Qt=Ot===-1?255:(e.data[Ot++]-c[3])*$[3];s.fillStyle="rgba("+St+","+xt+","+Dt+","+Qt+")",s.fillRect(Ct,At,1,1)}if("toDataURL"in i)return i.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},is=(e,o)=>{let i=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(i!=null){let h,a,d;o?.tensorLayout!==void 0&&o.tensorLayout==="NHWC"?(h=e.dims[2],a=e.dims[1],d=e.dims[3]):(h=e.dims[3],a=e.dims[2],d=e.dims[1]);let et=o!==void 0&&o.format!==void 0?o.format:"RGB",$=o?.norm,c,b;$===void 0||$.mean===void 0?c=[255,255,255,255]:typeof $.mean=="number"?c=[$.mean,$.mean,$.mean,$.mean]:(c=[$.mean[0],$.mean[1],$.mean[2],255],$.mean[3]!==void 0&&(c[3]=$.mean[3])),$===void 0||$.bias===void 0?b=[0,0,0,0]:typeof $.bias=="number"?b=[$.bias,$.bias,$.bias,$.bias]:(b=[$.bias[0],$.bias[1],$.bias[2],0],$.bias[3]!==void 0&&(b[3]=$.bias[3]));let g=a*h;if(o!==void 0&&(o.format!==void 0&&d===4&&o.format!=="RGBA"||d===3&&o.format!=="RGB"&&o.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let nt=4,at=0,Ot=1,At=2,Ct=3,St=0,xt=g,Dt=g*2,Qt=-1;et==="RGBA"?(St=0,xt=g,Dt=g*2,Qt=g*3):et==="RGB"?(St=0,xt=g,Dt=g*2):et==="RBG"&&(St=0,Dt=g,xt=g*2),s=i.createImageData(h,a);for(let Zt=0;Zt<a*h;at+=nt,Ot+=nt,At+=nt,Ct+=nt,Zt++)s.data[at]=(e.data[St++]-b[0])*c[0],s.data[Ot]=(e.data[xt++]-b[1])*c[1],s.data[At]=(e.data[Dt++]-b[2])*c[2],s.data[Ct]=Qt===-1?255:(e.data[Qt++]-b[3])*c[3]}else throw new Error("Can not access image data");return s}}),Fo,ss,us,ls,fs,cs=O(()=>{ln(),Fo=(e,o)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(o.height===void 0||o.width===void 0)throw new Error("Image height and width must be defined");if(o.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:i,width:s}=o,h=o.norm??{mean:255,bias:0},a,d;typeof h.mean=="number"?a=[h.mean,h.mean,h.mean,h.mean]:a=[h.mean[0],h.mean[1],h.mean[2],h.mean[3]??255],typeof h.bias=="number"?d=[h.bias,h.bias,h.bias,h.bias]:d=[h.bias[0],h.bias[1],h.bias[2],h.bias[3]??0];let et=o.format!==void 0?o.format:"RGBA",$=o.tensorFormat!==void 0&&o.tensorFormat!==void 0?o.tensorFormat:"RGB",c=i*s,b=$==="RGBA"?new Float32Array(c*4):new Float32Array(c*3),g=4,nt=0,at=1,Ot=2,At=3,Ct=0,St=c,xt=c*2,Dt=-1;et==="RGB"&&(g=3,nt=0,at=1,Ot=2,At=-1),$==="RGBA"?Dt=c*3:$==="RBG"?(Ct=0,xt=c,St=c*2):$==="BGR"&&(xt=0,St=c,Ct=c*2);for(let Qt=0;Qt<c;Qt++,nt+=g,Ot+=g,at+=g,At+=g)b[Ct++]=(e[nt]+d[0])/a[0],b[St++]=(e[at]+d[1])/a[1],b[xt++]=(e[Ot]+d[2])/a[2],Dt!==-1&&At!==-1&&(b[Dt++]=(e[At]+d[3])/a[3]);return $==="RGBA"?new Lt("float32",b,[1,4,i,s]):new Lt("float32",b,[1,3,i,s])},ss=async(e,o)=>{let i=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,h=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,a=typeof e=="string",d,et=o??{},$=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},c=b=>b instanceof HTMLCanvasElement||b instanceof OffscreenCanvas?b.getContext("2d"):null;if(i){let b=$();b.width=e.width,b.height=e.height;let g=c(b);if(g!=null){let nt=e.height,at=e.width;if(o!==void 0&&o.resizedHeight!==void 0&&o.resizedWidth!==void 0&&(nt=o.resizedHeight,at=o.resizedWidth),o!==void 0){if(et=o,o.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");et.tensorFormat="RGBA",et.height=nt,et.width=at}else et.tensorFormat="RGBA",et.height=nt,et.width=at;g.drawImage(e,0,0),d=g.getImageData(0,0,at,nt).data}else throw new Error("Can not access image data")}else if(s){let b,g;if(o!==void 0&&o.resizedWidth!==void 0&&o.resizedHeight!==void 0?(b=o.resizedHeight,g=o.resizedWidth):(b=e.height,g=e.width),o!==void 0&&(et=o),et.format="RGBA",et.height=b,et.width=g,o!==void 0){let nt=$();nt.width=g,nt.height=b;let at=c(nt);if(at!=null)at.putImageData(e,0,0),d=at.getImageData(0,0,g,b).data;else throw new Error("Can not access image data")}else d=e.data}else if(h){if(o===void 0)throw new Error("Please provide image config with format for Imagebitmap");let b=$();b.width=e.width,b.height=e.height;let g=c(b);if(g!=null){let nt=e.height,at=e.width;return g.drawImage(e,0,0,at,nt),d=g.getImageData(0,0,at,nt).data,et.height=nt,et.width=at,Fo(d,et)}else throw new Error("Can not access image data")}else{if(a)return new Promise((b,g)=>{let nt=$(),at=c(nt);if(!e||!at)return g();let Ot=new Image;Ot.crossOrigin="Anonymous",Ot.src=e,Ot.onload=()=>{nt.width=Ot.width,nt.height=Ot.height,at.drawImage(Ot,0,0,nt.width,nt.height);let At=at.getImageData(0,0,nt.width,nt.height);et.height=nt.height,et.width=nt.width,b(Fo(At.data,et))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(d!==void 0)return Fo(d,et);throw new Error("Input data provided is not supported - aborted tensor creation")},us=(e,o)=>{let{width:i,height:s,download:h,dispose:a}=o,d=[1,s,i,4];return new Lt({location:"texture",type:"float32",texture:e,dims:d,download:h,dispose:a})},ls=(e,o)=>{let{dataType:i,dims:s,download:h,dispose:a}=o;return new Lt({location:"gpu-buffer",type:i??"float32",gpuBuffer:e,dims:s,download:h,dispose:a})},fs=(e,o,i)=>new Lt({location:"cpu-pinned",type:e,data:o,dims:i??[o.length]})}),ke,Sr,ps,ds,hs=O(()=>{ke=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Sr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),ps=!1,ds=()=>{if(!ps){ps=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,o=typeof BigUint64Array<"u"&&BigUint64Array.from,i=typeof Float16Array<"u"&&Float16Array.from;e&&(ke.set("int64",BigInt64Array),Sr.set(BigInt64Array,"int64")),o&&(ke.set("uint64",BigUint64Array),Sr.set(BigUint64Array,"uint64")),i?(ke.set("float16",Float16Array),Sr.set(Float16Array,"float16")):ke.set("float16",Uint16Array)}}}),ms,bs,gs=O(()=>{ln(),ms=e=>{let o=1;for(let i=0;i<e.length;i++){let s=e[i];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${i}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${s}`);o*=s}return o},bs=(e,o)=>{switch(e.location){case"cpu":return new Lt(e.type,e.data,o);case"cpu-pinned":return new Lt({location:"cpu-pinned",data:e.data,type:e.type,dims:o});case"texture":return new Lt({location:"texture",texture:e.texture,type:e.type,dims:o});case"gpu-buffer":return new Lt({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:o});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),Lt,ln=O(()=>{as(),cs(),hs(),gs(),Lt=class{constructor(e,o,i){ds();let s,h;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,s=e.type,h=e.dims,e.location){case"cpu-pinned":{let d=ke.get(s);if(!d)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(e.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=e.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,et;if(typeof e=="string")if(s=e,et=i,e==="string"){if(!Array.isArray(o))throw new TypeError("A string tensor's data must be a string array.");d=o}else{let $=ke.get(e);if($===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(o)){if(e==="float16"&&$===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${$.name} as data.`);e==="uint64"||e==="int64"?d=$.from(o,BigInt):d=$.from(o)}else if(o instanceof $)d=o;else throw new TypeError(`A ${s} tensor's data must be type of ${$}`)}else if(et=o,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let $=typeof e[0];if($==="string")s="string",d=e;else if($==="boolean")s="bool",d=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${$}.`)}else{let $=Sr.get(e.constructor);if($===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);s=$,d=e}if(et===void 0)et=[d.length];else if(!Array.isArray(et))throw new TypeError("A tensor's dims must be a number array");h=et,this.cpuData=d,this.dataLocation="cpu"}let a=ms(h);if(this.cpuData&&a!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=h,this.size=a}static async fromImage(e,o){return ss(e,o)}static fromTexture(e,o){return us(e,o)}static fromGpuBuffer(e,o){return ls(e,o)}static fromPinnedBuffer(e,o,i){return fs(e,o,i)}toDataURL(e){return os(this,e)}toImageData(e){return is(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let o=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=o,e&&this.disposer&&(this.disposer(),this.disposer=void 0),o}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return bs(this,e)}}}),Tt,fn=O(()=>{ln(),Tt=Lt}),ys,xs,Be,Fe,Co=O(()=>{Bo(),ys=(e,o)=>{(typeof Rt.trace>"u"?!Rt.wasm.trace:!Rt.trace)||console.timeStamp(`${e}::ORT::${o}`)},xs=(e,o)=>{let i=new Error().stack?.split(/\r\n|\r|\n/g)||[],s=!1;for(let h=0;h<i.length;h++){if(s&&!i[h].includes("TRACE_FUNC")){let a=`FUNC_${e}::${i[h].trim().split(" ")[1]}`;o&&(a+=`::${o}`),ys("CPU",a);return}i[h].includes("TRACE_FUNC")&&(s=!0)}},Be=e=>{(typeof Rt.trace>"u"?!Rt.wasm.trace:!Rt.trace)||xs("BEGIN",e)},Fe=e=>{(typeof Rt.trace>"u"?!Rt.wasm.trace:!Rt.trace)||xs("END",e)}}),cn,Ts=O(()=>{un(),fn(),Co(),cn=class jP{constructor(o){this.handler=o}async run(o,i,s){Be();let h={},a={};if(typeof o!="object"||o===null||o instanceof Tt||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let d=!0;if(typeof i=="object"){if(i===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(i instanceof Tt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(i)){if(i.length===0)throw new TypeError("'fetches' cannot be an empty array.");d=!1;for(let c of i){if(typeof c!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(c)===-1)throw new RangeError(`'fetches' contains invalid output name: ${c}.`);h[c]=null}if(typeof s=="object"&&s!==null)a=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let c=!1,b=Object.getOwnPropertyNames(i);for(let g of this.outputNames)if(b.indexOf(g)!==-1){let nt=i[g];(nt===null||nt instanceof Tt)&&(c=!0,d=!1,h[g]=nt)}if(c){if(typeof s=="object"&&s!==null)a=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else a=i}}else if(typeof i<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let c of this.inputNames)if(typeof o[c]>"u")throw new Error(`input '${c}' is missing in 'feeds'.`);if(d)for(let c of this.outputNames)h[c]=null;let et=await this.handler.run(o,h,a),$={};for(let c in et)if(Object.hasOwnProperty.call(et,c)){let b=et[c];b instanceof Tt?$[c]=b:$[c]=new Tt(b.type,b.data,b.dims)}return Fe(),$}async release(){return this.handler.dispose()}static async create(o,i,s,h){Be();let a,d={};if(typeof o=="string"){if(a=o,typeof i=="object"&&i!==null)d=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(o instanceof Uint8Array){if(a=o,typeof i=="object"&&i!==null)d=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(o instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&o instanceof SharedArrayBuffer){let b=o,g=0,nt=o.byteLength;if(typeof i=="object"&&i!==null)d=i;else if(typeof i=="number"){if(g=i,!Number.isSafeInteger(g))throw new RangeError("'byteOffset' must be an integer.");if(g<0||g>=b.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${b.byteLength}).`);if(nt=o.byteLength-g,typeof s=="number"){if(nt=s,!Number.isSafeInteger(nt))throw new RangeError("'byteLength' must be an integer.");if(nt<=0||g+nt>b.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${b.byteLength-g}].`);if(typeof h=="object"&&h!==null)d=h;else if(typeof h<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof i<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(b,g,nt)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[et,$]=await sn(d),c=await et.createInferenceSessionHandler(a,$);return Fe(),new jP(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Kd,ws=O(()=>{Ts(),Kd=cn}),vs=O(()=>{}),Is=O(()=>{}),_s=O(()=>{}),Os=O(()=>{}),Jd,pn,Ss=O(()=>{un(),fn(),Jd="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",pn=class zP{constructor(o,i,s){this.handler=o,this.hasOptimizerModel=i,this.hasEvalModel=s}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(o,i){let s=o.evalModel||"",h=o.optimizerModel||"",a=i||{},[d,et]=await sn(a);if(d.createTrainingSessionHandler){let $=await d.createTrainingSessionHandler(o.checkpointState,o.trainModel,s,h,et);return new zP($,!!o.optimizerModel,!!o.evalModel)}else throw new Error(Jd)}typeNarrowingForRunStep(o,i,s,h,a){let d={},et={};if(typeof s!="object"||s===null||s instanceof Tt||Array.isArray(s))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let $=!0;if(typeof h=="object"){if(h===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(h instanceof Tt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(h)){if(h.length===0)throw new TypeError("'fetches' cannot be an empty array.");$=!1;for(let c of h){if(typeof c!="string")throw new TypeError("'fetches' must be a string array or an object.");if(i.indexOf(c)===-1)throw new RangeError(`'fetches' contains invalid output name: ${c}.`);d[c]=null}if(typeof a=="object"&&a!==null)et=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let c=!1,b=Object.getOwnPropertyNames(h);for(let g of i)if(b.indexOf(g)!==-1){let nt=h[g];(nt===null||nt instanceof Tt)&&(c=!0,$=!1,d[g]=nt)}if(c){if(typeof a=="object"&&a!==null)et=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else et=h}}else if(typeof h<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let c of o)if(typeof s[c]>"u")throw new Error(`input '${c}' is missing in 'feeds'.`);if($)for(let c of i)d[c]=null;return[d,et]}convertHandlerReturnTypeToMapOfTensors(o){let i={};for(let s in o)if(Object.hasOwnProperty.call(o,s)){let h=o[s];h instanceof Tt?i[s]=h:i[s]=new Tt(h.type,h.data,h.dims)}return i}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(o,i,s){let[h,a]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,o,i,s),d=await this.handler.runTrainStep(o,h,a);return this.convertHandlerReturnTypeToMapOfTensors(d)}async runOptimizerStep(o){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(o||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(o,i,s){if(this.hasEvalModel){let[h,a]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,o,i,s),d=await this.handler.runEvalStep(o,h,a);return this.convertHandlerReturnTypeToMapOfTensors(d)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(o=!0){return this.handler.getParametersSize(o)}async loadParametersBuffer(o,i=!0){let s=await this.getParametersSize(i);if(o.length!==4*s)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(o,i)}async getContiguousParameters(o=!0){return this.handler.getContiguousParameters(o)}async release(){return this.handler.dispose()}}}),Yd,As=O(()=>{Ss(),Yd=pn}),No={};Or(No,{InferenceSession:()=>Kd,TRACE:()=>ys,TRACE_FUNC_BEGIN:()=>Be,TRACE_FUNC_END:()=>Fe,Tensor:()=>Tt,TrainingSession:()=>Yd,env:()=>z,registerBackend:()=>nr});var Kt=O(()=>{Qa(),ns(),ws(),fn(),vs(),Is(),Co(),_s(),Os(),As()});function Ie(e,o,i,s){if(o===void 0)return Qd(e);if(i===void 0)dn(e,o);else if(typeof i=="number"&&s===void 0)dn(e,o);else if(typeof i=="string"&&s===void 0)dn(e,i,1,o);else if(typeof i=="string"&&typeof s=="number")dn(e,i,s,o);else throw new TypeError("input is valid")}function Qd(e){return{verbose:Ie.verbose.bind(null,e),info:Ie.info.bind(null,e),warning:Ie.warning.bind(null,e),error:Ie.error.bind(null,e),fatal:Ie.fatal.bind(null,e)}}function dn(e,o,i,s){let h=Ar[s||""]||Ar[""];Es[e]<Es[h.minimalSeverity]||(h.logDateTime&&(o=`${new Date().toISOString()}|${o}`),h.logSourceLocation,Zd[h.provider].log(e,o,s))}var Ro,Go,Es,Zd,Ds,Ar,tt,mn,bn,gn,hn,Mt=O(()=>{Ro=class{log(e,o,i){}},Go=class{log(e,o,i){console.log(`${this.color(e)} ${i?"\x1B[35m"+i+"\x1B[0m ":""}${o}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},Es={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},Zd={none:new Ro,console:new Go},Ds={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Ar={"":Ds},(e=>{function o(c,b){e("verbose",c,b)}e.verbose=o;function i(c,b){e("info",c,b)}e.info=i;function s(c,b){e("warning",c,b)}e.warning=s;function h(c,b){e("error",c,b)}e.error=h;function a(c,b){e("fatal",c,b)}e.fatal=a;function d(c){Ar={},et("",c||{})}e.reset=d;function et(c,b){if(c==="*")d(b);else{let g=Ar[c]||Ds;Ar[c]={provider:b.provider||g.provider,minimalSeverity:b.minimalSeverity||g.minimalSeverity,logDateTime:b.logDateTime===void 0?g.logDateTime:b.logDateTime,logSourceLocation:b.logSourceLocation===void 0?g.logSourceLocation:b.logSourceLocation}}}e.set=et;function $(c){let b={};c.logLevel&&(b.minimalSeverity=c.logLevel),et("",b)}e.setWithEnv=$})(Ie||={}),tt=Ie,mn=class{constructor(e,o,i,s,h,a){this.category=e,this.name=o,this.startTime=i,this.endCallback=s,this.timer=h,this.ctx=a}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},bn=class{constructor(e,o,i,s){this.category=e,this.name=o,this.startTime=i,this.endTime=s}},gn=class{constructor(e,o,i){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=o===void 0?10:o,this._flushIntervalInMilliseconds=i===void 0?5e3:i}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=hn(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,o,i,s){let h=this._started?this.begin(e,o,s):void 0,a=!1,d=i();if(d&&typeof d.then=="function")return a=!0,new Promise((et,$)=>{d.then(async c=>{h&&await h.end(),et(c)},async c=>{h&&await h.end(),$(c)})});if(!a&&h){let et=h.end();if(et&&typeof et.then=="function")return new Promise(($,c)=>{et.then(()=>{$(d)},b=>{c(b)})})}return d}begin(e,o,i){if(!this._started)throw new Error("profiler is not started yet");if(i===void 0){let s=hn();return this.flush(s),new mn(e,o,s,h=>this.endSync(h))}else{let s=i.beginTimer();return new mn(e,o,0,async h=>this.end(h),s,i)}}async end(e){let o=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new bn(e.category,e.name,e.startTime,o)),this.flush(o))}endSync(e){let o=hn();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new bn(e.category,e.name,e.startTime,o)),this.flush(o))}logOneEvent(e){tt.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let o=this._flushPointer;this._flushPointer<o+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=hn()}}get started(){return this._started}},hn=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Ls(e,o,i){for(let s of i){let h=s[0],a=s[1],d=s[2],et=s[3],$=s[4];if(e.opType===h){for(let c of o)if((c.domain===a||c.domain==="ai.onnx"&&a==="")&&th(c.version,d))return{opImpl:et,opInit:$}}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${o.map(s=>`${s.domain||"ai.onnx"} v${s.version}`).join(", ")}`)}function th(e,o){if(o.endsWith("+")){let i=Number.parseInt(o.substring(0,o.length-1),10);return!isNaN(i)&&i<=e}else if(o.split("-").length===2){let i=o.split("-"),s=Number.parseInt(i[0],10),h=Number.parseInt(i[1],10);return!isNaN(s)&&!isNaN(h)&&s<=e&&e<=h}else return Number.parseInt(o,10)===e}var $s=O(()=>{}),ks=mt(e=>{e.__esModule=!0;var o=function(){function i(s){if(!s)throw new TypeError("Invalid argument; `value` has no value.");this.value=i.EMPTY,s&&i.isGuid(s)&&(this.value=s)}return i.isGuid=function(s){var h=s.toString();return s&&(s instanceof i||i.validator.test(h))},i.create=function(){return new i([i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-"))},i.createEmpty=function(){return new i("emptyguid")},i.parse=function(s){return new i(s)},i.raw=function(){return[i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-")},i.gen=function(s){for(var h="",a=0;a<s;a++)h+=((1+Math.random())*65536|0).toString(16).substring(1);return h},i.prototype.equals=function(s){return i.isGuid(s)&&this.value===s.toString()},i.prototype.isEmpty=function(){return this.value===i.EMPTY},i.prototype.toString=function(){return this.value},i.prototype.toJSON=function(){return{value:this.value}},i.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),i.EMPTY="00000000-0000-0000-0000-000000000000",i}();e.Guid=o});function rt(e,o,i){this.low=e|0,this.high=o|0,this.unsigned=!!i}function Pt(e){return(e&&e.__isLong__)===!0}function Bs(e){var o=Math.clz32(e&-e);return e?31-o:o}function Ce(e,o){var i,s,h;return o?(e>>>=0,(h=0<=e&&e<256)&&(s=Cs[e],s)?s:(i=J(e,0,!0),h&&(Cs[e]=i),i)):(e|=0,(h=-128<=e&&e<128)&&(s=Fs[e],s)?s:(i=J(e,e<0?-1:0,!1),h&&(Fs[e]=i),i))}function Vt(e,o){if(isNaN(e))return o?he:Jt;if(o){if(e<0)return he;if(e>=Ms)return zs}else{if(e<=-Rs)return Ft;if(e+1>=Rs)return Vs}return e<0?Vt(-e,o).neg():J(e%ir|0,e/ir|0,o)}function J(e,o,i){return new rt(e,o,i)}function Vo(e,o,i){if(e.length===0)throw Error("empty string");if(typeof o=="number"?(i=o,o=!1):o=!!o,e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return o?he:Jt;if(i=i||10,i<2||36<i)throw RangeError("radix");var s;if((s=e.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Vo(e.substring(1),o,i).neg();for(var h=Vt(yn(i,8)),a=Jt,d=0;d<e.length;d+=8){var et=Math.min(8,e.length-d),$=parseInt(e.substring(d,d+et),i);if(et<8){var c=Vt(yn(i,et));a=a.mul(c).add(Vt($))}else a=a.mul(h),a=a.add(Vt($))}return a.unsigned=o,a}function Yt(e,o){return typeof e=="number"?Vt(e,o):typeof e=="string"?Vo(e,o):J(e.low,e.high,typeof o=="boolean"?o:e.unsigned)}var Ut,Fs,Cs,yn,Ns,rh,ir,Ms,Rs,Gs,Jt,he,or,Us,Uo,Vs,zs,Ft,D,me,zo=O(()=>{Ut=null;try{Ut=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}rt.prototype.__isLong__,Object.defineProperty(rt.prototype,"__isLong__",{value:!0}),rt.isLong=Pt,Fs={},Cs={},rt.fromInt=Ce,rt.fromNumber=Vt,rt.fromBits=J,yn=Math.pow,rt.fromString=Vo,rt.fromValue=Yt,Ns=65536,rh=1<<24,ir=Ns*Ns,Ms=ir*ir,Rs=Ms/2,Gs=Ce(rh),Jt=Ce(0),rt.ZERO=Jt,he=Ce(0,!0),rt.UZERO=he,or=Ce(1),rt.ONE=or,Us=Ce(1,!0),rt.UONE=Us,Uo=Ce(-1),rt.NEG_ONE=Uo,Vs=J(-1,2147483647,!1),rt.MAX_VALUE=Vs,zs=J(-1,-1,!0),rt.MAX_UNSIGNED_VALUE=zs,Ft=J(0,-2147483648,!1),rt.MIN_VALUE=Ft,D=rt.prototype,D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*ir+(this.low>>>0):this.high*ir+(this.low>>>0)},D.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Ft)){var o=Vt(e),i=this.div(o),s=i.mul(o).sub(this);return i.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var h=Vt(yn(e,6),this.unsigned),a=this,d="";;){var et=a.div(h),$=a.sub(et.mul(h)).toInt()>>>0,c=$.toString(e);if(a=et,a.isZero())return c+d;for(;c.length<6;)c="0"+c;d=""+c+d}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ft)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,o=31;o>0&&!(e&1<<o);o--);return this.high!=0?o+33:o+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(e){return Pt(e)||(e=Yt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low},D.eq=D.equals,D.notEquals=function(e){return!this.eq(e)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(e){return this.comp(e)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(e){return this.comp(e)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(e){return this.comp(e)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(e){return this.comp(e)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(e){if(Pt(e)||(e=Yt(e)),this.eq(e))return 0;var o=this.isNegative(),i=e.isNegative();return o&&!i?-1:!o&&i?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(Ft)?Ft:this.not().add(or)},D.neg=D.negate,D.add=function(e){Pt(e)||(e=Yt(e));var o=this.high>>>16,i=this.high&65535,s=this.low>>>16,h=this.low&65535,a=e.high>>>16,d=e.high&65535,et=e.low>>>16,$=e.low&65535,c=0,b=0,g=0,nt=0;return nt+=h+$,g+=nt>>>16,nt&=65535,g+=s+et,b+=g>>>16,g&=65535,b+=i+d,c+=b>>>16,b&=65535,c+=o+a,c&=65535,J(g<<16|nt,c<<16|b,this.unsigned)},D.subtract=function(e){return Pt(e)||(e=Yt(e)),this.add(e.neg())},D.sub=D.subtract,D.multiply=function(e){if(this.isZero())return this;if(Pt(e)||(e=Yt(e)),Ut){var o=Ut.mul(this.low,this.high,e.low,e.high);return J(o,Ut.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?he:Jt;if(this.eq(Ft))return e.isOdd()?Ft:Jt;if(e.eq(Ft))return this.isOdd()?Ft:Jt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Gs)&&e.lt(Gs))return Vt(this.toNumber()*e.toNumber(),this.unsigned);var i=this.high>>>16,s=this.high&65535,h=this.low>>>16,a=this.low&65535,d=e.high>>>16,et=e.high&65535,$=e.low>>>16,c=e.low&65535,b=0,g=0,nt=0,at=0;return at+=a*c,nt+=at>>>16,at&=65535,nt+=h*c,g+=nt>>>16,nt&=65535,nt+=a*$,g+=nt>>>16,nt&=65535,g+=s*c,b+=g>>>16,g&=65535,g+=h*$,b+=g>>>16,g&=65535,g+=a*et,b+=g>>>16,g&=65535,b+=i*c+s*$+h*et+a*d,b&=65535,J(nt<<16|at,b<<16|g,this.unsigned)},D.mul=D.multiply,D.divide=function(e){if(Pt(e)||(e=Yt(e)),e.isZero())throw Error("division by zero");if(Ut){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var o=(this.unsigned?Ut.div_u:Ut.div_s)(this.low,this.high,e.low,e.high);return J(o,Ut.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?he:Jt;var i,s,h;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return he;if(e.gt(this.shru(1)))return Us;h=he}else{if(this.eq(Ft)){if(e.eq(or)||e.eq(Uo))return Ft;if(e.eq(Ft))return or;var a=this.shr(1);return i=a.div(e).shl(1),i.eq(Jt)?e.isNegative()?or:Uo:(s=this.sub(e.mul(i)),h=i.add(s.div(e)),h)}else if(e.eq(Ft))return this.unsigned?he:Jt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();h=Jt}for(s=this;s.gte(e);){i=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var d=Math.ceil(Math.log(i)/Math.LN2),et=d<=48?1:yn(2,d-48),$=Vt(i),c=$.mul(e);c.isNegative()||c.gt(s);)i-=et,$=Vt(i,this.unsigned),c=$.mul(e);$.isZero()&&($=or),h=h.add($),s=s.sub(c)}return h},D.div=D.divide,D.modulo=function(e){if(Pt(e)||(e=Yt(e)),Ut){var o=(this.unsigned?Ut.rem_u:Ut.rem_s)(this.low,this.high,e.low,e.high);return J(o,Ut.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return J(~this.low,~this.high,this.unsigned)},D.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},D.clz=D.countLeadingZeros,D.countTrailingZeros=function(){return this.low?Bs(this.low):Bs(this.high)+32},D.ctz=D.countTrailingZeros,D.and=function(e){return Pt(e)||(e=Yt(e)),J(this.low&e.low,this.high&e.high,this.unsigned)},D.or=function(e){return Pt(e)||(e=Yt(e)),J(this.low|e.low,this.high|e.high,this.unsigned)},D.xor=function(e){return Pt(e)||(e=Yt(e)),J(this.low^e.low,this.high^e.high,this.unsigned)},D.shiftLeft=function(e){return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):J(0,this.low<<e-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(e){return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):J(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(e){return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?J(this.high,0,this.unsigned):J(this.high>>>e-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.rotateLeft=function(e){var o;return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?J(this.high,this.low,this.unsigned):e<32?(o=32-e,J(this.low<<e|this.high>>>o,this.high<<e|this.low>>>o,this.unsigned)):(e-=32,o=32-e,J(this.high<<e|this.low>>>o,this.low<<e|this.high>>>o,this.unsigned))},D.rotl=D.rotateLeft,D.rotateRight=function(e){var o;return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?J(this.high,this.low,this.unsigned):e<32?(o=32-e,J(this.high<<o|this.low>>>e,this.low<<o|this.high>>>e,this.unsigned)):(e-=32,o=32-e,J(this.low<<o|this.high>>>e,this.high<<o|this.low>>>e,this.unsigned))},D.rotr=D.rotateRight,D.toSigned=function(){return this.unsigned?J(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:J(this.low,this.high,!0)},D.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var e=this.high,o=this.low;return[o&255,o>>>8&255,o>>>16&255,o>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]},D.toBytesBE=function(){var e=this.high,o=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,o>>>24,o>>>16&255,o>>>8&255,o&255]},rt.fromBytes=function(e,o,i){return i?rt.fromBytesLE(e,o):rt.fromBytesBE(e,o)},rt.fromBytesLE=function(e,o){return new rt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,o)},rt.fromBytesBE=function(e,o){return new rt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],o)},me=rt}),T,xn=O(()=>{T={},T.Offset,T.Table,T.SIZEOF_SHORT=2,T.SIZEOF_INT=4,T.FILE_IDENTIFIER_LENGTH=4,T.SIZE_PREFIX_LENGTH=4,T.Encoding={UTF8_BYTES:1,UTF16_STRING:2},T.int32=new Int32Array(2),T.float32=new Float32Array(T.int32.buffer),T.float64=new Float64Array(T.int32.buffer),T.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,T.Long=function(e,o){this.low=e|0,this.high=o|0},T.Long.create=function(e,o){return e==0&&o==0?T.Long.ZERO:new T.Long(e,o)},T.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},T.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},T.Long.ZERO=new T.Long(0,0),T.Builder=function(e){if(e)var o=e;else var o=1024;this.bb=T.ByteBuffer.allocate(o),this.space=o,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},T.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},T.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},T.Builder.prototype.dataBuffer=function(){return this.bb},T.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},T.Builder.prototype.prep=function(e,o){e>this.minalign&&(this.minalign=e);for(var i=~(this.bb.capacity()-this.space+o)+1&e-1;this.space<i+e+o;){var s=this.bb.capacity();this.bb=T.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(i)},T.Builder.prototype.pad=function(e){for(var o=0;o<e;o++)this.bb.writeInt8(--this.space,0)},T.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},T.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},T.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},T.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},T.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},T.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},T.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},T.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},T.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},T.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},T.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},T.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},T.Builder.prototype.addFieldInt8=function(e,o,i){(this.force_defaults||o!=i)&&(this.addInt8(o),this.slot(e))},T.Builder.prototype.addFieldInt16=function(e,o,i){(this.force_defaults||o!=i)&&(this.addInt16(o),this.slot(e))},T.Builder.prototype.addFieldInt32=function(e,o,i){(this.force_defaults||o!=i)&&(this.addInt32(o),this.slot(e))},T.Builder.prototype.addFieldInt64=function(e,o,i){(this.force_defaults||!o.equals(i))&&(this.addInt64(o),this.slot(e))},T.Builder.prototype.addFieldFloat32=function(e,o,i){(this.force_defaults||o!=i)&&(this.addFloat32(o),this.slot(e))},T.Builder.prototype.addFieldFloat64=function(e,o,i){(this.force_defaults||o!=i)&&(this.addFloat64(o),this.slot(e))},T.Builder.prototype.addFieldOffset=function(e,o,i){(this.force_defaults||o!=i)&&(this.addOffset(o),this.slot(e))},T.Builder.prototype.addFieldStruct=function(e,o,i){o!=i&&(this.nested(o),this.slot(e))},T.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},T.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},T.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},T.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},T.Builder.growByteBuffer=function(e){var o=e.capacity();if(o&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var i=o<<1,s=T.ByteBuffer.allocate(i);return s.setPosition(i-o),s.bytes().set(e.bytes(),i-o),s},T.Builder.prototype.addOffset=function(e){this.prep(T.SIZEOF_INT,0),this.writeInt32(this.offset()-e+T.SIZEOF_INT)},T.Builder.prototype.startObject=function(e){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=e;for(var o=0;o<e;o++)this.vtable[o]=0;this.isNested=!0,this.object_start=this.offset()},T.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),o=this.vtable_in_use-1;o>=0&&this.vtable[o]==0;o--);for(var i=o+1;o>=0;o--)this.addInt16(this.vtable[o]!=0?e-this.vtable[o]:0);var s=2;this.addInt16(e-this.object_start);var h=(i+s)*T.SIZEOF_SHORT;this.addInt16(h);var a=0,d=this.space;e:for(o=0;o<this.vtables.length;o++){var et=this.bb.capacity()-this.vtables[o];if(h==this.bb.readInt16(et)){for(var $=T.SIZEOF_SHORT;$<h;$+=T.SIZEOF_SHORT)if(this.bb.readInt16(d+$)!=this.bb.readInt16(et+$))continue e;a=this.vtables[o];break}}return a?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,a-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},T.Builder.prototype.finish=function(e,o,i){var s=i?T.SIZE_PREFIX_LENGTH:0;if(o){var h=o;if(this.prep(this.minalign,T.SIZEOF_INT+T.FILE_IDENTIFIER_LENGTH+s),h.length!=T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+T.FILE_IDENTIFIER_LENGTH);for(var a=T.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(h.charCodeAt(a))}this.prep(this.minalign,T.SIZEOF_INT+s),this.addOffset(e),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},T.Builder.prototype.finishSizePrefixed=function(e,o){this.finish(e,o,!0)},T.Builder.prototype.requiredField=function(e,o){var i=this.bb.capacity()-e,s=i-this.bb.readInt32(i),h=this.bb.readInt16(s+o)!=0;if(!h)throw new Error("FlatBuffers: field "+o+" must be set")},T.Builder.prototype.startVector=function(e,o,i){this.notNested(),this.vector_num_elems=o,this.prep(T.SIZEOF_INT,e*o),this.prep(i,e*o)},T.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},T.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var o=e;else for(var o=[],i=0;i<e.length;){var s,h=e.charCodeAt(i++);if(h<55296||h>=56320)s=h;else{var a=e.charCodeAt(i++);s=(h<<10)+a+-56613888}s<128?o.push(s):(s<2048?o.push(s>>6&31|192):(s<65536?o.push(s>>12&15|224):o.push(s>>18&7|240,s>>12&63|128),o.push(s>>6&63|128)),o.push(s&63|128))}this.addInt8(0),this.startVector(1,o.length,1),this.bb.setPosition(this.space-=o.length);for(var i=0,d=this.space,et=this.bb.bytes();i<o.length;i++)et[d++]=o[i];return this.endVector()},T.Builder.prototype.createLong=function(e,o){return T.Long.create(e,o)},T.ByteBuffer=function(e){this.bytes_=e,this.position_=0},T.ByteBuffer.allocate=function(e){return new T.ByteBuffer(new Uint8Array(e))},T.ByteBuffer.prototype.clear=function(){this.position_=0},T.ByteBuffer.prototype.bytes=function(){return this.bytes_},T.ByteBuffer.prototype.position=function(){return this.position_},T.ByteBuffer.prototype.setPosition=function(e){this.position_=e},T.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},T.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},T.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},T.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},T.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},T.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},T.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},T.ByteBuffer.prototype.readInt64=function(e){return new T.Long(this.readInt32(e),this.readInt32(e+4))},T.ByteBuffer.prototype.readUint64=function(e){return new T.Long(this.readUint32(e),this.readUint32(e+4))},T.ByteBuffer.prototype.readFloat32=function(e){return T.int32[0]=this.readInt32(e),T.float32[0]},T.ByteBuffer.prototype.readFloat64=function(e){return T.int32[T.isLittleEndian?0:1]=this.readInt32(e),T.int32[T.isLittleEndian?1:0]=this.readInt32(e+4),T.float64[0]},T.ByteBuffer.prototype.writeInt8=function(e,o){this.bytes_[e]=o},T.ByteBuffer.prototype.writeUint8=function(e,o){this.bytes_[e]=o},T.ByteBuffer.prototype.writeInt16=function(e,o){this.bytes_[e]=o,this.bytes_[e+1]=o>>8},T.ByteBuffer.prototype.writeUint16=function(e,o){this.bytes_[e]=o,this.bytes_[e+1]=o>>8},T.ByteBuffer.prototype.writeInt32=function(e,o){this.bytes_[e]=o,this.bytes_[e+1]=o>>8,this.bytes_[e+2]=o>>16,this.bytes_[e+3]=o>>24},T.ByteBuffer.prototype.writeUint32=function(e,o){this.bytes_[e]=o,this.bytes_[e+1]=o>>8,this.bytes_[e+2]=o>>16,this.bytes_[e+3]=o>>24},T.ByteBuffer.prototype.writeInt64=function(e,o){this.writeInt32(e,o.low),this.writeInt32(e+4,o.high)},T.ByteBuffer.prototype.writeUint64=function(e,o){this.writeUint32(e,o.low),this.writeUint32(e+4,o.high)},T.ByteBuffer.prototype.writeFloat32=function(e,o){T.float32[0]=o,this.writeInt32(e,T.int32[0])},T.ByteBuffer.prototype.writeFloat64=function(e,o){T.float64[0]=o,this.writeInt32(e,T.int32[T.isLittleEndian?0:1]),this.writeInt32(e+4,T.int32[T.isLittleEndian?1:0])},T.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+T.SIZEOF_INT+T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",o=0;o<T.FILE_IDENTIFIER_LENGTH;o++)e+=String.fromCharCode(this.readInt8(this.position_+T.SIZEOF_INT+o));return e},T.ByteBuffer.prototype.__offset=function(e,o){var i=e-this.readInt32(e);return o<this.readInt16(i)?this.readInt16(i+o):0},T.ByteBuffer.prototype.__union=function(e,o){return e.bb_pos=o+this.readInt32(o),e.bb=this,e},T.ByteBuffer.prototype.__string=function(e,o){e+=this.readInt32(e);var i=this.readInt32(e),s="",h=0;if(e+=T.SIZEOF_INT,o===T.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+i);for(;h<i;){var a,d=this.readUint8(e+h++);if(d<192)a=d;else{var et=this.readUint8(e+h++);if(d<224)a=(d&31)<<6|et&63;else{var $=this.readUint8(e+h++);if(d<240)a=(d&15)<<12|(et&63)<<6|$&63;else{var c=this.readUint8(e+h++);a=(d&7)<<18|(et&63)<<12|($&63)<<6|c&63}}}a<65536?s+=String.fromCharCode(a):(a-=65536,s+=String.fromCharCode((a>>10)+55296,(a&1023)+56320))}return s},T.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},T.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+T.SIZEOF_INT},T.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},T.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+T.FILE_IDENTIFIER_LENGTH);for(var o=0;o<T.FILE_IDENTIFIER_LENGTH;o++)if(e.charCodeAt(o)!=this.readInt8(this.position_+T.SIZEOF_INT+o))return!1;return!0},T.ByteBuffer.prototype.createLong=function(e,o){return T.Long.create(e,o)}}),F,Pr=O(()=>{xn(),(e=>{(o=>{(i=>{(s=>(s[s.UNDEFINED=0]="UNDEFINED",s[s.FLOAT=1]="FLOAT",s[s.INT=2]="INT",s[s.STRING=3]="STRING",s[s.TENSOR=4]="TENSOR",s[s.GRAPH=5]="GRAPH",s[s.FLOATS=6]="FLOATS",s[s.INTS=7]="INTS",s[s.STRINGS=8]="STRINGS",s[s.TENSORS=9]="TENSORS",s[s.GRAPHS=10]="GRAPHS",s[s.SPARSE_TENSOR=11]="SPARSE_TENSOR",s[s.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(i.AttributeType||={})})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{(s=>(s[s.UNKNOWN=0]="UNKNOWN",s[s.VALUE=1]="VALUE",s[s.PARAM=2]="PARAM"))(i.DimensionValueType||={})})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{(s=>(s[s.UNDEFINED=0]="UNDEFINED",s[s.FLOAT=1]="FLOAT",s[s.UINT8=2]="UINT8",s[s.INT8=3]="INT8",s[s.UINT16=4]="UINT16",s[s.INT16=5]="INT16",s[s.INT32=6]="INT32",s[s.INT64=7]="INT64",s[s.STRING=8]="STRING",s[s.BOOL=9]="BOOL",s[s.FLOAT16=10]="FLOAT16",s[s.DOUBLE=11]="DOUBLE",s[s.UINT32=12]="UINT32",s[s.UINT64=13]="UINT64",s[s.COMPLEX64=14]="COMPLEX64",s[s.COMPLEX128=15]="COMPLEX128",s[s.BFLOAT16=16]="BFLOAT16",s[s.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",s[s.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",s[s.FLOAT8E5M2=19]="FLOAT8E5M2",s[s.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(i.TensorDataType||={})})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{(s=>(s[s.Primitive=0]="Primitive",s[s.Fused=1]="Fused"))(i.NodeType||={})})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{(s=>(s[s.NONE=0]="NONE",s[s.tensor_type=1]="tensor_type",s[s.sequence_type=2]="sequence_type",s[s.map_type=3]="map_type"))(i.TypeInfoValue||={})})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsShape(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsShape(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}dim(a,d){let et=this.bb.__offset(this.bb_pos,4);return et?(d||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}dimLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}static startShape(a){a.startObject(1)}static addDim(a,d){a.addFieldOffset(0,d,0)}static createDimVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startDimVector(a,d){a.startVector(4,d,4)}static endShape(a){return a.endObject()}static createShape(a,d){return s.startShape(a),s.addDim(a,d),s.endShape(a)}}i.Shape=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsDimension(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimension(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}value(a){let d=this.bb.__offset(this.bb_pos,4);return d?(a||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}denotation(a){let d=this.bb.__offset(this.bb_pos,6);return d?this.bb.__string(this.bb_pos+d,a):null}static startDimension(a){a.startObject(2)}static addValue(a,d){a.addFieldOffset(0,d,0)}static addDenotation(a,d){a.addFieldOffset(1,d,0)}static endDimension(a){return a.endObject()}static createDimension(a,d,et){return s.startDimension(a),s.addValue(a,d),s.addDenotation(a,et),s.endDimension(a)}}i.Dimension=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsDimensionValue(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimensionValue(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}dimType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt8(this.bb_pos+a):0}dimValue(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}dimParam(a){let d=this.bb.__offset(this.bb_pos,8);return d?this.bb.__string(this.bb_pos+d,a):null}static startDimensionValue(a){a.startObject(3)}static addDimType(a,d){a.addFieldInt8(0,d,0)}static addDimValue(a,d){a.addFieldInt64(1,d,a.createLong(0,0))}static addDimParam(a,d){a.addFieldOffset(2,d,0)}static endDimensionValue(a){return a.endObject()}static createDimensionValue(a,d,et,$){return s.startDimensionValue(a),s.addDimType(a,d),s.addDimValue(a,et),s.addDimParam(a,$),s.endDimensionValue(a)}}i.DimensionValue=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsTensorTypeAndShape(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensorTypeAndShape(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}elemType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}shape(a){let d=this.bb.__offset(this.bb_pos,6);return d?(a||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}static startTensorTypeAndShape(a){a.startObject(2)}static addElemType(a,d){a.addFieldInt32(0,d,0)}static addShape(a,d){a.addFieldOffset(1,d,0)}static endTensorTypeAndShape(a){return a.endObject()}static createTensorTypeAndShape(a,d,et){return s.startTensorTypeAndShape(a),s.addElemType(a,d),s.addShape(a,et),s.endTensorTypeAndShape(a)}}i.TensorTypeAndShape=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsMapType(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsMapType(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}keyType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}valueType(a){let d=this.bb.__offset(this.bb_pos,6);return d?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}static startMapType(a){a.startObject(2)}static addKeyType(a,d){a.addFieldInt32(0,d,0)}static addValueType(a,d){a.addFieldOffset(1,d,0)}static endMapType(a){return a.endObject()}static createMapType(a,d,et){return s.startMapType(a),s.addKeyType(a,d),s.addValueType(a,et),s.endMapType(a)}}i.MapType=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsSequenceType(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSequenceType(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}elemType(a){let d=this.bb.__offset(this.bb_pos,4);return d?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}static startSequenceType(a){a.startObject(1)}static addElemType(a,d){a.addFieldOffset(0,d,0)}static endSequenceType(a){return a.endObject()}static createSequenceType(a,d){return s.startSequenceType(a),s.addElemType(a,d),s.endSequenceType(a)}}i.SequenceType=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(a,d,et,$){return a.prep(4,12),a.writeInt32($),a.writeInt32(et),a.writeInt32(d),a.offset()}}i.EdgeEnd=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsNodeEdge(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNodeEdge(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}nodeIndex(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb_pos+a):0}inputEdges(a,d){let et=this.bb.__offset(this.bb_pos,6);return et?(d||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+et)+a*12,this.bb):null}inputEdgesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}outputEdges(a,d){let et=this.bb.__offset(this.bb_pos,8);return et?(d||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+et)+a*12,this.bb):null}outputEdgesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNodeEdge(a){a.startObject(3)}static addNodeIndex(a,d){a.addFieldInt32(0,d,0)}static addInputEdges(a,d){a.addFieldOffset(1,d,0)}static startInputEdgesVector(a,d){a.startVector(12,d,4)}static addOutputEdges(a,d){a.addFieldOffset(2,d,0)}static startOutputEdgesVector(a,d){a.startVector(12,d,4)}static endNodeEdge(a){return a.endObject()}static createNodeEdge(a,d,et,$){return s.startNodeEdge(a),s.addNodeIndex(a,d),s.addInputEdges(a,et),s.addOutputEdges(a,$),s.endNodeEdge(a)}}i.NodeEdge=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsNode(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNode(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}name(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.__string(this.bb_pos+d,a):null}docString(a){let d=this.bb.__offset(this.bb_pos,6);return d?this.bb.__string(this.bb_pos+d,a):null}domain(a){let d=this.bb.__offset(this.bb_pos,8);return d?this.bb.__string(this.bb_pos+d,a):null}sinceVersion(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}index(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint32(this.bb_pos+a):0}opType(a){let d=this.bb.__offset(this.bb_pos,14);return d?this.bb.__string(this.bb_pos+d,a):null}type(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.readInt32(this.bb_pos+a):0}executionProviderType(a){let d=this.bb.__offset(this.bb_pos,18);return d?this.bb.__string(this.bb_pos+d,a):null}inputs(a,d){let et=this.bb.__offset(this.bb_pos,20);return et?this.bb.__string(this.bb.__vector(this.bb_pos+et)+a*4,d):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,d){let et=this.bb.__offset(this.bb_pos,22);return et?this.bb.__string(this.bb.__vector(this.bb_pos+et)+a*4,d):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}attributes(a,d){let et=this.bb.__offset(this.bb_pos,24);return et?(d||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}attributesLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCounts(a){let d=this.bb.__offset(this.bb_pos,26);return d?this.bb.readInt32(this.bb.__vector(this.bb_pos+d)+a*4):0}inputArgCountsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCountsArray(){let a=this.bb.__offset(this.bb_pos,26);return a?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}implicitInputs(a,d){let et=this.bb.__offset(this.bb_pos,28);return et?this.bb.__string(this.bb.__vector(this.bb_pos+et)+a*4,d):null}implicitInputsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNode(a){a.startObject(13)}static addName(a,d){a.addFieldOffset(0,d,0)}static addDocString(a,d){a.addFieldOffset(1,d,0)}static addDomain(a,d){a.addFieldOffset(2,d,0)}static addSinceVersion(a,d){a.addFieldInt32(3,d,0)}static addIndex(a,d){a.addFieldInt32(4,d,0)}static addOpType(a,d){a.addFieldOffset(5,d,0)}static addType(a,d){a.addFieldInt32(6,d,0)}static addExecutionProviderType(a,d){a.addFieldOffset(7,d,0)}static addInputs(a,d){a.addFieldOffset(8,d,0)}static createInputsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startInputsVector(a,d){a.startVector(4,d,4)}static addOutputs(a,d){a.addFieldOffset(9,d,0)}static createOutputsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startOutputsVector(a,d){a.startVector(4,d,4)}static addAttributes(a,d){a.addFieldOffset(10,d,0)}static createAttributesVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startAttributesVector(a,d){a.startVector(4,d,4)}static addInputArgCounts(a,d){a.addFieldOffset(11,d,0)}static createInputArgCountsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addInt32(d[et]);return a.endVector()}static startInputArgCountsVector(a,d){a.startVector(4,d,4)}static addImplicitInputs(a,d){a.addFieldOffset(12,d,0)}static createImplicitInputsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startImplicitInputsVector(a,d){a.startVector(4,d,4)}static endNode(a){return a.endObject()}static createNode(a,d,et,$,c,b,g,nt,at,Ot,At,Ct,St,xt){return s.startNode(a),s.addName(a,d),s.addDocString(a,et),s.addDomain(a,$),s.addSinceVersion(a,c),s.addIndex(a,b),s.addOpType(a,g),s.addType(a,nt),s.addExecutionProviderType(a,at),s.addInputs(a,Ot),s.addOutputs(a,At),s.addAttributes(a,Ct),s.addInputArgCounts(a,St),s.addImplicitInputs(a,xt),s.endNode(a)}}i.Node=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsValueInfo(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsValueInfo(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}name(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.__string(this.bb_pos+d,a):null}docString(a){let d=this.bb.__offset(this.bb_pos,6);return d?this.bb.__string(this.bb_pos+d,a):null}type(a){let d=this.bb.__offset(this.bb_pos,8);return d?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}static startValueInfo(a){a.startObject(3)}static addName(a,d){a.addFieldOffset(0,d,0)}static addDocString(a,d){a.addFieldOffset(1,d,0)}static addType(a,d){a.addFieldOffset(2,d,0)}static endValueInfo(a){return a.endObject()}static createValueInfo(a,d,et,$){return s.startValueInfo(a),s.addName(a,d),s.addDocString(a,et),s.addType(a,$),s.endValueInfo(a)}}i.ValueInfo=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsTypeInfo(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTypeInfo(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}denotation(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.__string(this.bb_pos+d,a):null}valueType(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint8(this.bb_pos+a):0}value(a){let d=this.bb.__offset(this.bb_pos,8);return d?this.bb.__union(a,this.bb_pos+d):null}static startTypeInfo(a){a.startObject(3)}static addDenotation(a,d){a.addFieldOffset(0,d,0)}static addValueType(a,d){a.addFieldInt8(1,d,0)}static addValue(a,d){a.addFieldOffset(2,d,0)}static endTypeInfo(a){return a.endObject()}static createTypeInfo(a,d,et,$){return s.startTypeInfo(a),s.addDenotation(a,d),s.addValueType(a,et),s.addValue(a,$),s.endTypeInfo(a)}}i.TypeInfo=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsOperatorSetId(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsOperatorSetId(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}domain(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.__string(this.bb_pos+d,a):null}version(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}static startOperatorSetId(a){a.startObject(2)}static addDomain(a,d){a.addFieldOffset(0,d,0)}static addVersion(a,d){a.addFieldInt64(1,d,a.createLong(0,0))}static endOperatorSetId(a){return a.endObject()}static createOperatorSetId(a,d,et){return s.startOperatorSetId(a),s.addDomain(a,d),s.addVersion(a,et),s.endOperatorSetId(a)}}i.OperatorSetId=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsTensor(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensor(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}name(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.__string(this.bb_pos+d,a):null}docString(a){let d=this.bb.__offset(this.bb_pos,6);return d?this.bb.__string(this.bb_pos+d,a):null}dims(a){let d=this.bb.__offset(this.bb_pos,8);return d?this.bb.readInt64(this.bb.__vector(this.bb_pos+d)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}dataType(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}rawData(a){let d=this.bb.__offset(this.bb_pos,12);return d?this.bb.readUint8(this.bb.__vector(this.bb_pos+d)+a):0}rawDataLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}rawDataArray(){let a=this.bb.__offset(this.bb_pos,12);return a?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}stringData(a,d){let et=this.bb.__offset(this.bb_pos,14);return et?this.bb.__string(this.bb.__vector(this.bb_pos+et)+a*4,d):null}stringDataLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}static startTensor(a){a.startObject(6)}static addName(a,d){a.addFieldOffset(0,d,0)}static addDocString(a,d){a.addFieldOffset(1,d,0)}static addDims(a,d){a.addFieldOffset(2,d,0)}static createDimsVector(a,d){a.startVector(8,d.length,8);for(let et=d.length-1;et>=0;et--)a.addInt64(d[et]);return a.endVector()}static startDimsVector(a,d){a.startVector(8,d,8)}static addDataType(a,d){a.addFieldInt32(3,d,0)}static addRawData(a,d){a.addFieldOffset(4,d,0)}static createRawDataVector(a,d){a.startVector(1,d.length,1);for(let et=d.length-1;et>=0;et--)a.addInt8(d[et]);return a.endVector()}static startRawDataVector(a,d){a.startVector(1,d,1)}static addStringData(a,d){a.addFieldOffset(5,d,0)}static createStringDataVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startStringDataVector(a,d){a.startVector(4,d,4)}static endTensor(a){return a.endObject()}static createTensor(a,d,et,$,c,b,g){return s.startTensor(a),s.addName(a,d),s.addDocString(a,et),s.addDims(a,$),s.addDataType(a,c),s.addRawData(a,b),s.addStringData(a,g),s.endTensor(a)}}i.Tensor=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsSparseTensor(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSparseTensor(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}values(a){let d=this.bb.__offset(this.bb_pos,4);return d?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}indices(a){let d=this.bb.__offset(this.bb_pos,6);return d?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}dims(a){let d=this.bb.__offset(this.bb_pos,8);return d?this.bb.readInt64(this.bb.__vector(this.bb_pos+d)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSparseTensor(a){a.startObject(3)}static addValues(a,d){a.addFieldOffset(0,d,0)}static addIndices(a,d){a.addFieldOffset(1,d,0)}static addDims(a,d){a.addFieldOffset(2,d,0)}static createDimsVector(a,d){a.startVector(8,d.length,8);for(let et=d.length-1;et>=0;et--)a.addInt64(d[et]);return a.endVector()}static startDimsVector(a,d){a.startVector(8,d,8)}static endSparseTensor(a){return a.endObject()}static createSparseTensor(a,d,et,$){return s.startSparseTensor(a),s.addValues(a,d),s.addIndices(a,et),s.addDims(a,$),s.endSparseTensor(a)}}i.SparseTensor=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsAttribute(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsAttribute(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}name(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.__string(this.bb_pos+d,a):null}docString(a){let d=this.bb.__offset(this.bb_pos,6);return d?this.bb.__string(this.bb_pos+d,a):null}type(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt32(this.bb_pos+a):0}f(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readFloat32(this.bb_pos+a):0}i(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}s(a){let d=this.bb.__offset(this.bb_pos,14);return d?this.bb.__string(this.bb_pos+d,a):null}t(a){let d=this.bb.__offset(this.bb_pos,16);return d?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}g(a){let d=this.bb.__offset(this.bb_pos,18);return d?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}floats(a){let d=this.bb.__offset(this.bb_pos,20);return d?this.bb.readFloat32(this.bb.__vector(this.bb_pos+d)+a*4):0}floatsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}floatsArray(){let a=this.bb.__offset(this.bb_pos,20);return a?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}ints(a){let d=this.bb.__offset(this.bb_pos,22);return d?this.bb.readInt64(this.bb.__vector(this.bb_pos+d)+a*8):this.bb.createLong(0,0)}intsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}strings(a,d){let et=this.bb.__offset(this.bb_pos,24);return et?this.bb.__string(this.bb.__vector(this.bb_pos+et)+a*4,d):null}stringsLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}tensors(a,d){let et=this.bb.__offset(this.bb_pos,26);return et?(d||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}tensorsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}graphs(a,d){let et=this.bb.__offset(this.bb_pos,28);return et?(d||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}graphsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startAttribute(a){a.startObject(13)}static addName(a,d){a.addFieldOffset(0,d,0)}static addDocString(a,d){a.addFieldOffset(1,d,0)}static addType(a,d){a.addFieldInt32(2,d,0)}static addF(a,d){a.addFieldFloat32(3,d,0)}static addI(a,d){a.addFieldInt64(4,d,a.createLong(0,0))}static addS(a,d){a.addFieldOffset(5,d,0)}static addT(a,d){a.addFieldOffset(6,d,0)}static addG(a,d){a.addFieldOffset(7,d,0)}static addFloats(a,d){a.addFieldOffset(8,d,0)}static createFloatsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addFloat32(d[et]);return a.endVector()}static startFloatsVector(a,d){a.startVector(4,d,4)}static addInts(a,d){a.addFieldOffset(9,d,0)}static createIntsVector(a,d){a.startVector(8,d.length,8);for(let et=d.length-1;et>=0;et--)a.addInt64(d[et]);return a.endVector()}static startIntsVector(a,d){a.startVector(8,d,8)}static addStrings(a,d){a.addFieldOffset(10,d,0)}static createStringsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startStringsVector(a,d){a.startVector(4,d,4)}static addTensors(a,d){a.addFieldOffset(11,d,0)}static createTensorsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startTensorsVector(a,d){a.startVector(4,d,4)}static addGraphs(a,d){a.addFieldOffset(12,d,0)}static createGraphsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startGraphsVector(a,d){a.startVector(4,d,4)}static endAttribute(a){return a.endObject()}static createAttribute(a,d,et,$,c,b,g,nt,at,Ot,At,Ct,St,xt){return s.startAttribute(a),s.addName(a,d),s.addDocString(a,et),s.addType(a,$),s.addF(a,c),s.addI(a,b),s.addS(a,g),s.addT(a,nt),s.addG(a,at),s.addFloats(a,Ot),s.addInts(a,At),s.addStrings(a,Ct),s.addTensors(a,St),s.addGraphs(a,xt),s.endAttribute(a)}}i.Attribute=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsGraph(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsGraph(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}initializers(a,d){let et=this.bb.__offset(this.bb_pos,4);return et?(d||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}initializersLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeArgs(a,d){let et=this.bb.__offset(this.bb_pos,6);return et?(d||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}nodeArgsLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}nodes(a,d){let et=this.bb.__offset(this.bb_pos,8);return et?(d||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}nodesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}maxNodeIndex(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readUint32(this.bb_pos+a):0}nodeEdges(a,d){let et=this.bb.__offset(this.bb_pos,12);return et?(d||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}nodeEdgesLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}inputs(a,d){let et=this.bb.__offset(this.bb_pos,14);return et?this.bb.__string(this.bb.__vector(this.bb_pos+et)+a*4,d):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,d){let et=this.bb.__offset(this.bb_pos,16);return et?this.bb.__string(this.bb.__vector(this.bb_pos+et)+a*4,d):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__vector_len(this.bb_pos+a):0}sparseInitializers(a,d){let et=this.bb.__offset(this.bb_pos,18);return et?(d||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}sparseInitializersLength(){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__vector_len(this.bb_pos+a):0}static startGraph(a){a.startObject(8)}static addInitializers(a,d){a.addFieldOffset(0,d,0)}static createInitializersVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startInitializersVector(a,d){a.startVector(4,d,4)}static addNodeArgs(a,d){a.addFieldOffset(1,d,0)}static createNodeArgsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startNodeArgsVector(a,d){a.startVector(4,d,4)}static addNodes(a,d){a.addFieldOffset(2,d,0)}static createNodesVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startNodesVector(a,d){a.startVector(4,d,4)}static addMaxNodeIndex(a,d){a.addFieldInt32(3,d,0)}static addNodeEdges(a,d){a.addFieldOffset(4,d,0)}static createNodeEdgesVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startNodeEdgesVector(a,d){a.startVector(4,d,4)}static addInputs(a,d){a.addFieldOffset(5,d,0)}static createInputsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startInputsVector(a,d){a.startVector(4,d,4)}static addOutputs(a,d){a.addFieldOffset(6,d,0)}static createOutputsVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startOutputsVector(a,d){a.startVector(4,d,4)}static addSparseInitializers(a,d){a.addFieldOffset(7,d,0)}static createSparseInitializersVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startSparseInitializersVector(a,d){a.startVector(4,d,4)}static endGraph(a){return a.endObject()}static createGraph(a,d,et,$,c,b,g,nt,at){return s.startGraph(a),s.addInitializers(a,d),s.addNodeArgs(a,et),s.addNodes(a,$),s.addMaxNodeIndex(a,c),s.addNodeEdges(a,b),s.addInputs(a,g),s.addOutputs(a,nt),s.addSparseInitializers(a,at),s.endGraph(a)}}i.Graph=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsModel(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsModel(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}irVersion(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}opsetImport(a,d){let et=this.bb.__offset(this.bb_pos,6);return et?(d||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}opsetImportLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}producerName(a){let d=this.bb.__offset(this.bb_pos,8);return d?this.bb.__string(this.bb_pos+d,a):null}producerVersion(a){let d=this.bb.__offset(this.bb_pos,10);return d?this.bb.__string(this.bb_pos+d,a):null}domain(a){let d=this.bb.__offset(this.bb_pos,12);return d?this.bb.__string(this.bb_pos+d,a):null}modelVersion(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}docString(a){let d=this.bb.__offset(this.bb_pos,16);return d?this.bb.__string(this.bb_pos+d,a):null}graph(a){let d=this.bb.__offset(this.bb_pos,18);return d?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}graphDocString(a){let d=this.bb.__offset(this.bb_pos,20);return d?this.bb.__string(this.bb_pos+d,a):null}static startModel(a){a.startObject(9)}static addIrVersion(a,d){a.addFieldInt64(0,d,a.createLong(0,0))}static addOpsetImport(a,d){a.addFieldOffset(1,d,0)}static createOpsetImportVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startOpsetImportVector(a,d){a.startVector(4,d,4)}static addProducerName(a,d){a.addFieldOffset(2,d,0)}static addProducerVersion(a,d){a.addFieldOffset(3,d,0)}static addDomain(a,d){a.addFieldOffset(4,d,0)}static addModelVersion(a,d){a.addFieldInt64(5,d,a.createLong(0,0))}static addDocString(a,d){a.addFieldOffset(6,d,0)}static addGraph(a,d){a.addFieldOffset(7,d,0)}static addGraphDocString(a,d){a.addFieldOffset(8,d,0)}static endModel(a){return a.endObject()}static createModel(a,d,et,$,c,b,g,nt,at,Ot){return s.startModel(a),s.addIrVersion(a,d),s.addOpsetImport(a,et),s.addProducerName(a,$),s.addProducerVersion(a,c),s.addDomain(a,b),s.addModelVersion(a,g),s.addDocString(a,nt),s.addGraph(a,at),s.addGraphDocString(a,Ot),s.endModel(a)}}i.Model=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsKernelCreateInfos(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsKernelCreateInfos(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}nodeIndices(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.readUint32(this.bb.__vector(this.bb_pos+d)+a*4):0}nodeIndicesLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeIndicesArray(){let a=this.bb.__offset(this.bb_pos,4);return a?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}kernelDefHashes(a){let d=this.bb.__offset(this.bb_pos,6);return d?this.bb.readUint64(this.bb.__vector(this.bb_pos+d)+a*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startKernelCreateInfos(a){a.startObject(2)}static addNodeIndices(a,d){a.addFieldOffset(0,d,0)}static createNodeIndicesVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addInt32(d[et]);return a.endVector()}static startNodeIndicesVector(a,d){a.startVector(4,d,4)}static addKernelDefHashes(a,d){a.addFieldOffset(1,d,0)}static createKernelDefHashesVector(a,d){a.startVector(8,d.length,8);for(let et=d.length-1;et>=0;et--)a.addInt64(d[et]);return a.endVector()}static startKernelDefHashesVector(a,d){a.startVector(8,d,8)}static endKernelCreateInfos(a){return a.endObject()}static createKernelCreateInfos(a,d,et){return s.startKernelCreateInfos(a),s.addNodeIndices(a,d),s.addKernelDefHashes(a,et),s.endKernelCreateInfos(a)}}i.KernelCreateInfos=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsSubGraphSessionState(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSubGraphSessionState(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}graphId(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.__string(this.bb_pos+d,a):null}sessionState(a){let d=this.bb.__offset(this.bb_pos,6);return d?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}static startSubGraphSessionState(a){a.startObject(2)}static addGraphId(a,d){a.addFieldOffset(0,d,0)}static addSessionState(a,d){a.addFieldOffset(1,d,0)}static endSubGraphSessionState(a){let d=a.endObject();return a.requiredField(d,4),d}static createSubGraphSessionState(a,d,et){return s.startSubGraphSessionState(a),s.addGraphId(a,d),s.addSessionState(a,et),s.endSubGraphSessionState(a)}}i.SubGraphSessionState=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsSessionState(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSessionState(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}kernels(a){let d=this.bb.__offset(this.bb_pos,4);return d?(a||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}subGraphSessionStates(a,d){let et=this.bb.__offset(this.bb_pos,6);return et?(d||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+et)+a*4),this.bb):null}subGraphSessionStatesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSessionState(a){a.startObject(2)}static addKernels(a,d){a.addFieldOffset(0,d,0)}static addSubGraphSessionStates(a,d){a.addFieldOffset(1,d,0)}static createSubGraphSessionStatesVector(a,d){a.startVector(4,d.length,4);for(let et=d.length-1;et>=0;et--)a.addOffset(d[et]);return a.endVector()}static startSubGraphSessionStatesVector(a,d){a.startVector(4,d,4)}static endSessionState(a){return a.endObject()}static createSessionState(a,d,et){return s.startSessionState(a),s.addKernels(a,d),s.addSubGraphSessionStates(a,et),s.endSessionState(a)}}i.SessionState=s})(o.fbs||={})})(e.experimental||={})})(F||={}),(e=>{(o=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(a,d){return this.bb_pos=a,this.bb=d,this}static getRootAsInferenceSession(a,d){return(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsInferenceSession(a,d){return a.setPosition(a.position()+T.SIZE_PREFIX_LENGTH),(d||new s).__init(a.readInt32(a.position())+a.position(),a)}static bufferHasIdentifier(a){return a.__has_identifier("ORTM")}ortVersion(a){let d=this.bb.__offset(this.bb_pos,4);return d?this.bb.__string(this.bb_pos+d,a):null}model(a){let d=this.bb.__offset(this.bb_pos,6);return d?(a||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}sessionState(a){let d=this.bb.__offset(this.bb_pos,8);return d?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+d),this.bb):null}static startInferenceSession(a){a.startObject(3)}static addOrtVersion(a,d){a.addFieldOffset(0,d,0)}static addModel(a,d){a.addFieldOffset(1,d,0)}static addSessionState(a,d){a.addFieldOffset(2,d,0)}static endInferenceSession(a){return a.endObject()}static finishInferenceSessionBuffer(a,d){a.finish(d,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(a,d){a.finish(d,"ORTM",!0)}static createInferenceSession(a,d,et,$){return s.startInferenceSession(a),s.addOrtVersion(a,d),s.addModel(a,et),s.addSessionState(a,$),s.endInferenceSession(a)}}i.InferenceSession=s})(o.fbs||={})})(e.experimental||={})})(F||={})}),Hs=mt((e,o)=>{o.exports=i;function i(s,h){for(var a=new Array(arguments.length-1),d=0,et=2,$=!0;et<arguments.length;)a[d++]=arguments[et++];return new Promise(function(c,b){a[d]=function(g){if($)if($=!1,g)b(g);else{for(var nt=new Array(arguments.length-1),at=0;at<nt.length;)nt[at++]=arguments[at];c.apply(null,nt)}};try{s.apply(h||null,a)}catch(g){$&&($=!1,b(g))}})}}),Ks=mt(e=>{var o=e;o.length=function(d){var et=d.length;if(!et)return 0;for(var $=0;--et%4>1&&d.charAt(et)==="=";)++$;return Math.ceil(d.length*3)/4-$};var i=new Array(64),s=new Array(123);for(h=0;h<64;)s[i[h]=h<26?h+65:h<52?h+71:h<62?h-4:h-59|43]=h++;var h;o.encode=function(d,et,$){for(var c=null,b=[],g=0,nt=0,at;et<$;){var Ot=d[et++];switch(nt){case 0:b[g++]=i[Ot>>2],at=(Ot&3)<<4,nt=1;break;case 1:b[g++]=i[at|Ot>>4],at=(Ot&15)<<2,nt=2;break;case 2:b[g++]=i[at|Ot>>6],b[g++]=i[Ot&63],nt=0;break}g>8191&&((c||(c=[])).push(String.fromCharCode.apply(String,b)),g=0)}return nt&&(b[g++]=i[at],b[g++]=61,nt===1&&(b[g++]=61)),c?(g&&c.push(String.fromCharCode.apply(String,b.slice(0,g))),c.join("")):String.fromCharCode.apply(String,b.slice(0,g))};var a="invalid encoding";o.decode=function(d,et,$){for(var c=$,b=0,g,nt=0;nt<d.length;){var at=d.charCodeAt(nt++);if(at===61&&b>1)break;if((at=s[at])===void 0)throw Error(a);switch(b){case 0:g=at,b=1;break;case 1:et[$++]=g<<2|(at&48)>>4,g=at,b=2;break;case 2:et[$++]=(g&15)<<4|(at&60)>>2,g=at,b=3;break;case 3:et[$++]=(g&3)<<6|at,b=0;break}}if(b===1)throw Error(a);return $-c},o.test=function(d){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(d)}}),Ys=mt((e,o)=>{o.exports=i;function i(){this._listeners={}}i.prototype.on=function(s,h,a){return(this._listeners[s]||(this._listeners[s]=[])).push({fn:h,ctx:a||this}),this},i.prototype.off=function(s,h){if(s===void 0)this._listeners={};else if(h===void 0)this._listeners[s]=[];else for(var a=this._listeners[s],d=0;d<a.length;)a[d].fn===h?a.splice(d,1):++d;return this},i.prototype.emit=function(s){var h=this._listeners[s];if(h){for(var a=[],d=1;d<arguments.length;)a.push(arguments[d++]);for(d=0;d<h.length;)h[d].fn.apply(h[d++].ctx,a)}return this}}),ou=mt((e,o)=>{o.exports=i(i);function i(et){return typeof Float32Array<"u"?function(){var $=new Float32Array([-0]),c=new Uint8Array($.buffer),b=c[3]===128;function g(At,Ct,St){$[0]=At,Ct[St]=c[0],Ct[St+1]=c[1],Ct[St+2]=c[2],Ct[St+3]=c[3]}function nt(At,Ct,St){$[0]=At,Ct[St]=c[3],Ct[St+1]=c[2],Ct[St+2]=c[1],Ct[St+3]=c[0]}et.writeFloatLE=b?g:nt,et.writeFloatBE=b?nt:g;function at(At,Ct){return c[0]=At[Ct],c[1]=At[Ct+1],c[2]=At[Ct+2],c[3]=At[Ct+3],$[0]}function Ot(At,Ct){return c[3]=At[Ct],c[2]=At[Ct+1],c[1]=At[Ct+2],c[0]=At[Ct+3],$[0]}et.readFloatLE=b?at:Ot,et.readFloatBE=b?Ot:at}():function(){function $(b,g,nt,at){var Ot=g<0?1:0;if(Ot&&(g=-g),g===0)b(1/g>0?0:2147483648,nt,at);else if(isNaN(g))b(2143289344,nt,at);else if(g>34028234663852886e22)b((Ot<<31|2139095040)>>>0,nt,at);else if(g<11754943508222875e-54)b((Ot<<31|Math.round(g/1401298464324817e-60))>>>0,nt,at);else{var At=Math.floor(Math.log(g)/Math.LN2),Ct=Math.round(g*Math.pow(2,-At)*8388608)&8388607;b((Ot<<31|At+127<<23|Ct)>>>0,nt,at)}}et.writeFloatLE=$.bind(null,s),et.writeFloatBE=$.bind(null,h);function c(b,g,nt){var at=b(g,nt),Ot=(at>>31)*2+1,At=at>>>23&255,Ct=at&8388607;return At===255?Ct?NaN:Ot*(1/0):At===0?Ot*1401298464324817e-60*Ct:Ot*Math.pow(2,At-150)*(Ct+8388608)}et.readFloatLE=c.bind(null,a),et.readFloatBE=c.bind(null,d)}(),typeof Float64Array<"u"?function(){var $=new Float64Array([-0]),c=new Uint8Array($.buffer),b=c[7]===128;function g(At,Ct,St){$[0]=At,Ct[St]=c[0],Ct[St+1]=c[1],Ct[St+2]=c[2],Ct[St+3]=c[3],Ct[St+4]=c[4],Ct[St+5]=c[5],Ct[St+6]=c[6],Ct[St+7]=c[7]}function nt(At,Ct,St){$[0]=At,Ct[St]=c[7],Ct[St+1]=c[6],Ct[St+2]=c[5],Ct[St+3]=c[4],Ct[St+4]=c[3],Ct[St+5]=c[2],Ct[St+6]=c[1],Ct[St+7]=c[0]}et.writeDoubleLE=b?g:nt,et.writeDoubleBE=b?nt:g;function at(At,Ct){return c[0]=At[Ct],c[1]=At[Ct+1],c[2]=At[Ct+2],c[3]=At[Ct+3],c[4]=At[Ct+4],c[5]=At[Ct+5],c[6]=At[Ct+6],c[7]=At[Ct+7],$[0]}function Ot(At,Ct){return c[7]=At[Ct],c[6]=At[Ct+1],c[5]=At[Ct+2],c[4]=At[Ct+3],c[3]=At[Ct+4],c[2]=At[Ct+5],c[1]=At[Ct+6],c[0]=At[Ct+7],$[0]}et.readDoubleLE=b?at:Ot,et.readDoubleBE=b?Ot:at}():function(){function $(b,g,nt,at,Ot,At){var Ct=at<0?1:0;if(Ct&&(at=-at),at===0)b(0,Ot,At+g),b(1/at>0?0:2147483648,Ot,At+nt);else if(isNaN(at))b(0,Ot,At+g),b(2146959360,Ot,At+nt);else if(at>17976931348623157e292)b(0,Ot,At+g),b((Ct<<31|2146435072)>>>0,Ot,At+nt);else{var St;if(at<22250738585072014e-324)St=at/5e-324,b(St>>>0,Ot,At+g),b((Ct<<31|St/4294967296)>>>0,Ot,At+nt);else{var xt=Math.floor(Math.log(at)/Math.LN2);xt===1024&&(xt=1023),St=at*Math.pow(2,-xt),b(St*4503599627370496>>>0,Ot,At+g),b((Ct<<31|xt+1023<<20|St*1048576&1048575)>>>0,Ot,At+nt)}}}et.writeDoubleLE=$.bind(null,s,0,4),et.writeDoubleBE=$.bind(null,h,4,0);function c(b,g,nt,at,Ot){var At=b(at,Ot+g),Ct=b(at,Ot+nt),St=(Ct>>31)*2+1,xt=Ct>>>20&2047,Dt=4294967296*(Ct&1048575)+At;return xt===2047?Dt?NaN:St*(1/0):xt===0?St*5e-324*Dt:St*Math.pow(2,xt-1075)*(Dt+4503599627370496)}et.readDoubleLE=c.bind(null,a,0,4),et.readDoubleBE=c.bind(null,d,4,0)}(),et}function s(et,$,c){$[c]=et&255,$[c+1]=et>>>8&255,$[c+2]=et>>>16&255,$[c+3]=et>>>24}function h(et,$,c){$[c]=et>>>24,$[c+1]=et>>>16&255,$[c+2]=et>>>8&255,$[c+3]=et&255}function a(et,$){return(et[$]|et[$+1]<<8|et[$+2]<<16|et[$+3]<<24)>>>0}function d(et,$){return(et[$]<<24|et[$+1]<<16|et[$+2]<<8|et[$+3])>>>0}}),iu=mt((exports,module)=>{module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}}),su=mt(e=>{var o=e;o.length=function(i){for(var s=0,h=0,a=0;a<i.length;++a)h=i.charCodeAt(a),h<128?s+=1:h<2048?s+=2:(h&64512)===55296&&(i.charCodeAt(a+1)&64512)===56320?(++a,s+=4):s+=3;return s},o.read=function(i,s,h){var a=h-s;if(a<1)return"";for(var d=null,et=[],$=0,c;s<h;)c=i[s++],c<128?et[$++]=c:c>191&&c<224?et[$++]=(c&31)<<6|i[s++]&63:c>239&&c<365?(c=((c&7)<<18|(i[s++]&63)<<12|(i[s++]&63)<<6|i[s++]&63)-65536,et[$++]=55296+(c>>10),et[$++]=56320+(c&1023)):et[$++]=(c&15)<<12|(i[s++]&63)<<6|i[s++]&63,$>8191&&((d||(d=[])).push(String.fromCharCode.apply(String,et)),$=0);return d?($&&d.push(String.fromCharCode.apply(String,et.slice(0,$))),d.join("")):String.fromCharCode.apply(String,et.slice(0,$))},o.write=function(i,s,h){for(var a=h,d,et,$=0;$<i.length;++$)d=i.charCodeAt($),d<128?s[h++]=d:d<2048?(s[h++]=d>>6|192,s[h++]=d&63|128):(d&64512)===55296&&((et=i.charCodeAt($+1))&64512)===56320?(d=65536+((d&1023)<<10)+(et&1023),++$,s[h++]=d>>18|240,s[h++]=d>>12&63|128,s[h++]=d>>6&63|128,s[h++]=d&63|128):(s[h++]=d>>12|224,s[h++]=d>>6&63|128,s[h++]=d&63|128);return h-a}}),lu=mt((e,o)=>{o.exports=i;function i(s,h,a){var d=a||8192,et=d>>>1,$=null,c=d;return function(b){if(b<1||b>et)return s(b);c+b>d&&($=s(d),c=0);var g=h.call($,c,c+=b);return c&7&&(c=(c|7)+1),g}}}),cu=mt((e,o)=>{o.exports=s;var i=Oe();function s(et,$){this.lo=et>>>0,this.hi=$>>>0}var h=s.zero=new s(0,0);h.toNumber=function(){return 0},h.zzEncode=h.zzDecode=function(){return this},h.length=function(){return 1};var a=s.zeroHash="\0\0\0\0\0\0\0\0";s.fromNumber=function(et){if(et===0)return h;var $=et<0;$&&(et=-et);var c=et>>>0,b=(et-c)/4294967296>>>0;return $&&(b=~b>>>0,c=~c>>>0,++c>4294967295&&(c=0,++b>4294967295&&(b=0))),new s(c,b)},s.from=function(et){if(typeof et=="number")return s.fromNumber(et);if(i.isString(et))if(i.Long)et=i.Long.fromString(et);else return s.fromNumber(parseInt(et,10));return et.low||et.high?new s(et.low>>>0,et.high>>>0):h},s.prototype.toNumber=function(et){if(!et&&this.hi>>>31){var $=~this.lo+1>>>0,c=~this.hi>>>0;return $||(c=c+1>>>0),-($+c*4294967296)}return this.lo+this.hi*4294967296},s.prototype.toLong=function(et){return i.Long?new i.Long(this.lo|0,this.hi|0,!!et):{low:this.lo|0,high:this.hi|0,unsigned:!!et}};var d=String.prototype.charCodeAt;s.fromHash=function(et){return et===a?h:new s((d.call(et,0)|d.call(et,1)<<8|d.call(et,2)<<16|d.call(et,3)<<24)>>>0,(d.call(et,4)|d.call(et,5)<<8|d.call(et,6)<<16|d.call(et,7)<<24)>>>0)},s.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},s.prototype.zzEncode=function(){var et=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^et)>>>0,this.lo=(this.lo<<1^et)>>>0,this},s.prototype.zzDecode=function(){var et=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^et)>>>0,this.hi=(this.hi>>>1^et)>>>0,this},s.prototype.length=function(){var et=this.lo,$=(this.lo>>>28|this.hi<<4)>>>0,c=this.hi>>>24;return c===0?$===0?et<16384?et<128?1:2:et<2097152?3:4:$<16384?$<128?5:6:$<2097152?7:8:c<128?9:10}}),Oe=mt(e=>{var o=e;o.asPromise=Hs(),o.base64=Ks(),o.EventEmitter=Ys(),o.float=ou(),o.inquire=iu(),o.utf8=su(),o.pool=lu(),o.LongBits=cu(),o.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),o.global=o.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||e,o.emptyArray=Object.freeze?Object.freeze([]):[],o.emptyObject=Object.freeze?Object.freeze({}):{},o.isInteger=Number.isInteger||function(h){return typeof h=="number"&&isFinite(h)&&Math.floor(h)===h},o.isString=function(h){return typeof h=="string"||h instanceof String},o.isObject=function(h){return h&&typeof h=="object"},o.isset=o.isSet=function(h,a){var d=h[a];return d!=null&&h.hasOwnProperty(a)?typeof d!="object"||(Array.isArray(d)?d.length:Object.keys(d).length)>0:!1},o.Buffer=function(){try{var h=o.inquire("buffer").Buffer;return h.prototype.utf8Write?h:null}catch{return null}}(),o._Buffer_from=null,o._Buffer_allocUnsafe=null,o.newBuffer=function(h){return typeof h=="number"?o.Buffer?o._Buffer_allocUnsafe(h):new o.Array(h):o.Buffer?o._Buffer_from(h):typeof Uint8Array>"u"?h:new Uint8Array(h)},o.Array=typeof Uint8Array<"u"?Uint8Array:Array,o.Long=o.global.dcodeIO&&o.global.dcodeIO.Long||o.global.Long||o.inquire("long"),o.key2Re=/^true|false|0|1$/,o.key32Re=/^-?(?:0|[1-9][0-9]*)$/,o.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,o.longToHash=function(h){return h?o.LongBits.from(h).toHash():o.LongBits.zeroHash},o.longFromHash=function(h,a){var d=o.LongBits.fromHash(h);return o.Long?o.Long.fromBits(d.lo,d.hi,a):d.toNumber(!!a)};function i(h,a,d){for(var et=Object.keys(a),$=0;$<et.length;++$)(h[et[$]]===void 0||!d)&&(h[et[$]]=a[et[$]]);return h}o.merge=i,o.lcFirst=function(h){return h.charAt(0).toLowerCase()+h.substring(1)};function s(h){function a(d,et){if(!(this instanceof a))return new a(d,et);Object.defineProperty(this,"message",{get:function(){return d}}),Error.captureStackTrace?Error.captureStackTrace(this,a):Object.defineProperty(this,"stack",{value:new Error().stack||""}),et&&i(this,et)}return a.prototype=Object.create(Error.prototype,{constructor:{value:a,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return h},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),a}o.newError=s,o.ProtocolError=s("ProtocolError"),o.oneOfGetter=function(h){for(var a={},d=0;d<h.length;++d)a[h[d]]=1;return function(){for(var et=Object.keys(this),$=et.length-1;$>-1;--$)if(a[et[$]]===1&&this[et[$]]!==void 0&&this[et[$]]!==null)return et[$]}},o.oneOfSetter=function(h){return function(a){for(var d=0;d<h.length;++d)h[d]!==a&&delete this[h[d]]}},o.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},o._configure=function(){var h=o.Buffer;if(!h){o._Buffer_from=o._Buffer_allocUnsafe=null;return}o._Buffer_from=h.from!==Uint8Array.from&&h.from||function(a,d){return new h(a,d)},o._Buffer_allocUnsafe=h.allocUnsafe||function(a){return new h(a)}}}),Zo=mt((e,o)=>{o.exports=b;var i=Oe(),s,h=i.LongBits,a=i.base64,d=i.utf8;function et(xt,Dt,Qt){this.fn=xt,this.len=Dt,this.next=void 0,this.val=Qt}function $(){}function c(xt){this.head=xt.head,this.tail=xt.tail,this.len=xt.len,this.next=xt.states}function b(){this.len=0,this.head=new et($,0,0),this.tail=this.head,this.states=null}var g=function(){return i.Buffer?function(){return(b.create=function(){return new s})()}:function(){return new b}};b.create=g(),b.alloc=function(xt){return new i.Array(xt)},i.Array!==Array&&(b.alloc=i.pool(b.alloc,i.Array.prototype.subarray)),b.prototype._push=function(xt,Dt,Qt){return this.tail=this.tail.next=new et(xt,Dt,Qt),this.len+=Dt,this};function nt(xt,Dt,Qt){Dt[Qt]=xt&255}function at(xt,Dt,Qt){for(;xt>127;)Dt[Qt++]=xt&127|128,xt>>>=7;Dt[Qt]=xt}function Ot(xt,Dt){this.len=xt,this.next=void 0,this.val=Dt}Ot.prototype=Object.create(et.prototype),Ot.prototype.fn=at,b.prototype.uint32=function(xt){return this.len+=(this.tail=this.tail.next=new Ot((xt=xt>>>0)<128?1:xt<16384?2:xt<2097152?3:xt<268435456?4:5,xt)).len,this},b.prototype.int32=function(xt){return xt<0?this._push(At,10,h.fromNumber(xt)):this.uint32(xt)},b.prototype.sint32=function(xt){return this.uint32((xt<<1^xt>>31)>>>0)};function At(xt,Dt,Qt){for(;xt.hi;)Dt[Qt++]=xt.lo&127|128,xt.lo=(xt.lo>>>7|xt.hi<<25)>>>0,xt.hi>>>=7;for(;xt.lo>127;)Dt[Qt++]=xt.lo&127|128,xt.lo=xt.lo>>>7;Dt[Qt++]=xt.lo}b.prototype.uint64=function(xt){var Dt=h.from(xt);return this._push(At,Dt.length(),Dt)},b.prototype.int64=b.prototype.uint64,b.prototype.sint64=function(xt){var Dt=h.from(xt).zzEncode();return this._push(At,Dt.length(),Dt)},b.prototype.bool=function(xt){return this._push(nt,1,xt?1:0)};function Ct(xt,Dt,Qt){Dt[Qt]=xt&255,Dt[Qt+1]=xt>>>8&255,Dt[Qt+2]=xt>>>16&255,Dt[Qt+3]=xt>>>24}b.prototype.fixed32=function(xt){return this._push(Ct,4,xt>>>0)},b.prototype.sfixed32=b.prototype.fixed32,b.prototype.fixed64=function(xt){var Dt=h.from(xt);return this._push(Ct,4,Dt.lo)._push(Ct,4,Dt.hi)},b.prototype.sfixed64=b.prototype.fixed64,b.prototype.float=function(xt){return this._push(i.float.writeFloatLE,4,xt)},b.prototype.double=function(xt){return this._push(i.float.writeDoubleLE,8,xt)};var St=i.Array.prototype.set?function(xt,Dt,Qt){Dt.set(xt,Qt)}:function(xt,Dt,Qt){for(var Zt=0;Zt<xt.length;++Zt)Dt[Qt+Zt]=xt[Zt]};b.prototype.bytes=function(xt){var Dt=xt.length>>>0;if(!Dt)return this._push(nt,1,0);if(i.isString(xt)){var Qt=b.alloc(Dt=a.length(xt));a.decode(xt,Qt,0),xt=Qt}return this.uint32(Dt)._push(St,Dt,xt)},b.prototype.string=function(xt){var Dt=d.length(xt);return Dt?this.uint32(Dt)._push(d.write,Dt,xt):this._push(nt,1,0)},b.prototype.fork=function(){return this.states=new c(this),this.head=this.tail=new et($,0,0),this.len=0,this},b.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new et($,0,0),this.len=0),this},b.prototype.ldelim=function(){var xt=this.head,Dt=this.tail,Qt=this.len;return this.reset().uint32(Qt),Qt&&(this.tail.next=xt.next,this.tail=Dt,this.len+=Qt),this},b.prototype.finish=function(){for(var xt=this.head.next,Dt=this.constructor.alloc(this.len),Qt=0;xt;)xt.fn(xt.val,Dt,Qt),Qt+=xt.len,xt=xt.next;return Dt},b._configure=function(xt){s=xt,b.create=g(),s._configure()}}),Tu=mt((e,o)=>{o.exports=h;var i=Zo();(h.prototype=Object.create(i.prototype)).constructor=h;var s=Oe();function h(){i.call(this)}h._configure=function(){h.alloc=s._Buffer_allocUnsafe,h.writeBytesBuffer=s.Buffer&&s.Buffer.prototype instanceof Uint8Array&&s.Buffer.prototype.set.name==="set"?function(d,et,$){et.set(d,$)}:function(d,et,$){if(d.copy)d.copy(et,$,0,d.length);else for(var c=0;c<d.length;)et[$++]=d[c++]}},h.prototype.bytes=function(d){s.isString(d)&&(d=s._Buffer_from(d,"base64"));var et=d.length>>>0;return this.uint32(et),et&&this._push(h.writeBytesBuffer,et,d),this};function a(d,et,$){d.length<40?s.utf8.write(d,et,$):et.utf8Write?et.utf8Write(d,$):et.write(d,$)}h.prototype.string=function(d){var et=s.Buffer.byteLength(d);return this.uint32(et),et&&this._push(a,et,d),this},h._configure()}),ei=mt((e,o)=>{o.exports=et;var i=Oe(),s,h=i.LongBits,a=i.utf8;function d(at,Ot){return RangeError("index out of range: "+at.pos+" + "+(Ot||1)+" > "+at.len)}function et(at){this.buf=at,this.pos=0,this.len=at.length}var $=typeof Uint8Array<"u"?function(at){if(at instanceof Uint8Array||Array.isArray(at))return new et(at);throw Error("illegal buffer")}:function(at){if(Array.isArray(at))return new et(at);throw Error("illegal buffer")},c=function(){return i.Buffer?function(at){return(et.create=function(Ot){return i.Buffer.isBuffer(Ot)?new s(Ot):$(Ot)})(at)}:$};et.create=c(),et.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,et.prototype.uint32=function(){var at=4294967295;return function(){if(at=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(at=(at|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(at=(at|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(at=(at|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(at=(at|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return at;if((this.pos+=5)>this.len)throw this.pos=this.len,d(this,10);return at}}(),et.prototype.int32=function(){return this.uint32()|0},et.prototype.sint32=function(){var at=this.uint32();return at>>>1^-(at&1)|0};function b(){var at=new h(0,0),Ot=0;if(this.len-this.pos>4){for(;Ot<4;++Ot)if(at.lo=(at.lo|(this.buf[this.pos]&127)<<Ot*7)>>>0,this.buf[this.pos++]<128)return at;if(at.lo=(at.lo|(this.buf[this.pos]&127)<<28)>>>0,at.hi=(at.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return at;Ot=0}else{for(;Ot<3;++Ot){if(this.pos>=this.len)throw d(this);if(at.lo=(at.lo|(this.buf[this.pos]&127)<<Ot*7)>>>0,this.buf[this.pos++]<128)return at}return at.lo=(at.lo|(this.buf[this.pos++]&127)<<Ot*7)>>>0,at}if(this.len-this.pos>4){for(;Ot<5;++Ot)if(at.hi=(at.hi|(this.buf[this.pos]&127)<<Ot*7+3)>>>0,this.buf[this.pos++]<128)return at}else for(;Ot<5;++Ot){if(this.pos>=this.len)throw d(this);if(at.hi=(at.hi|(this.buf[this.pos]&127)<<Ot*7+3)>>>0,this.buf[this.pos++]<128)return at}throw Error("invalid varint encoding")}et.prototype.bool=function(){return this.uint32()!==0};function g(at,Ot){return(at[Ot-4]|at[Ot-3]<<8|at[Ot-2]<<16|at[Ot-1]<<24)>>>0}et.prototype.fixed32=function(){if(this.pos+4>this.len)throw d(this,4);return g(this.buf,this.pos+=4)},et.prototype.sfixed32=function(){if(this.pos+4>this.len)throw d(this,4);return g(this.buf,this.pos+=4)|0};function nt(){if(this.pos+8>this.len)throw d(this,8);return new h(g(this.buf,this.pos+=4),g(this.buf,this.pos+=4))}et.prototype.float=function(){if(this.pos+4>this.len)throw d(this,4);var at=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,at},et.prototype.double=function(){if(this.pos+8>this.len)throw d(this,4);var at=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,at},et.prototype.bytes=function(){var at=this.uint32(),Ot=this.pos,At=this.pos+at;if(At>this.len)throw d(this,at);if(this.pos+=at,Array.isArray(this.buf))return this.buf.slice(Ot,At);if(Ot===At){var Ct=i.Buffer;return Ct?Ct.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,Ot,At)},et.prototype.string=function(){var at=this.bytes();return a.read(at,0,at.length)},et.prototype.skip=function(at){if(typeof at=="number"){if(this.pos+at>this.len)throw d(this,at);this.pos+=at}else do if(this.pos>=this.len)throw d(this);while(this.buf[this.pos++]&128);return this},et.prototype.skipType=function(at){switch(at){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(at=this.uint32()&7)!==4;)this.skipType(at);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+at+" at offset "+this.pos)}return this},et._configure=function(at){s=at,et.create=c(),s._configure();var Ot=i.Long?"toLong":"toNumber";i.merge(et.prototype,{int64:function(){return b.call(this)[Ot](!1)},uint64:function(){return b.call(this)[Ot](!0)},sint64:function(){return b.call(this).zzDecode()[Ot](!1)},fixed64:function(){return nt.call(this)[Ot](!0)},sfixed64:function(){return nt.call(this)[Ot](!1)}})}}),Eu=mt((e,o)=>{o.exports=h;var i=ei();(h.prototype=Object.create(i.prototype)).constructor=h;var s=Oe();function h(a){i.call(this,a)}h._configure=function(){s.Buffer&&(h.prototype._slice=s.Buffer.prototype.slice)},h.prototype.string=function(){var a=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+a,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+a,this.len))},h._configure()}),Lu=mt((e,o)=>{o.exports=s;var i=Oe();(s.prototype=Object.create(i.EventEmitter.prototype)).constructor=s;function s(h,a,d){if(typeof h!="function")throw TypeError("rpcImpl must be a function");i.EventEmitter.call(this),this.rpcImpl=h,this.requestDelimited=!!a,this.responseDelimited=!!d}s.prototype.rpcCall=function h(a,d,et,$,c){if(!$)throw TypeError("request must be specified");var b=this;if(!c)return i.asPromise(h,b,a,d,et,$);if(!b.rpcImpl){setTimeout(function(){c(Error("already ended"))},0);return}try{return b.rpcImpl(a,d[b.requestDelimited?"encodeDelimited":"encode"]($).finish(),function(g,nt){if(g)return b.emit("error",g,a),c(g);if(nt===null){b.end(!0);return}if(!(nt instanceof et))try{nt=et[b.responseDelimited?"decodeDelimited":"decode"](nt)}catch(at){return b.emit("error",at,a),c(at)}return b.emit("data",nt,a),c(null,nt)})}catch(g){b.emit("error",g,a),setTimeout(function(){c(g)},0);return}},s.prototype.end=function(h){return this.rpcImpl&&(h||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),ku=mt(e=>{var o=e;o.Service=Lu()}),Fu=mt((e,o)=>{o.exports={}}),Ru=mt(e=>{var o=e;o.build="minimal",o.Writer=Zo(),o.BufferWriter=Tu(),o.Reader=ei(),o.BufferReader=Eu(),o.util=Oe(),o.rpc=ku(),o.roots=Fu(),o.configure=i;function i(){o.util._configure(),o.Writer._configure(o.BufferWriter),o.Reader._configure(o.BufferReader)}i()}),Mu=mt((e,o)=>{o.exports=Ru()}),sr=mt((e,o)=>{var i=Mu(),s=i.Reader,h=i.Writer,a=i.util,d=i.roots.default||(i.roots.default={});d.onnx=function(){var et={};return et.Version=function(){var $={},c=Object.create($);return c[$[0]="_START_VERSION"]=0,c[$[1]="IR_VERSION_2017_10_10"]=1,c[$[2]="IR_VERSION_2017_10_30"]=2,c[$[3]="IR_VERSION_2017_11_3"]=3,c[$[4]="IR_VERSION_2019_1_22"]=4,c[$[5]="IR_VERSION_2019_3_18"]=5,c[$[6]="IR_VERSION_2019_9_19"]=6,c[$[7]="IR_VERSION_2020_5_8"]=7,c[$[8]="IR_VERSION_2021_7_30"]=8,c[$[9]="IR_VERSION"]=9,c}(),et.AttributeProto=function(){function $(c){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.name="",$.prototype.refAttrName="",$.prototype.docString="",$.prototype.type=0,$.prototype.f=0,$.prototype.i=a.Long?a.Long.fromBits(0,0,!1):0,$.prototype.s=a.newBuffer([]),$.prototype.t=null,$.prototype.g=null,$.prototype.sparseTensor=null,$.prototype.tp=null,$.prototype.floats=a.emptyArray,$.prototype.ints=a.emptyArray,$.prototype.strings=a.emptyArray,$.prototype.tensors=a.emptyArray,$.prototype.graphs=a.emptyArray,$.prototype.sparseTensors=a.emptyArray,$.prototype.typeProtos=a.emptyArray,$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.name!=null&&Object.hasOwnProperty.call(c,"name")&&b.uint32(10).string(c.name),c.f!=null&&Object.hasOwnProperty.call(c,"f")&&b.uint32(21).float(c.f),c.i!=null&&Object.hasOwnProperty.call(c,"i")&&b.uint32(24).int64(c.i),c.s!=null&&Object.hasOwnProperty.call(c,"s")&&b.uint32(34).bytes(c.s),c.t!=null&&Object.hasOwnProperty.call(c,"t")&&d.onnx.TensorProto.encode(c.t,b.uint32(42).fork()).ldelim(),c.g!=null&&Object.hasOwnProperty.call(c,"g")&&d.onnx.GraphProto.encode(c.g,b.uint32(50).fork()).ldelim(),c.floats!=null&&c.floats.length){b.uint32(58).fork();for(var g=0;g<c.floats.length;++g)b.float(c.floats[g]);b.ldelim()}if(c.ints!=null&&c.ints.length){b.uint32(66).fork();for(var g=0;g<c.ints.length;++g)b.int64(c.ints[g]);b.ldelim()}if(c.strings!=null&&c.strings.length)for(var g=0;g<c.strings.length;++g)b.uint32(74).bytes(c.strings[g]);if(c.tensors!=null&&c.tensors.length)for(var g=0;g<c.tensors.length;++g)d.onnx.TensorProto.encode(c.tensors[g],b.uint32(82).fork()).ldelim();if(c.graphs!=null&&c.graphs.length)for(var g=0;g<c.graphs.length;++g)d.onnx.GraphProto.encode(c.graphs[g],b.uint32(90).fork()).ldelim();if(c.docString!=null&&Object.hasOwnProperty.call(c,"docString")&&b.uint32(106).string(c.docString),c.tp!=null&&Object.hasOwnProperty.call(c,"tp")&&d.onnx.TypeProto.encode(c.tp,b.uint32(114).fork()).ldelim(),c.typeProtos!=null&&c.typeProtos.length)for(var g=0;g<c.typeProtos.length;++g)d.onnx.TypeProto.encode(c.typeProtos[g],b.uint32(122).fork()).ldelim();if(c.type!=null&&Object.hasOwnProperty.call(c,"type")&&b.uint32(160).int32(c.type),c.refAttrName!=null&&Object.hasOwnProperty.call(c,"refAttrName")&&b.uint32(170).string(c.refAttrName),c.sparseTensor!=null&&Object.hasOwnProperty.call(c,"sparseTensor")&&d.onnx.SparseTensorProto.encode(c.sparseTensor,b.uint32(178).fork()).ldelim(),c.sparseTensors!=null&&c.sparseTensors.length)for(var g=0;g<c.sparseTensors.length;++g)d.onnx.SparseTensorProto.encode(c.sparseTensors[g],b.uint32(186).fork()).ldelim();return b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.AttributeProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.name=c.string();break}case 21:{nt.refAttrName=c.string();break}case 13:{nt.docString=c.string();break}case 20:{nt.type=c.int32();break}case 2:{nt.f=c.float();break}case 3:{nt.i=c.int64();break}case 4:{nt.s=c.bytes();break}case 5:{nt.t=d.onnx.TensorProto.decode(c,c.uint32());break}case 6:{nt.g=d.onnx.GraphProto.decode(c,c.uint32());break}case 22:{nt.sparseTensor=d.onnx.SparseTensorProto.decode(c,c.uint32());break}case 14:{nt.tp=d.onnx.TypeProto.decode(c,c.uint32());break}case 7:{if(nt.floats&&nt.floats.length||(nt.floats=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.floats.push(c.float());else nt.floats.push(c.float());break}case 8:{if(nt.ints&&nt.ints.length||(nt.ints=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.ints.push(c.int64());else nt.ints.push(c.int64());break}case 9:{nt.strings&&nt.strings.length||(nt.strings=[]),nt.strings.push(c.bytes());break}case 10:{nt.tensors&&nt.tensors.length||(nt.tensors=[]),nt.tensors.push(d.onnx.TensorProto.decode(c,c.uint32()));break}case 11:{nt.graphs&&nt.graphs.length||(nt.graphs=[]),nt.graphs.push(d.onnx.GraphProto.decode(c,c.uint32()));break}case 23:{nt.sparseTensors&&nt.sparseTensors.length||(nt.sparseTensors=[]),nt.sparseTensors.push(d.onnx.SparseTensorProto.decode(c,c.uint32()));break}case 15:{nt.typeProtos&&nt.typeProtos.length||(nt.typeProtos=[]),nt.typeProtos.push(d.onnx.TypeProto.decode(c,c.uint32()));break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.name!=null&&c.hasOwnProperty("name")&&!a.isString(c.name))return"name: string expected";if(c.refAttrName!=null&&c.hasOwnProperty("refAttrName")&&!a.isString(c.refAttrName))return"refAttrName: string expected";if(c.docString!=null&&c.hasOwnProperty("docString")&&!a.isString(c.docString))return"docString: string expected";if(c.type!=null&&c.hasOwnProperty("type"))switch(c.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(c.f!=null&&c.hasOwnProperty("f")&&typeof c.f!="number")return"f: number expected";if(c.i!=null&&c.hasOwnProperty("i")&&!a.isInteger(c.i)&&!(c.i&&a.isInteger(c.i.low)&&a.isInteger(c.i.high)))return"i: integer|Long expected";if(c.s!=null&&c.hasOwnProperty("s")&&!(c.s&&typeof c.s.length=="number"||a.isString(c.s)))return"s: buffer expected";if(c.t!=null&&c.hasOwnProperty("t")){var b=d.onnx.TensorProto.verify(c.t);if(b)return"t."+b}if(c.g!=null&&c.hasOwnProperty("g")){var b=d.onnx.GraphProto.verify(c.g);if(b)return"g."+b}if(c.sparseTensor!=null&&c.hasOwnProperty("sparseTensor")){var b=d.onnx.SparseTensorProto.verify(c.sparseTensor);if(b)return"sparseTensor."+b}if(c.tp!=null&&c.hasOwnProperty("tp")){var b=d.onnx.TypeProto.verify(c.tp);if(b)return"tp."+b}if(c.floats!=null&&c.hasOwnProperty("floats")){if(!Array.isArray(c.floats))return"floats: array expected";for(var g=0;g<c.floats.length;++g)if(typeof c.floats[g]!="number")return"floats: number[] expected"}if(c.ints!=null&&c.hasOwnProperty("ints")){if(!Array.isArray(c.ints))return"ints: array expected";for(var g=0;g<c.ints.length;++g)if(!a.isInteger(c.ints[g])&&!(c.ints[g]&&a.isInteger(c.ints[g].low)&&a.isInteger(c.ints[g].high)))return"ints: integer|Long[] expected"}if(c.strings!=null&&c.hasOwnProperty("strings")){if(!Array.isArray(c.strings))return"strings: array expected";for(var g=0;g<c.strings.length;++g)if(!(c.strings[g]&&typeof c.strings[g].length=="number"||a.isString(c.strings[g])))return"strings: buffer[] expected"}if(c.tensors!=null&&c.hasOwnProperty("tensors")){if(!Array.isArray(c.tensors))return"tensors: array expected";for(var g=0;g<c.tensors.length;++g){var b=d.onnx.TensorProto.verify(c.tensors[g]);if(b)return"tensors."+b}}if(c.graphs!=null&&c.hasOwnProperty("graphs")){if(!Array.isArray(c.graphs))return"graphs: array expected";for(var g=0;g<c.graphs.length;++g){var b=d.onnx.GraphProto.verify(c.graphs[g]);if(b)return"graphs."+b}}if(c.sparseTensors!=null&&c.hasOwnProperty("sparseTensors")){if(!Array.isArray(c.sparseTensors))return"sparseTensors: array expected";for(var g=0;g<c.sparseTensors.length;++g){var b=d.onnx.SparseTensorProto.verify(c.sparseTensors[g]);if(b)return"sparseTensors."+b}}if(c.typeProtos!=null&&c.hasOwnProperty("typeProtos")){if(!Array.isArray(c.typeProtos))return"typeProtos: array expected";for(var g=0;g<c.typeProtos.length;++g){var b=d.onnx.TypeProto.verify(c.typeProtos[g]);if(b)return"typeProtos."+b}}return null},$.fromObject=function(c){if(c instanceof d.onnx.AttributeProto)return c;var b=new d.onnx.AttributeProto;switch(c.name!=null&&(b.name=String(c.name)),c.refAttrName!=null&&(b.refAttrName=String(c.refAttrName)),c.docString!=null&&(b.docString=String(c.docString)),c.type){default:if(typeof c.type=="number"){b.type=c.type;break}break;case"UNDEFINED":case 0:b.type=0;break;case"FLOAT":case 1:b.type=1;break;case"INT":case 2:b.type=2;break;case"STRING":case 3:b.type=3;break;case"TENSOR":case 4:b.type=4;break;case"GRAPH":case 5:b.type=5;break;case"SPARSE_TENSOR":case 11:b.type=11;break;case"TYPE_PROTO":case 13:b.type=13;break;case"FLOATS":case 6:b.type=6;break;case"INTS":case 7:b.type=7;break;case"STRINGS":case 8:b.type=8;break;case"TENSORS":case 9:b.type=9;break;case"GRAPHS":case 10:b.type=10;break;case"SPARSE_TENSORS":case 12:b.type=12;break;case"TYPE_PROTOS":case 14:b.type=14;break}if(c.f!=null&&(b.f=Number(c.f)),c.i!=null&&(a.Long?(b.i=a.Long.fromValue(c.i)).unsigned=!1:typeof c.i=="string"?b.i=parseInt(c.i,10):typeof c.i=="number"?b.i=c.i:typeof c.i=="object"&&(b.i=new a.LongBits(c.i.low>>>0,c.i.high>>>0).toNumber())),c.s!=null&&(typeof c.s=="string"?a.base64.decode(c.s,b.s=a.newBuffer(a.base64.length(c.s)),0):c.s.length>=0&&(b.s=c.s)),c.t!=null){if(typeof c.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");b.t=d.onnx.TensorProto.fromObject(c.t)}if(c.g!=null){if(typeof c.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");b.g=d.onnx.GraphProto.fromObject(c.g)}if(c.sparseTensor!=null){if(typeof c.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");b.sparseTensor=d.onnx.SparseTensorProto.fromObject(c.sparseTensor)}if(c.tp!=null){if(typeof c.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");b.tp=d.onnx.TypeProto.fromObject(c.tp)}if(c.floats){if(!Array.isArray(c.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");b.floats=[];for(var g=0;g<c.floats.length;++g)b.floats[g]=Number(c.floats[g])}if(c.ints){if(!Array.isArray(c.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");b.ints=[];for(var g=0;g<c.ints.length;++g)a.Long?(b.ints[g]=a.Long.fromValue(c.ints[g])).unsigned=!1:typeof c.ints[g]=="string"?b.ints[g]=parseInt(c.ints[g],10):typeof c.ints[g]=="number"?b.ints[g]=c.ints[g]:typeof c.ints[g]=="object"&&(b.ints[g]=new a.LongBits(c.ints[g].low>>>0,c.ints[g].high>>>0).toNumber())}if(c.strings){if(!Array.isArray(c.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");b.strings=[];for(var g=0;g<c.strings.length;++g)typeof c.strings[g]=="string"?a.base64.decode(c.strings[g],b.strings[g]=a.newBuffer(a.base64.length(c.strings[g])),0):c.strings[g].length>=0&&(b.strings[g]=c.strings[g])}if(c.tensors){if(!Array.isArray(c.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");b.tensors=[];for(var g=0;g<c.tensors.length;++g){if(typeof c.tensors[g]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");b.tensors[g]=d.onnx.TensorProto.fromObject(c.tensors[g])}}if(c.graphs){if(!Array.isArray(c.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");b.graphs=[];for(var g=0;g<c.graphs.length;++g){if(typeof c.graphs[g]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");b.graphs[g]=d.onnx.GraphProto.fromObject(c.graphs[g])}}if(c.sparseTensors){if(!Array.isArray(c.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");b.sparseTensors=[];for(var g=0;g<c.sparseTensors.length;++g){if(typeof c.sparseTensors[g]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");b.sparseTensors[g]=d.onnx.SparseTensorProto.fromObject(c.sparseTensors[g])}}if(c.typeProtos){if(!Array.isArray(c.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");b.typeProtos=[];for(var g=0;g<c.typeProtos.length;++g){if(typeof c.typeProtos[g]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");b.typeProtos[g]=d.onnx.TypeProto.fromObject(c.typeProtos[g])}}return b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.floats=[],g.ints=[],g.strings=[],g.tensors=[],g.graphs=[],g.typeProtos=[],g.sparseTensors=[]),b.defaults){if(g.name="",g.f=0,a.Long){var nt=new a.Long(0,0,!1);g.i=b.longs===String?nt.toString():b.longs===Number?nt.toNumber():nt}else g.i=b.longs===String?"0":0;b.bytes===String?g.s="":(g.s=[],b.bytes!==Array&&(g.s=a.newBuffer(g.s))),g.t=null,g.g=null,g.docString="",g.tp=null,g.type=b.enums===String?"UNDEFINED":0,g.refAttrName="",g.sparseTensor=null}if(c.name!=null&&c.hasOwnProperty("name")&&(g.name=c.name),c.f!=null&&c.hasOwnProperty("f")&&(g.f=b.json&&!isFinite(c.f)?String(c.f):c.f),c.i!=null&&c.hasOwnProperty("i")&&(typeof c.i=="number"?g.i=b.longs===String?String(c.i):c.i:g.i=b.longs===String?a.Long.prototype.toString.call(c.i):b.longs===Number?new a.LongBits(c.i.low>>>0,c.i.high>>>0).toNumber():c.i),c.s!=null&&c.hasOwnProperty("s")&&(g.s=b.bytes===String?a.base64.encode(c.s,0,c.s.length):b.bytes===Array?Array.prototype.slice.call(c.s):c.s),c.t!=null&&c.hasOwnProperty("t")&&(g.t=d.onnx.TensorProto.toObject(c.t,b)),c.g!=null&&c.hasOwnProperty("g")&&(g.g=d.onnx.GraphProto.toObject(c.g,b)),c.floats&&c.floats.length){g.floats=[];for(var at=0;at<c.floats.length;++at)g.floats[at]=b.json&&!isFinite(c.floats[at])?String(c.floats[at]):c.floats[at]}if(c.ints&&c.ints.length){g.ints=[];for(var at=0;at<c.ints.length;++at)typeof c.ints[at]=="number"?g.ints[at]=b.longs===String?String(c.ints[at]):c.ints[at]:g.ints[at]=b.longs===String?a.Long.prototype.toString.call(c.ints[at]):b.longs===Number?new a.LongBits(c.ints[at].low>>>0,c.ints[at].high>>>0).toNumber():c.ints[at]}if(c.strings&&c.strings.length){g.strings=[];for(var at=0;at<c.strings.length;++at)g.strings[at]=b.bytes===String?a.base64.encode(c.strings[at],0,c.strings[at].length):b.bytes===Array?Array.prototype.slice.call(c.strings[at]):c.strings[at]}if(c.tensors&&c.tensors.length){g.tensors=[];for(var at=0;at<c.tensors.length;++at)g.tensors[at]=d.onnx.TensorProto.toObject(c.tensors[at],b)}if(c.graphs&&c.graphs.length){g.graphs=[];for(var at=0;at<c.graphs.length;++at)g.graphs[at]=d.onnx.GraphProto.toObject(c.graphs[at],b)}if(c.docString!=null&&c.hasOwnProperty("docString")&&(g.docString=c.docString),c.tp!=null&&c.hasOwnProperty("tp")&&(g.tp=d.onnx.TypeProto.toObject(c.tp,b)),c.typeProtos&&c.typeProtos.length){g.typeProtos=[];for(var at=0;at<c.typeProtos.length;++at)g.typeProtos[at]=d.onnx.TypeProto.toObject(c.typeProtos[at],b)}if(c.type!=null&&c.hasOwnProperty("type")&&(g.type=b.enums===String?d.onnx.AttributeProto.AttributeType[c.type]===void 0?c.type:d.onnx.AttributeProto.AttributeType[c.type]:c.type),c.refAttrName!=null&&c.hasOwnProperty("refAttrName")&&(g.refAttrName=c.refAttrName),c.sparseTensor!=null&&c.hasOwnProperty("sparseTensor")&&(g.sparseTensor=d.onnx.SparseTensorProto.toObject(c.sparseTensor,b)),c.sparseTensors&&c.sparseTensors.length){g.sparseTensors=[];for(var at=0;at<c.sparseTensors.length;++at)g.sparseTensors[at]=d.onnx.SparseTensorProto.toObject(c.sparseTensors[at],b)}return g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.AttributeProto"},$.AttributeType=function(){var c={},b=Object.create(c);return b[c[0]="UNDEFINED"]=0,b[c[1]="FLOAT"]=1,b[c[2]="INT"]=2,b[c[3]="STRING"]=3,b[c[4]="TENSOR"]=4,b[c[5]="GRAPH"]=5,b[c[11]="SPARSE_TENSOR"]=11,b[c[13]="TYPE_PROTO"]=13,b[c[6]="FLOATS"]=6,b[c[7]="INTS"]=7,b[c[8]="STRINGS"]=8,b[c[9]="TENSORS"]=9,b[c[10]="GRAPHS"]=10,b[c[12]="SPARSE_TENSORS"]=12,b[c[14]="TYPE_PROTOS"]=14,b}(),$}(),et.ValueInfoProto=function(){function $(c){if(c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.name="",$.prototype.type=null,$.prototype.docString="",$.create=function(c){return new $(c)},$.encode=function(c,b){return b||(b=h.create()),c.name!=null&&Object.hasOwnProperty.call(c,"name")&&b.uint32(10).string(c.name),c.type!=null&&Object.hasOwnProperty.call(c,"type")&&d.onnx.TypeProto.encode(c.type,b.uint32(18).fork()).ldelim(),c.docString!=null&&Object.hasOwnProperty.call(c,"docString")&&b.uint32(26).string(c.docString),b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.ValueInfoProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.name=c.string();break}case 2:{nt.type=d.onnx.TypeProto.decode(c,c.uint32());break}case 3:{nt.docString=c.string();break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.name!=null&&c.hasOwnProperty("name")&&!a.isString(c.name))return"name: string expected";if(c.type!=null&&c.hasOwnProperty("type")){var b=d.onnx.TypeProto.verify(c.type);if(b)return"type."+b}return c.docString!=null&&c.hasOwnProperty("docString")&&!a.isString(c.docString)?"docString: string expected":null},$.fromObject=function(c){if(c instanceof d.onnx.ValueInfoProto)return c;var b=new d.onnx.ValueInfoProto;if(c.name!=null&&(b.name=String(c.name)),c.type!=null){if(typeof c.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");b.type=d.onnx.TypeProto.fromObject(c.type)}return c.docString!=null&&(b.docString=String(c.docString)),b},$.toObject=function(c,b){b||(b={});var g={};return b.defaults&&(g.name="",g.type=null,g.docString=""),c.name!=null&&c.hasOwnProperty("name")&&(g.name=c.name),c.type!=null&&c.hasOwnProperty("type")&&(g.type=d.onnx.TypeProto.toObject(c.type,b)),c.docString!=null&&c.hasOwnProperty("docString")&&(g.docString=c.docString),g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.ValueInfoProto"},$}(),et.NodeProto=function(){function $(c){if(this.input=[],this.output=[],this.attribute=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.input=a.emptyArray,$.prototype.output=a.emptyArray,$.prototype.name="",$.prototype.opType="",$.prototype.domain="",$.prototype.attribute=a.emptyArray,$.prototype.docString="",$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.input!=null&&c.input.length)for(var g=0;g<c.input.length;++g)b.uint32(10).string(c.input[g]);if(c.output!=null&&c.output.length)for(var g=0;g<c.output.length;++g)b.uint32(18).string(c.output[g]);if(c.name!=null&&Object.hasOwnProperty.call(c,"name")&&b.uint32(26).string(c.name),c.opType!=null&&Object.hasOwnProperty.call(c,"opType")&&b.uint32(34).string(c.opType),c.attribute!=null&&c.attribute.length)for(var g=0;g<c.attribute.length;++g)d.onnx.AttributeProto.encode(c.attribute[g],b.uint32(42).fork()).ldelim();return c.docString!=null&&Object.hasOwnProperty.call(c,"docString")&&b.uint32(50).string(c.docString),c.domain!=null&&Object.hasOwnProperty.call(c,"domain")&&b.uint32(58).string(c.domain),b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.NodeProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.input&&nt.input.length||(nt.input=[]),nt.input.push(c.string());break}case 2:{nt.output&&nt.output.length||(nt.output=[]),nt.output.push(c.string());break}case 3:{nt.name=c.string();break}case 4:{nt.opType=c.string();break}case 7:{nt.domain=c.string();break}case 5:{nt.attribute&&nt.attribute.length||(nt.attribute=[]),nt.attribute.push(d.onnx.AttributeProto.decode(c,c.uint32()));break}case 6:{nt.docString=c.string();break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.input!=null&&c.hasOwnProperty("input")){if(!Array.isArray(c.input))return"input: array expected";for(var b=0;b<c.input.length;++b)if(!a.isString(c.input[b]))return"input: string[] expected"}if(c.output!=null&&c.hasOwnProperty("output")){if(!Array.isArray(c.output))return"output: array expected";for(var b=0;b<c.output.length;++b)if(!a.isString(c.output[b]))return"output: string[] expected"}if(c.name!=null&&c.hasOwnProperty("name")&&!a.isString(c.name))return"name: string expected";if(c.opType!=null&&c.hasOwnProperty("opType")&&!a.isString(c.opType))return"opType: string expected";if(c.domain!=null&&c.hasOwnProperty("domain")&&!a.isString(c.domain))return"domain: string expected";if(c.attribute!=null&&c.hasOwnProperty("attribute")){if(!Array.isArray(c.attribute))return"attribute: array expected";for(var b=0;b<c.attribute.length;++b){var g=d.onnx.AttributeProto.verify(c.attribute[b]);if(g)return"attribute."+g}}return c.docString!=null&&c.hasOwnProperty("docString")&&!a.isString(c.docString)?"docString: string expected":null},$.fromObject=function(c){if(c instanceof d.onnx.NodeProto)return c;var b=new d.onnx.NodeProto;if(c.input){if(!Array.isArray(c.input))throw TypeError(".onnx.NodeProto.input: array expected");b.input=[];for(var g=0;g<c.input.length;++g)b.input[g]=String(c.input[g])}if(c.output){if(!Array.isArray(c.output))throw TypeError(".onnx.NodeProto.output: array expected");b.output=[];for(var g=0;g<c.output.length;++g)b.output[g]=String(c.output[g])}if(c.name!=null&&(b.name=String(c.name)),c.opType!=null&&(b.opType=String(c.opType)),c.domain!=null&&(b.domain=String(c.domain)),c.attribute){if(!Array.isArray(c.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");b.attribute=[];for(var g=0;g<c.attribute.length;++g){if(typeof c.attribute[g]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");b.attribute[g]=d.onnx.AttributeProto.fromObject(c.attribute[g])}}return c.docString!=null&&(b.docString=String(c.docString)),b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.input=[],g.output=[],g.attribute=[]),b.defaults&&(g.name="",g.opType="",g.docString="",g.domain=""),c.input&&c.input.length){g.input=[];for(var nt=0;nt<c.input.length;++nt)g.input[nt]=c.input[nt]}if(c.output&&c.output.length){g.output=[];for(var nt=0;nt<c.output.length;++nt)g.output[nt]=c.output[nt]}if(c.name!=null&&c.hasOwnProperty("name")&&(g.name=c.name),c.opType!=null&&c.hasOwnProperty("opType")&&(g.opType=c.opType),c.attribute&&c.attribute.length){g.attribute=[];for(var nt=0;nt<c.attribute.length;++nt)g.attribute[nt]=d.onnx.AttributeProto.toObject(c.attribute[nt],b)}return c.docString!=null&&c.hasOwnProperty("docString")&&(g.docString=c.docString),c.domain!=null&&c.hasOwnProperty("domain")&&(g.domain=c.domain),g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.NodeProto"},$}(),et.TrainingInfoProto=function(){function $(c){if(this.initializationBinding=[],this.updateBinding=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.initialization=null,$.prototype.algorithm=null,$.prototype.initializationBinding=a.emptyArray,$.prototype.updateBinding=a.emptyArray,$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.initialization!=null&&Object.hasOwnProperty.call(c,"initialization")&&d.onnx.GraphProto.encode(c.initialization,b.uint32(10).fork()).ldelim(),c.algorithm!=null&&Object.hasOwnProperty.call(c,"algorithm")&&d.onnx.GraphProto.encode(c.algorithm,b.uint32(18).fork()).ldelim(),c.initializationBinding!=null&&c.initializationBinding.length)for(var g=0;g<c.initializationBinding.length;++g)d.onnx.StringStringEntryProto.encode(c.initializationBinding[g],b.uint32(26).fork()).ldelim();if(c.updateBinding!=null&&c.updateBinding.length)for(var g=0;g<c.updateBinding.length;++g)d.onnx.StringStringEntryProto.encode(c.updateBinding[g],b.uint32(34).fork()).ldelim();return b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.TrainingInfoProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.initialization=d.onnx.GraphProto.decode(c,c.uint32());break}case 2:{nt.algorithm=d.onnx.GraphProto.decode(c,c.uint32());break}case 3:{nt.initializationBinding&&nt.initializationBinding.length||(nt.initializationBinding=[]),nt.initializationBinding.push(d.onnx.StringStringEntryProto.decode(c,c.uint32()));break}case 4:{nt.updateBinding&&nt.updateBinding.length||(nt.updateBinding=[]),nt.updateBinding.push(d.onnx.StringStringEntryProto.decode(c,c.uint32()));break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.initialization!=null&&c.hasOwnProperty("initialization")){var b=d.onnx.GraphProto.verify(c.initialization);if(b)return"initialization."+b}if(c.algorithm!=null&&c.hasOwnProperty("algorithm")){var b=d.onnx.GraphProto.verify(c.algorithm);if(b)return"algorithm."+b}if(c.initializationBinding!=null&&c.hasOwnProperty("initializationBinding")){if(!Array.isArray(c.initializationBinding))return"initializationBinding: array expected";for(var g=0;g<c.initializationBinding.length;++g){var b=d.onnx.StringStringEntryProto.verify(c.initializationBinding[g]);if(b)return"initializationBinding."+b}}if(c.updateBinding!=null&&c.hasOwnProperty("updateBinding")){if(!Array.isArray(c.updateBinding))return"updateBinding: array expected";for(var g=0;g<c.updateBinding.length;++g){var b=d.onnx.StringStringEntryProto.verify(c.updateBinding[g]);if(b)return"updateBinding."+b}}return null},$.fromObject=function(c){if(c instanceof d.onnx.TrainingInfoProto)return c;var b=new d.onnx.TrainingInfoProto;if(c.initialization!=null){if(typeof c.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");b.initialization=d.onnx.GraphProto.fromObject(c.initialization)}if(c.algorithm!=null){if(typeof c.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");b.algorithm=d.onnx.GraphProto.fromObject(c.algorithm)}if(c.initializationBinding){if(!Array.isArray(c.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");b.initializationBinding=[];for(var g=0;g<c.initializationBinding.length;++g){if(typeof c.initializationBinding[g]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");b.initializationBinding[g]=d.onnx.StringStringEntryProto.fromObject(c.initializationBinding[g])}}if(c.updateBinding){if(!Array.isArray(c.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");b.updateBinding=[];for(var g=0;g<c.updateBinding.length;++g){if(typeof c.updateBinding[g]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");b.updateBinding[g]=d.onnx.StringStringEntryProto.fromObject(c.updateBinding[g])}}return b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.initializationBinding=[],g.updateBinding=[]),b.defaults&&(g.initialization=null,g.algorithm=null),c.initialization!=null&&c.hasOwnProperty("initialization")&&(g.initialization=d.onnx.GraphProto.toObject(c.initialization,b)),c.algorithm!=null&&c.hasOwnProperty("algorithm")&&(g.algorithm=d.onnx.GraphProto.toObject(c.algorithm,b)),c.initializationBinding&&c.initializationBinding.length){g.initializationBinding=[];for(var nt=0;nt<c.initializationBinding.length;++nt)g.initializationBinding[nt]=d.onnx.StringStringEntryProto.toObject(c.initializationBinding[nt],b)}if(c.updateBinding&&c.updateBinding.length){g.updateBinding=[];for(var nt=0;nt<c.updateBinding.length;++nt)g.updateBinding[nt]=d.onnx.StringStringEntryProto.toObject(c.updateBinding[nt],b)}return g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.TrainingInfoProto"},$}(),et.ModelProto=function(){function $(c){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.irVersion=a.Long?a.Long.fromBits(0,0,!1):0,$.prototype.opsetImport=a.emptyArray,$.prototype.producerName="",$.prototype.producerVersion="",$.prototype.domain="",$.prototype.modelVersion=a.Long?a.Long.fromBits(0,0,!1):0,$.prototype.docString="",$.prototype.graph=null,$.prototype.metadataProps=a.emptyArray,$.prototype.trainingInfo=a.emptyArray,$.prototype.functions=a.emptyArray,$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.irVersion!=null&&Object.hasOwnProperty.call(c,"irVersion")&&b.uint32(8).int64(c.irVersion),c.producerName!=null&&Object.hasOwnProperty.call(c,"producerName")&&b.uint32(18).string(c.producerName),c.producerVersion!=null&&Object.hasOwnProperty.call(c,"producerVersion")&&b.uint32(26).string(c.producerVersion),c.domain!=null&&Object.hasOwnProperty.call(c,"domain")&&b.uint32(34).string(c.domain),c.modelVersion!=null&&Object.hasOwnProperty.call(c,"modelVersion")&&b.uint32(40).int64(c.modelVersion),c.docString!=null&&Object.hasOwnProperty.call(c,"docString")&&b.uint32(50).string(c.docString),c.graph!=null&&Object.hasOwnProperty.call(c,"graph")&&d.onnx.GraphProto.encode(c.graph,b.uint32(58).fork()).ldelim(),c.opsetImport!=null&&c.opsetImport.length)for(var g=0;g<c.opsetImport.length;++g)d.onnx.OperatorSetIdProto.encode(c.opsetImport[g],b.uint32(66).fork()).ldelim();if(c.metadataProps!=null&&c.metadataProps.length)for(var g=0;g<c.metadataProps.length;++g)d.onnx.StringStringEntryProto.encode(c.metadataProps[g],b.uint32(114).fork()).ldelim();if(c.trainingInfo!=null&&c.trainingInfo.length)for(var g=0;g<c.trainingInfo.length;++g)d.onnx.TrainingInfoProto.encode(c.trainingInfo[g],b.uint32(162).fork()).ldelim();if(c.functions!=null&&c.functions.length)for(var g=0;g<c.functions.length;++g)d.onnx.FunctionProto.encode(c.functions[g],b.uint32(202).fork()).ldelim();return b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.ModelProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.irVersion=c.int64();break}case 8:{nt.opsetImport&&nt.opsetImport.length||(nt.opsetImport=[]),nt.opsetImport.push(d.onnx.OperatorSetIdProto.decode(c,c.uint32()));break}case 2:{nt.producerName=c.string();break}case 3:{nt.producerVersion=c.string();break}case 4:{nt.domain=c.string();break}case 5:{nt.modelVersion=c.int64();break}case 6:{nt.docString=c.string();break}case 7:{nt.graph=d.onnx.GraphProto.decode(c,c.uint32());break}case 14:{nt.metadataProps&&nt.metadataProps.length||(nt.metadataProps=[]),nt.metadataProps.push(d.onnx.StringStringEntryProto.decode(c,c.uint32()));break}case 20:{nt.trainingInfo&&nt.trainingInfo.length||(nt.trainingInfo=[]),nt.trainingInfo.push(d.onnx.TrainingInfoProto.decode(c,c.uint32()));break}case 25:{nt.functions&&nt.functions.length||(nt.functions=[]),nt.functions.push(d.onnx.FunctionProto.decode(c,c.uint32()));break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.irVersion!=null&&c.hasOwnProperty("irVersion")&&!a.isInteger(c.irVersion)&&!(c.irVersion&&a.isInteger(c.irVersion.low)&&a.isInteger(c.irVersion.high)))return"irVersion: integer|Long expected";if(c.opsetImport!=null&&c.hasOwnProperty("opsetImport")){if(!Array.isArray(c.opsetImport))return"opsetImport: array expected";for(var b=0;b<c.opsetImport.length;++b){var g=d.onnx.OperatorSetIdProto.verify(c.opsetImport[b]);if(g)return"opsetImport."+g}}if(c.producerName!=null&&c.hasOwnProperty("producerName")&&!a.isString(c.producerName))return"producerName: string expected";if(c.producerVersion!=null&&c.hasOwnProperty("producerVersion")&&!a.isString(c.producerVersion))return"producerVersion: string expected";if(c.domain!=null&&c.hasOwnProperty("domain")&&!a.isString(c.domain))return"domain: string expected";if(c.modelVersion!=null&&c.hasOwnProperty("modelVersion")&&!a.isInteger(c.modelVersion)&&!(c.modelVersion&&a.isInteger(c.modelVersion.low)&&a.isInteger(c.modelVersion.high)))return"modelVersion: integer|Long expected";if(c.docString!=null&&c.hasOwnProperty("docString")&&!a.isString(c.docString))return"docString: string expected";if(c.graph!=null&&c.hasOwnProperty("graph")){var g=d.onnx.GraphProto.verify(c.graph);if(g)return"graph."+g}if(c.metadataProps!=null&&c.hasOwnProperty("metadataProps")){if(!Array.isArray(c.metadataProps))return"metadataProps: array expected";for(var b=0;b<c.metadataProps.length;++b){var g=d.onnx.StringStringEntryProto.verify(c.metadataProps[b]);if(g)return"metadataProps."+g}}if(c.trainingInfo!=null&&c.hasOwnProperty("trainingInfo")){if(!Array.isArray(c.trainingInfo))return"trainingInfo: array expected";for(var b=0;b<c.trainingInfo.length;++b){var g=d.onnx.TrainingInfoProto.verify(c.trainingInfo[b]);if(g)return"trainingInfo."+g}}if(c.functions!=null&&c.hasOwnProperty("functions")){if(!Array.isArray(c.functions))return"functions: array expected";for(var b=0;b<c.functions.length;++b){var g=d.onnx.FunctionProto.verify(c.functions[b]);if(g)return"functions."+g}}return null},$.fromObject=function(c){if(c instanceof d.onnx.ModelProto)return c;var b=new d.onnx.ModelProto;if(c.irVersion!=null&&(a.Long?(b.irVersion=a.Long.fromValue(c.irVersion)).unsigned=!1:typeof c.irVersion=="string"?b.irVersion=parseInt(c.irVersion,10):typeof c.irVersion=="number"?b.irVersion=c.irVersion:typeof c.irVersion=="object"&&(b.irVersion=new a.LongBits(c.irVersion.low>>>0,c.irVersion.high>>>0).toNumber())),c.opsetImport){if(!Array.isArray(c.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");b.opsetImport=[];for(var g=0;g<c.opsetImport.length;++g){if(typeof c.opsetImport[g]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");b.opsetImport[g]=d.onnx.OperatorSetIdProto.fromObject(c.opsetImport[g])}}if(c.producerName!=null&&(b.producerName=String(c.producerName)),c.producerVersion!=null&&(b.producerVersion=String(c.producerVersion)),c.domain!=null&&(b.domain=String(c.domain)),c.modelVersion!=null&&(a.Long?(b.modelVersion=a.Long.fromValue(c.modelVersion)).unsigned=!1:typeof c.modelVersion=="string"?b.modelVersion=parseInt(c.modelVersion,10):typeof c.modelVersion=="number"?b.modelVersion=c.modelVersion:typeof c.modelVersion=="object"&&(b.modelVersion=new a.LongBits(c.modelVersion.low>>>0,c.modelVersion.high>>>0).toNumber())),c.docString!=null&&(b.docString=String(c.docString)),c.graph!=null){if(typeof c.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");b.graph=d.onnx.GraphProto.fromObject(c.graph)}if(c.metadataProps){if(!Array.isArray(c.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");b.metadataProps=[];for(var g=0;g<c.metadataProps.length;++g){if(typeof c.metadataProps[g]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");b.metadataProps[g]=d.onnx.StringStringEntryProto.fromObject(c.metadataProps[g])}}if(c.trainingInfo){if(!Array.isArray(c.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");b.trainingInfo=[];for(var g=0;g<c.trainingInfo.length;++g){if(typeof c.trainingInfo[g]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");b.trainingInfo[g]=d.onnx.TrainingInfoProto.fromObject(c.trainingInfo[g])}}if(c.functions){if(!Array.isArray(c.functions))throw TypeError(".onnx.ModelProto.functions: array expected");b.functions=[];for(var g=0;g<c.functions.length;++g){if(typeof c.functions[g]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");b.functions[g]=d.onnx.FunctionProto.fromObject(c.functions[g])}}return b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.opsetImport=[],g.metadataProps=[],g.trainingInfo=[],g.functions=[]),b.defaults){if(a.Long){var nt=new a.Long(0,0,!1);g.irVersion=b.longs===String?nt.toString():b.longs===Number?nt.toNumber():nt}else g.irVersion=b.longs===String?"0":0;if(g.producerName="",g.producerVersion="",g.domain="",a.Long){var nt=new a.Long(0,0,!1);g.modelVersion=b.longs===String?nt.toString():b.longs===Number?nt.toNumber():nt}else g.modelVersion=b.longs===String?"0":0;g.docString="",g.graph=null}if(c.irVersion!=null&&c.hasOwnProperty("irVersion")&&(typeof c.irVersion=="number"?g.irVersion=b.longs===String?String(c.irVersion):c.irVersion:g.irVersion=b.longs===String?a.Long.prototype.toString.call(c.irVersion):b.longs===Number?new a.LongBits(c.irVersion.low>>>0,c.irVersion.high>>>0).toNumber():c.irVersion),c.producerName!=null&&c.hasOwnProperty("producerName")&&(g.producerName=c.producerName),c.producerVersion!=null&&c.hasOwnProperty("producerVersion")&&(g.producerVersion=c.producerVersion),c.domain!=null&&c.hasOwnProperty("domain")&&(g.domain=c.domain),c.modelVersion!=null&&c.hasOwnProperty("modelVersion")&&(typeof c.modelVersion=="number"?g.modelVersion=b.longs===String?String(c.modelVersion):c.modelVersion:g.modelVersion=b.longs===String?a.Long.prototype.toString.call(c.modelVersion):b.longs===Number?new a.LongBits(c.modelVersion.low>>>0,c.modelVersion.high>>>0).toNumber():c.modelVersion),c.docString!=null&&c.hasOwnProperty("docString")&&(g.docString=c.docString),c.graph!=null&&c.hasOwnProperty("graph")&&(g.graph=d.onnx.GraphProto.toObject(c.graph,b)),c.opsetImport&&c.opsetImport.length){g.opsetImport=[];for(var at=0;at<c.opsetImport.length;++at)g.opsetImport[at]=d.onnx.OperatorSetIdProto.toObject(c.opsetImport[at],b)}if(c.metadataProps&&c.metadataProps.length){g.metadataProps=[];for(var at=0;at<c.metadataProps.length;++at)g.metadataProps[at]=d.onnx.StringStringEntryProto.toObject(c.metadataProps[at],b)}if(c.trainingInfo&&c.trainingInfo.length){g.trainingInfo=[];for(var at=0;at<c.trainingInfo.length;++at)g.trainingInfo[at]=d.onnx.TrainingInfoProto.toObject(c.trainingInfo[at],b)}if(c.functions&&c.functions.length){g.functions=[];for(var at=0;at<c.functions.length;++at)g.functions[at]=d.onnx.FunctionProto.toObject(c.functions[at],b)}return g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.ModelProto"},$}(),et.StringStringEntryProto=function(){function $(c){if(c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.key="",$.prototype.value="",$.create=function(c){return new $(c)},$.encode=function(c,b){return b||(b=h.create()),c.key!=null&&Object.hasOwnProperty.call(c,"key")&&b.uint32(10).string(c.key),c.value!=null&&Object.hasOwnProperty.call(c,"value")&&b.uint32(18).string(c.value),b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.StringStringEntryProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.key=c.string();break}case 2:{nt.value=c.string();break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){return typeof c!="object"||c===null?"object expected":c.key!=null&&c.hasOwnProperty("key")&&!a.isString(c.key)?"key: string expected":c.value!=null&&c.hasOwnProperty("value")&&!a.isString(c.value)?"value: string expected":null},$.fromObject=function(c){if(c instanceof d.onnx.StringStringEntryProto)return c;var b=new d.onnx.StringStringEntryProto;return c.key!=null&&(b.key=String(c.key)),c.value!=null&&(b.value=String(c.value)),b},$.toObject=function(c,b){b||(b={});var g={};return b.defaults&&(g.key="",g.value=""),c.key!=null&&c.hasOwnProperty("key")&&(g.key=c.key),c.value!=null&&c.hasOwnProperty("value")&&(g.value=c.value),g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.StringStringEntryProto"},$}(),et.TensorAnnotation=function(){function $(c){if(this.quantParameterTensorNames=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.tensorName="",$.prototype.quantParameterTensorNames=a.emptyArray,$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.tensorName!=null&&Object.hasOwnProperty.call(c,"tensorName")&&b.uint32(10).string(c.tensorName),c.quantParameterTensorNames!=null&&c.quantParameterTensorNames.length)for(var g=0;g<c.quantParameterTensorNames.length;++g)d.onnx.StringStringEntryProto.encode(c.quantParameterTensorNames[g],b.uint32(18).fork()).ldelim();return b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.TensorAnnotation;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.tensorName=c.string();break}case 2:{nt.quantParameterTensorNames&&nt.quantParameterTensorNames.length||(nt.quantParameterTensorNames=[]),nt.quantParameterTensorNames.push(d.onnx.StringStringEntryProto.decode(c,c.uint32()));break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.tensorName!=null&&c.hasOwnProperty("tensorName")&&!a.isString(c.tensorName))return"tensorName: string expected";if(c.quantParameterTensorNames!=null&&c.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(c.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var b=0;b<c.quantParameterTensorNames.length;++b){var g=d.onnx.StringStringEntryProto.verify(c.quantParameterTensorNames[b]);if(g)return"quantParameterTensorNames."+g}}return null},$.fromObject=function(c){if(c instanceof d.onnx.TensorAnnotation)return c;var b=new d.onnx.TensorAnnotation;if(c.tensorName!=null&&(b.tensorName=String(c.tensorName)),c.quantParameterTensorNames){if(!Array.isArray(c.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");b.quantParameterTensorNames=[];for(var g=0;g<c.quantParameterTensorNames.length;++g){if(typeof c.quantParameterTensorNames[g]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");b.quantParameterTensorNames[g]=d.onnx.StringStringEntryProto.fromObject(c.quantParameterTensorNames[g])}}return b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.quantParameterTensorNames=[]),b.defaults&&(g.tensorName=""),c.tensorName!=null&&c.hasOwnProperty("tensorName")&&(g.tensorName=c.tensorName),c.quantParameterTensorNames&&c.quantParameterTensorNames.length){g.quantParameterTensorNames=[];for(var nt=0;nt<c.quantParameterTensorNames.length;++nt)g.quantParameterTensorNames[nt]=d.onnx.StringStringEntryProto.toObject(c.quantParameterTensorNames[nt],b)}return g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.TensorAnnotation"},$}(),et.GraphProto=function(){function $(c){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.node=a.emptyArray,$.prototype.name="",$.prototype.initializer=a.emptyArray,$.prototype.sparseInitializer=a.emptyArray,$.prototype.docString="",$.prototype.input=a.emptyArray,$.prototype.output=a.emptyArray,$.prototype.valueInfo=a.emptyArray,$.prototype.quantizationAnnotation=a.emptyArray,$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.node!=null&&c.node.length)for(var g=0;g<c.node.length;++g)d.onnx.NodeProto.encode(c.node[g],b.uint32(10).fork()).ldelim();if(c.name!=null&&Object.hasOwnProperty.call(c,"name")&&b.uint32(18).string(c.name),c.initializer!=null&&c.initializer.length)for(var g=0;g<c.initializer.length;++g)d.onnx.TensorProto.encode(c.initializer[g],b.uint32(42).fork()).ldelim();if(c.docString!=null&&Object.hasOwnProperty.call(c,"docString")&&b.uint32(82).string(c.docString),c.input!=null&&c.input.length)for(var g=0;g<c.input.length;++g)d.onnx.ValueInfoProto.encode(c.input[g],b.uint32(90).fork()).ldelim();if(c.output!=null&&c.output.length)for(var g=0;g<c.output.length;++g)d.onnx.ValueInfoProto.encode(c.output[g],b.uint32(98).fork()).ldelim();if(c.valueInfo!=null&&c.valueInfo.length)for(var g=0;g<c.valueInfo.length;++g)d.onnx.ValueInfoProto.encode(c.valueInfo[g],b.uint32(106).fork()).ldelim();if(c.quantizationAnnotation!=null&&c.quantizationAnnotation.length)for(var g=0;g<c.quantizationAnnotation.length;++g)d.onnx.TensorAnnotation.encode(c.quantizationAnnotation[g],b.uint32(114).fork()).ldelim();if(c.sparseInitializer!=null&&c.sparseInitializer.length)for(var g=0;g<c.sparseInitializer.length;++g)d.onnx.SparseTensorProto.encode(c.sparseInitializer[g],b.uint32(122).fork()).ldelim();return b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.GraphProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.node&&nt.node.length||(nt.node=[]),nt.node.push(d.onnx.NodeProto.decode(c,c.uint32()));break}case 2:{nt.name=c.string();break}case 5:{nt.initializer&&nt.initializer.length||(nt.initializer=[]),nt.initializer.push(d.onnx.TensorProto.decode(c,c.uint32()));break}case 15:{nt.sparseInitializer&&nt.sparseInitializer.length||(nt.sparseInitializer=[]),nt.sparseInitializer.push(d.onnx.SparseTensorProto.decode(c,c.uint32()));break}case 10:{nt.docString=c.string();break}case 11:{nt.input&&nt.input.length||(nt.input=[]),nt.input.push(d.onnx.ValueInfoProto.decode(c,c.uint32()));break}case 12:{nt.output&&nt.output.length||(nt.output=[]),nt.output.push(d.onnx.ValueInfoProto.decode(c,c.uint32()));break}case 13:{nt.valueInfo&&nt.valueInfo.length||(nt.valueInfo=[]),nt.valueInfo.push(d.onnx.ValueInfoProto.decode(c,c.uint32()));break}case 14:{nt.quantizationAnnotation&&nt.quantizationAnnotation.length||(nt.quantizationAnnotation=[]),nt.quantizationAnnotation.push(d.onnx.TensorAnnotation.decode(c,c.uint32()));break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.node!=null&&c.hasOwnProperty("node")){if(!Array.isArray(c.node))return"node: array expected";for(var b=0;b<c.node.length;++b){var g=d.onnx.NodeProto.verify(c.node[b]);if(g)return"node."+g}}if(c.name!=null&&c.hasOwnProperty("name")&&!a.isString(c.name))return"name: string expected";if(c.initializer!=null&&c.hasOwnProperty("initializer")){if(!Array.isArray(c.initializer))return"initializer: array expected";for(var b=0;b<c.initializer.length;++b){var g=d.onnx.TensorProto.verify(c.initializer[b]);if(g)return"initializer."+g}}if(c.sparseInitializer!=null&&c.hasOwnProperty("sparseInitializer")){if(!Array.isArray(c.sparseInitializer))return"sparseInitializer: array expected";for(var b=0;b<c.sparseInitializer.length;++b){var g=d.onnx.SparseTensorProto.verify(c.sparseInitializer[b]);if(g)return"sparseInitializer."+g}}if(c.docString!=null&&c.hasOwnProperty("docString")&&!a.isString(c.docString))return"docString: string expected";if(c.input!=null&&c.hasOwnProperty("input")){if(!Array.isArray(c.input))return"input: array expected";for(var b=0;b<c.input.length;++b){var g=d.onnx.ValueInfoProto.verify(c.input[b]);if(g)return"input."+g}}if(c.output!=null&&c.hasOwnProperty("output")){if(!Array.isArray(c.output))return"output: array expected";for(var b=0;b<c.output.length;++b){var g=d.onnx.ValueInfoProto.verify(c.output[b]);if(g)return"output."+g}}if(c.valueInfo!=null&&c.hasOwnProperty("valueInfo")){if(!Array.isArray(c.valueInfo))return"valueInfo: array expected";for(var b=0;b<c.valueInfo.length;++b){var g=d.onnx.ValueInfoProto.verify(c.valueInfo[b]);if(g)return"valueInfo."+g}}if(c.quantizationAnnotation!=null&&c.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(c.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var b=0;b<c.quantizationAnnotation.length;++b){var g=d.onnx.TensorAnnotation.verify(c.quantizationAnnotation[b]);if(g)return"quantizationAnnotation."+g}}return null},$.fromObject=function(c){if(c instanceof d.onnx.GraphProto)return c;var b=new d.onnx.GraphProto;if(c.node){if(!Array.isArray(c.node))throw TypeError(".onnx.GraphProto.node: array expected");b.node=[];for(var g=0;g<c.node.length;++g){if(typeof c.node[g]!="object")throw TypeError(".onnx.GraphProto.node: object expected");b.node[g]=d.onnx.NodeProto.fromObject(c.node[g])}}if(c.name!=null&&(b.name=String(c.name)),c.initializer){if(!Array.isArray(c.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");b.initializer=[];for(var g=0;g<c.initializer.length;++g){if(typeof c.initializer[g]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");b.initializer[g]=d.onnx.TensorProto.fromObject(c.initializer[g])}}if(c.sparseInitializer){if(!Array.isArray(c.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");b.sparseInitializer=[];for(var g=0;g<c.sparseInitializer.length;++g){if(typeof c.sparseInitializer[g]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");b.sparseInitializer[g]=d.onnx.SparseTensorProto.fromObject(c.sparseInitializer[g])}}if(c.docString!=null&&(b.docString=String(c.docString)),c.input){if(!Array.isArray(c.input))throw TypeError(".onnx.GraphProto.input: array expected");b.input=[];for(var g=0;g<c.input.length;++g){if(typeof c.input[g]!="object")throw TypeError(".onnx.GraphProto.input: object expected");b.input[g]=d.onnx.ValueInfoProto.fromObject(c.input[g])}}if(c.output){if(!Array.isArray(c.output))throw TypeError(".onnx.GraphProto.output: array expected");b.output=[];for(var g=0;g<c.output.length;++g){if(typeof c.output[g]!="object")throw TypeError(".onnx.GraphProto.output: object expected");b.output[g]=d.onnx.ValueInfoProto.fromObject(c.output[g])}}if(c.valueInfo){if(!Array.isArray(c.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");b.valueInfo=[];for(var g=0;g<c.valueInfo.length;++g){if(typeof c.valueInfo[g]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");b.valueInfo[g]=d.onnx.ValueInfoProto.fromObject(c.valueInfo[g])}}if(c.quantizationAnnotation){if(!Array.isArray(c.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");b.quantizationAnnotation=[];for(var g=0;g<c.quantizationAnnotation.length;++g){if(typeof c.quantizationAnnotation[g]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");b.quantizationAnnotation[g]=d.onnx.TensorAnnotation.fromObject(c.quantizationAnnotation[g])}}return b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.node=[],g.initializer=[],g.input=[],g.output=[],g.valueInfo=[],g.quantizationAnnotation=[],g.sparseInitializer=[]),b.defaults&&(g.name="",g.docString=""),c.node&&c.node.length){g.node=[];for(var nt=0;nt<c.node.length;++nt)g.node[nt]=d.onnx.NodeProto.toObject(c.node[nt],b)}if(c.name!=null&&c.hasOwnProperty("name")&&(g.name=c.name),c.initializer&&c.initializer.length){g.initializer=[];for(var nt=0;nt<c.initializer.length;++nt)g.initializer[nt]=d.onnx.TensorProto.toObject(c.initializer[nt],b)}if(c.docString!=null&&c.hasOwnProperty("docString")&&(g.docString=c.docString),c.input&&c.input.length){g.input=[];for(var nt=0;nt<c.input.length;++nt)g.input[nt]=d.onnx.ValueInfoProto.toObject(c.input[nt],b)}if(c.output&&c.output.length){g.output=[];for(var nt=0;nt<c.output.length;++nt)g.output[nt]=d.onnx.ValueInfoProto.toObject(c.output[nt],b)}if(c.valueInfo&&c.valueInfo.length){g.valueInfo=[];for(var nt=0;nt<c.valueInfo.length;++nt)g.valueInfo[nt]=d.onnx.ValueInfoProto.toObject(c.valueInfo[nt],b)}if(c.quantizationAnnotation&&c.quantizationAnnotation.length){g.quantizationAnnotation=[];for(var nt=0;nt<c.quantizationAnnotation.length;++nt)g.quantizationAnnotation[nt]=d.onnx.TensorAnnotation.toObject(c.quantizationAnnotation[nt],b)}if(c.sparseInitializer&&c.sparseInitializer.length){g.sparseInitializer=[];for(var nt=0;nt<c.sparseInitializer.length;++nt)g.sparseInitializer[nt]=d.onnx.SparseTensorProto.toObject(c.sparseInitializer[nt],b)}return g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.GraphProto"},$}(),et.TensorProto=function(){function $(c){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.dims=a.emptyArray,$.prototype.dataType=0,$.prototype.segment=null,$.prototype.floatData=a.emptyArray,$.prototype.int32Data=a.emptyArray,$.prototype.stringData=a.emptyArray,$.prototype.int64Data=a.emptyArray,$.prototype.name="",$.prototype.docString="",$.prototype.rawData=a.newBuffer([]),$.prototype.externalData=a.emptyArray,$.prototype.dataLocation=0,$.prototype.doubleData=a.emptyArray,$.prototype.uint64Data=a.emptyArray,$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.dims!=null&&c.dims.length){b.uint32(10).fork();for(var g=0;g<c.dims.length;++g)b.int64(c.dims[g]);b.ldelim()}if(c.dataType!=null&&Object.hasOwnProperty.call(c,"dataType")&&b.uint32(16).int32(c.dataType),c.segment!=null&&Object.hasOwnProperty.call(c,"segment")&&d.onnx.TensorProto.Segment.encode(c.segment,b.uint32(26).fork()).ldelim(),c.floatData!=null&&c.floatData.length){b.uint32(34).fork();for(var g=0;g<c.floatData.length;++g)b.float(c.floatData[g]);b.ldelim()}if(c.int32Data!=null&&c.int32Data.length){b.uint32(42).fork();for(var g=0;g<c.int32Data.length;++g)b.int32(c.int32Data[g]);b.ldelim()}if(c.stringData!=null&&c.stringData.length)for(var g=0;g<c.stringData.length;++g)b.uint32(50).bytes(c.stringData[g]);if(c.int64Data!=null&&c.int64Data.length){b.uint32(58).fork();for(var g=0;g<c.int64Data.length;++g)b.int64(c.int64Data[g]);b.ldelim()}if(c.name!=null&&Object.hasOwnProperty.call(c,"name")&&b.uint32(66).string(c.name),c.rawData!=null&&Object.hasOwnProperty.call(c,"rawData")&&b.uint32(74).bytes(c.rawData),c.doubleData!=null&&c.doubleData.length){b.uint32(82).fork();for(var g=0;g<c.doubleData.length;++g)b.double(c.doubleData[g]);b.ldelim()}if(c.uint64Data!=null&&c.uint64Data.length){b.uint32(90).fork();for(var g=0;g<c.uint64Data.length;++g)b.uint64(c.uint64Data[g]);b.ldelim()}if(c.docString!=null&&Object.hasOwnProperty.call(c,"docString")&&b.uint32(98).string(c.docString),c.externalData!=null&&c.externalData.length)for(var g=0;g<c.externalData.length;++g)d.onnx.StringStringEntryProto.encode(c.externalData[g],b.uint32(106).fork()).ldelim();return c.dataLocation!=null&&Object.hasOwnProperty.call(c,"dataLocation")&&b.uint32(112).int32(c.dataLocation),b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.TensorProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{if(nt.dims&&nt.dims.length||(nt.dims=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.dims.push(c.int64());else nt.dims.push(c.int64());break}case 2:{nt.dataType=c.int32();break}case 3:{nt.segment=d.onnx.TensorProto.Segment.decode(c,c.uint32());break}case 4:{if(nt.floatData&&nt.floatData.length||(nt.floatData=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.floatData.push(c.float());else nt.floatData.push(c.float());break}case 5:{if(nt.int32Data&&nt.int32Data.length||(nt.int32Data=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.int32Data.push(c.int32());else nt.int32Data.push(c.int32());break}case 6:{nt.stringData&&nt.stringData.length||(nt.stringData=[]),nt.stringData.push(c.bytes());break}case 7:{if(nt.int64Data&&nt.int64Data.length||(nt.int64Data=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.int64Data.push(c.int64());else nt.int64Data.push(c.int64());break}case 8:{nt.name=c.string();break}case 12:{nt.docString=c.string();break}case 9:{nt.rawData=c.bytes();break}case 13:{nt.externalData&&nt.externalData.length||(nt.externalData=[]),nt.externalData.push(d.onnx.StringStringEntryProto.decode(c,c.uint32()));break}case 14:{nt.dataLocation=c.int32();break}case 10:{if(nt.doubleData&&nt.doubleData.length||(nt.doubleData=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.doubleData.push(c.double());else nt.doubleData.push(c.double());break}case 11:{if(nt.uint64Data&&nt.uint64Data.length||(nt.uint64Data=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.uint64Data.push(c.uint64());else nt.uint64Data.push(c.uint64());break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.dims!=null&&c.hasOwnProperty("dims")){if(!Array.isArray(c.dims))return"dims: array expected";for(var b=0;b<c.dims.length;++b)if(!a.isInteger(c.dims[b])&&!(c.dims[b]&&a.isInteger(c.dims[b].low)&&a.isInteger(c.dims[b].high)))return"dims: integer|Long[] expected"}if(c.dataType!=null&&c.hasOwnProperty("dataType")&&!a.isInteger(c.dataType))return"dataType: integer expected";if(c.segment!=null&&c.hasOwnProperty("segment")){var g=d.onnx.TensorProto.Segment.verify(c.segment);if(g)return"segment."+g}if(c.floatData!=null&&c.hasOwnProperty("floatData")){if(!Array.isArray(c.floatData))return"floatData: array expected";for(var b=0;b<c.floatData.length;++b)if(typeof c.floatData[b]!="number")return"floatData: number[] expected"}if(c.int32Data!=null&&c.hasOwnProperty("int32Data")){if(!Array.isArray(c.int32Data))return"int32Data: array expected";for(var b=0;b<c.int32Data.length;++b)if(!a.isInteger(c.int32Data[b]))return"int32Data: integer[] expected"}if(c.stringData!=null&&c.hasOwnProperty("stringData")){if(!Array.isArray(c.stringData))return"stringData: array expected";for(var b=0;b<c.stringData.length;++b)if(!(c.stringData[b]&&typeof c.stringData[b].length=="number"||a.isString(c.stringData[b])))return"stringData: buffer[] expected"}if(c.int64Data!=null&&c.hasOwnProperty("int64Data")){if(!Array.isArray(c.int64Data))return"int64Data: array expected";for(var b=0;b<c.int64Data.length;++b)if(!a.isInteger(c.int64Data[b])&&!(c.int64Data[b]&&a.isInteger(c.int64Data[b].low)&&a.isInteger(c.int64Data[b].high)))return"int64Data: integer|Long[] expected"}if(c.name!=null&&c.hasOwnProperty("name")&&!a.isString(c.name))return"name: string expected";if(c.docString!=null&&c.hasOwnProperty("docString")&&!a.isString(c.docString))return"docString: string expected";if(c.rawData!=null&&c.hasOwnProperty("rawData")&&!(c.rawData&&typeof c.rawData.length=="number"||a.isString(c.rawData)))return"rawData: buffer expected";if(c.externalData!=null&&c.hasOwnProperty("externalData")){if(!Array.isArray(c.externalData))return"externalData: array expected";for(var b=0;b<c.externalData.length;++b){var g=d.onnx.StringStringEntryProto.verify(c.externalData[b]);if(g)return"externalData."+g}}if(c.dataLocation!=null&&c.hasOwnProperty("dataLocation"))switch(c.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(c.doubleData!=null&&c.hasOwnProperty("doubleData")){if(!Array.isArray(c.doubleData))return"doubleData: array expected";for(var b=0;b<c.doubleData.length;++b)if(typeof c.doubleData[b]!="number")return"doubleData: number[] expected"}if(c.uint64Data!=null&&c.hasOwnProperty("uint64Data")){if(!Array.isArray(c.uint64Data))return"uint64Data: array expected";for(var b=0;b<c.uint64Data.length;++b)if(!a.isInteger(c.uint64Data[b])&&!(c.uint64Data[b]&&a.isInteger(c.uint64Data[b].low)&&a.isInteger(c.uint64Data[b].high)))return"uint64Data: integer|Long[] expected"}return null},$.fromObject=function(c){if(c instanceof d.onnx.TensorProto)return c;var b=new d.onnx.TensorProto;if(c.dims){if(!Array.isArray(c.dims))throw TypeError(".onnx.TensorProto.dims: array expected");b.dims=[];for(var g=0;g<c.dims.length;++g)a.Long?(b.dims[g]=a.Long.fromValue(c.dims[g])).unsigned=!1:typeof c.dims[g]=="string"?b.dims[g]=parseInt(c.dims[g],10):typeof c.dims[g]=="number"?b.dims[g]=c.dims[g]:typeof c.dims[g]=="object"&&(b.dims[g]=new a.LongBits(c.dims[g].low>>>0,c.dims[g].high>>>0).toNumber())}if(c.dataType!=null&&(b.dataType=c.dataType|0),c.segment!=null){if(typeof c.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");b.segment=d.onnx.TensorProto.Segment.fromObject(c.segment)}if(c.floatData){if(!Array.isArray(c.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");b.floatData=[];for(var g=0;g<c.floatData.length;++g)b.floatData[g]=Number(c.floatData[g])}if(c.int32Data){if(!Array.isArray(c.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");b.int32Data=[];for(var g=0;g<c.int32Data.length;++g)b.int32Data[g]=c.int32Data[g]|0}if(c.stringData){if(!Array.isArray(c.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");b.stringData=[];for(var g=0;g<c.stringData.length;++g)typeof c.stringData[g]=="string"?a.base64.decode(c.stringData[g],b.stringData[g]=a.newBuffer(a.base64.length(c.stringData[g])),0):c.stringData[g].length>=0&&(b.stringData[g]=c.stringData[g])}if(c.int64Data){if(!Array.isArray(c.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");b.int64Data=[];for(var g=0;g<c.int64Data.length;++g)a.Long?(b.int64Data[g]=a.Long.fromValue(c.int64Data[g])).unsigned=!1:typeof c.int64Data[g]=="string"?b.int64Data[g]=parseInt(c.int64Data[g],10):typeof c.int64Data[g]=="number"?b.int64Data[g]=c.int64Data[g]:typeof c.int64Data[g]=="object"&&(b.int64Data[g]=new a.LongBits(c.int64Data[g].low>>>0,c.int64Data[g].high>>>0).toNumber())}if(c.name!=null&&(b.name=String(c.name)),c.docString!=null&&(b.docString=String(c.docString)),c.rawData!=null&&(typeof c.rawData=="string"?a.base64.decode(c.rawData,b.rawData=a.newBuffer(a.base64.length(c.rawData)),0):c.rawData.length>=0&&(b.rawData=c.rawData)),c.externalData){if(!Array.isArray(c.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");b.externalData=[];for(var g=0;g<c.externalData.length;++g){if(typeof c.externalData[g]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");b.externalData[g]=d.onnx.StringStringEntryProto.fromObject(c.externalData[g])}}switch(c.dataLocation){default:if(typeof c.dataLocation=="number"){b.dataLocation=c.dataLocation;break}break;case"DEFAULT":case 0:b.dataLocation=0;break;case"EXTERNAL":case 1:b.dataLocation=1;break}if(c.doubleData){if(!Array.isArray(c.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");b.doubleData=[];for(var g=0;g<c.doubleData.length;++g)b.doubleData[g]=Number(c.doubleData[g])}if(c.uint64Data){if(!Array.isArray(c.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");b.uint64Data=[];for(var g=0;g<c.uint64Data.length;++g)a.Long?(b.uint64Data[g]=a.Long.fromValue(c.uint64Data[g])).unsigned=!0:typeof c.uint64Data[g]=="string"?b.uint64Data[g]=parseInt(c.uint64Data[g],10):typeof c.uint64Data[g]=="number"?b.uint64Data[g]=c.uint64Data[g]:typeof c.uint64Data[g]=="object"&&(b.uint64Data[g]=new a.LongBits(c.uint64Data[g].low>>>0,c.uint64Data[g].high>>>0).toNumber(!0))}return b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.dims=[],g.floatData=[],g.int32Data=[],g.stringData=[],g.int64Data=[],g.doubleData=[],g.uint64Data=[],g.externalData=[]),b.defaults&&(g.dataType=0,g.segment=null,g.name="",b.bytes===String?g.rawData="":(g.rawData=[],b.bytes!==Array&&(g.rawData=a.newBuffer(g.rawData))),g.docString="",g.dataLocation=b.enums===String?"DEFAULT":0),c.dims&&c.dims.length){g.dims=[];for(var nt=0;nt<c.dims.length;++nt)typeof c.dims[nt]=="number"?g.dims[nt]=b.longs===String?String(c.dims[nt]):c.dims[nt]:g.dims[nt]=b.longs===String?a.Long.prototype.toString.call(c.dims[nt]):b.longs===Number?new a.LongBits(c.dims[nt].low>>>0,c.dims[nt].high>>>0).toNumber():c.dims[nt]}if(c.dataType!=null&&c.hasOwnProperty("dataType")&&(g.dataType=c.dataType),c.segment!=null&&c.hasOwnProperty("segment")&&(g.segment=d.onnx.TensorProto.Segment.toObject(c.segment,b)),c.floatData&&c.floatData.length){g.floatData=[];for(var nt=0;nt<c.floatData.length;++nt)g.floatData[nt]=b.json&&!isFinite(c.floatData[nt])?String(c.floatData[nt]):c.floatData[nt]}if(c.int32Data&&c.int32Data.length){g.int32Data=[];for(var nt=0;nt<c.int32Data.length;++nt)g.int32Data[nt]=c.int32Data[nt]}if(c.stringData&&c.stringData.length){g.stringData=[];for(var nt=0;nt<c.stringData.length;++nt)g.stringData[nt]=b.bytes===String?a.base64.encode(c.stringData[nt],0,c.stringData[nt].length):b.bytes===Array?Array.prototype.slice.call(c.stringData[nt]):c.stringData[nt]}if(c.int64Data&&c.int64Data.length){g.int64Data=[];for(var nt=0;nt<c.int64Data.length;++nt)typeof c.int64Data[nt]=="number"?g.int64Data[nt]=b.longs===String?String(c.int64Data[nt]):c.int64Data[nt]:g.int64Data[nt]=b.longs===String?a.Long.prototype.toString.call(c.int64Data[nt]):b.longs===Number?new a.LongBits(c.int64Data[nt].low>>>0,c.int64Data[nt].high>>>0).toNumber():c.int64Data[nt]}if(c.name!=null&&c.hasOwnProperty("name")&&(g.name=c.name),c.rawData!=null&&c.hasOwnProperty("rawData")&&(g.rawData=b.bytes===String?a.base64.encode(c.rawData,0,c.rawData.length):b.bytes===Array?Array.prototype.slice.call(c.rawData):c.rawData),c.doubleData&&c.doubleData.length){g.doubleData=[];for(var nt=0;nt<c.doubleData.length;++nt)g.doubleData[nt]=b.json&&!isFinite(c.doubleData[nt])?String(c.doubleData[nt]):c.doubleData[nt]}if(c.uint64Data&&c.uint64Data.length){g.uint64Data=[];for(var nt=0;nt<c.uint64Data.length;++nt)typeof c.uint64Data[nt]=="number"?g.uint64Data[nt]=b.longs===String?String(c.uint64Data[nt]):c.uint64Data[nt]:g.uint64Data[nt]=b.longs===String?a.Long.prototype.toString.call(c.uint64Data[nt]):b.longs===Number?new a.LongBits(c.uint64Data[nt].low>>>0,c.uint64Data[nt].high>>>0).toNumber(!0):c.uint64Data[nt]}if(c.docString!=null&&c.hasOwnProperty("docString")&&(g.docString=c.docString),c.externalData&&c.externalData.length){g.externalData=[];for(var nt=0;nt<c.externalData.length;++nt)g.externalData[nt]=d.onnx.StringStringEntryProto.toObject(c.externalData[nt],b)}return c.dataLocation!=null&&c.hasOwnProperty("dataLocation")&&(g.dataLocation=b.enums===String?d.onnx.TensorProto.DataLocation[c.dataLocation]===void 0?c.dataLocation:d.onnx.TensorProto.DataLocation[c.dataLocation]:c.dataLocation),g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.TensorProto"},$.DataType=function(){var c={},b=Object.create(c);return b[c[0]="UNDEFINED"]=0,b[c[1]="FLOAT"]=1,b[c[2]="UINT8"]=2,b[c[3]="INT8"]=3,b[c[4]="UINT16"]=4,b[c[5]="INT16"]=5,b[c[6]="INT32"]=6,b[c[7]="INT64"]=7,b[c[8]="STRING"]=8,b[c[9]="BOOL"]=9,b[c[10]="FLOAT16"]=10,b[c[11]="DOUBLE"]=11,b[c[12]="UINT32"]=12,b[c[13]="UINT64"]=13,b[c[14]="COMPLEX64"]=14,b[c[15]="COMPLEX128"]=15,b[c[16]="BFLOAT16"]=16,b[c[17]="FLOAT8E4M3FN"]=17,b[c[18]="FLOAT8E4M3FNUZ"]=18,b[c[19]="FLOAT8E5M2"]=19,b[c[20]="FLOAT8E5M2FNUZ"]=20,b}(),$.Segment=function(){function c(b){if(b)for(var g=Object.keys(b),nt=0;nt<g.length;++nt)b[g[nt]]!=null&&(this[g[nt]]=b[g[nt]])}return c.prototype.begin=a.Long?a.Long.fromBits(0,0,!1):0,c.prototype.end=a.Long?a.Long.fromBits(0,0,!1):0,c.create=function(b){return new c(b)},c.encode=function(b,g){return g||(g=h.create()),b.begin!=null&&Object.hasOwnProperty.call(b,"begin")&&g.uint32(8).int64(b.begin),b.end!=null&&Object.hasOwnProperty.call(b,"end")&&g.uint32(16).int64(b.end),g},c.encodeDelimited=function(b,g){return this.encode(b,g).ldelim()},c.decode=function(b,g){b instanceof s||(b=s.create(b));for(var nt=g===void 0?b.len:b.pos+g,at=new d.onnx.TensorProto.Segment;b.pos<nt;){var Ot=b.uint32();switch(Ot>>>3){case 1:{at.begin=b.int64();break}case 2:{at.end=b.int64();break}default:b.skipType(Ot&7);break}}return at},c.decodeDelimited=function(b){return b instanceof s||(b=new s(b)),this.decode(b,b.uint32())},c.verify=function(b){return typeof b!="object"||b===null?"object expected":b.begin!=null&&b.hasOwnProperty("begin")&&!a.isInteger(b.begin)&&!(b.begin&&a.isInteger(b.begin.low)&&a.isInteger(b.begin.high))?"begin: integer|Long expected":b.end!=null&&b.hasOwnProperty("end")&&!a.isInteger(b.end)&&!(b.end&&a.isInteger(b.end.low)&&a.isInteger(b.end.high))?"end: integer|Long expected":null},c.fromObject=function(b){if(b instanceof d.onnx.TensorProto.Segment)return b;var g=new d.onnx.TensorProto.Segment;return b.begin!=null&&(a.Long?(g.begin=a.Long.fromValue(b.begin)).unsigned=!1:typeof b.begin=="string"?g.begin=parseInt(b.begin,10):typeof b.begin=="number"?g.begin=b.begin:typeof b.begin=="object"&&(g.begin=new a.LongBits(b.begin.low>>>0,b.begin.high>>>0).toNumber())),b.end!=null&&(a.Long?(g.end=a.Long.fromValue(b.end)).unsigned=!1:typeof b.end=="string"?g.end=parseInt(b.end,10):typeof b.end=="number"?g.end=b.end:typeof b.end=="object"&&(g.end=new a.LongBits(b.end.low>>>0,b.end.high>>>0).toNumber())),g},c.toObject=function(b,g){g||(g={});var nt={};if(g.defaults){if(a.Long){var at=new a.Long(0,0,!1);nt.begin=g.longs===String?at.toString():g.longs===Number?at.toNumber():at}else nt.begin=g.longs===String?"0":0;if(a.Long){var at=new a.Long(0,0,!1);nt.end=g.longs===String?at.toString():g.longs===Number?at.toNumber():at}else nt.end=g.longs===String?"0":0}return b.begin!=null&&b.hasOwnProperty("begin")&&(typeof b.begin=="number"?nt.begin=g.longs===String?String(b.begin):b.begin:nt.begin=g.longs===String?a.Long.prototype.toString.call(b.begin):g.longs===Number?new a.LongBits(b.begin.low>>>0,b.begin.high>>>0).toNumber():b.begin),b.end!=null&&b.hasOwnProperty("end")&&(typeof b.end=="number"?nt.end=g.longs===String?String(b.end):b.end:nt.end=g.longs===String?a.Long.prototype.toString.call(b.end):g.longs===Number?new a.LongBits(b.end.low>>>0,b.end.high>>>0).toNumber():b.end),nt},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(b){return b===void 0&&(b="type.googleapis.com"),b+"/onnx.TensorProto.Segment"},c}(),$.DataLocation=function(){var c={},b=Object.create(c);return b[c[0]="DEFAULT"]=0,b[c[1]="EXTERNAL"]=1,b}(),$}(),et.SparseTensorProto=function(){function $(c){if(this.dims=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.values=null,$.prototype.indices=null,$.prototype.dims=a.emptyArray,$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.values!=null&&Object.hasOwnProperty.call(c,"values")&&d.onnx.TensorProto.encode(c.values,b.uint32(10).fork()).ldelim(),c.indices!=null&&Object.hasOwnProperty.call(c,"indices")&&d.onnx.TensorProto.encode(c.indices,b.uint32(18).fork()).ldelim(),c.dims!=null&&c.dims.length){b.uint32(26).fork();for(var g=0;g<c.dims.length;++g)b.int64(c.dims[g]);b.ldelim()}return b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.SparseTensorProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.values=d.onnx.TensorProto.decode(c,c.uint32());break}case 2:{nt.indices=d.onnx.TensorProto.decode(c,c.uint32());break}case 3:{if(nt.dims&&nt.dims.length||(nt.dims=[]),(at&7)===2)for(var Ot=c.uint32()+c.pos;c.pos<Ot;)nt.dims.push(c.int64());else nt.dims.push(c.int64());break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.values!=null&&c.hasOwnProperty("values")){var b=d.onnx.TensorProto.verify(c.values);if(b)return"values."+b}if(c.indices!=null&&c.hasOwnProperty("indices")){var b=d.onnx.TensorProto.verify(c.indices);if(b)return"indices."+b}if(c.dims!=null&&c.hasOwnProperty("dims")){if(!Array.isArray(c.dims))return"dims: array expected";for(var g=0;g<c.dims.length;++g)if(!a.isInteger(c.dims[g])&&!(c.dims[g]&&a.isInteger(c.dims[g].low)&&a.isInteger(c.dims[g].high)))return"dims: integer|Long[] expected"}return null},$.fromObject=function(c){if(c instanceof d.onnx.SparseTensorProto)return c;var b=new d.onnx.SparseTensorProto;if(c.values!=null){if(typeof c.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");b.values=d.onnx.TensorProto.fromObject(c.values)}if(c.indices!=null){if(typeof c.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");b.indices=d.onnx.TensorProto.fromObject(c.indices)}if(c.dims){if(!Array.isArray(c.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");b.dims=[];for(var g=0;g<c.dims.length;++g)a.Long?(b.dims[g]=a.Long.fromValue(c.dims[g])).unsigned=!1:typeof c.dims[g]=="string"?b.dims[g]=parseInt(c.dims[g],10):typeof c.dims[g]=="number"?b.dims[g]=c.dims[g]:typeof c.dims[g]=="object"&&(b.dims[g]=new a.LongBits(c.dims[g].low>>>0,c.dims[g].high>>>0).toNumber())}return b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.dims=[]),b.defaults&&(g.values=null,g.indices=null),c.values!=null&&c.hasOwnProperty("values")&&(g.values=d.onnx.TensorProto.toObject(c.values,b)),c.indices!=null&&c.hasOwnProperty("indices")&&(g.indices=d.onnx.TensorProto.toObject(c.indices,b)),c.dims&&c.dims.length){g.dims=[];for(var nt=0;nt<c.dims.length;++nt)typeof c.dims[nt]=="number"?g.dims[nt]=b.longs===String?String(c.dims[nt]):c.dims[nt]:g.dims[nt]=b.longs===String?a.Long.prototype.toString.call(c.dims[nt]):b.longs===Number?new a.LongBits(c.dims[nt].low>>>0,c.dims[nt].high>>>0).toNumber():c.dims[nt]}return g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.SparseTensorProto"},$}(),et.TensorShapeProto=function(){function $(c){if(this.dim=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.dim=a.emptyArray,$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.dim!=null&&c.dim.length)for(var g=0;g<c.dim.length;++g)d.onnx.TensorShapeProto.Dimension.encode(c.dim[g],b.uint32(10).fork()).ldelim();return b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.TensorShapeProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.dim&&nt.dim.length||(nt.dim=[]),nt.dim.push(d.onnx.TensorShapeProto.Dimension.decode(c,c.uint32()));break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.dim!=null&&c.hasOwnProperty("dim")){if(!Array.isArray(c.dim))return"dim: array expected";for(var b=0;b<c.dim.length;++b){var g=d.onnx.TensorShapeProto.Dimension.verify(c.dim[b]);if(g)return"dim."+g}}return null},$.fromObject=function(c){if(c instanceof d.onnx.TensorShapeProto)return c;var b=new d.onnx.TensorShapeProto;if(c.dim){if(!Array.isArray(c.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");b.dim=[];for(var g=0;g<c.dim.length;++g){if(typeof c.dim[g]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");b.dim[g]=d.onnx.TensorShapeProto.Dimension.fromObject(c.dim[g])}}return b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.dim=[]),c.dim&&c.dim.length){g.dim=[];for(var nt=0;nt<c.dim.length;++nt)g.dim[nt]=d.onnx.TensorShapeProto.Dimension.toObject(c.dim[nt],b)}return g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.TensorShapeProto"},$.Dimension=function(){function c(g){if(g)for(var nt=Object.keys(g),at=0;at<nt.length;++at)g[nt[at]]!=null&&(this[nt[at]]=g[nt[at]])}c.prototype.dimValue=null,c.prototype.dimParam=null,c.prototype.denotation="";var b;return Object.defineProperty(c.prototype,"value",{get:a.oneOfGetter(b=["dimValue","dimParam"]),set:a.oneOfSetter(b)}),c.create=function(g){return new c(g)},c.encode=function(g,nt){return nt||(nt=h.create()),g.dimValue!=null&&Object.hasOwnProperty.call(g,"dimValue")&&nt.uint32(8).int64(g.dimValue),g.dimParam!=null&&Object.hasOwnProperty.call(g,"dimParam")&&nt.uint32(18).string(g.dimParam),g.denotation!=null&&Object.hasOwnProperty.call(g,"denotation")&&nt.uint32(26).string(g.denotation),nt},c.encodeDelimited=function(g,nt){return this.encode(g,nt).ldelim()},c.decode=function(g,nt){g instanceof s||(g=s.create(g));for(var at=nt===void 0?g.len:g.pos+nt,Ot=new d.onnx.TensorShapeProto.Dimension;g.pos<at;){var At=g.uint32();switch(At>>>3){case 1:{Ot.dimValue=g.int64();break}case 2:{Ot.dimParam=g.string();break}case 3:{Ot.denotation=g.string();break}default:g.skipType(At&7);break}}return Ot},c.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},c.verify=function(g){if(typeof g!="object"||g===null)return"object expected";var nt={};if(g.dimValue!=null&&g.hasOwnProperty("dimValue")&&(nt.value=1,!a.isInteger(g.dimValue)&&!(g.dimValue&&a.isInteger(g.dimValue.low)&&a.isInteger(g.dimValue.high))))return"dimValue: integer|Long expected";if(g.dimParam!=null&&g.hasOwnProperty("dimParam")){if(nt.value===1)return"value: multiple values";if(nt.value=1,!a.isString(g.dimParam))return"dimParam: string expected"}return g.denotation!=null&&g.hasOwnProperty("denotation")&&!a.isString(g.denotation)?"denotation: string expected":null},c.fromObject=function(g){if(g instanceof d.onnx.TensorShapeProto.Dimension)return g;var nt=new d.onnx.TensorShapeProto.Dimension;return g.dimValue!=null&&(a.Long?(nt.dimValue=a.Long.fromValue(g.dimValue)).unsigned=!1:typeof g.dimValue=="string"?nt.dimValue=parseInt(g.dimValue,10):typeof g.dimValue=="number"?nt.dimValue=g.dimValue:typeof g.dimValue=="object"&&(nt.dimValue=new a.LongBits(g.dimValue.low>>>0,g.dimValue.high>>>0).toNumber())),g.dimParam!=null&&(nt.dimParam=String(g.dimParam)),g.denotation!=null&&(nt.denotation=String(g.denotation)),nt},c.toObject=function(g,nt){nt||(nt={});var at={};return nt.defaults&&(at.denotation=""),g.dimValue!=null&&g.hasOwnProperty("dimValue")&&(typeof g.dimValue=="number"?at.dimValue=nt.longs===String?String(g.dimValue):g.dimValue:at.dimValue=nt.longs===String?a.Long.prototype.toString.call(g.dimValue):nt.longs===Number?new a.LongBits(g.dimValue.low>>>0,g.dimValue.high>>>0).toNumber():g.dimValue,nt.oneofs&&(at.value="dimValue")),g.dimParam!=null&&g.hasOwnProperty("dimParam")&&(at.dimParam=g.dimParam,nt.oneofs&&(at.value="dimParam")),g.denotation!=null&&g.hasOwnProperty("denotation")&&(at.denotation=g.denotation),at},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TensorShapeProto.Dimension"},c}(),$}(),et.TypeProto=function(){function $(b){if(b)for(var g=Object.keys(b),nt=0;nt<g.length;++nt)b[g[nt]]!=null&&(this[g[nt]]=b[g[nt]])}$.prototype.tensorType=null,$.prototype.sequenceType=null,$.prototype.mapType=null,$.prototype.optionalType=null,$.prototype.sparseTensorType=null,$.prototype.denotation="";var c;return Object.defineProperty($.prototype,"value",{get:a.oneOfGetter(c=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:a.oneOfSetter(c)}),$.create=function(b){return new $(b)},$.encode=function(b,g){return g||(g=h.create()),b.tensorType!=null&&Object.hasOwnProperty.call(b,"tensorType")&&d.onnx.TypeProto.Tensor.encode(b.tensorType,g.uint32(10).fork()).ldelim(),b.sequenceType!=null&&Object.hasOwnProperty.call(b,"sequenceType")&&d.onnx.TypeProto.Sequence.encode(b.sequenceType,g.uint32(34).fork()).ldelim(),b.mapType!=null&&Object.hasOwnProperty.call(b,"mapType")&&d.onnx.TypeProto.Map.encode(b.mapType,g.uint32(42).fork()).ldelim(),b.denotation!=null&&Object.hasOwnProperty.call(b,"denotation")&&g.uint32(50).string(b.denotation),b.sparseTensorType!=null&&Object.hasOwnProperty.call(b,"sparseTensorType")&&d.onnx.TypeProto.SparseTensor.encode(b.sparseTensorType,g.uint32(66).fork()).ldelim(),b.optionalType!=null&&Object.hasOwnProperty.call(b,"optionalType")&&d.onnx.TypeProto.Optional.encode(b.optionalType,g.uint32(74).fork()).ldelim(),g},$.encodeDelimited=function(b,g){return this.encode(b,g).ldelim()},$.decode=function(b,g){b instanceof s||(b=s.create(b));for(var nt=g===void 0?b.len:b.pos+g,at=new d.onnx.TypeProto;b.pos<nt;){var Ot=b.uint32();switch(Ot>>>3){case 1:{at.tensorType=d.onnx.TypeProto.Tensor.decode(b,b.uint32());break}case 4:{at.sequenceType=d.onnx.TypeProto.Sequence.decode(b,b.uint32());break}case 5:{at.mapType=d.onnx.TypeProto.Map.decode(b,b.uint32());break}case 9:{at.optionalType=d.onnx.TypeProto.Optional.decode(b,b.uint32());break}case 8:{at.sparseTensorType=d.onnx.TypeProto.SparseTensor.decode(b,b.uint32());break}case 6:{at.denotation=b.string();break}default:b.skipType(Ot&7);break}}return at},$.decodeDelimited=function(b){return b instanceof s||(b=new s(b)),this.decode(b,b.uint32())},$.verify=function(b){if(typeof b!="object"||b===null)return"object expected";var g={};if(b.tensorType!=null&&b.hasOwnProperty("tensorType")){g.value=1;{var nt=d.onnx.TypeProto.Tensor.verify(b.tensorType);if(nt)return"tensorType."+nt}}if(b.sequenceType!=null&&b.hasOwnProperty("sequenceType")){if(g.value===1)return"value: multiple values";g.value=1;{var nt=d.onnx.TypeProto.Sequence.verify(b.sequenceType);if(nt)return"sequenceType."+nt}}if(b.mapType!=null&&b.hasOwnProperty("mapType")){if(g.value===1)return"value: multiple values";g.value=1;{var nt=d.onnx.TypeProto.Map.verify(b.mapType);if(nt)return"mapType."+nt}}if(b.optionalType!=null&&b.hasOwnProperty("optionalType")){if(g.value===1)return"value: multiple values";g.value=1;{var nt=d.onnx.TypeProto.Optional.verify(b.optionalType);if(nt)return"optionalType."+nt}}if(b.sparseTensorType!=null&&b.hasOwnProperty("sparseTensorType")){if(g.value===1)return"value: multiple values";g.value=1;{var nt=d.onnx.TypeProto.SparseTensor.verify(b.sparseTensorType);if(nt)return"sparseTensorType."+nt}}return b.denotation!=null&&b.hasOwnProperty("denotation")&&!a.isString(b.denotation)?"denotation: string expected":null},$.fromObject=function(b){if(b instanceof d.onnx.TypeProto)return b;var g=new d.onnx.TypeProto;if(b.tensorType!=null){if(typeof b.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");g.tensorType=d.onnx.TypeProto.Tensor.fromObject(b.tensorType)}if(b.sequenceType!=null){if(typeof b.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");g.sequenceType=d.onnx.TypeProto.Sequence.fromObject(b.sequenceType)}if(b.mapType!=null){if(typeof b.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");g.mapType=d.onnx.TypeProto.Map.fromObject(b.mapType)}if(b.optionalType!=null){if(typeof b.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");g.optionalType=d.onnx.TypeProto.Optional.fromObject(b.optionalType)}if(b.sparseTensorType!=null){if(typeof b.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");g.sparseTensorType=d.onnx.TypeProto.SparseTensor.fromObject(b.sparseTensorType)}return b.denotation!=null&&(g.denotation=String(b.denotation)),g},$.toObject=function(b,g){g||(g={});var nt={};return g.defaults&&(nt.denotation=""),b.tensorType!=null&&b.hasOwnProperty("tensorType")&&(nt.tensorType=d.onnx.TypeProto.Tensor.toObject(b.tensorType,g),g.oneofs&&(nt.value="tensorType")),b.sequenceType!=null&&b.hasOwnProperty("sequenceType")&&(nt.sequenceType=d.onnx.TypeProto.Sequence.toObject(b.sequenceType,g),g.oneofs&&(nt.value="sequenceType")),b.mapType!=null&&b.hasOwnProperty("mapType")&&(nt.mapType=d.onnx.TypeProto.Map.toObject(b.mapType,g),g.oneofs&&(nt.value="mapType")),b.denotation!=null&&b.hasOwnProperty("denotation")&&(nt.denotation=b.denotation),b.sparseTensorType!=null&&b.hasOwnProperty("sparseTensorType")&&(nt.sparseTensorType=d.onnx.TypeProto.SparseTensor.toObject(b.sparseTensorType,g),g.oneofs&&(nt.value="sparseTensorType")),b.optionalType!=null&&b.hasOwnProperty("optionalType")&&(nt.optionalType=d.onnx.TypeProto.Optional.toObject(b.optionalType,g),g.oneofs&&(nt.value="optionalType")),nt},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(b){return b===void 0&&(b="type.googleapis.com"),b+"/onnx.TypeProto"},$.Tensor=function(){function b(g){if(g)for(var nt=Object.keys(g),at=0;at<nt.length;++at)g[nt[at]]!=null&&(this[nt[at]]=g[nt[at]])}return b.prototype.elemType=0,b.prototype.shape=null,b.create=function(g){return new b(g)},b.encode=function(g,nt){return nt||(nt=h.create()),g.elemType!=null&&Object.hasOwnProperty.call(g,"elemType")&&nt.uint32(8).int32(g.elemType),g.shape!=null&&Object.hasOwnProperty.call(g,"shape")&&d.onnx.TensorShapeProto.encode(g.shape,nt.uint32(18).fork()).ldelim(),nt},b.encodeDelimited=function(g,nt){return this.encode(g,nt).ldelim()},b.decode=function(g,nt){g instanceof s||(g=s.create(g));for(var at=nt===void 0?g.len:g.pos+nt,Ot=new d.onnx.TypeProto.Tensor;g.pos<at;){var At=g.uint32();switch(At>>>3){case 1:{Ot.elemType=g.int32();break}case 2:{Ot.shape=d.onnx.TensorShapeProto.decode(g,g.uint32());break}default:g.skipType(At&7);break}}return Ot},b.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},b.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.elemType!=null&&g.hasOwnProperty("elemType")&&!a.isInteger(g.elemType))return"elemType: integer expected";if(g.shape!=null&&g.hasOwnProperty("shape")){var nt=d.onnx.TensorShapeProto.verify(g.shape);if(nt)return"shape."+nt}return null},b.fromObject=function(g){if(g instanceof d.onnx.TypeProto.Tensor)return g;var nt=new d.onnx.TypeProto.Tensor;if(g.elemType!=null&&(nt.elemType=g.elemType|0),g.shape!=null){if(typeof g.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");nt.shape=d.onnx.TensorShapeProto.fromObject(g.shape)}return nt},b.toObject=function(g,nt){nt||(nt={});var at={};return nt.defaults&&(at.elemType=0,at.shape=null),g.elemType!=null&&g.hasOwnProperty("elemType")&&(at.elemType=g.elemType),g.shape!=null&&g.hasOwnProperty("shape")&&(at.shape=d.onnx.TensorShapeProto.toObject(g.shape,nt)),at},b.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},b.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TypeProto.Tensor"},b}(),$.Sequence=function(){function b(g){if(g)for(var nt=Object.keys(g),at=0;at<nt.length;++at)g[nt[at]]!=null&&(this[nt[at]]=g[nt[at]])}return b.prototype.elemType=null,b.create=function(g){return new b(g)},b.encode=function(g,nt){return nt||(nt=h.create()),g.elemType!=null&&Object.hasOwnProperty.call(g,"elemType")&&d.onnx.TypeProto.encode(g.elemType,nt.uint32(10).fork()).ldelim(),nt},b.encodeDelimited=function(g,nt){return this.encode(g,nt).ldelim()},b.decode=function(g,nt){g instanceof s||(g=s.create(g));for(var at=nt===void 0?g.len:g.pos+nt,Ot=new d.onnx.TypeProto.Sequence;g.pos<at;){var At=g.uint32();switch(At>>>3){case 1:{Ot.elemType=d.onnx.TypeProto.decode(g,g.uint32());break}default:g.skipType(At&7);break}}return Ot},b.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},b.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.elemType!=null&&g.hasOwnProperty("elemType")){var nt=d.onnx.TypeProto.verify(g.elemType);if(nt)return"elemType."+nt}return null},b.fromObject=function(g){if(g instanceof d.onnx.TypeProto.Sequence)return g;var nt=new d.onnx.TypeProto.Sequence;if(g.elemType!=null){if(typeof g.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");nt.elemType=d.onnx.TypeProto.fromObject(g.elemType)}return nt},b.toObject=function(g,nt){nt||(nt={});var at={};return nt.defaults&&(at.elemType=null),g.elemType!=null&&g.hasOwnProperty("elemType")&&(at.elemType=d.onnx.TypeProto.toObject(g.elemType,nt)),at},b.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},b.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TypeProto.Sequence"},b}(),$.Map=function(){function b(g){if(g)for(var nt=Object.keys(g),at=0;at<nt.length;++at)g[nt[at]]!=null&&(this[nt[at]]=g[nt[at]])}return b.prototype.keyType=0,b.prototype.valueType=null,b.create=function(g){return new b(g)},b.encode=function(g,nt){return nt||(nt=h.create()),g.keyType!=null&&Object.hasOwnProperty.call(g,"keyType")&&nt.uint32(8).int32(g.keyType),g.valueType!=null&&Object.hasOwnProperty.call(g,"valueType")&&d.onnx.TypeProto.encode(g.valueType,nt.uint32(18).fork()).ldelim(),nt},b.encodeDelimited=function(g,nt){return this.encode(g,nt).ldelim()},b.decode=function(g,nt){g instanceof s||(g=s.create(g));for(var at=nt===void 0?g.len:g.pos+nt,Ot=new d.onnx.TypeProto.Map;g.pos<at;){var At=g.uint32();switch(At>>>3){case 1:{Ot.keyType=g.int32();break}case 2:{Ot.valueType=d.onnx.TypeProto.decode(g,g.uint32());break}default:g.skipType(At&7);break}}return Ot},b.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},b.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.keyType!=null&&g.hasOwnProperty("keyType")&&!a.isInteger(g.keyType))return"keyType: integer expected";if(g.valueType!=null&&g.hasOwnProperty("valueType")){var nt=d.onnx.TypeProto.verify(g.valueType);if(nt)return"valueType."+nt}return null},b.fromObject=function(g){if(g instanceof d.onnx.TypeProto.Map)return g;var nt=new d.onnx.TypeProto.Map;if(g.keyType!=null&&(nt.keyType=g.keyType|0),g.valueType!=null){if(typeof g.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");nt.valueType=d.onnx.TypeProto.fromObject(g.valueType)}return nt},b.toObject=function(g,nt){nt||(nt={});var at={};return nt.defaults&&(at.keyType=0,at.valueType=null),g.keyType!=null&&g.hasOwnProperty("keyType")&&(at.keyType=g.keyType),g.valueType!=null&&g.hasOwnProperty("valueType")&&(at.valueType=d.onnx.TypeProto.toObject(g.valueType,nt)),at},b.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},b.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TypeProto.Map"},b}(),$.Optional=function(){function b(g){if(g)for(var nt=Object.keys(g),at=0;at<nt.length;++at)g[nt[at]]!=null&&(this[nt[at]]=g[nt[at]])}return b.prototype.elemType=null,b.create=function(g){return new b(g)},b.encode=function(g,nt){return nt||(nt=h.create()),g.elemType!=null&&Object.hasOwnProperty.call(g,"elemType")&&d.onnx.TypeProto.encode(g.elemType,nt.uint32(10).fork()).ldelim(),nt},b.encodeDelimited=function(g,nt){return this.encode(g,nt).ldelim()},b.decode=function(g,nt){g instanceof s||(g=s.create(g));for(var at=nt===void 0?g.len:g.pos+nt,Ot=new d.onnx.TypeProto.Optional;g.pos<at;){var At=g.uint32();switch(At>>>3){case 1:{Ot.elemType=d.onnx.TypeProto.decode(g,g.uint32());break}default:g.skipType(At&7);break}}return Ot},b.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},b.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.elemType!=null&&g.hasOwnProperty("elemType")){var nt=d.onnx.TypeProto.verify(g.elemType);if(nt)return"elemType."+nt}return null},b.fromObject=function(g){if(g instanceof d.onnx.TypeProto.Optional)return g;var nt=new d.onnx.TypeProto.Optional;if(g.elemType!=null){if(typeof g.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");nt.elemType=d.onnx.TypeProto.fromObject(g.elemType)}return nt},b.toObject=function(g,nt){nt||(nt={});var at={};return nt.defaults&&(at.elemType=null),g.elemType!=null&&g.hasOwnProperty("elemType")&&(at.elemType=d.onnx.TypeProto.toObject(g.elemType,nt)),at},b.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},b.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TypeProto.Optional"},b}(),$.SparseTensor=function(){function b(g){if(g)for(var nt=Object.keys(g),at=0;at<nt.length;++at)g[nt[at]]!=null&&(this[nt[at]]=g[nt[at]])}return b.prototype.elemType=0,b.prototype.shape=null,b.create=function(g){return new b(g)},b.encode=function(g,nt){return nt||(nt=h.create()),g.elemType!=null&&Object.hasOwnProperty.call(g,"elemType")&&nt.uint32(8).int32(g.elemType),g.shape!=null&&Object.hasOwnProperty.call(g,"shape")&&d.onnx.TensorShapeProto.encode(g.shape,nt.uint32(18).fork()).ldelim(),nt},b.encodeDelimited=function(g,nt){return this.encode(g,nt).ldelim()},b.decode=function(g,nt){g instanceof s||(g=s.create(g));for(var at=nt===void 0?g.len:g.pos+nt,Ot=new d.onnx.TypeProto.SparseTensor;g.pos<at;){var At=g.uint32();switch(At>>>3){case 1:{Ot.elemType=g.int32();break}case 2:{Ot.shape=d.onnx.TensorShapeProto.decode(g,g.uint32());break}default:g.skipType(At&7);break}}return Ot},b.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},b.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.elemType!=null&&g.hasOwnProperty("elemType")&&!a.isInteger(g.elemType))return"elemType: integer expected";if(g.shape!=null&&g.hasOwnProperty("shape")){var nt=d.onnx.TensorShapeProto.verify(g.shape);if(nt)return"shape."+nt}return null},b.fromObject=function(g){if(g instanceof d.onnx.TypeProto.SparseTensor)return g;var nt=new d.onnx.TypeProto.SparseTensor;if(g.elemType!=null&&(nt.elemType=g.elemType|0),g.shape!=null){if(typeof g.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");nt.shape=d.onnx.TensorShapeProto.fromObject(g.shape)}return nt},b.toObject=function(g,nt){nt||(nt={});var at={};return nt.defaults&&(at.elemType=0,at.shape=null),g.elemType!=null&&g.hasOwnProperty("elemType")&&(at.elemType=g.elemType),g.shape!=null&&g.hasOwnProperty("shape")&&(at.shape=d.onnx.TensorShapeProto.toObject(g.shape,nt)),at},b.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},b.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TypeProto.SparseTensor"},b}(),$}(),et.OperatorSetIdProto=function(){function $(c){if(c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.domain="",$.prototype.version=a.Long?a.Long.fromBits(0,0,!1):0,$.create=function(c){return new $(c)},$.encode=function(c,b){return b||(b=h.create()),c.domain!=null&&Object.hasOwnProperty.call(c,"domain")&&b.uint32(10).string(c.domain),c.version!=null&&Object.hasOwnProperty.call(c,"version")&&b.uint32(16).int64(c.version),b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.OperatorSetIdProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.domain=c.string();break}case 2:{nt.version=c.int64();break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){return typeof c!="object"||c===null?"object expected":c.domain!=null&&c.hasOwnProperty("domain")&&!a.isString(c.domain)?"domain: string expected":c.version!=null&&c.hasOwnProperty("version")&&!a.isInteger(c.version)&&!(c.version&&a.isInteger(c.version.low)&&a.isInteger(c.version.high))?"version: integer|Long expected":null},$.fromObject=function(c){if(c instanceof d.onnx.OperatorSetIdProto)return c;var b=new d.onnx.OperatorSetIdProto;return c.domain!=null&&(b.domain=String(c.domain)),c.version!=null&&(a.Long?(b.version=a.Long.fromValue(c.version)).unsigned=!1:typeof c.version=="string"?b.version=parseInt(c.version,10):typeof c.version=="number"?b.version=c.version:typeof c.version=="object"&&(b.version=new a.LongBits(c.version.low>>>0,c.version.high>>>0).toNumber())),b},$.toObject=function(c,b){b||(b={});var g={};if(b.defaults)if(g.domain="",a.Long){var nt=new a.Long(0,0,!1);g.version=b.longs===String?nt.toString():b.longs===Number?nt.toNumber():nt}else g.version=b.longs===String?"0":0;return c.domain!=null&&c.hasOwnProperty("domain")&&(g.domain=c.domain),c.version!=null&&c.hasOwnProperty("version")&&(typeof c.version=="number"?g.version=b.longs===String?String(c.version):c.version:g.version=b.longs===String?a.Long.prototype.toString.call(c.version):b.longs===Number?new a.LongBits(c.version.low>>>0,c.version.high>>>0).toNumber():c.version),g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.OperatorSetIdProto"},$}(),et.OperatorStatus=function(){var $={},c=Object.create($);return c[$[0]="EXPERIMENTAL"]=0,c[$[1]="STABLE"]=1,c}(),et.FunctionProto=function(){function $(c){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],c)for(var b=Object.keys(c),g=0;g<b.length;++g)c[b[g]]!=null&&(this[b[g]]=c[b[g]])}return $.prototype.name="",$.prototype.input=a.emptyArray,$.prototype.output=a.emptyArray,$.prototype.attribute=a.emptyArray,$.prototype.attributeProto=a.emptyArray,$.prototype.node=a.emptyArray,$.prototype.docString="",$.prototype.opsetImport=a.emptyArray,$.prototype.domain="",$.create=function(c){return new $(c)},$.encode=function(c,b){if(b||(b=h.create()),c.name!=null&&Object.hasOwnProperty.call(c,"name")&&b.uint32(10).string(c.name),c.input!=null&&c.input.length)for(var g=0;g<c.input.length;++g)b.uint32(34).string(c.input[g]);if(c.output!=null&&c.output.length)for(var g=0;g<c.output.length;++g)b.uint32(42).string(c.output[g]);if(c.attribute!=null&&c.attribute.length)for(var g=0;g<c.attribute.length;++g)b.uint32(50).string(c.attribute[g]);if(c.node!=null&&c.node.length)for(var g=0;g<c.node.length;++g)d.onnx.NodeProto.encode(c.node[g],b.uint32(58).fork()).ldelim();if(c.docString!=null&&Object.hasOwnProperty.call(c,"docString")&&b.uint32(66).string(c.docString),c.opsetImport!=null&&c.opsetImport.length)for(var g=0;g<c.opsetImport.length;++g)d.onnx.OperatorSetIdProto.encode(c.opsetImport[g],b.uint32(74).fork()).ldelim();if(c.domain!=null&&Object.hasOwnProperty.call(c,"domain")&&b.uint32(82).string(c.domain),c.attributeProto!=null&&c.attributeProto.length)for(var g=0;g<c.attributeProto.length;++g)d.onnx.AttributeProto.encode(c.attributeProto[g],b.uint32(90).fork()).ldelim();return b},$.encodeDelimited=function(c,b){return this.encode(c,b).ldelim()},$.decode=function(c,b){c instanceof s||(c=s.create(c));for(var g=b===void 0?c.len:c.pos+b,nt=new d.onnx.FunctionProto;c.pos<g;){var at=c.uint32();switch(at>>>3){case 1:{nt.name=c.string();break}case 4:{nt.input&&nt.input.length||(nt.input=[]),nt.input.push(c.string());break}case 5:{nt.output&&nt.output.length||(nt.output=[]),nt.output.push(c.string());break}case 6:{nt.attribute&&nt.attribute.length||(nt.attribute=[]),nt.attribute.push(c.string());break}case 11:{nt.attributeProto&&nt.attributeProto.length||(nt.attributeProto=[]),nt.attributeProto.push(d.onnx.AttributeProto.decode(c,c.uint32()));break}case 7:{nt.node&&nt.node.length||(nt.node=[]),nt.node.push(d.onnx.NodeProto.decode(c,c.uint32()));break}case 8:{nt.docString=c.string();break}case 9:{nt.opsetImport&&nt.opsetImport.length||(nt.opsetImport=[]),nt.opsetImport.push(d.onnx.OperatorSetIdProto.decode(c,c.uint32()));break}case 10:{nt.domain=c.string();break}default:c.skipType(at&7);break}}return nt},$.decodeDelimited=function(c){return c instanceof s||(c=new s(c)),this.decode(c,c.uint32())},$.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.name!=null&&c.hasOwnProperty("name")&&!a.isString(c.name))return"name: string expected";if(c.input!=null&&c.hasOwnProperty("input")){if(!Array.isArray(c.input))return"input: array expected";for(var b=0;b<c.input.length;++b)if(!a.isString(c.input[b]))return"input: string[] expected"}if(c.output!=null&&c.hasOwnProperty("output")){if(!Array.isArray(c.output))return"output: array expected";for(var b=0;b<c.output.length;++b)if(!a.isString(c.output[b]))return"output: string[] expected"}if(c.attribute!=null&&c.hasOwnProperty("attribute")){if(!Array.isArray(c.attribute))return"attribute: array expected";for(var b=0;b<c.attribute.length;++b)if(!a.isString(c.attribute[b]))return"attribute: string[] expected"}if(c.attributeProto!=null&&c.hasOwnProperty("attributeProto")){if(!Array.isArray(c.attributeProto))return"attributeProto: array expected";for(var b=0;b<c.attributeProto.length;++b){var g=d.onnx.AttributeProto.verify(c.attributeProto[b]);if(g)return"attributeProto."+g}}if(c.node!=null&&c.hasOwnProperty("node")){if(!Array.isArray(c.node))return"node: array expected";for(var b=0;b<c.node.length;++b){var g=d.onnx.NodeProto.verify(c.node[b]);if(g)return"node."+g}}if(c.docString!=null&&c.hasOwnProperty("docString")&&!a.isString(c.docString))return"docString: string expected";if(c.opsetImport!=null&&c.hasOwnProperty("opsetImport")){if(!Array.isArray(c.opsetImport))return"opsetImport: array expected";for(var b=0;b<c.opsetImport.length;++b){var g=d.onnx.OperatorSetIdProto.verify(c.opsetImport[b]);if(g)return"opsetImport."+g}}return c.domain!=null&&c.hasOwnProperty("domain")&&!a.isString(c.domain)?"domain: string expected":null},$.fromObject=function(c){if(c instanceof d.onnx.FunctionProto)return c;var b=new d.onnx.FunctionProto;if(c.name!=null&&(b.name=String(c.name)),c.input){if(!Array.isArray(c.input))throw TypeError(".onnx.FunctionProto.input: array expected");b.input=[];for(var g=0;g<c.input.length;++g)b.input[g]=String(c.input[g])}if(c.output){if(!Array.isArray(c.output))throw TypeError(".onnx.FunctionProto.output: array expected");b.output=[];for(var g=0;g<c.output.length;++g)b.output[g]=String(c.output[g])}if(c.attribute){if(!Array.isArray(c.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");b.attribute=[];for(var g=0;g<c.attribute.length;++g)b.attribute[g]=String(c.attribute[g])}if(c.attributeProto){if(!Array.isArray(c.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");b.attributeProto=[];for(var g=0;g<c.attributeProto.length;++g){if(typeof c.attributeProto[g]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");b.attributeProto[g]=d.onnx.AttributeProto.fromObject(c.attributeProto[g])}}if(c.node){if(!Array.isArray(c.node))throw TypeError(".onnx.FunctionProto.node: array expected");b.node=[];for(var g=0;g<c.node.length;++g){if(typeof c.node[g]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");b.node[g]=d.onnx.NodeProto.fromObject(c.node[g])}}if(c.docString!=null&&(b.docString=String(c.docString)),c.opsetImport){if(!Array.isArray(c.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");b.opsetImport=[];for(var g=0;g<c.opsetImport.length;++g){if(typeof c.opsetImport[g]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");b.opsetImport[g]=d.onnx.OperatorSetIdProto.fromObject(c.opsetImport[g])}}return c.domain!=null&&(b.domain=String(c.domain)),b},$.toObject=function(c,b){b||(b={});var g={};if((b.arrays||b.defaults)&&(g.input=[],g.output=[],g.attribute=[],g.node=[],g.opsetImport=[],g.attributeProto=[]),b.defaults&&(g.name="",g.docString="",g.domain=""),c.name!=null&&c.hasOwnProperty("name")&&(g.name=c.name),c.input&&c.input.length){g.input=[];for(var nt=0;nt<c.input.length;++nt)g.input[nt]=c.input[nt]}if(c.output&&c.output.length){g.output=[];for(var nt=0;nt<c.output.length;++nt)g.output[nt]=c.output[nt]}if(c.attribute&&c.attribute.length){g.attribute=[];for(var nt=0;nt<c.attribute.length;++nt)g.attribute[nt]=c.attribute[nt]}if(c.node&&c.node.length){g.node=[];for(var nt=0;nt<c.node.length;++nt)g.node[nt]=d.onnx.NodeProto.toObject(c.node[nt],b)}if(c.docString!=null&&c.hasOwnProperty("docString")&&(g.docString=c.docString),c.opsetImport&&c.opsetImport.length){g.opsetImport=[];for(var nt=0;nt<c.opsetImport.length;++nt)g.opsetImport[nt]=d.onnx.OperatorSetIdProto.toObject(c.opsetImport[nt],b)}if(c.domain!=null&&c.hasOwnProperty("domain")&&(g.domain=c.domain),c.attributeProto&&c.attributeProto.length){g.attributeProto=[];for(var nt=0;nt<c.attributeProto.length;++nt)g.attributeProto[nt]=d.onnx.AttributeProto.toObject(c.attributeProto[nt],b)}return g},$.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},$.getTypeUrl=function(c){return c===void 0&&(c="type.googleapis.com"),c+"/onnx.FunctionProto"},$}(),et}(),o.exports=d});function ur(e,o){if(!e)throw new Error(typeof o=="string"?o:o())}function kr(e){return new TextDecoder().decode(e)}var ot,Ge,ni,$t,_n,_t,Nt,B,$r,Me,Ue,Ve,Y=O(()=>{xn(),zo(),ot=rr(sr()),ze(),Ge=class{static arraysEqual(e,o){if(e.length!==o.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==o[i])return!1;return!0}},ni=class{static preprocessInputShapes(e,o){let i=e.length===1?[1,e[0]]:e,s=o.length===1?[o[0],1]:o;return[i,s]}static postprocessOutputShape(e,o,i){o===1&&e.splice(e.length-2,1),i===1&&e.pop()}static calcMatMulShape(e,o){return e[1]!==o[0]?void 0:[e[0],o[1]]}},$t=class mE{static calcShape(o,i,s=!1){let h=o.length,a=i.length;if(h===0)return i;if(a===0)return o;let d=Math.max(o.length,i.length),et=new Array(d);if(s){if(h<2||a<2)return;let $=ni.calcMatMulShape([o[h-2],o[h-1]],[i[a-2],i[a-1]]);if($===void 0)return;[et[d-2],et[d-1]]=$}for(let $=s?3:1;$<=d;$++){let c=h-$<0?1:o[h-$],b=a-$<0?1:i[a-$];if(c!==b&&c>1&&b>1)return;et[d-$]=Math.max(c,b)}return et}static index(o,i){let s=new Array(i.length);return mE.fillIndex(o,i,s),s}static fillIndex(o,i,s){let h=o.length-i.length;for(let a=0;a<i.length;a++)s[a]=o[h+a]%i[a]}static calc(o,i,s,h,a){let d=mE.calcShape(o.dims,i.dims);if(d){if(h&&!B.areEqual(d,o.dims))return;let et=B.size(d),$=h?o:new bt(d,a||o.type);if(d.length===0)$.set([],s(o.get([]),i.get([])));else{let c=new Array(d.length),b=new Array(o.dims.length),g=new Array(i.dims.length),nt=0,at=0,Ot=!1,At=!1;o.dims.length===0&&(nt=o.get([]),Ot=!0),i.dims.length===0&&(at=i.get([]),At=!0);let Ct;for(let St=0;St<et;St++){Ct=St;for(let xt=d.length-1;xt>=0;xt--)c[xt]=Ct%d[xt],Ct=Math.floor(Ct/d[xt]);Ot||(mE.fillIndex(c,o.dims,b),nt=o.get(b)),At||(mE.fillIndex(c,i.dims,g),at=i.get(g)),$.set(c,s(nt,at))}}return $}}static isValidBroadcast(o,i){let s=o.length,h=i.length;if(s>h)return!1;for(let a=1;a<=s;a++)if(o[s-a]!==1&&o[s-a]!==i[h-a])return!1;return!0}static getBroadcastDims(o,i){let s=o.length,h=[];for(let a=0;a<s;a++){let d=s-1-a,et=o[d]||1;(i[i.length-1-a]||1)>1&&et===1&&h.unshift(d)}return h}},_n=class{static getShapeOfGemmResult(e,o,i,s,h){if(e.length!==2||i.length!==2)throw new Error("shape need to be of size 2");let a,d,et;o?(a=e[1],d=e[0]):(a=e[0],d=e[1]);let $=-1;if(s?(et=i[0],$=1):(et=i[1],$=0),i[$]!==d)throw new Error("dimension mismatch");if(a<=0||et<=0||d<=0)throw new Error("invalid shape specified");if(h&&!$t.isValidBroadcast(h,[a,et]))throw new Error("gemm: invalid bias shape for broadcast");return[a,et,d]}},_t=class m${static tensorDataTypeFromProto(o){switch(o){case ot.onnx.TensorProto.DataType.INT8:return"int8";case ot.onnx.TensorProto.DataType.UINT8:return"uint8";case ot.onnx.TensorProto.DataType.BOOL:return"bool";case ot.onnx.TensorProto.DataType.INT16:return"int16";case ot.onnx.TensorProto.DataType.UINT16:return"uint16";case ot.onnx.TensorProto.DataType.INT32:return"int32";case ot.onnx.TensorProto.DataType.UINT32:return"uint32";case ot.onnx.TensorProto.DataType.FLOAT:return"float32";case ot.onnx.TensorProto.DataType.DOUBLE:return"float64";case ot.onnx.TensorProto.DataType.STRING:return"string";case ot.onnx.TensorProto.DataType.INT64:return"int32";case ot.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${ot.onnx.TensorProto.DataType[o]}`)}}static tensorDataTypeStringToEnum(o){switch(o){case"int8":return ot.onnx.TensorProto.DataType.INT8;case"uint8":return ot.onnx.TensorProto.DataType.UINT8;case"bool":return ot.onnx.TensorProto.DataType.BOOL;case"int16":return ot.onnx.TensorProto.DataType.INT16;case"uint16":return ot.onnx.TensorProto.DataType.UINT16;case"int32":return ot.onnx.TensorProto.DataType.INT32;case"uint32":return ot.onnx.TensorProto.DataType.UINT32;case"float32":return ot.onnx.TensorProto.DataType.FLOAT;case"float64":return ot.onnx.TensorProto.DataType.DOUBLE;case"string":return ot.onnx.TensorProto.DataType.STRING;case"int64":return ot.onnx.TensorProto.DataType.INT64;case"uint64":return ot.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${o}`)}}static tensorDimsFromProto(o){return o.map(i=>me.isLong(i)?i.toNumber():i)}static tensorValueTypeFromProto(o){return{tensorType:m$.tensorDataTypeFromProto(o.elemType),shape:{dims:m$.tensorDimsFromProto(o.shape.dim.map(i=>i.dimValue))}}}static tensorDimsFromORTFormat(o){let i=[];for(let s=0;s<o.dimsLength();s++)i.push(Nt.longToNumber(o.dims(s)));return i}static tensorAttributesFromORTFormat(o){let i=[];for(let s=0;s<o.attributesLength();s++)i.push(o.attributes(s));return i}},Nt=class{static longToNumber(e,o){return me.isLong(e)?e.toNumber():e instanceof T.Long?me.fromValue({low:e.low,high:e.high,unsigned:o??!1}).toNumber():e}static isLong(e){return me.isLong(e)||e instanceof T.Long}},B=class Y1{static size(o){return Y1.getSizeFromDimensionRange(o,0,o.length)}static sizeFromDimension(o,i){if(i<0||i>o.length)throw new Error(`invalid dimension of ${i} for sizeFromDimension as Tensor has ${o.length} dimensions.`);return Y1.getSizeFromDimensionRange(o,i,o.length)}static sizeToDimension(o,i){if(i<0||i>o.length)throw new Error(`invalid dimension of ${i} for sizeToDimension as Tensor has ${o.length} dimensions.`);return Y1.getSizeFromDimensionRange(o,0,i)}static getSizeFromDimensionRange(o,i,s){let h=1;for(let a=i;a<s;a++){if(o[a]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");h*=o[a]}return h}static computeStrides(o){let i=o.length;if(i===0)return[];if(i===1)return[1];let s=new Array(i);s[i-1]=1,s[i-2]=o[i-1];for(let h=i-3;h>=0;--h)s[h]=s[h+1]*o[h+1];return s}static transpose(o){return o.slice().reverse()}static indicesToOffset(o,i,s){s===void 0&&(s=o.length);let h=0;for(let a=0;a<s;++a)h+=i[a]*o[a];return h}static offsetToIndices(o,i){let s=i.length;if(s===0)return[];if(s===1)return[o*i[0]];let h=new Array(i.length);for(let a=0;a<h.length-1;++a)h[a]=Math.floor(o/i[a]),o-=h[a]*i[a];return h[h.length-1]=o,h}static normalizeAxis(o,i){if(o<-i&&o>=i)throw new Error("unsupported axis for this operation.");return o<0?o+i:o}static normalizeAxes(o,i){return o.map(s=>this.normalizeAxis(s,i))}static incrementIndex(o,i,s){if(i.length===0||o.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(s===void 0)s=i.length;else if(s<=0||s>i.length)throw new Error("Incorrect axis to increment on");for(let h=s-1;h>=0&&(o[h]++,!(o[h]<i[h]));--h)o[h]=0}static calculateReshapedDims(o,i){if(i.length===0){if(o.length===0||Y1.size(o)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let s=i.length,h=new Array(s),a=-1,d=1;for(let $=0;$<s;$++){if(i[$]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(i[$]===-1){if(a!==-1)throw new Error("at most one dimension in shape hints can be -1");a=$}else{if(i[$]===0){if($>=o.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");h[$]=o[$]}else h[$]=i[$];d*=h[$]}}let et=Y1.size(o);if(a!==-1){if(et%d!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${o}] Output shape: [${i}]`);h[a]=et/d}else if(d!==et)throw new Error("reshapedDims and originalDims don't have matching sizes");return h}static sortBasedOnPerm(o,i){return i?i.map(s=>o[s]):o.slice().reverse()}static padShape(o,i){let s=o.length;return o.map((h,a)=>h+i[a]+i[a+s])}static areEqual(o,i){return o.length!==i.length?!1:o.every((s,h)=>s===i[h])}static validateDimsAndCalcSize(o){if(o.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let i=1;for(let s of o){if(!Number.isInteger(s))throw new TypeError(`Invalid shape: ${s} is not an integer`);if(s<0||s>2147483647)throw new TypeError(`Invalid shape: length ${s} is not allowed`);i*=s}return i}static flattenShape(o,i){i<0&&(i+=o.length);let s=o.reduce((a,d)=>a*d,1),h=o.slice(i).reduce((a,d)=>a*d,1);return[s/h,h]}static squeezeShape(o,i){let s=new Array;i=Y1.normalizeAxes(i,o.length);for(let h=0;h<o.length;h++){let a=i.indexOf(h)>=0;if(a&&o[h]!==1)throw new Error("squeeze an axis of size different than 1");(i.length===0&&o[h]>1||i.length>0&&!a)&&s.push(o[h])}return s}static unsqueezeShape(o,i){let s=new Array(o.length+i.length);s.fill(0);for(let a=0;a<i.length;a++){let d=Y1.normalizeAxis(i[a],s.length);if(d>=s.length)throw new Error("'axes' has an out of range axis");if(s[d]!==0)throw new Error("'axes' has a duplicate axis");s[d]=1}let h=0;for(let a=0;a<s.length;a++)s[a]===0&&(s[a]=o[h++]);if(h!==o.length)throw new Error("the unsqueezed dimension could not be established");return s}},$r=class NP{static splitShape(o,i,s,h){if(s.length===0){if(!h)throw new Error("need to know number of outputs when the 'split' attribute is not specified");NP.determineSplit(o[i],h,s)}let a=[],d=[0];for(let et=0;et<s.length;++et){et!==0&&d.push(d[et-1]+s[et-1]);let $=o.slice();$[i]=s[et],a.push($)}return[a,d]}static determineSplit(o,i,s){if(o%i!==0)throw new Error("cannot split tensor to equal sized parts");for(let h=0;h<i;++h)s.push(o/i)}},Me=class gE{static adjustPoolAttributes(o,i,s,h,a,d){if(!o&&s.length!==i.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(o)for(let et=0;et<i.length-2;et++)et>=s.length?s.push(i[et+2]):s[et]=i[et+2];for(let et=0;et<s.length;et++)if(et<h.length){if(h[et]<0)throw new Error("strides should be greater than or equal to 1")}else h.push(1);for(let et=0;et<s.length;et++)if(et<a.length){if(a[et]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let et=0;et<s.length*2;et++)if(et<d.length){if(d[et]<0)throw new Error("pad should be greater than or equal to 1")}else d.push(0);for(let et=0;et<s.length;et++){if(s[et]<=0)throw new Error("kernel shapes need to be greater than 0");if(d[et]>=s[et]||d[et+s.length]>=s[et])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(o,i,s,h,a,d){if(d){if(a.length!==2*(o.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(i.length!==o.length-2)throw new Error("length of strides should be the length of data dimensions");if(h.length!==o.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let et=0;et<o.length-2;et++)gE.adjustPadAndReturnShape(o[et+2],i[et],s[et],h[et],a,et,et+o.length-2,d)}}static computePoolOutputShape(o,i,s,h,a,d,et){if(i.length<=0)throw new Error("input shape must be of size greater than 0");let $=[i[0],i[1]];return gE.computeShapeHelper(o,i,$,s,h,a,d,et),$}static computeConvOutputShape(o,i,s,h,a,d,et){if(o.length<=0||i.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let $=[o[0],i[0]];return gE.computeShapeHelper(!1,o,$,s,h,a,d,et),$}static computeShapeHelper(o,i,s,h,a,d,et,$){if(o)for(let c=0;c<i.length-2;c++)s.push(1);else for(let c=0;c<i.length-2;c++)s.push(gE.adjustPadAndReturnShape(i[c+2],h[c],a[c],d[c],et,c,c+i.length-2,$))}static adjustPadAndReturnShape(o,i,s,h,a,d,et,$){let c=s*(h-1)+1;if($&&$!=="NOTSET")switch($){case"VALID":return a[d]=0,a[et]=0,Math.floor((o-c)/i+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let b=((o+i-1)/i-1)*i+h-o;return a[d]=Math.floor($==="SAME_LOWER"?(b+1)/2:b/2),a[et]=b-a[d],Math.floor((o+b-h)/i+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((o+a[d]+a[et]-c)/i+1)}},Ue=-34028234663852886e22,Ve=34028234663852886e22});function ph(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}function Vu(e){switch(e){case H.onnx.TensorProto.DataType.UINT8:case H.onnx.TensorProto.DataType.INT8:case H.onnx.TensorProto.DataType.BOOL:return 1;case H.onnx.TensorProto.DataType.UINT16:case H.onnx.TensorProto.DataType.INT16:return 2;case H.onnx.TensorProto.DataType.FLOAT:case H.onnx.TensorProto.DataType.INT32:case H.onnx.TensorProto.DataType.UINT32:return 4;case H.onnx.TensorProto.DataType.INT64:case H.onnx.TensorProto.DataType.DOUBLE:case H.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${H.onnx.TensorProto.DataType[e]}`)}}function dh(e,o){return new(Hu(o))(e)}function Hu(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ii(e,o){if(o===H.onnx.TensorProto.DataType.INT64||o===oi.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(o===H.onnx.TensorProto.DataType.UINT32||o===oi.TensorDataType.UINT32||o===H.onnx.TensorProto.DataType.UINT64||o===oi.TensorDataType.UINT64){if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${H.onnx.TensorProto.DataType[o]}`);return e.toNumber()}function zu(e,o,i){switch(o){case H.onnx.TensorProto.DataType.BOOL:case H.onnx.TensorProto.DataType.UINT8:return e.getUint8(i);case H.onnx.TensorProto.DataType.INT8:return e.getInt8(i);case H.onnx.TensorProto.DataType.UINT16:return e.getUint16(i,!0);case H.onnx.TensorProto.DataType.INT16:return e.getInt16(i,!0);case H.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(i,!0);case H.onnx.TensorProto.DataType.INT32:return e.getInt32(i,!0);case H.onnx.TensorProto.DataType.UINT32:return e.getUint32(i,!0);case H.onnx.TensorProto.DataType.INT64:return ii(me.fromBits(e.getUint32(i,!0),e.getUint32(i+4,!0),!1),o);case H.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(i,!0);case H.onnx.TensorProto.DataType.UINT64:return ii(me.fromBits(e.getUint32(i,!0),e.getUint32(i+4,!0),!0),o);default:throw new Error(`cannot read from DataView for type ${H.onnx.TensorProto.DataType[o]}`)}}var Wu,H,oi,bt,ze=O(()=>{Wu=rr(ks()),zo(),Pr(),H=rr(sr()),Y(),oi=F.experimental.fbs,bt=class S2{constructor(o,i,s,h,a,d=Wu.Guid.create()){this.dims=o,this.type=i,this.dataProvider=s,this.asyncDataProvider=h,this.cache=a,this.dataId=d,this.size=B.validateDimsAndCalcSize(o);let et=this.size,$=s===void 0&&h===void 0&&a===void 0;if(a!==void 0&&a.length!==et)throw new RangeError("Input dims doesn't match data length.");if(i==="string"){if(a!==void 0&&(!Array.isArray(a)||!a.every(c=>typeof c=="string")))throw new TypeError("cache should be a string array");$&&(this.cache=new Array(et))}else{if(a!==void 0){let c=Hu(i);if(!(a instanceof c))throw new TypeError(`cache should be type ${c.name}`)}if($){let c=new ArrayBuffer(et*ph(i));this.cache=dh(c,i)}}}get data(){if(this.cache===void 0){let o=this.dataProvider(this.dataId);if(o.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=o}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(o){return this.data[B.indicesToOffset(o,this.strides)]}set(o,i){this.data[B.indicesToOffset(o,this.strides)]=i}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=B.computeStrides(this.dims)),this._strides}static fromProto(o){if(!o)throw new Error("cannot construct Value from an empty tensor");let i=_t.tensorDataTypeFromProto(o.dataType),s=_t.tensorDimsFromProto(o.dims),h=new S2(s,i);if(i==="string")o.stringData.forEach((a,d)=>{h.data[d]=kr(a)});else if(o.rawData&&typeof o.rawData.byteLength=="number"&&o.rawData.byteLength>0){let a=h.data,d=new DataView(o.rawData.buffer,o.rawData.byteOffset,o.rawData.byteLength),et=Vu(o.dataType),$=o.rawData.byteLength/et;if(o.rawData.byteLength%et!==0)throw new Error("invalid buffer length");if(a.length!==$)throw new Error("buffer length mismatch");for(let c=0;c<$;c++){let b=zu(d,o.dataType,c*et);a[c]=b}}else{let a;switch(o.dataType){case H.onnx.TensorProto.DataType.FLOAT:a=o.floatData;break;case H.onnx.TensorProto.DataType.INT32:case H.onnx.TensorProto.DataType.INT16:case H.onnx.TensorProto.DataType.UINT16:case H.onnx.TensorProto.DataType.INT8:case H.onnx.TensorProto.DataType.UINT8:case H.onnx.TensorProto.DataType.BOOL:a=o.int32Data;break;case H.onnx.TensorProto.DataType.INT64:a=o.int64Data;break;case H.onnx.TensorProto.DataType.DOUBLE:a=o.doubleData;break;case H.onnx.TensorProto.DataType.UINT32:case H.onnx.TensorProto.DataType.UINT64:a=o.uint64Data;break;default:throw new Error("unspecific error")}if(a==null)throw new Error("failed to populate data from a tensorproto value");let d=h.data;if(d.length!==a.length)throw new Error("array length mismatch");for(let et=0;et<a.length;et++){let $=a[et];me.isLong($)?d[et]=ii($,o.dataType):d[et]=$}}return h}static fromData(o,i,s){return new S2(i,s,void 0,void 0,o)}static fromOrtTensor(o){if(!o)throw new Error("cannot construct Value from an empty tensor");let i=_t.tensorDimsFromORTFormat(o),s=_t.tensorDataTypeFromProto(o.dataType()),h=new S2(i,s);if(s==="string")for(let a=0;a<o.stringDataLength();a++)h.data[a]=o.stringData(a);else if(o.rawDataArray()&&typeof o.rawDataLength()=="number"&&o.rawDataLength()>0){let a=h.data,d=new DataView(o.rawDataArray().buffer,o.rawDataArray().byteOffset,o.rawDataLength()),et=Vu(o.dataType()),$=o.rawDataLength()/et;if(o.rawDataLength()%et!==0)throw new Error("invalid buffer length");if(a.length!==$)throw new Error("buffer length mismatch");for(let c=0;c<$;c++){let b=zu(d,o.dataType(),c*et);a[c]=b}}return h}}});function G(e){return e===1?hh:mh}function qu(e){let o=G(e);return`${o.version}
      precision highp float;
      ${o.attribute} vec3 position;
      ${o.attribute} vec2 textureCoord;

      ${o.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function ju(e){let o=G(e);return`${o.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${o.varyingFrag} vec2 TexCoords;
    ${o.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Xu(e,o){let i=G(e);return`
  void main() {
    int indices[${o}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i.output} = result;
  }
  `}var hh,mh,st=O(()=>{hh={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},mh={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),j=O(()=>{});async function ai(e,o=s=>0,i){return new Promise((s,h)=>{let a=0,d=()=>{if(e()){s();return}a++;let et=o(a);setTimeout(d,et)};d()})}function On(e){return ur(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)}function Ku(e){return ur(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"}function lr(e,o){let i=JSON.parse(JSON.stringify(e));return i=o,i}function fr(e,o){return o.map(i=>e[i]).join(", ")}function kt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function ee(e=6){return["x","y","z","w","u","v"].slice(0,e)}var ue=O(()=>{Y()});function bh(e,o){return ee(o).map(i=>`${e}.${i}`)}function cr(e,o){return o===1?[e]:bh(e,o)}function le(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var We=O(()=>{ue()});function yh(e,o,i){if(e===0)return"false";if(e===1)return`rc > ${o[0]}`;let s="";for(let h=e-2;h<e;h++)s+=`${i[h]} >= ${o[h-e+2]}`,h<e-1&&(s+="||");return s}function xh(e,o){let i=e.length;if(i===0)return"getA(), 0, 0, 0";if(i===1)return`getA(rc),
            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),
            0, 0`;let s="r, c",h="r, cp1",a="rp1, c",d="rp1, cp1",et="";if(i>2)for(let $=0;$<i-2;++$)et=et+`${o[$]},`;return`getA(${et}${s}),
          rEdge ? 0. : getA(${et}${a}),
          cEdge ? 0. : getA(${et}${h}),
          rEdge || cEdge ? 0. : getA(${et}${d})`}function Th(e,o,i,s){return e===0||e===1?"":`
    int r = ${o[e-2]};
    int c = ${o[e-1]};
    int rp1 = ${o[e-2]} + 1;
    int cp1 = ${o[e-1]} + 1;
    bool rEdge = rp1 >= ${s};
    bool cEdge = cp1 >= ${i};
    `}var Ju,gh,Yu,Zu=O(()=>{st(),j(),ue(),We(),Ju={name:"pack",inputNames:["A"],inputTypes:[1]},gh=(e,o)=>{let i=G(e.session.backend.glContext.version),s=o.dims,h=s.length,a=o.dims.length,d=kt(a),et=cr("rc",a),$=Th(a,et,s[s.length-2],s[s.length-1]),c;h===0?c=[1,1]:h===1?c=[s[0],1]:c=[s[a-1],s[a-2]];let b=yh(a,c,et),g=xh(s,et),nt=`
        void main() {
          ${d} rc = getOutputCoords();

          if(${b}) {
            ${i.output} = vec4(0);
          } else {
            ${$}

            ${i.output} = vec4(${g});
          }
        }
      `;return{...Ju,hasMain:!0,output:{dims:o.dims,type:o.type,textureType:2},shaderSource:nt}},Yu=(e,o)=>({...Ju,get:()=>gh(e,o)})});function si(e){if(e.length===0)return[1,1,1];let o=1;for(let i=0;i<e.length-2;++i)o*=e[i];return[o,e.length>1?e[e.length-2]:1,e[e.length-1]]}function tl(e,o){let i=!1;return e.length===0||o.length===0?i=!0:e.length<2||o.length<2?i=e[e.length-1]===o[o.length-1]:i=e[e.length-1]===o[o.length-1]&&e[e.length-2]===o[o.length-2],i}function Ih(e){let o=B.computeStrides(e),i=["b","r","c"],s="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${o.map((h,a)=>{let d=`int ${i[a]} = ${s} / ${h}`,et=a===o.length-1?`int ${i[a+1]} = ${s} - ${i[a]} * ${h}`:`index -= ${i[a]} * ${h}`;return`${d}; ${et};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function _h(e){let o=B.computeStrides(e);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${o[0]} + coords.z * ${o[1]} + coords.y;
  }
`}var wh,vh,Qu,el=O(()=>{Y(),st(),j(),We(),wh=e=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${e}`}),vh=(e,o,i,s)=>{let h=o.dims,a=s,d="";for(let c=0;c<4;c++){let b="";switch(c){case 0:b="outputCoords = rc;";break;case 1:b="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:b="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:b="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}d+=`
        ${b}
        ${c>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${c}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${c>0?"}":""}
      `}let et=G(e.session.backend.glContext.version),$=`
      ${Ih(h)}
      ${_h(a)}
      ${le()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${a[2]};
        int cols = ${a[1]};

        ${d}
        ${et.output} = result;
      }
    `;return{...i,output:{dims:a,type:o.type,textureType:2},shaderSource:$,hasMain:!0}},Qu=(e,o,i)=>{let s=wh(i);return{...s,get:()=>vh(e,o,s,i)}}}),ui,rl=O(()=>{st(),j(),ui=(e,o)=>{let i=o.shape,s=G(e.session.backend.glContext.version),h=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${s.texture2D}(X,TexCoords).r;
      ${s.output} = encodeAsUint8(value);
    }`,a={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:i,type:o.tensor.type,textureType:3},shaderSource:h,hasMain:!0};return e.executeProgram(a,[o.tensor])}});function Sh(e,o){if(e===1)return"rc";let i="";for(let s=0;s<e;s++)i+=o[s],s<e-1&&(i+=",");return i}var nl,Oh,ol,il=O(()=>{st(),j(),ue(),We(),nl={name:"unpack",inputNames:["A"],inputTypes:[2]},Oh=(e,o)=>{let i=o.dims.length,s=cr("rc",i),h=s.slice(-2),a=kt(i),d=le(),et=o.dims.length===0?"":Sh(i,s),$=i<=1?"rc":`vec2(${h.join(",")})`,c=G(e.session.backend.glContext.version),b=`
    ${d}
    void main() {
      ${a} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${et});

       ${c.output} = vec4(getChannel(packedInput, ${$}), 0, 0, 0);
     }
   `;return{...nl,hasMain:!0,output:{dims:o.dims,type:o.type,textureType:0},shaderSource:b}},ol=(e,o)=>({...nl,get:()=>Oh(e,o)})}),Sn,Br,An,Fr=O(()=>{Mt(),Sn=class{constructor(e,o=1){if(o===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=o;else if(o===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=o;else throw new Error(`Invalid number of channels: ${o}`)}encode(e,o){let i,s;return e.constructor!==Float32Array&&(tt.warning("Encoder","data was not of type Float32; creating new Float32Array"),s=new Float32Array(e)),o*this.channelSize>e.length?(tt.warning("Encoder","Source data too small. Allocating larger array"),s=e,i=this.allocate(o*this.channelSize),s.forEach((h,a)=>i[a]=h)):(s=e,i=s),i}allocate(e){return new Float32Array(e*4)}decode(e,o){return this.channelSize===1?e.filter((i,s)=>s%4===0).subarray(0,o):e.subarray(0,o)}},Br=class{constructor(e,o=1,i){if(o!==1&&o!==4)throw new Error(`Invalid number of channels: ${o}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=o,this.textureType=i||e.FLOAT}encode(e,o){let i=e;return this.channelSize===1&&(tt.verbose("Encoder","Exploding into a larger array"),i=this.allocate(o),e.forEach((s,h)=>i[h*4]=s)),i}allocate(e){return new Float32Array(e*4)}decode(e,o){return this.channelSize===1?e.filter((i,s)=>s%4===0).subarray(0,o):e.subarray(0,o)}},An=class{constructor(e,o=1){if(this.channelSize=4,o===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=o;else if(o===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=o;else throw new Error(`Invalid number of channels: ${o}`)}encode(e,o){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,o){if(e instanceof Uint8Array)return e.subarray(0,o);throw new Error(`Invalid array type: ${e.constructor}`)}}}),Cr,al,li,sl=O(()=>{Y(),j(),Cr=(e,o,i)=>{let s=i===0||i===1?1:4,h=i===2,a=i===1||i===2,d=i===4?o.length-1:void 0,et=i===4?o.map(($,c)=>c===o.length-1?$*4:$):void 0;return li(e,o,s,et,{isPacked:h,reverseWH:a,breakAxis:d})},al=(e,o,i)=>{let s=Cr(e,o,i);return[s.width,s.height]},li=(e,o,i=1,s,h)=>{let a=!!(h&&h.isPacked),[d,et]=e.computeTextureWH(a&&s||o,h),$=o.length,c=o.slice(0);if($===0&&(c=[1]),i===1)s=o;else if(a){if(i!==4)throw new Error("a packed texture must be 4-channel");s=o,$>0&&(c[$-1]=Math.ceil(c[$-1]/2)),$>1&&(c[$-2]=Math.ceil(c[$-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:d,height:et,channels:i,isPacked:a,shape:c,strides:B.computeStrides(c),unpackedShape:s,reversedWH:h&&h.reverseWH}}}),Ph,Pn,ll=O(()=>{Mt(),ze(),Y(),Zu(),el(),rl(),il(),Fr(),sl(),j(),Ph=(e,o)=>{let i=o.map(h=>`${h.unpackedShape.join(",")};${h.width}x${h.height}`).join("_"),s=e.name;return e.cacheHint&&(s+="["+e.cacheHint+"]"),s+=":"+i,s},Pn=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,o){return al(this.session.layoutStrategy,e,o)}executeProgram(e,o){if(o.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let i=[];for(let $=0;$<e.inputNames.length;++$)i[$]=this.getOrCreateTextureData(o[$],e.inputTypes[$]);let s=Ph(e,i),h=this.session.programManager.getArtifact(s),a=h?h.programInfo:typeof e.get=="function"?e.get():e,d=Cr(this.session.layoutStrategy,a.output.dims,a.output.textureType),et=this.createTextureData(d,a.output.type);return h||(h=this.session.programManager.build(a,i,et),this.session.programManager.setArtifact(s,h)),this.runProgram(h,i,et),et}run(e,o){return this.executeProgram(e,o).tensor}runProgram(e,o,i){for(let s=0;s<o.length;++s)if(!!o[s].isPacked!=(e.programInfo.inputTypes[s]===2))throw new Error(`input[${s}] property packed inconsistent`);if(!!i.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,o,i)}getOrCreateTextureData(e,o){let i=this.getTextureData(e.dataId,o===2);if(!i&&(i=this.getTextureData(e.dataId,o!==2),i))return o===2?this.pack(i):this.unpack(i);if(!i){let s=Cr(this.session.layoutStrategy,e.dims,o);if(o===4){let h=e.dims;if(h.length===4){let a=[h[0],Math.ceil(h[1]*h[2]*h[3]/4)],d=Cr(this.session.layoutStrategy,a,o),et=e.numberData;if(h[1]*h[2]*h[3]%4!==0){let $=h[0],c=h[1]*h[2]*h[3],b=Math.ceil(c*1/4)*4,g=$*b;et=new Float32Array(g);for(let nt=0;nt<$;++nt){let at=nt*c,Ot=nt*b+nt%1*c;et.set(e.numberData.subarray(at,at+c),Ot)}}return this.createTextureData(d,e.type,et,e,1)}}if(o===2){let h=li(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),a=this.createTextureData(h,e.type,e.numberData,e,1);i=this.pack(a)}else i=this.createTextureData(s,e.type,e.numberData,e,1)}return i}createTextureDataFromLayoutBindTensor(e,o,i,s){return this.createTextureData(e,o,i,s,1)}createTextureData(e,o,i,s,h){tt.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let a=this.session.textureManager.createTextureFromLayout(o,e,i,h);return this.createTextureDataFromTexture(e,o,a,s)}reshapeUnpacked(e,o){let i=this.getOrCreateTextureData(e,0),s={channels:i.channels,height:i.height,width:i.width,shape:o.length!==0?o:[1],strides:B.computeStrides(o),unpackedShape:o};return this.createTextureDataFromTexture(s,e.type,i.texture).tensor}reshapePacked(e,o){let i=this.getOrCreateTextureData(e,2);if(tl(e.dims,o)){let et={channels:i.channels,height:i.height,width:i.width,shape:o.length!==0?o:[1],strides:B.computeStrides(o),unpackedShape:o,isPacked:!0};return this.createTextureDataFromTexture(et,e.type,i.texture).tensor}let s=si(e.dims),h=si(o),a=this.reshapePacked(e,s),d=this.run(Qu(this,a,h),[a]);return this.reshapePacked(d,o)}cast(e,o){let i=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(i,o,i.texture).tensor}createTextureDataFromTexture(e,o,i,s,h){let a={...e,tensor:s||new bt(e.unpackedShape,o,d=>this.readTexture(a),async d=>this.readTextureAsync(a),void 0,h),texture:i};return this.setTextureData(a.tensor.dataId,a,e.isPacked),a}getTextureData(e,o=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,o):o?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,o,i=!1){this.session.isInitializer(e)?this.session.setTextureData(e,o,i):(i?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,o)}isTextureLayoutCached(e,o=!1){return!!this.getTextureData(e.dataId,o)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(ui(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(ui(this,e))}pack(e){return this.executeProgram(Yu(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(ol(this,e.tensor),[e.tensor])}}}),fi,W,vt=O(()=>{fi=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},W=e=>new fi(e)}),fl,cl,pl,Eh,Dh,dl=O(()=>{vt(),st(),j(),fl={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},cl=(e,o,i)=>(Dh(o),[e.run({...fl,cacheHint:i.cacheKey,get:()=>Eh(e,o,i)},o)]),pl=e=>{let o=e.attributes.getFloat("epsilon",1e-5),i=e.attributes.getFloat("momentum",.9),s=e.attributes.getInt("spatial",1);return W({epsilon:o,momentum:i,spatial:s})},Eh=(e,o,i)=>{let s=G(e.session.backend.glContext.version),h=o[0].dims.length,[a,d]=e.calculateTextureWidthAndHeight(o[1].dims,0),et=`
  float process(int[${h}] indices) {
    vec2 position = offsetToCoords(indices[1], ${a}, ${d});
    float scale = getColorAsFloat(${s.texture2D}(Scale, position));
    float mean = getColorAsFloat(${s.texture2D}(Mean, position));
    float variance = getColorAsFloat(${s.texture2D}(Variance, position));
    float b = getColorAsFloat(${s.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${i.epsilon})) ) + b;
  }`;return{...fl,output:{dims:o[0].dims,type:o[0].type,textureType:0},shaderSource:et}},Dh=e=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let o=e[0],i=e[1],s=e[2],h=e[3],a=e[4];if(o.dims.length<3||i.dims.length!==1||s.dims.length!==1||h.dims.length!==1||a.dims.length!==1)throw new Error("invalid input shape.");if(i.dims[0]!==o.dims[1]||s.dims[0]!==o.dims[1]||h.dims[0]!==o.dims[1]||a.dims[0]!==o.dims[1])throw new Error("invalid input shape.");if(o.type!=="float32"&&o.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||h.type!=="float32"&&h.type!=="float64"||a.type!=="float32"&&a.type!=="float64")throw new Error("invalid input tensor types.")}}),En,Wt,k,Nr,Dn,be=O(()=>{En=class{constructor(e,o,i,s){this.glContext=e,this.programInfo=o,this.inputTextureLayouts=i,this.outputTextureLayout=s}},Wt=class{constructor(e){this.context=e}},k=class{constructor(e,o){this.routineBody=e,this.dependencies=o}},Nr=class{constructor(e,o,i){this.name=e,i?this.dependencies=i:this.dependencies=[],o&&(this.routineBody=o)}addDependency(e){e&&this.dependencies.push(e)}},Dn=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let o=new Set,i=new Set,s=new Array;return this.createOrderedNodes(e,o,i,s),s}static createOrderedNodes(e,o,i,s){for(let h=0;h<e.length;++h)this.dfsTraverse(e[h],o,i,s)}static dfsTraverse(e,o,i,s){if(!e||i.has(e.name))return;if(o.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");o.add(e.name);let h=e.dependencies;if(h&&h.length>0)for(let a=0;a<h.length;++a)this.dfsTraverse(h[a],o,i,s);s.push(e),i.add(e.name),o.delete(e.name)}}});function $h(){let e="add_";return{body:`
  float ${e}(float a, float b) {
    return a + b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:e,type:0}}function kh(){let e="div_";return{body:`
  float ${e}(float a, float b) {
    return a / b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:e,type:0}}function Bh(){let e="mul_";return{body:`
  float ${e}(float a, float b) {
    return a * b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:e,type:0}}function Fh(){let e="sub_";return{body:`
  float ${e}(float a, float b) {
    return a - b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:e,type:0}}function Ch(){let e="equal_";return{body:`
  float ${e}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:e,type:0}}function Nh(){let e="greater_";return{body:`
  float ${e}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:e,type:0}}function Rh(){let e="less_";return{body:`
  float ${e}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:e,type:0}}function Gh(){let e="and_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:e,type:0}}function Mh(){let e="or_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:e,type:0}}function Uh(){let e="xor_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:e,type:0}}function Vh(){return Wh("pow")}function zh(){let e="prelu_";return{body:`
  float ${e}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:e,type:0}}function Wh(e){let o=`${e}_`;return{body:`
  float ${o}(float a, float b) {
    return ${e}(a, b);
  }
  vec4 ${o}(vec4 v1, vec4 v2) {
    return ${e}(v1, v2);
  }
  `,name:o,type:0}}var Ht,Hh,hl,ml,bl,gl,yl,xl,Tl,wl,vl,Il,_l,Ol,Sl=O(()=>{Y(),be(),st(),j(),Ht=(e,o,i,s=o[0].type,h)=>{let a=e.session.pack?2:0;return{name:i.name,inputNames:["A","B"],inputTypes:[a,a],cacheHint:h,get:()=>Hh(e,o,i,s)}},Hh=(e,o,i,s=o[0].type)=>{let h=e.session.pack?2:0,a=!B.areEqual(o[0].dims,o[1].dims),d=o[0].dims,et=e.session.pack;if(a){let b=$t.calcShape(o[0].dims,o[1].dims,!1);if(!b)throw new Error("Can't perform binary op on the given tensors");d=b;let g=d.length,nt=o[0].dims.length!==0?o[0].dims.length:1,at=o[1].dims.length!==0?o[1].dims.length:1,Ot=o[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",At=o[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",Ct=G(e.session.backend.glContext.version),St=et?`
      ${i.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${i.name}(a, b);
        ${Ct.output} = result;
      }`:`
      ${i.body}
      float process(int indices[${g}]) {
        int aindices[${nt}];
        int bindices[${at}];
        ${Ot}
        ${At}
        return ${i.name}(_A(aindices), _B(bindices));
      }`;return{name:i.name,inputNames:["A","B"],inputTypes:[h,h],output:{dims:d,type:s,textureType:h},shaderSource:St,hasMain:et}}let $=G(e.session.backend.glContext.version),c=`
    ${i.body}
    void main() {
      vec4 v1 = ${$.texture2D}(A, TexCoords);
      vec4 v2 = ${$.texture2D}(B, TexCoords);
      vec4 result = ${i.name}(v1, v2);
      ${$.output} = result;
    }
    `;return{name:i.name,inputNames:["A","B"],inputTypes:[h,h],output:{dims:o[0].dims,type:s,textureType:h},shaderSource:c,hasMain:!0}},hl=(e,o)=>[e.run(Ht(e,o,$h()),o)],ml=(e,o)=>[e.run(Ht(e,o,Gh(),"bool"),o)],bl=(e,o)=>[e.run(Ht(e,o,kh()),o)],gl=(e,o)=>[e.run(Ht(e,o,Ch(),"bool"),o)],yl=(e,o)=>[e.run(Ht(e,o,Nh(),"bool"),o)],xl=(e,o)=>[e.run(Ht(e,o,Rh(),"bool"),o)],Tl=(e,o)=>[e.run(Ht(e,o,Bh()),o)],wl=(e,o)=>[e.run(Ht(e,o,Mh(),"bool"),o)],vl=(e,o)=>[e.run(Ht(e,o,Vh()),o)],Il=(e,o)=>[e.run(Ht(e,o,zh()),o)],_l=(e,o)=>[e.run(Ht(e,o,Fh()),o)],Ol=(e,o)=>[e.run(Ht(e,o,Uh(),"bool"),o)]}),Al,Pl,jh,El=O(()=>{Y(),Al=(e,o,i)=>(jh(o),[e.cast(o[0],i)]),Pl=e=>_t.tensorDataTypeFromProto(e.attributes.getInt("to")),jh=e=>{if(!e||e.length!==1)throw new Error("Cast requires 1 input.");if(e[0].type==="string")throw new Error("Invalid input type.")}}),Xh,Kh,Dl,Ln,Ll=O(()=>{st(),j(),ue(),We(),Xh=(e,o)=>({name:"Concat (packed)",inputNames:Array.from({length:e},(i,s)=>`X${s}`),inputTypes:Array(e).fill(2),cacheHint:o}),Kh=(e,o,i,s)=>{let h=i[0].dims.slice();if(s>=h.length||s<-1*h.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=h.length+s);let a=h.slice(0);for(let Zt=1;Zt<i.length;Zt++){let gr=i[Zt].dims.slice();for(let vr=0;vr<h.length;vr++)if(vr===s)a[s]+=gr[vr];else if(h[vr]!==gr[vr])throw new Error("non concat dimensions must match")}let d=a.length,et=cr("coords",d),$=kt(d),c=le(),b=i.map(Zt=>Zt.dims),g=ee(d),nt=new Array(b.length-1);nt[0]=b[0][s];for(let Zt=1;Zt<nt.length;Zt++)nt[Zt]=nt[Zt-1]+b[Zt][s];let at=g[s],Ot=g.slice(-2),At=g.join(),Ct=`if (${at} < ${nt[0]}) {
        return getChannel(
            getX0(${At}), vec2(${Ot.join()}));
        }`;for(let Zt=1;Zt<nt.length;Zt++){let gr=nt[Zt-1];Ct+=`
            if (${at} < ${nt[Zt]}  && ${at} >= ${nt[Zt-1]}) {
              return getChannel(
                getX${Zt}(${Ln(g,at,gr)}),
                vec2(${Ln(Ot,at,gr)}));
            }`}let St=nt.length,xt=nt[nt.length-1];Ct+=`
            return getChannel(
              getX${St}(${Ln(g,at,xt)}),
              vec2(${Ln(Ot,at,xt)}));`;let Dt=G(e.session.backend.glContext.version),Qt=`
          ${c}
          float getValue(${g.map(Zt=>"int "+Zt)}) {
            ${Ct}
          }

          void main() {
            ${$} coords = getOutputCoords();
            int lastDim = coords.${g[d-1]};
            coords.${g[d-1]} = coords.${g[d-2]};
            coords.${g[d-2]} = lastDim;

            vec4 result = vec4(getValue(${et}), 0., 0., 0.);

            ${et[d-1]} = ${et[d-1]} + 1;
            if (${et[d-1]} < ${a[d-1]}) {
              result.g = getValue(${et});
            }

            ${et[d-2]} = ${et[d-2]} + 1;
            if (${et[d-2]} < ${a[d-2]}) {
              result.a = getValue(${et});
            }

            ${et[d-1]} = ${et[d-1]} - 1;
            if (${et[d-2]} < ${a[d-2]} &&
                ${et[d-1]} < ${a[d-1]}) {
              result.b = getValue(${et});
            }
            ${Dt.output} = result;
          }
        `;return{...o,output:{dims:a,type:i[0].type,textureType:2},shaderSource:Qt,hasMain:!0}},Dl=(e,o,i)=>{let s=Xh(o.length,i.cacheKey);return{...s,get:()=>Kh(e,s,o,i.axis)}},Ln=(e,o,i)=>{let s=e.indexOf(o);return e.map((h,a)=>a===s?`${h} - ${i}`:h).join()}}),$l,Jh,Yh,Zh,kl,Qh,tm,em,Bl,rm,Fl=O(()=>{vt(),j(),Ll(),$l=(e,o,i)=>(rm(o),e.session.pack&&o[0].dims.length>1?[e.run(Dl(e,o,i),o)]:[e.run(Zh(e,o,i),o)]),Jh=(e,o)=>({name:"Concat",inputNames:Array.from({length:e},(i,s)=>`X${s}`),inputTypes:Array(e).fill(0),cacheHint:o}),Yh=(e,o,i,s)=>{let h=i[0].dims.slice();if(s>=h.length||s<-1*h.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=h.length+s);let a=h.slice(0);for(let at=1;at<i.length;at++){let Ot=i[at].dims.slice();for(let At=0;At<h.length;At++)if(At===s)a[s]+=Ot[At];else if(h[At]!==Ot[At])throw new Error("non concat dimensions must match")}let d=a.length,et=new Array(i.length),$=0;for(let at=0;at<et.length;++at)$+=i[at].dims[s],et[at]=$;let c="";i.length<5?c=kl(et):c=Qh(et);let b=tm(i.length,d),g=em(et),nt=`
        ${b}
        ${g}
        ${c}
        float process(int indices[${d}]) {
          int textureIndex = getTextureWhereDataResides (indices[${s}]);

          if(textureIndex != 0) {
            indices[${s}] = indices[${s}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...o,output:{dims:a,type:i[0].type,textureType:0},shaderSource:nt}},Zh=(e,o,i)=>{let s=Jh(o.length,i.cacheKey);return{...s,get:()=>Yh(e,s,o,i.axis)}},kl=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((o,i)=>`if(index<${o}) {return ${i};}
`).join("")}
    }`,Qh=e=>kl(e),tm=(e,o)=>{let i=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${o}]) {`];for(let s=0;s<e;++s)s===0?i.push(`	if (textureIndex == ${s}) { return _X${s}(indices); }`):s===e-1?i.push(`	else { return _X${s}(indices); }`):i.push(`	else if (textureIndex == ${s}) { return _X${s}(indices); }`);return i.push("	}"),i.join(`
`)},em=e=>{let o=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let i=0;i<e.length;++i)i===0?o.push(`	if (index == ${i}) { return ${e[i]}; }`):i===e.length-1?o.push(`	else { return ${e[i]}; }`):o.push(`	else if (index == ${i}) { return ${e[i]}; }`);return o.push("	}"),o.join(`
`)},Bl=e=>W({axis:e.attributes.getInt("axis")}),rm=e=>{if(!e||e.length<1)throw new Error("too few inputs");let o=e[0].type,i=e[0].dims.length;if(o==="string")throw new Error("string tensor is not supported yet");for(let s of e){if(s.type!==o)throw new Error("input tensors should be one type");if(s.dims.length!==i)throw new Error("input tensors should have the same shape")}}});function nm(){return qt("abs")}function om(){return qt("acos")}function im(){return qt("asin")}function am(){return qt("atan")}function sm(){return qt("ceil")}function um(){return qt("cos")}function lm(e){let o="elu";return{body:`
  const float alpha = float(${e});

  float ${o}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${o}_(vec4 v) {
    return vec4(${o}_(v.x), ${o}_(v.y), ${o}_(v.z), ${o}_(v.w));
  }
  `,name:o,type:0}}function fm(){return qt("exp")}function cm(){return qt("floor")}function ci(e,o){let i="clip";return{body:`
  const float min = float(${e});
  const float max = float(${o});

  float ${i}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${i}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:i,type:0}}function pm(){let e="indentity";return{body:`
  float ${e}_(float a) {
    return a;
  }
  vec4 ${e}_(vec4 v) {
    return v;
  }
  `,name:e,type:0}}function dm(e){let o="leakyRelu";return{body:`
  const float alpha = float(${e});

  float ${o}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${o}_(vec4 v) {
    return vec4(${o}_(v.x), ${o}_(v.y), ${o}_(v.z), ${o}_(v.w));
  }
  `,name:o,type:0}}function hm(){return qt("log")}function mm(){let e="neg";return{body:`
  float ${e}_(float a) {
    return -a;
  }
  vec4 ${e}_(vec4 v) {
    return -v;
  }
  `,name:e,type:0}}function bm(){let e="not";return{body:`
  float ${e}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e}_(bool a) {
    return !a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:e,type:0}}function gm(){return qt("sin")}function pi(){let e="relu";return{body:`
  float ${e}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:e,type:0}}function di(){let e="sigmoid";return{body:`
  float ${e}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:e,type:0}}function ym(){return qt("sqrt")}function xm(){return qt("tan")}function Tm(){let e="tanh";return{body:`
  float ${e}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:e,type:0}}function qt(e){return{body:`
  float ${e}_(float a) {
    return ${e}(a);
  }
  vec4 ${e}_(vec4 v) {
    return ${e}(v);
  }
  `,name:e,type:0}}var wm,dt,Cl,Nl,Rl,Gl,hi,Ml,Ul,vm,Vl,zl,Wl,Hl,ql,jl,mi,Xl,Kl,Jl,Yl,Zl,Ql,tf,ef,rf,nf,of,bi=O(()=>{vt(),Y(),be(),st(),j(),wm=(e,o,i,s)=>{let h=e.session.pack?2:0,a=G(e.session.backend.glContext.version);return{...o,output:{dims:i.dims,type:i.type,textureType:h},shaderSource:`
     ${s.body}
     void main() {
       vec4 v = ${a.texture2D}(A, TexCoords);
       v = ${s.name}_(v);
       ${a.output} = v;
     }
     `,hasMain:!0}},dt=(e,o,i,s)=>{let h=e.session.pack?2:0,a={name:i.name,inputTypes:[h],inputNames:["A"],cacheHint:s};return{...a,get:()=>wm(e,a,o,i)}},Cl=(e,o)=>[e.run(dt(e,o[0],nm()),o)],Nl=(e,o)=>[e.run(dt(e,o[0],om()),o)],Rl=(e,o)=>[e.run(dt(e,o[0],im()),o)],Gl=(e,o)=>[e.run(dt(e,o[0],am()),o)],hi=(e,o,i)=>[e.run(dt(e,o[0],ci(i.min,i.max),i.cacheKey),o)],Ml=e=>W({min:e.attributes.getFloat("min",Ue),max:e.attributes.getFloat("max",Ve)}),Ul=(e,o)=>{let i=vm(e,o);return hi(e,[o[0]],i)},vm=(e,o)=>{if(o.length>=3&&(!e.session.isInitializer(o[1].dataId)||!e.session.isInitializer(o[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let i=o.length>=3?o[1].numberData[0]:Ue,s=o.length>=3?o[2].numberData[0]:Ve;return W({min:i,max:s})},Vl=(e,o)=>[e.run(dt(e,o[0],sm()),o)],zl=(e,o)=>[e.run(dt(e,o[0],um()),o)],Wl=(e,o,i)=>[e.run(dt(e,o[0],lm(i.alpha),i.cacheKey),o)],Hl=e=>W({alpha:e.attributes.getFloat("alpha",1)}),ql=(e,o)=>[e.run(dt(e,o[0],fm()),o)],jl=(e,o)=>[e.run(dt(e,o[0],cm()),o)],mi=(e,o)=>[e.run(dt(e,o[0],pm()),o)],Xl=(e,o,i)=>[e.run(dt(e,o[0],dm(i.alpha),i.cacheKey),o)],Kl=e=>W({alpha:e.attributes.getFloat("alpha",.01)}),Jl=(e,o)=>[e.run(dt(e,o[0],hm()),o)],Yl=(e,o)=>[e.run(dt(e,o[0],mm()),o)],Zl=(e,o)=>[e.run(dt(e,o[0],bm()),o)],Ql=(e,o)=>[e.run(dt(e,o[0],pi()),o)],tf=(e,o)=>[e.run(dt(e,o[0],di()),o)],ef=(e,o)=>[e.run(dt(e,o[0],gm()),o)],rf=(e,o)=>[e.run(dt(e,o[0],ym()),o)],nf=(e,o)=>[e.run(dt(e,o[0],xm()),o)],of=(e,o)=>[e.run(dt(e,o[0],Tm()),o)]});function fe(e){let o;switch(e.activation){case"Relu":o=pi();break;case"Sigmoid":o=di();break;case"Clip":o=ci(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let i=o.name,s=o.body,h=`value = ${i}_(value);`;return{activationFunction:s,applyActivation:h}}var pr,He=O(()=>{Y(),bi(),pr=e=>{let o=e.getString("activation","");if(o==="Clip"){let[i,s]=e.getFloats("activation_params",[Ue,Ve]);return{activation:o,clipMax:s,clipMin:i,activationCacheKey:`${o}:${i},${s}`}}return{activation:o,activationCacheKey:o}}}),_m,Om,af,sf=O(()=>{Mt(),st(),j(),$n(),He(),_m=(e,o)=>({name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:o}),Om=(e,o,i,s)=>{let h=o.length>2?"value += getBias(output_channel);":"",a=o[0].dims.slice(),d=o[1].dims.slice(),et=d[0]/s.group;tt.verbose("GroupedConv",`autpPad:${s.autoPad}, dilations:${s.dilations}, group:${s.group}, kernelShape:${s.kernelShape}, pads:${s.pads}, strides:${s.strides}`);let $=dr(a,d,s.dilations,s.pads,s.strides),c=G(e.session.backend.glContext.version),{activationFunction:b,applyActivation:g}=fe(s),nt=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${b}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${et};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${d[1]}; wInChannel++) {
      int input_channel = group_id * ${d[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${d[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${s.dilations[0]};

        if (xHeight < 0 || xHeight >= ${a[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${d[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${s.dilations[1]};
          if (xWidth < 0 || xWidth >= ${a[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${h}
    ${g}
    ${c.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:$,type:o[0].type,textureType:0},shaderSource:nt,hasMain:!0}},af=(e,o,i)=>{let s=_m(o.length>2,i.cacheKey);return{...s,get:()=>Om(e,o,s,i)}}}),Sm,Am,uf,lf=O(()=>{st(),j(),We(),Sm=e=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:e}),Am=(e,o,i,s,h,a)=>{let d=i.dims,et=s.dims,$=2,c=3,b=h.length,g=[et[1]*et[2]*et[3],h[2]*h[3]],nt=et[2]*et[3],at=le(),Ot=G(e.session.backend.glContext.version),At="";for(let St=0;St<=1;St++)for(let xt=0;xt<=1;xt++)At+=`
            blockIndex = rc.x + ${xt};
            pos = rc.y + ${St};

            if(blockIndex < ${g[1]} && pos < ${g[0]}) {
              offsetY = int(blockIndex / (${h[b-1]})) * ${a.strides[0]} -
                ${a.pads[0]};
              d0 = offsetY + ${a.dilations[0]} * (imod(pos, ${nt}) / ${et[2]});

              if(d0 < ${d[$]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${h[b-1]}) * ${a.strides[1]} -
                  ${a.pads[1]};
                d1 = offsetX + ${a.dilations[1]} * imod(imod(pos, ${nt}), ${et[2]});

                if(d1 < ${d[c]} && d1 >= 0) {

                  ch = int(float(pos)/ ${nt}.);
                    innerDims = vec2(d0, d1);
                    result[${St*2+xt}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let Ct=`
      ${at}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${At}
          ${Ot.output} = result;
      }
            `;return{...o,output:{dims:g,type:i.type,textureType:2},shaderSource:Ct,hasMain:!0}},uf=(e,o,i,s,h)=>{let a=Sm(h.cacheKey);return{...a,get:()=>Am(e,a,o,i,s,h)}}});function Em(e,o,i){let s=o[0].dims,h=o[1].dims,a=$t.calcShape(s,h,!0);if(!a)throw new Error("Can't use matmul on the given tensors");let d=kt(a.length),et=ee(),{activationFunction:$,applyActivation:c}=fe(i),b=o.length>2,g=b?"value += getBiasForMatmul();":"",nt=b?`${yi(d,et,o[2].dims,a,!1)}`:"",at=a.length,Ot=s.length,At=h.length,Ct=s[s.length-1],St=`
    ${$}
    ${nt}
    float process(int indices[${at}]) {
        int a[${Ot}];
        int b[${At}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${Ct}; ++k) {
            a[${Ot-1}] = k;
            b[${At-2}] = k;
            value += _A(a) * _B(b);
        }
        ${g}
        ${c}
        return value;
    }`;return{...e,output:{dims:a,type:o[0].type,textureType:0},shaderSource:St}}function gi(e,o){let i=Pm(e.length>2,o.activationCacheKey);return{...i,get:()=>Em(i,e,o)}}function yi(e,o,i,s,h){let a="",d=i.length,et=s.length,$=et-d;et<2&&d>0?a="coords":a=i.map((nt,at)=>`coords.${o[at+$]}`).join(", ");let c=$t.getBroadcastDims(i,s).map(nt=>`coords.${o[nt+$]} = 0;`).join(`
`),b=B.size(i)===1,g="vec4(outputValue.xx, outputValue.yy)";return b&&(g="vec4(outputValue.x)"),h?`
vec4 getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${c}
  vec4 outputValue = getBias(${a});
  return ${g};
}`:`
float getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${c}
  return getBias(coords.x);
}`}var ff,cf,Pm,Dm,kn=O(()=>{Y(),j(),ue(),He(),xi(),ff=(e,o,i)=>(Dm(o),e.session.pack?[e.run(Bn(e,o,i),o)]:[e.run(gi(o,i),o)]),cf=e=>pr(e.attributes),Pm=(e,o)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[0,0,0]:[0,0],cacheHint:o}),Dm=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64")throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")}});function km(e,o,i,s){let h=[],a=[],d=i[0].dims,et=i[1].dims,$=d.length,c=et.length,b=s.length,g=b-$,nt=b-c;h=d.map((xt,Dt)=>`coords.${o[Dt+g]}`),h[$-1]="i*2",h.join(", "),a=et.map((xt,Dt)=>`coords.${o[Dt+nt]}`),a[c-2]="i*2",a.join(", ");let at=$t.getBroadcastDims(d,s),Ot=$t.getBroadcastDims(et,s),At=at.map(xt=>`coords.${o[xt+g]} = 0;`).join(`
`),Ct=Ot.map(xt=>`coords.${o[xt+nt]} = 0;`).join(`
`),St=`int lastDim = coords.${o[b-1]};
  coords.${o[b-1]} = coords.${o[b-2]};
  coords.${o[b-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${St}
  ${At}
  vec4 outputValue = getA(${h});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${St}
  ${Ct}
  vec4 outputValue = getB(${a});
  return outputValue;
}`}function Bm(e,o){let i="";for(let s=0;s<o-2;s++)i+=`rc.${e[s]}, `;return i+=`rc.${e[o-2]}, i*2`,i}function Fm(e,o){let i="";for(let s=0;s<o-2;s++)i+=`rc.${e[s]}, `;return i+=`i*2, rc.${e[o-1]}`,i}var Lm,$m,Bn,xi=O(()=>{Y(),st(),j(),ue(),He(),kn(),Lm=(e,o)=>({name:"MatMul (packed)",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[2,2,2]:[2,2],cacheHint:o}),$m=(e,o,i,s)=>{let h=i.length>2,a=h?"value += getBiasForMatmul();":"",d=i[0].dims,et=i[1].dims,$=$t.calcShape(d,et,!0),c=!B.areEqual(i[0].dims,i[1].dims);if(!$)throw new Error("Can't use matmul on the given tensors");let b=d[d.length-1],g=Math.ceil(b/2),nt=d.length,at=et.length,Ot=G(e.session.backend.glContext.version),At=kt($.length),Ct=$.length,St=ee(),{activationFunction:xt,applyActivation:Dt}=fe(s),Qt=h?`${yi(At,St,i[2].dims,$,!0)}`:"",Zt=c?`${km(At,St,i,$)}`:"",gr=c?"getAAtOutCoordsMatmul(i)":`getA(${Bm(St,nt)})`,vr=c?"getBAtOutCoordsMatmul(i)":`getB(${Fm(St,at)})`,Er=c?"":`${At} rc =
          getOutputCoords(); int lastDim = rc.${St[Ct-1]}; rc.${St[Ct-1]} =
          rc.${St[Ct-2]}; rc.${St[Ct-2]} = lastDim;
      `,wo=`
            ${Zt}
            ${Qt}
            ${xt}
            void main() {
              ${Er}

              vec4 value = vec4(0);
              for (int i = 0; i < ${g}; i++) {
                vec4 a = ${gr};
                vec4 b = ${vr};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${a}
              ${Dt}
              ${Ot.output} = value;
            }`;return{...o,output:{dims:$,type:i[0].type,textureType:2},shaderSource:wo,hasMain:!0}},Bn=(e,o,i)=>{let s=Lm(o.length>2,i.activationCacheKey);return{...s,get:()=>$m(e,s,o,i)}}}),pf,df=O(()=>{$n(),lf(),xi(),pf=(e,o,i)=>{let s=o[0].dims,h=o[1].dims,a=dr(s,h,i.dilations,i.pads,i.strides),d=e.run(uf(e,o[0],o[1],a,i),[o[0]]),et=e.reshapePacked(o[1],[h[0],h[1]*h[2]*h[3]]),$=o.length===3?[et,d,o[2]]:[et,d],c=e.run(Bn(e,$,i),$);return e.reshapePacked(c,a)}}),Cm,Nm,hf,Ti,wi=O(()=>{j(),Cm=e=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:e}),Nm=(e,o,i,s,h,a)=>{let d=i.dims,et=s.dims,$=h.length,c=Ti(d,et,h,4),b=`
        const int XC = ${d[1]};
        const int XH = ${d[2]};
        const int XW = ${d[3]};
        const int KH = ${a.kernelShape[0]};
        const int KW = ${a.kernelShape[1]};
        const int dilationH = ${a.dilations[0]};
        const int dilationW = ${a.dilations[1]};
        const int strideH = ${a.strides[0]};
        const int strideW = ${a.strides[1]};
        const int padH = ${a.pads[0]};
        const int padW = ${a.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${$}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${d.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...o,output:{dims:c,type:i.type,textureType:4},shaderSource:b}},hf=(e,o,i,s,h)=>{let a=Cm(h.cacheKey);return{...a,get:()=>Nm(e,a,o,i,s,h)}},Ti=(e,o,i,s=4)=>[i[0],i[2],i[3],Math.ceil(e[1]*o[2]*o[3]/s)]}),Rm,Gm,mf,bf=O(()=>{Y(),st(),j(),He(),wi(),Rm=(e,o)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[0,4,0]:[0,4],cacheKey:o.activationCacheKey}),Gm=(e,o,i,s,h)=>{let a=i[0].dims,d=i[1].dims,et=[d[0],Math.ceil(a[1]*d[2]*d[3]/4)],$=Ti(a,d,s),[c,b]=e.calculateTextureWidthAndHeight(et,4),g=B.computeStrides($),[nt,at]=e.calculateTextureWidthAndHeight($,4),Ot=s.length,At=i.length<3?"0.0":"_B(b)",Ct=Math.ceil(a[1]*d[2]*d[3]/4),{activationFunction:St,applyActivation:xt}=fe(h),Dt=G(e.session.backend.glContext.version),Qt=`
${St}
float process(int indices[${Ot}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${g[0]} + im2col[1] * ${g[1]} + im2col[2] * ${g[2]};
  int kernelOffset = indices[1] * ${et[1]};
  float value = ${At};
  for (int i = 0; i < ${Ct}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${nt}, ${at});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${c}, ${b});
    value += dot(${Dt.texture2D}(Im2Col, im2colCoords), ${Dt.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${xt}
  return value;
}`;return{...o,output:{dims:s,type:i[0].type,textureType:0},shaderSource:Qt}},mf=(e,o,i,s)=>{let h=Rm(o.length>2,s);return{...h,get:()=>Gm(e,h,o,i,s)}}}),dr,vi,Mm,Um,Vm,zm,Ii,Wm,$n=O(()=>{vt(),Y(),sf(),df(),bf(),He(),wi(),kn(),dr=(e,o,i,s,h)=>{let a=e[0],d=e.slice(2),et=d.length,$=o[0],c=o.slice(2).map((g,nt)=>g+(g-1)*(i[nt]-1)),b=d.map((g,nt)=>g+s[nt]+s[nt+et]).map((g,nt)=>Math.floor((g-c[nt]+h[nt])/h[nt]));return[a,$].concat(...b)},vi=(e,o,i)=>(Wm(o,i),Mm(e,o,i)),Mm=(e,o,i)=>{let s=zm(i,o),h=e.session.pack,a=s.kernelShape[0]===1&&s.kernelShape[1]===1;return s.group>1?[e.run(af(e,o,s),o)]:a&&h?[Um(e,o,s)]:h&&o[0].dims.length===4&&o[0].dims[0]===1&&!a?[pf(e,o,s)]:[Vm(e,o,s)]},Um=(e,o,i)=>{let s=o[0].dims,h=o[1].dims,a=dr(s,h,i.dilations,i.pads,i.strides),d=e.reshapeUnpacked(o[0],[s[1],s[2]*s[3]]),et=e.reshapeUnpacked(o[1],[h[0],h[1]]),$=o.length>2?[et,d,o[2]]:[et,d],c=e.run(gi($,i),$);return e.reshapeUnpacked(c,a)},Vm=(e,o,i)=>{let s=o[0].dims,h=o[1].dims,a=dr(s,h,i.dilations,i.pads,i.strides),d=e.run(hf(e,o[0],o[1],a,i),[o[0]]),et=o.length===3?[d,o[1],o[2]]:[d,o[1]];return e.run(mf(e,o,a,i),et)},zm=(e,o)=>{let i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let a=2;a<o[1].dims.length;++a)i.push(o[1].dims[a]);let s=e.pads.slice();Me.adjustPadsBasedOnAutoPad(o[0].dims,e.strides,e.dilations,i,s,e.autoPad);let h=Object.assign({},e);return Object.assign(h,{kernelShape:i,pads:s,cacheKey:e.cacheKey}),h},Ii=e=>{let o=e.attributes,i=pr(o),s=o.getString("auto_pad","NOTSET"),h=o.getInts("dilations",[1,1]),a=o.getInt("group",1),d=o.getInts("kernel_shape",[]),et=o.getInts("pads",[0,0,0,0]),$=o.getInts("strides",[1,1]);return W({autoPad:s,dilations:h,group:a,kernelShape:d,pads:et,strides:$,...i})},Wm=(e,o)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=e[0].dims[1],s=e[1].dims[1]*o.group;if(i!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let h=e[0].dims.length-2;if(o.dilations.length!==h)throw new Error(`dilations should be ${h}D`);if(o.strides.length!==h)throw new Error(`strides should be ${h}D`);if(o.pads.length!==h*2)throw new Error(`pads should be ${h*2}D`);if(o.kernelShape.length!==0&&o.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),Hm,qm,jm,gf,Xm,Km,Jm,Ym,Zm,Qm,yf,tb,xf=O(()=>{vt(),st(),j(),He(),Hm=(e,o,i,s,h,a)=>(e-1)*o+i+(s-1)*h+1-a,qm=(e,o,i,s,h)=>{let a=Math.floor(e/2);o==="SAME_UPPER"?(i[s]=a,i[h]=e-a):o==="SAME_LOWER"&&(i[s]=e-a,i[h]=a)},jm=(e,o,i,s,h,a,d,et)=>{let $=e.length-2,c=et.length===0;for(let b=0;b<$;++b){let g=c?e[b+2]*a[b]:et[b],nt=Hm(e[b+2],a[b],h[b],o[b],i[b],g);qm(nt,s,h,b,b+$),c&&et.push(a[b]*(e[b+2]-1)+d[b]+(o[b]-1)*i[b]+1-h[b]-h[b+$])}},gf=(e,o,i)=>(tb(o,i),Xm(e,o,i)),Xm=(e,o,i)=>{let s=Qm(i,o);return[Zm(e,o,s)]},Km=(e,o)=>({name:"ConvTranspose",inputNames:e?["X","W","B"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:o}),Jm=(e,o,i,s)=>{let h=o.length>2?"getB(output_channel)":"0.0",a=o[0].dims,d=o[1].dims,et=d[1],$=d[0]/s.group,c=[o[0].dims[0],o[1].dims[1]*s.group,...s.outputShape],b=G(e.session.backend.glContext.version),{activationFunction:g,applyActivation:nt}=fe(s),at=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${g}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${et};
    int wOutChannel = output_channel - group_id * ${et};

    float value = ${h};
    for (int inChannelOffset = 0; inChannelOffset < ${$}; inChannelOffset++) {
      int input_channel = group_id * ${$} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${d[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${d[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${s.dilations[0]}, wHOff * ${s.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${a[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${a[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${nt}
    ${b.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:c,type:o[0].type,textureType:0},shaderSource:at,hasMain:!0}},Ym=(e,o,i)=>{let s=Km(o.length>2,i.cacheKey);return{...s,get:()=>Jm(e,o,s,i)}},Zm=(e,o,i)=>e.run(Ym(e,o,i),o),Qm=(e,o)=>{let i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let et=2;et<o[1].dims.length;++et)i.push(o[1].dims[et]);let s=e.pads.slice(),h=e.outputShape.slice(),a=o[0].dims;jm(a,i,e.dilations,e.autoPad,s,e.strides,e.outputPadding,h);let d=Object.assign({},e);return Object.assign(d,{kernelShape:i,pads:s,outputShape:h,cacheKey:e.cacheKey}),d},yf=e=>{let o=e.attributes,i=pr(o),s=o.getString("auto_pad","NOTSET"),h=o.getInts("dilations",[1,1]),a=o.getInt("group",1),d=o.getInts("kernel_shape",[]),et=o.getInts("output_padding",[0,0]),$=o.getInts("output_shape",[]),c=o.getInts("pads",[0,0,0,0]),b=o.getInts("strides",[1,1]);return W({autoPad:s,dilations:h,group:a,kernelShape:d,outputPadding:et,outputShape:$,pads:c,strides:b,...i})},tb=(e,o)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=e[0].dims[1],s=e[1].dims[0];if(i!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let h=e[1].dims[1]*o.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==h))throw new Error("invalid bias");let a=e[0].dims.length-2;if(o.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(o.strides.length!==a)throw new Error(`strides should be ${a}D`);if(o.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(o.outputPadding.length!==a)throw new Error(`output_padding should be ${a}D`);if(o.kernelShape.length!==0&&o.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(o.outputShape.length!==0&&o.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),Tf,qe,wf,eb,vf,rb,nb,ob,Fn=O(()=>{vt(),Y(),j(),Tf={name:"Transpose",inputNames:["A"],inputTypes:[0]},qe=(e,o,i)=>(ob(o),[e.run({...Tf,cacheHint:i.cacheKey,get:()=>eb(e,o[0],i.perm)},o)]),wf=e=>W({perm:e.attributes.getInts("perm",[])}),eb=(e,o,i)=>{let s=o.dims;i=vf(s,i);let h=rb(s,i),a=s.length,d=`
      ${nb("perm",i,a)}
      float process(int indices[${a}]) {
        int a[${a}];
        perm(a, indices);
        return _A(a);
      }`;return{...Tf,output:{dims:h,type:o.type,textureType:0},shaderSource:d}},vf=(e,o)=>(o&&o.length!==e.length&&(o=[...e.keys()].reverse()),o),rb=(e,o)=>(o=vf(e,o),B.sortBasedOnPerm(e,o)),nb=(e,o,i)=>{let s=[];s.push(`void ${e}(out int a[${i}], int src[${i}]) {`);for(let h=0;h<i;++h)s.push(`	a[${o[h]}]=src[${h}];`);return s.push("	}"),s.join(`
`)},ob=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}}),If,_f,ib,Of=O(()=>{Fn(),If=(e,o,i)=>{ib(o);let s=i.blocksize,h=s*s,a=i.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],d=i.mode==="DCR"?[o[0].dims[0],s,s,o[0].dims[1]/h,o[0].dims[2],o[0].dims[3]]:[o[0].dims[0],o[0].dims[1]/h,s,s,o[0].dims[2],o[0].dims[3]],et=e.reshapeUnpacked(o[0],d),$={perm:a,cacheKey:`${a}`},[c]=qe(e,[et],$),b=[o[0].dims[0],o[0].dims[1]/h,o[0].dims[2]*s,o[0].dims[3]*s];return[e.reshapeUnpacked(c,b)]},_f=e=>{let o=e.attributes.getInt("blocksize");if(o<1)throw new Error(`blocksize must be >= 1, but got : ${o} for DepthToSpace`);let i=e.attributes.getString("mode","DCR");if(i!=="DCR"&&i!=="CRD")throw new Error(`unrecognized mode: ${i} for DepthToSpace`);return{mode:i,blocksize:o}},ib=e=>{if(e.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if(e[0].type==="string"||e[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),Sf,Af,ab,Pf=O(()=>{Y(),Sf=(e,o,i)=>{ab(o,i);let s=B.flattenShape(o[0].dims,i);return[e.reshapeUnpacked(o[0],s)]},Af=e=>e.attributes.getInt("axis",1),ab=(e,o)=>{if(!e||e.length!==1)throw new Error("Flatten requires 1 input.");let i=e[0].dims.length;if(i===0)throw new Error("scalar tensor is not supported.");if(o<-i||o>i)throw new Error("Invalid axis");if(e[0].type==="string")throw new Error("string tensor is not supported.")}}),Ae,Rr=O(()=>{Ae=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),Ef,Df,sb,ub,lb,fb,Lf=O(()=>{vt(),Rr(),Y(),j(),Ef=(e,o,i)=>(fb(o,i.axis),[e.run(lb(e,o,i),o)]),Df=e=>W({axis:e.attributes.getInt("axis",0)}),sb={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},ub=(e,o,i,s)=>{let h=i[0].dims.slice(),a=i[1].dims.slice(),d=new Array(h.length+a.length-1);s=B.normalizeAxis(s,h.length);let et=[];for(let nt=0;nt<d.length;nt++)nt<s?(d[nt]=h[nt],et.push(`inputIdx[${nt}] = outputIdx[${nt}];`)):nt<s+a.length?(d[nt]=a[nt-s],et.push(`indexDataIdx[${nt-s}] = outputIdx[${nt}];`)):(d[nt]=h[nt-a.length+1],et.push(`inputIdx[${nt-a.length+1}] = outputIdx[${nt}];`));let $=d.length||1,c=h.length,b=a.length||1,g=`
      float process(int outputIdx[${$}]) {
        int inputIdx[${c}];
        int indexDataIdx[${b}];
        indexDataIdx[0] = 0;
        ${et.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${s}] = idx < 0 ? idx + ${h[s]} : idx;
        return _A(inputIdx);
      }`;return{...o,output:{dims:d,type:i[0].type,textureType:0},shaderSource:g}},lb=(e,o,i)=>{let s={...sb,cacheHint:i.cacheKey};return{...s,get:()=>ub(e,s,o,i.axis)}},fb=(e,o)=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.");let i=e[0].dims.length;if(i<1)throw new Error("Invalid input shape.");if(o<-i||o>i-1)throw new Error("Invalid axis.");if(Ae.indexOf(e[0].type)===-1)throw new Error("Invaid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invaid input type.")}}),_i,$f,kf,Bf,cb,pb,db,Ff=O(()=>{vt(),Y(),j(),_i=(e,o,i)=>(db(o,i),[e.run(cb(o,i),o)]),$f=(e,o)=>{let i=e.attributes.getInt("transA",0)!==0,s=e.attributes.getInt("transB",0)!==0,h=e.attributes.getFloat("alpha",1),a=e.attributes.getFloat("beta",1);return W({transA:i,transB:s,alpha:h,beta:a,isOptionalC:o})},kf=e=>$f(e,!1),Bf=e=>$f(e,!0),cb=(e,o)=>{let i={name:"Gemm",inputNames:e.length===3?["A","B","C"]:["A","B"],inputTypes:e.length===3?[0,0,0]:[0,0],key:o.cacheKey};return{...i,get:()=>pb(i,e,o)}},pb=(e,o,i)=>{let s=o[0].dims.slice(),h=o[1].dims.slice(),[a,d]=_n.getShapeOfGemmResult(s,i.transA,h,i.transB,o.length===3?o[2].dims:void 0),et=[a,d];if(!et)throw new Error("Can't use gemm on the given tensors");let $=s[s.length-1],c="";i.transA&&($=s[0]),i.transA&&i.transB?c="value += _A_T(a) * _B_T(b);":i.transA&&!i.transB?c="value += _A_T(a) * _B(b);":!i.transA&&i.transB?c="value += _A(a) * _B_T(b);":!i.transA&&!i.transB&&(c="value += _A(a) * _B(b);");let b=et.length,g=o.length===3?`int c[${o[2].dims.length}];`:"",nt=o.length===3?"bcastIndices_C(indices, c);":"",at=o.length===3?"value += beta * _C(c);":"",Ot=`
      float process(int indices[${b}]) {
          int a[${b}];
          int b[${b}];
          ${g}

          copyVec(indices, a);
          copyVec(indices, b);
          ${nt}

          float value = 0.0;
          for (int k=0; k<${$}; ++k) {
              a[${b-1}] = k;
              b[${b-2}] = k;
              ${c}
          }

          value = value * alpha;
          ${at}
          return value;
      }`;return{...e,output:{dims:et,type:o[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:i.alpha},{name:"beta",type:"float",data:i.beta}],shaderSource:Ot}},db=(e,o)=>{if(!e)throw new Error("Input is missing");if(o.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!o.isOptionalC&&e.length!==3)throw new Error("Gemm requires 3 inputs");if(e.length===3&&e[2].dims.length!==1&&e[2].dims.length!==2)throw new Error("Invalid input shape of C");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64"||e.length===3&&e[2].type!=="float32"&&e[2].type!=="float64")throw new Error("Invalid input type.");if(e[0].type!==e[1].type||e.length===3&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}}),Cf,Nf,hb,mb,bb,gb,yb,Rf=O(()=>{vt(),j(),Cf=(e,o,i)=>(yb(o),[e.run(bb(e,o,i),o)]),Nf=e=>{let o=e.attributes.getFloat("scale"),i=e.attributes.getFloats("bias");return W({scale:o,bias:i})},hb={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},mb=(e,o,i,s)=>{let h=i[0].dims.slice(),a=h.length,d=`
      ${gb(s.bias.length)}
      float process(int indices[${a}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...o,output:{dims:h,type:i[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:s.bias.length,data:s.bias},{name:"scale",type:"float",data:s.scale}],shaderSource:d}},bb=(e,o,i)=>{let s={...hb,cacheHint:i.cacheKey};return{...s,get:()=>mb(e,s,o,i)}},gb=e=>{let o=[`float getBias(float bias[${e}], int channel) {`];for(let i=0;i<e;++i)i===0?o.push(`	if (channel == ${i}) { return bias[${i}]; }`):i===e-1?o.push(`	else { return bias[${i}]; }`):o.push(`	else if (channel == ${i}) { return bias[${i}]; }`);return o.push("	}"),o.join(`
`)},yb=e=>{if(!e||e.length!==1)throw new Error("ImageScaler requires 1 input.");if(e[0].dims.length!==4)throw new Error("Invalid input shape.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")}}),Mf,Uf,Gf,xb,Tb,wb,vb,Ib,_b,Vf=O(()=>{st(),j(),Mf=(e,o,i)=>{_b(o);let s=e.run(Tb(o[0]),o);return[e.run(Ib(e,o[0],i,s.dims),[o[0],s,o[1],o[2]])]},Uf=e=>e.attributes.getFloat("epsilon",1e-5),Gf={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},xb=(e,o)=>{let i=o.dims.slice(),s=i[1],h=i[2]*i[3],a=[i[0],s],d=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${h});
        temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${h});

        return v;
      }`;return{...e,output:{dims:a,type:o.type,textureType:4},shaderSource:d}},Tb=e=>({...Gf,get:()=>xb(Gf,e)}),wb={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},vb=(e,o,i,s,h)=>{let a=G(e.session.backend.glContext.version),[d,et]=e.calculateTextureWidthAndHeight(h,4),[$,c]=[d/4,et],b=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${$}, ${c});
        return ${a.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...o,output:{dims:i.dims,type:i.type,textureType:0},variables:[{name:"epsilon",type:"float",data:s}],shaderSource:b}},Ib=(e,o,i,s)=>{let h={...wb,cacheHint:`${i}`};return{...h,get:()=>vb(e,h,o,i,s)}},_b=e=>{if(!e||e.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let o=e[0],i=e[1],s=e[2];if(o.dims.length<3||i.dims.length!==1||s.dims.length!==1)throw new Error("Invalid input shape.");if(i.dims[0]!==o.dims[1]||s.dims[0]!==o.dims[1])throw new Error("Input shapes are mismatched.");if(o.type!=="float32"&&o.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||s.type!=="float32"&&s.type!=="float64")throw new Error("Invalid input type.");if(e[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function Ob(e,o){let i=e[0].dims[1],s=e[0].dims.length,h=-Math.floor((o.size-1)/2),a=Math.ceil((o.size-1)/2),d=`float(${o.alpha}) / float(${o.size})`,et=`float(${o.bias})`,$=`float(${o.beta})`,c=`
    float process(int indices[${s}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${h}; i <= ${a}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${i}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${et} + ${d} * square_sum, ${$});
    }`;return{...Hf,cacheHint:o.cacheKey,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:c}}function Sb(e,o){return{...Hf,cacheHint:o.cacheKey,get:()=>Ob(e,o)}}var zf,Wf,Hf,Ab,qf=O(()=>{vt(),j(),zf=(e,o,i)=>(Ab(o),[e.run(Sb(o,i),o)]),Wf=e=>{let o=e.attributes.getFloat("alpha",1e-4),i=e.attributes.getFloat("beta",.75),s=e.attributes.getFloat("bias",1),h=e.attributes.getInt("size");return W({alpha:o,beta:i,bias:s,size:h})},Hf={name:"LRN",inputNames:["X"],inputTypes:[0]},Ab=e=>{if(!e||e.length!==1)throw new Error("LRN requires 1 input.");if(e[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(e[0].type!=="float32")throw new Error("input should be float type")}}),Pb,Oi,jf,Xf,Kf,Eb,Db,Lb,$b,kb,Bb,Fb,Cb,Jf=O(()=>{vt(),Y(),st(),j(),Pb={name:"Pad",inputNames:["A"],inputTypes:[0]},Oi=(e,o,i)=>(Lb(o),[e.run({...Pb,cacheHint:i.cacheKey,get:()=>Db(e,o[0],i)},o)]),jf=e=>{let o=e.attributes.getString("mode","constant"),i=e.attributes.getFloat("value",0),s=e.attributes.getInts("pads");return W({mode:o,value:i,pads:s})},Xf=(e,o,i)=>{$b(o);let s=Eb(e,o,i);return Oi(e,[o[0]],s)},Kf=e=>e.attributes.getString("mode","constant"),Eb=(e,o,i)=>{if(!e.session.isInitializer(o[1].dataId)||o.length>=3&&!e.session.isInitializer(o[2].dataId))throw new Error("dynamic pad attributes are not allowed");let s=Array.from(o[1].integerData),h=o.length>=3?o[2].floatData[0]:0;return W({mode:i,pads:s,value:h})},Db=(e,o,i)=>{let s=B.padShape(o.dims.slice(),i.pads),h=s.length,a=`
      ${kb(e,o,i)}
      float process(int[${h}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:s,type:o.type,textureType:0},shaderSource:a}},Lb=e=>{if(!e||e.length!==1)throw new Error("Pad requires 1 input");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},$b=e=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(e[1].type!=="int32")throw new Error("Invalid input type.");if(e.length>=3&&e[2].type==="string")throw new Error("Invalid input type.")},kb=(e,o,i)=>{let s=G(e.session.backend.glContext.version),[h,a]=e.calculateTextureWidthAndHeight(o.dims,0),d=B.computeStrides(o.dims);switch(i.mode){case"constant":return Bb(s,o.dims,d,h,a,i.pads,i.value);case"reflect":return Fb(s,o.dims,d,h,a,i.pads);case"edge":return Cb(s,o.dims,d,h,a,i.pads);default:throw new Error("Invalid mode")}},Bb=(e,o,i,s,h,a,d)=>{let et=o.length,$="";for(let c=et-1;c>=0;--c)$+=`
        k = m[${c}] - ${a[c]};
        if (k < 0)  return constant;
        if (k >= ${o[c]}) return constant;
        offset += k * ${i[c]};
        `;return`
      float padA(int m[${et}]) {
        const float constant = float(${d});
        int offset = 0;
        int k = 0;
        ${$}
        vec2 coords = offsetToCoords(offset, ${s}, ${h});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},Fb=(e,o,i,s,h,a)=>{let d=o.length,et="";for(let $=d-1;$>=0;--$)et+=`
        k = m[${$}] - ${a[$]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(o[$]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${o[$]}) { k = _2n_1 - k; }
        }
        offset += k * ${i[$]};
        `;return`
      float padA(int m[${d}]) {
        int offset = 0;
        int k = 0;
        ${et}
        vec2 coords = offsetToCoords(offset, ${s}, ${h});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},Cb=(e,o,i,s,h,a)=>{let d=o.length,et="";for(let $=d-1;$>=0;--$)et+=`
        k = m[${$}] - ${a[$]};
        if (k < 0)  k = 0;
        if (k >= ${o[$]}) k = ${o[$]-1};
        offset += k * ${i[$]};
      `;return`
      float padA(int m[${d}]) {
        int offset = 0;
        int k = 0;
        ${et}
        vec2 coords = offsetToCoords(offset, ${s}, ${h});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `}}),Zf,Qf,tc,ec,rc,nc,oc,ic,ac,Nb,Yf,sc,Nn,uc,Cn,Rb,lc=O(()=>{vt(),Y(),j(),Zf=(e,o,i)=>{Nn(o);let s={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[e.run({...s,get:()=>tc(o,s,!1,i)},o)]},Qf=e=>{let o=e.attributes.getString("auto_pad","NOTSET"),i=e.attributes.getInt("ceil_mode",0),s=e.attributes.getInt("count_include_pad",0)!==0,h=e.attributes.getInts("kernel_shape"),a=e.attributes.getInts("strides",[]),d=e.attributes.getInts("pads",[]);if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return W({autoPad:o,ceilMode:i,countIncludePad:s,kernelShape:h,strides:a,pads:d})},tc=(e,o,i,s)=>{let[h,a]=ac(e,s,i),d=B.size(h.kernelShape),et="value += _X(x);",$="";h.countIncludePad?$+=`value /= float(${d});`:$+=`value /= float(${d} - pad);`;let c=`
        ${uc(e[0].dims,h,et,$,"0.0")}
      `;return{...o,output:{dims:a,type:e[0].type,textureType:0},shaderSource:c}},ec=(e,o,i)=>{Nn(o);let s={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${i.countIncludePad}`};return[e.run({...s,get:()=>tc(o,s,!0,i)},o)]},rc=e=>{let o=e.attributes.getInt("count_include_pad",0)!==0;return W({autoPad:"",ceilMode:0,countIncludePad:o,kernelShape:[],strides:[],pads:[]})},nc=(e,o,i)=>{Nn(o);let s={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[e.run({...s,get:()=>ic(o,s,!1,i)},o)]},oc=e=>{let o=e.attributes.getString("auto_pad","NOTSET"),i=e.attributes.getInt("ceil_mode",0),s=e.attributes.getInts("kernel_shape"),h=e.attributes.getInts("strides",[]),a=e.attributes.getInts("pads",[]),d=e.attributes.getInt("storage_order",0),et=e.attributes.getInts("dilations",[]);if(d!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return W({autoPad:o,ceilMode:i,countIncludePad:!1,kernelShape:s,strides:h,pads:a,storageOrder:d,dilations:et})},ic=(e,o,i,s)=>{let[h,a]=ac(e,s,i),d=`
      value = max(_X(x), value);
    `,et="",$=`
      ${uc(e[0].dims,h,d,et,"-1e5")}
    `;return{...o,output:{dims:a,type:e[0].type,textureType:0},shaderSource:$}},ac=(e,o,i)=>{let s=e[0].dims.slice(),h=Object.hasOwnProperty.call(o,"dilations"),a=o.kernelShape.slice(),d=o.strides.slice(),et=h?o.dilations.slice():[],$=o.pads.slice();Me.adjustPoolAttributes(i,s,a,d,et,$);let c=Me.computePoolOutputShape(i,s,d,et,a,$,o.autoPad),b=Object.assign({},o);return h?Object.assign(b,{kernelShape:a,strides:d,pads:$,dilations:et,cacheKey:o.cacheKey}):Object.assign(b,{kernelShape:a,strides:d,pads:$,cacheKey:o.cacheKey}),[b,c]},Nb={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Yf={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},sc=(e,o)=>(Nn(o),[e.run({...Yf,get:()=>ic(o,Yf,!0,Nb)},o)]),Nn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},uc=(e,o,i,s,h)=>{let a=e.length;if(o.kernelShape.length<=2){let d=o.kernelShape[o.kernelShape.length-1],et=o.strides[o.strides.length-1],$=o.pads[o.pads.length/2-1],c=o.pads[o.pads.length-1],b=e[a-1],g="",nt="",at="";if($+c!==0?g=`
          for (int i = 0; i < ${d}; i++) {
            x[${a} - 1] = indices[${a} - 1] * ${et} - ${$} + i;
            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${b}) {
              pad++;
              continue;
            }
            ${i}
          }`:g=`
          for (int i = 0; i < ${d}; i++) {
            x[${a} - 1] = indices[${a} - 1] * ${et} - ${$} + i;
            ${i}
          }`,o.kernelShape.length===2){let Ot=o.kernelShape[o.kernelShape.length-2],At=o.strides[o.strides.length-2],Ct=o.pads[o.pads.length/2-2],St=o.pads[o.pads.length-2],xt=e[a-2];Ct+St!==0?nt=`
            for (int j = 0; j < ${Ot}; j++) {
              x[${a} - 2] = indices[${a} - 2] * ${At} - ${Ct} + j;
              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${xt}) {
                pad+= ${d};
                continue;
              }
          `:nt=`
            for (int j = 0; j < ${Ot}; j++) {
              x[${a} - 2] = indices[${a} - 2] * ${At} - ${Ct} + j;
            `,at=`
          }
        `}return`
        float process(int indices[${a}]) {
          int x[${a}];
          copyVec(indices, x);

          float value = ${h};
          int pad = 0;
          ${nt}
          ${g}
          ${at}
          ${s}
          return value;
        }
      `}else{let d=B.size(o.kernelShape),et=B.computeStrides(o.kernelShape),$=et.length,c=o.pads.length,b=Rb($),g=Cn(e,"inputDims"),nt=Cn(o.pads,"pads"),at=Cn(et,"kernelStrides"),Ot=Cn(o.strides,"strides"),At=o.pads.reduce((St,xt)=>St+xt),Ct="";return At?Ct=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${i}
          }`:Ct=`
          }
          ${i}
        `,`
        ${b}
        float process(int indices[${a}]) {
          int x[${a}];
          copyVec(indices, x);
          int offset[${$}];
          int pads[${c}];
          int inputDims[${a}];
          int kernelStrides[${$}];
          int strides[${$}];
          ${nt}
          ${g}
          ${Ot}
          ${at}

          float value = ${h};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${d}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a} - ${$}; j < ${a}; j++) {
              x[j] = indices[j] * strides[j - ${a} + ${$}]
                + offset[j - ${a} + ${$}] - pads[j - 2];
              ${Ct}
          }
          ${s}

          return value;
        }
      `}},Cn=(e,o)=>{let i="";for(let s=0;s<e.length;s++)i+=`
      ${o}[${s}] = ${e[s]};
    `;return i},Rb=e=>`
  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {
    if (${e} == 0) {
      return;
    }
    for (int i = 0; i < ${e} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e} - 1] = offset;
  }`}),je,Pe,Gb,Mb,fc,cc,pc,dc,hc,mc,bc,gc=O(()=>{vt(),Rr(),Y(),j(),je=(e,o,i,s,h)=>{Mb(o);let a={name:s,inputNames:["A"],inputTypes:[0]};return[e.run({...a,cacheHint:i.cacheKey,get:()=>Gb(e,o,i,s,h,a)},o)]},Pe=e=>{let o=e.attributes.getInts("axes",[]),i=e.attributes.getInt("keepdims",1)===1;return W({axes:o,keepDims:i})},Gb=(e,o,i,s,h,a)=>{let d=[],et=o[0].dims.length||1,$=[],c=B.normalizeAxes(i.axes,o[0].dims.length),b=h(o,c),g=b[1];for(let at=0;at<o[0].dims.length;at++)c.indexOf(at)>=0||c.length===0?(i.keepDims&&d.push(1),g=`
          for(int j${at} = 0; j${at} < ${o[0].dims[at]}; j${at}++) {
            inputIdx[${at}] = j${at};
            ${g}
          }`):($.push(`inputIdx[${at}] = outputIdx[${d.length}];`),d.push(o[0].dims[at]));let nt=`
      float process(int outputIdx[${d.length||1}]) {
        float value;                 // final result
        int inputIdx[${et}];      // addressing input data
        ${$.join(`
`)}
        ${b[0]}       // init ops for reduce max/min
        ${g}
        ${b[2]}       // final computation for reduce mean
        return value;
      }`;return{...a,output:{dims:d,type:o[0].type,textureType:0},shaderSource:nt}},Mb=e=>{if(!e||e.length!==1)throw new Error("Reduce op requires 1 input.");if(Ae.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},fc=(e,o,i)=>je(e,o,i,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),cc=(e,o,i)=>je(e,o,i,"ReduceMean",(s,h)=>{let a=1;for(let d=0;d<s[0].dims.length;d++)(h.indexOf(d)>=0||h.length===0)&&(a*=s[0].dims[d]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${a}.;`]}),pc=(e,o,i)=>je(e,o,i,"ReduceMax",(s,h)=>{let a=[];for(let d=0;d<s[0].dims.length;d++)(h.indexOf(d)>=0||h.length===0)&&a.push(`inputIdx[${d}] = 0;`);return[`${a.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),dc=(e,o,i)=>je(e,o,i,"ReduceMin",(s,h)=>{let a=[];for(let d=0;d<s[0].dims.length;d++)(h.indexOf(d)>=0||h.length===0)&&a.push(`inputIdx[${d}] = 0;`);return[`${a.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),hc=(e,o,i)=>je(e,o,i,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),mc=(e,o,i)=>je(e,o,i,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),bc=(e,o,i)=>je(e,o,i,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),yc,xc=O(()=>{Y(),yc=(e,o)=>{let i=B.calculateReshapedDims(o[0].dims,o[1].integerData);return e.session.pack?[e.reshapePacked(o[0],i)]:[e.reshapeUnpacked(o[0],i)]}}),Tc,Si,wc,vc,Gr,Ub,Ai,Rn,Pi=O(()=>{vt(),st(),j(),Tc={name:"Upsample",inputNames:["X"],inputTypes:[0]},Si=(e,o,i)=>(Ai(o,i),[e.run({...Tc,cacheHint:i.cacheKey,get:()=>Ub(e,o,i)},o)]),wc=e=>Gr(e,7),vc=e=>Gr(e,9),Gr=(e,o)=>{let i=o>=10,s=e.attributes.getString("mode","nearest");if(s!=="nearest"&&s!=="linear"&&(o<11||s!=="cubic"))throw new Error(`unrecognized mode: ${s}`);let h=[];o<9&&(h=e.attributes.getFloats("scales"),Rn(h,s,i));let a=e.attributes.getFloat("extrapolation_value",0),d=o>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(d)===-1)throw new Error(`coordinate_transform_mode '${d}' is not supported`);let et=d==="tf_crop_and_resize",$=et,c=s==="nearest"&&o>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(c)===-1)throw new Error(`nearest_mode '${c}' is not supported`);let b=e.attributes.getFloat("cubic_coeff_a",-.75),g=e.attributes.getInt("exclude_outside",0)!==0;if(g&&s!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let nt=o<11?!0:s==="nearest"&&d==="asymmetric"&&c==="floor",at=0,Ot=0,At=0;return o>10?e.inputs.length>2?(at=1,Ot=2,At=3):(Ot=1,At=2):o===9&&(Ot=1),W({opset:o,isResize:i,mode:s,scales:h,extrapolationValue:a,coordinateTransformMode:d,useExtrapolation:$,needRoiInput:et,nearestMode:c,cubicCoefficientA:b,excludeOutside:g,useNearest2xOptimization:nt,roiInputIdx:at,scalesInputIdx:Ot,sizesInputIdx:At})},Ub=(e,o,i)=>{let s=G(e.session.backend.glContext.version),[h,a]=e.calculateTextureWidthAndHeight(o[0].dims,0),d=o[0].dims.map((At,Ct)=>Math.floor(At*i.scales[Ct])),[et,$]=e.calculateTextureWidthAndHeight(d,0),c=d.length,b=new Array(c),g=new Array(c),nt=`
      int output_pitches[${c}];
      int input_pitches[${c}];
      `;for(let At=c-1;At>=0;At--)b[At]=At===c-1?1:b[At+1]*d[At+1],g[At]=At===c-1?1:g[At+1]*o[0].dims[At+1],nt+=`
        output_pitches[${At}] = ${b[At]};
        input_pitches[${At}] = ${g[At]};
        `;let at=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${h}, ${a});
        float value = getColorAsFloat(${s.texture2D}(X, coords));
        return value;
      }
      `,Ot=i.mode==="nearest"?`
    ${at}
    float process(int indices[${c}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${et}, ${$});

      ${nt}

      int d, m;
      for (int dim = 0; dim < ${c}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:c===4?`
    ${at}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${et}, ${$});

      ${nt}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${o[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${at}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${et}, ${$});

      ${nt}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${o[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...Tc,output:{dims:d,type:o[0].type,textureType:0},shaderSource:Ot,variables:[{name:"scales",type:"int",arrayLength:i.scales.length,data:i.scales.map(At=>Math.ceil(At))}]}},Ai=(e,o)=>{if(!e||o.opset<9&&e.length!==1||o.opset>=9&&o.opset<11&&e.length!==2||o.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(o.scales.length>0&&e[0].dims.length!==o.scales.length)throw new Error("Invalid input shape.");if(e[0].type==="string")throw new Error("Invalid input tensor types.")},Rn=(e,o,i)=>{if(i){for(let s of e)if(s<=0)throw new Error("Scale value should be greater than 0.")}else for(let s of e)if(s<1)throw new Error("Scale value should be greater than or equal to 1.");if((o==="linear"||o==="cubic")&&e.length!==2&&(e.length!==4||e[0]!==1||e[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${i?"Resize":"Upsample"} opeartor.`)}}),Ei,Di,Ic,_c,Vb,zb,Wb,Hb,Oc=O(()=>{st(),j(),ue(),We(),Pi(),Ei={name:"Resize",inputNames:["A"],inputTypes:[2]},Di=(e,o,i)=>(Ai(o,i),[e.run({...Ei,cacheHint:i.cacheKey,get:()=>Vb(e,o,i)},o)]),Ic=e=>Gr(e,10),_c=e=>Gr(e,11),Vb=(e,o,i)=>{let s=G(e.session.backend.glContext.version),[h,a]=zb(o,i);if(h.every(xt=>xt===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return{...Ei,output:{dims:a,type:o[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${s.texture2D}(X, TexCoords);
                    ${s.output} = v;
                }`};let d=a.length;if(d<2)throw new Error(`output dimension should be at least 2, but got ${d}`);let et=a[d-2],$=a[d-1],c=o[0].dims;if(d!==c.length)throw new Error(`output dimension should match input ${c.length}, but got ${d}`);let b=c[d-2],g=c[d-1],nt=h[d-2],at=h[d-1],Ot="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":Ot=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":Ot=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":Ot=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${$}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${et}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${$}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${et}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":Ot=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${$}.0 - 1.0, ${et}.0 - 1.0, ${$}.0 - 1.0,
                            ${et}.0 - 1.0);
                        vec4 original = vec4(${g}.0 - 1.0, ${b}.0 - 1.0, ${g}.0 - 1.0,
                            ${b}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}let At=kt(d),Ct=le(),St=`
            const vec2 inputWH = vec2(${b}.0, ${g}.0);
            const vec4 scaleWHWH = vec4(float(${nt}), float(${at}), float(${nt}), float(${at}));
            ${Ct}
            ${Ot}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${At} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${et-1};
                bool hasNextCol = rc.z < ${$-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s.output} = vec4(newValue);
            }
        `;return{...Ei,output:{dims:a,type:o[0].type,textureType:2},hasMain:!0,shaderSource:St}},zb=(e,o)=>{let i=e[0].dims,s=o.scales,h;if(s.length===0){let d=e[o.scalesInputIdx];if(d&&d.size!==0){if(e[o.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");s=Wb(d,o.mode,o.isResize)}else{let et=e[o.sizesInputIdx];if(!et||et.size===0)throw new Error("Either scales or sizes MUST be provided as input.");h=Array.from(et.integerData),s=Hb(h,i,o.mode,o.isResize)}}else if(e[o.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let a=h||i.map((d,et)=>Math.floor(d*s[et]));return[s,a]},Wb=(e,o,i)=>{let s=Array.from(e.floatData);return Rn(s,o,i),s},Hb=(e,o,i,s)=>{let h=o.length,a=new Array(h);for(let d=0,et=h;d<et;d++)if(o[d]===0){if(e[d]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");a[d]=1}else a[d]=e[d]/o[d];return Rn(a,i,s),a}}),Sc,qb,Ac=O(()=>{ze(),Sc=(e,o)=>(qb(o),[new bt([o[0].dims.length],"int32",void 0,void 0,new Int32Array(o[0].dims))]),qb=e=>{if(!e||e.length!==1)throw new Error("Shape requires 1 input.")}}),Li,Pc,Ec,Dc,jb,Lc,Xb,Kb,$c=O(()=>{vt(),Rr(),Y(),j(),Li={name:"Slice",inputNames:["A"],inputTypes:[0]},Pc=(e,o,i)=>(jb(o),[e.run({...Li,cacheHint:i.cacheKey,get:()=>Dc(e,o[0],i)},o)]),Ec=e=>{let o=e.attributes.getInts("starts"),i=e.attributes.getInts("ends"),s=e.attributes.getInts("axes",[]);return W({starts:o,ends:i,axes:s})},Dc=(e,o,i)=>{let s=i.axes.length===0?o.dims.slice(0).map((b,g)=>g):i.axes,h=B.normalizeAxes(s,o.dims.length),a=i.starts.map((b,g)=>b>o.dims[h[g]]-1?o.dims[h[g]]:B.normalizeAxis(b,o.dims[h[g]])),d=i.ends.map((b,g)=>b>o.dims[h[g]]-1?o.dims[h[g]]:B.normalizeAxis(b,o.dims[h[g]])),et=o.dims.slice(),$=[];for(let b=0;b<h.length;b++)et[h[b]]=d[b]-a[b],a[b]>0&&$.push(`outputIdx[${h[b]}] += ${a[b]};`);let c=`
      float process(int outputIdx[${et.length}]) {
        ${$.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Li,output:{dims:et,type:o.type,textureType:0},shaderSource:c}},jb=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(Ae.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},Lc=(e,o)=>{Kb(o);let i=Xb(e,o);return[e.run({...Li,cacheHint:i.cacheKey,get:()=>Dc(e,o[0],i)},[o[0]])]},Xb=(e,o)=>{if(!e.session.isInitializer(o[1].dataId)||!e.session.isInitializer(o[2].dataId)||o.length>=4&&!e.session.isInitializer(o[3].dataId)||o.length>=5&&!e.session.isInitializer(o[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(o.length>=5&&o[4].integerData.some(d=>d!==1))throw new Error("currently non-1 steps is not supported for Slice");let i=Array.from(o[1].integerData),s=Array.from(o[2].integerData),h=o.length>=4?Array.from(o[3].integerData):[],a=`${h};${i};${s}`;return{starts:i,ends:s,axes:h,cacheKey:a}},Kb=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}}),kc,Bc,Fc,Cc,Nc,Rc,Gc,Mc,Jb,Yb,Zb,Uc,Vc=O(()=>{vt(),Y(),st(),j(),Fn(),kc={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Bc={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Fc={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Cc=(e,o,i)=>{Uc(o);let s=o[0].dims.slice(),h=B.normalizeAxis(i.axis,s.length),a=B.sizeToDimension(s,h),d=B.sizeFromDimension(s,h);return Mc(e,o,i,a,d)},Nc=e=>W({axis:e.attributes.getInt("axis",1)}),Rc=e=>W({axis:e.attributes.getInt("axis",-1)}),Gc=(e,o,i)=>{Uc(o);let s=o[0].dims.slice(),h=B.normalizeAxis(i.axis,s.length),a=s.length,d=h!==a-1,et=[],$=[],c=[],b;d&&($=Array.from({length:a}).map((Ot,At)=>At),$[h]=a-1,$[a-1]=h,$.map(Ot=>et.push(s[Ot])),b=W({perm:$}),c=qe(e,o,b));let g=d?B.sizeToDimension(et,a-1):B.sizeToDimension(s,a-1),nt=d?B.sizeFromDimension(et,a-1):B.sizeFromDimension(s,a-1),at=Mc(e,d?c:o,i,g,nt);return d?qe(e,at,b):at},Mc=(e,o,i,s,h)=>{let a=Jb(e,o[0],s,h,[s]),d=e.run({...kc,cacheHint:i.cacheKey,get:()=>a},o),et=Yb(e,o[0],s,h,a.output.dims,[s]),$=e.run({...Bc,cacheHint:i.cacheKey,get:()=>et},[o[0],d]),c=Zb(e,o[0],s,h,a.output.dims,et.output.dims);return[e.run({...Fc,cacheHint:i.cacheKey,get:()=>c},[o[0],d,$])]},Jb=(e,o,i,s,h)=>{let[a,d]=e.calculateTextureWidthAndHeight(o.dims,0),et=h.length;if(i<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(h.length!==1)throw new Error("Dimensionality of the output should be 1");if(h[0]!==i)throw new Error("Shape of the output should be equal to logical row count");let $=G(e.session.backend.glContext.version),c=`
      float process(int[${et}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float max = getColorAsFloat(${$.texture2D}(A, offsetToCoords(logical_row_start_offset, ${a},
        ${d} )));
        for(int i=1; i<${s}; ++i)
        {
          float current = getColorAsFloat(${$.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${a}, ${d})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...kc,output:{dims:h,type:o.type,textureType:0},shaderSource:c}},Yb=(e,o,i,s,h,a)=>{let[d,et]=e.calculateTextureWidthAndHeight(o.dims,0),$=a.length;if(i<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(a.length!==1)throw new Error("Dimensionality of the output should be 1");if(a[0]!==i)throw new Error("Shape of the output should be equal to logical row count");if(h.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(h[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let c=G(e.session.backend.glContext.version),b=`
      float process(int[${$}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${s}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${c.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${d}, ${et}))) - max);
        }

        return norm_factor;
      }`;return{...Bc,output:{dims:a,type:o.type,textureType:0},shaderSource:b}},Zb=(e,o,i,s,h,a)=>{let[d,et]=e.calculateTextureWidthAndHeight(o.dims,0),$=o.dims.length;if(i<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(h.length!==1||a.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(h[0]!==i||a[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let c=`
      float process(int[${$}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${d}, ${et});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${s};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Fc,output:{dims:o.dims,type:o.type,textureType:0},shaderSource:c}},Uc=e=>{if(!e||e.length!==1)throw new Error("Softmax requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type")}}),zc,Wc,Hc,Qb,tg,eg,qc=O(()=>{vt(),Y(),j(),zc={name:"Split",inputNames:["A"],inputTypes:[0]},Wc=(e,o,i)=>{eg(o);let s=B.normalizeAxis(i.axis,o[0].dims.length),h=Qb(e,o,s,i),a=[];for(let d=0;d<h;++d)a.push(e.run({...zc,cacheHint:`${i.cacheKey};${d}`,get:()=>tg(e,o[0],i,s,d)},o));return a},Hc=e=>{let o=e.attributes.getInt("axis",0),i=e.attributes.getInts("split",[]),s=e.outputs.length;return W({axis:o,split:i,numOutputs:s})},Qb=(e,o,i,s)=>{let[,h]=$r.splitShape(o[0].dims,i,s.split,s.numOutputs);return h.length},tg=(e,o,i,s,h)=>{let[a,d]=$r.splitShape(o.dims,s,i.split,i.numOutputs),et=d[h],$=a[h],c=`
      float process(int indices[${$.length}]) {
        indices[${s}] += ${et};
        return _A(indices);
      }
    `;return{...zc,cacheHint:`${i.cacheKey}:${h}`,output:{dims:$,type:o.type,textureType:0},shaderSource:c}},eg=e=>{if(!e||e.length!==1)throw new Error("Split requires one input.");if(e[0].type!=="int8"&&e[0].type!=="uint8"&&e[0].type!=="int16"&&e[0].type!=="uint16"&&e[0].type!=="int32"&&e[0].type!=="uint32"&&e[0].type!=="float32"&&e[0].type!=="float64"&&e[0].type!=="bool")throw new Error("Invalid input type.")}}),$i,jc,Xc,rg,ng,Kc=O(()=>{Y(),$i=(e,o,i)=>{rg(o);let s=B.squeezeShape(o[0].dims,i);return[e.reshapeUnpacked(o[0],s)]},jc=(e,o)=>(ng(o),$i(e,[o[0]],Array.from(o[1].integerData))),Xc=e=>e.attributes.getInts("axes"),rg=e=>{if(!e||e.length!==1)throw new Error("Squeeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},ng=e=>{if(!e||e.length!==2)throw new Error("Squeeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),Jc,og,ig,Yc=O(()=>{st(),j(),Jc=(e,o)=>{ig(o);let i={name:"Sum",inputNames:o.map((s,h)=>`X${h}`),inputTypes:new Array(o.length).fill(0)};return[e.run({...i,get:()=>og(e,o,i)},o)]},og=(e,o,i)=>{let s=G(e.session.backend.glContext.version),h=o[0].dims.slice(),a=`
      void main() {
        vec4 result = ${o.map((d,et)=>`${s.texture2D}(X${et},TexCoords)`).join(" + ")};
        ${s.output} = result;
      }
    `;return{...i,output:{dims:h,type:o[0].type,textureType:0},hasMain:!0,shaderSource:a}},ig=e=>{if(!e||e.length===0)throw new Error("Sum requires inputs.");let o=e[0].dims.length;for(let i=1;i<e.length;i++){if(o!==e[i].dims.length)throw new Error("Input shapes are mismatched.");for(let s=0;s<o;s++)if(e[0].dims[s]!==e[i].dims[s])throw new Error("Input shapes are not matched.")}if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.");for(let i=1;i<e.length;i++)if(e[0].type!==e[i].type)throw new Error("Input types are not matched.")}}),Zc,ag,sg,Qc=O(()=>{Rr(),j(),Zc=(e,o)=>{sg(o);let i={name:"Tile",inputNames:["A"],inputTypes:[0]};return[e.run({...i,get:()=>ag(e,o,i)},o)]},ag=(e,o,i)=>{let s=o[0].dims.slice(),h=new Array(s.length),a=[];for(let $=0;$<s.length;$++)h[$]=s[$]*o[1].numberData[$],a.push(`inputIdx[${$}] = int(mod(float(outputIdx[${$}]), ${s[$]}.));`);let d=h.length,et=`
      float process(int outputIdx[${d}]) {
        int inputIdx[${d}];
        ${a.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...i,output:{dims:h,type:o[0].type,textureType:0},shaderSource:et}},sg=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 input.");if(e[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(Ae.indexOf(e[0].type)===-1)throw new Error("Invalid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invalid repeat type.")}}),ki,tp,ep,ug,lg,rp=O(()=>{Y(),ki=(e,o,i)=>{ug(o);let s=B.unsqueezeShape(o[0].dims,i);return[e.reshapeUnpacked(o[0],s)]},tp=(e,o)=>(lg(o),ki(e,[o[0]],Array.from(o[1].integerData))),ep=e=>e.attributes.getInts("axes"),ug=e=>{if(!e||e.length!==1)throw new Error("Unsqueeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},lg=e=>{if(!e||e.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),np,op=O(()=>{dl(),Sl(),El(),Fl(),$n(),xf(),Of(),Pf(),Lf(),Ff(),Rf(),Vf(),qf(),kn(),Jf(),lc(),gc(),xc(),Oc(),Ac(),$c(),Vc(),qc(),Kc(),Yc(),Qc(),Fn(),bi(),rp(),Pi(),np=[["Abs","","6+",Cl],["Acos","","7+",Nl],["Add","","7+",hl],["And","","7+",ml],["Asin","","7+",Rl],["Atan","","7+",Gl],["AveragePool","","7+",Zf,Qf],["BatchNormalization","","7+",cl,pl],["Cast","","6+",Al,Pl],["Ceil","","6+",Vl],["Clip","","6-10",hi,Ml],["Clip","","11+",Ul],["Concat","","4+",$l,Bl],["Conv","","1+",vi,Ii],["ConvTranspose","","1+",gf,yf],["Cos","","7+",zl],["Div","","7+",bl],["Dropout","","7+",mi],["DepthToSpace","","1+",If,_f],["Equal","","7+",gl],["Elu","","6+",Wl,Hl],["Exp","","6+",ql],["Flatten","","1+",Sf,Af],["Floor","","6+",jl],["FusedConv","com.microsoft","1+",vi,Ii],["Gather","","1+",Ef,Df],["Gemm","","7-10",_i,kf],["Gemm","","11+",_i,Bf],["GlobalAveragePool","","1+",ec,rc],["GlobalMaxPool","","1+",sc],["Greater","","7+",yl],["Identity","","1+",mi],["ImageScaler","","1+",Cf,Nf],["InstanceNormalization","","6+",Mf,Uf],["LeakyRelu","","6+",Xl,Kl],["Less","","7+",xl],["LRN","","1+",zf,Wf],["Log","","6+",Jl],["MatMul","","1+",ff,cf],["MaxPool","","1+",nc,oc],["Mul","","7+",Tl],["Neg","","6+",Yl],["Not","","1+",Zl],["Or","","7+",wl],["Pad","","2-10",Oi,jf],["Pad","","11+",Xf,Kf],["Pow","","7+",vl],["PRelu","","7+",Il],["ReduceLogSum","","1+",mc,Pe],["ReduceMax","","1+",pc,Pe],["ReduceMean","","1+",cc,Pe],["ReduceMin","","1+",dc,Pe],["ReduceProd","","1+",hc,Pe],["ReduceSum","","1-12",fc,Pe],["ReduceSumSquare","","1+",bc,Pe],["Relu","","6+",Ql],["Reshape","","5+",yc],["Resize","","10",Di,Ic],["Resize","","11+",Di,_c],["Shape","","1+",Sc],["Sigmoid","","6+",tf],["Sin","","7+",ef],["Slice","","10+",Lc],["Slice","","1-9",Pc,Ec],["Softmax","","1-12",Cc,Nc],["Softmax","","13+",Gc,Rc],["Split","","2-12",Wc,Hc],["Sqrt","","6+",rf],["Squeeze","","1-12",$i,Xc],["Squeeze","","13+",jc],["Sub","","7+",_l],["Sum","","6+",Jc],["Tan","","7+",nf],["Tanh","","6+",of],["Tile","","6+",Zc],["Transpose","","1+",qe,wf],["Upsample","","7-8",Si,wc],["Upsample","","9",Si,vc],["Unsqueeze","","1-12",ki,ep],["Unsqueeze","","13+",tp],["Xor","","7+",Ol]]});function ap(e){let o={},i;for(;(i=ip.exec(e))!==null;){let s=i[3].split(",").map(h=>{let a=h.trim().split(" ");return a&&a.length===2?{type:a[0],name:a[1]}:null}).filter(h=>h!==null);o[i[2]]={params:s,body:i[4]}}for(let s in o){let h=fg.replace("__FUNC__",s),a=new RegExp(h,"gm");for(;(i=a.exec(e))!==null;){let d=i[1],et=i[2],$=i[3].split(","),c=d?`${d} ${et};`:"",b=o[s].body,g="";o[s].params.forEach((at,Ot)=>{at&&(g+=`${at.type} ${at.name} = ${$[Ot]};
`)}),b=`${g}
 ${b}`,b=b.replace("return",`${et} = `);let nt=`
      ${c}
      {
        ${b}
      }
      `;e=e.replace(i[0],nt)}}return e=e.replace(ip,""),e}var ip,fg,sp=O(()=>{ip=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,fg="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function hr(e,o){let i=[],s=[];for(let h=0;h<e.length;++h)e[h]!==1&&(i.push(e[h]),s.push(h));return{newShape:i,keptDims:s}}function dg(e){if(e.length===0)return 1;let o=e[0];for(let i=1;i<e.length;i++)o*=e[i];return o}function up(e){let o=Math.ceil(Math.sqrt(e));return[o,Math.ceil(e/o)]}var Gn,Bi=O(()=>{Mt(),Y(),Gn=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,o){let i=this.computeTexture(e,o);return o&&o.isPacked&&(i[0]/=2,i[1]/=2),o&&o.reverseWH?[i[1],i[0]]:i}computeTexture(e,o){let i=o&&o.isPacked;if(e.length===0)return i?[2,2]:[1,1];let s=this.maxTextureSize;if(o&&o.breakAxis!==void 0){let d=o.breakAxis>=e.length?1:e.slice(o.breakAxis).reduce(($,c)=>$*c),et=o.breakAxis<=0?1:e.slice(0,o.breakAxis).reduce(($,c)=>$*c);if(d>s||et>s)tt.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${o.breakAxis}`);else return[d,et]}let h=e.slice(0);i&&(s=s*2,h=h.map((d,et)=>et>=h.length-2?h[et]%2===0?h[et]:h[et]+1:h[et]),h.length===1&&(h=[2,h[0]])),h.length!==2&&(h=hr(h).newShape);let a=dg(h);return h.length<=1&&a<=s?[1,a]:h.length===2&&h[0]<=s&&h[1]<=s?h:h.length===3&&h[0]*h[1]<=s&&h[2]<=s?[h[0]*h[1],h[2]]:h.length===3&&h[0]<=s&&h[1]*h[2]<=s?[h[0],h[1]*h[2]]:h.length===4&&h[0]*h[1]*h[2]<=s&&h[3]<=s?[h[0]*h[1]*h[2],h[3]]:h.length===4&&h[0]<=s&&h[1]*h[2]*h[3]<=s?[h[0],h[1]*h[2]*h[3]]:i?up(a/4).map(d=>d*2):up(a)}}}),Mn,lp=O(()=>{Y(),be(),st(),Bi(),ue(),Mn=class extends Wt{constructor(e){super(e)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let e="offsetToCoords";return{offsetToCoords:new k(`
      vec2 ${e}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let e="coordsToOffset";return{coordsToOffset:new k(`
      int ${e}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){let o=e.unpackedShape,i=[e.width,e.height],s={},h="getOutputCoords";switch(o.length){case 0:s[h]=this.getOutputScalarCoords();break;case 1:s[h]=this.getOutputPacked1DCoords(o,i);break;case 2:s[h]=this.getOutputPacked2DCoords(o,i);break;case 3:s[h]=this.getOutputPacked3DCoords(o,i);break;default:s[h]=this.getOutputPackedNDCoords(o,i)}let a=`
      void setOutput(vec4 val) {
        ${G(this.context.glContext.version).output} = val;
      }
    `,d="floatTextureSetRGBA";return s[d]=new k(a),s}getUnpackedOutputSamplingSnippet(e){let o=e.unpackedShape,i=[e.width,e.height],s={},h="getOutputCoords";switch(o.length){case 0:s[h]=this.getOutputScalarCoords();break;case 1:s[h]=this.getOutputUnpacked1DCoords(o,i);break;case 2:s[h]=this.getOutputUnpacked2DCoords(o,i);break;case 3:s[h]=this.getOutputUnpacked3DCoords(o,i);break;case 4:s[h]=this.getOutputUnpacked4DCoords(o,i);break;case 5:s[h]=this.getOutputUnpacked5DCoords(o,i);break;case 6:s[h]=this.getOutputUnpacked6DCoords(o,i);break;default:throw new Error(`Unsupported output dimensionality: ${o.length}`)}let a=`
        void setOutput(float val) {
          ${G(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,d="floatTextureSetR";return s[d]=new k(a),s}getOutputScalarCoords(){return new k(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(e,o){let i=o,s="";return i[0]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${i[1]}.0);
          }
        `,new k(s)):i[1]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${i[0]}.0);
          }
        `,new k(s)):(s=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${i[0]}, ${i[1]}));
          return 2 * (resTexRC.y * ${i[0]} + resTexRC.x);
        }
      `,new k(s))}getOutputPacked2DCoords(e,o){let i="";if(Ge.arraysEqual(e,o))return i=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${o[0]}, ${o[1]}));
        }
      `,new k(i);let s=o,h=Math.ceil(e[1]/2);return i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));

          int index = resTexRC.y * ${s[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${h}) * 2;
          int c = 2 * (index / ${h});

          return ivec2(r, c);
        }
      `,new k(i)}getOutputPacked3DCoords(e,o){let i=[o[0],o[1]],s=Math.ceil(e[2]/2),h=s*Math.ceil(e[1]/2),a=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          int b = index / ${h};
          index -= b * ${h};

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec3(b, r, c);
        }
      `;return new k(a)}getOutputPackedNDCoords(e,o){let i=[o[0],o[1]],s=Math.ceil(e[e.length-1]/2),h=s*Math.ceil(e[e.length-2]/2),a=h,d="",et="b, r, c";for(let c=2;c<e.length-1;c++)a*=e[e.length-c-1],d=`
      int b${c} = index / ${a};
      index -= b${c} * ${a};
    `+d,et=`b${c}, `+et;let $=`
      ivec${e.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.y * ${i[0]} + resTexRC.x;

        ${d}

        int b = index / ${h};
        index -= b * ${h};

        // reverse r and c order for packed texture
        int r = imod(index, ${s}) * 2;
        int c = 2 * (index / ${s});

        return ivec${e.length}(${et});
      }
    `;return new k($)}getOutputUnpacked1DCoords(e,o){let i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          return resTexRC.y * ${o[0]} + resTexRC.x;
        }
      `;return new k(i)}getOutputUnpacked2DCoords(e,o){let i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;
          int r = index / ${e[1]};
          int c = index - r * ${e[1]};
          return ivec2(r, c);
        }
      `;return new k(i)}getOutputUnpacked3DCoords(e,o){let i="",s=e.length,h=null;s<2&&(h=[]),h=new Array(s-1),h[s-2]=e[s-1];for(let et=s-3;et>=0;--et)h[et]=h[et+1]*e[et+1];let a=["r","c","d"],d=h.map((et,$)=>{let c=`int ${a[$]} = index / ${et}`,b=$===h.length-1?`int ${a[$+1]} = index - ${a[$]} * ${et}`:`index -= ${a[$]} * ${et}`;return`${c}; ${b};`}).join("");return i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;
          ${d}
          return ivec3(r, c, d);
        }
      `,new k(i)}getOutputUnpacked4DCoords(e,o){let i="",s=e.length,h=null;s<2&&(h=[]),h=new Array(s-1),h[s-2]=e[s-1];for(let et=s-3;et>=0;--et)h[et]=h[et+1]*e[et+1];let a=["r","c","d","d2"],d=h.map((et,$)=>{let c=`int ${a[$]} = index / ${et}`,b=$===h.length-1?`int ${a[$+1]} = index - ${a[$]} * ${et}`:`index -= ${a[$]} * ${et}`;return`${c}; ${b};`}).join("");return i=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;
          ${d}
          return ivec4(r, c, d, d2);
        }
      `,new k(i)}getOutputUnpacked5DCoords(e,o){let i="",s=e.length,h=null;s<2&&(h=[]),h=new Array(s-1),h[s-2]=e[s-1];for(let et=s-3;et>=0;--et)h[et]=h[et+1]*e[et+1];let a=["r","c","d","d2","d3"],d=h.map((et,$)=>{let c=`int ${a[$]} = index / ${et}`,b=$===h.length-1?`int ${a[$+1]} = index - ${a[$]} * ${et}`:`index -= ${a[$]} * ${et}`;return`${c}; ${b};`}).join("");return i=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;
          ${d}
          return ivec5(r, c, d, d2, d3);
        }
      `,new k(i)}getOutputUnpacked6DCoords(e,o){let i="",s=e.length,h=null;s<2&&(h=[]),h=new Array(s-1),h[s-2]=e[s-1];for(let et=s-3;et>=0;--et)h[et]=h[et+1]*e[et+1];let a=["r","c","d","d2","d3","d4"],d=h.map((et,$)=>{let c=`int ${a[$]} = index / ${et}`,b=$===h.length-1?`int ${a[$+1]} = index - ${a[$]} * ${et}`:`index -= ${a[$]} * ${et}`;return`${c}; ${b};`}).join("");return i=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${o[0]}, ${o[1]}));
         int index = resTexRC.y * ${o[0]} + resTexRC.x;
         ${d}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new k(i)}getCommonUtilFuncs(){let e={},o="uvFromFlat";e[o]=new k(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),o="packedUVfrom1D",e[o]=new k(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),o="packedUVfrom2D",e[o]=new k(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),o="packedUVfrom3D",e[o]=new k(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),o="sampleTexture";let i=G(this.context.glContext.version);return e[o]=new k(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${i.texture2D}(textureSampler, uv).r;
        }`),e}getInputsSamplingSnippets(){let e={},o=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((i,s)=>{let h=this.context.inputTextureLayouts[s],a=On(i);h.isPacked?e[a]=this.getPackedSamplerFromInput(a,i,h):e[a]=this.getUnpackedSamplerFromInput(a,i,h);let d=Ku(i);h.unpackedShape.length<=o.unpackedShape.length&&(h.isPacked?e[d]=this.getPackedSamplerAtOutputCoords(d,h,o,i):e[d]=this.getUnpackedSamplerAtOutputCoords(d,h,o,i))}),e}getPackedSamplerAtOutputCoords(e,o,i,s){let h=o.unpackedShape,a=i.unpackedShape,d=On(s),et=h.length,$=a.length,c=$t.getBroadcastDims(h,a),b=kt($),g=$-et,nt,at=ee();et===0?nt="":$<2&&c.length>=1?nt="coords = 0;":nt=c.map(Qt=>`coords.${at[Qt+g]} = 0;`).join(`
`);let Ot="";$<2&&et>0?Ot="coords":Ot=h.map((Qt,Zt)=>`coords.${at[Zt+g]}`).join(", ");let At="return outputValue;",Ct=B.size(h)===1,St=B.size(a)===1;if(et===1&&!Ct&&!St)At=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(Ct&&!St)$===1?At=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:At=`
          return vec4(outputValue.x);
        `;else if(c.length){let Qt=et-2,Zt=et-1;c.indexOf(Qt)>-1&&c.indexOf(Zt)>-1?At="return vec4(outputValue.x);":c.indexOf(Qt)>-1?At="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":c.indexOf(Zt)>-1&&(At="return vec4(outputValue.xx, outputValue.zz);")}let xt=`
        int lastDim = coords.${at[$-1]};
        coords.${at[$-1]} = coords.${at[$-2]};
        coords.${at[$-2]} = lastDim;
      `,Dt=`
      vec4 ${e}() {
        ${b} coords = getOutputCoords();
        ${xt}
        ${nt}
        vec4 outputValue = ${d}(${Ot});
        ${At}
      }
    `;return new k(Dt,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,o,i,s){let h=[i.width,i.height],a=[o.width,o.height],d=o.unpackedShape.length,et=i.unpackedShape.length,$=o.unpackedShape,c=i.unpackedShape,b=On(s);if(d===et&&Ge.arraysEqual(a,h)){let xt=`
          float ${e}() {
            return sampleTexture(${s}, TexCoords);
          }
        `;return new k(xt,["coordinates.sampleTexture"])}let g=kt(et),nt=$t.getBroadcastDims($,c),at=et-d,Ot,At=ee();d===0?Ot="":et<2&&nt.length>=1?Ot="coords = 0;":Ot=nt.map(xt=>`coords.${At[xt+at]} = 0;`).join(`
`);let Ct="";et<2&&d>0?Ct="coords":Ct=o.unpackedShape.map((xt,Dt)=>`coords.${At[Dt+at]}`).join(", ");let St=`
        float ${e}() {
          ${g} coords = getOutputCoords();
          ${Ot}
          return ${b}(${Ct});
        }
      `;return new k(St,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,o,i){switch(i.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,o);case 1:return this.getPackedSampler1D(e,o,i);case 2:return this.getPackedSampler2D(e,o,i);case 3:return this.getPackedSampler3D(e,o,i);default:return this.getPackedSamplerND(e,o,i)}}getUnpackedSamplerFromInput(e,o,i){let s=i.unpackedShape;switch(s.length){case 0:return this.getUnpackedSamplerScalar(e,o,i);case 1:return this.getUnpackedSampler1D(e,o,i);case 2:return this.getUnpackedSampler2D(e,o,i);case 3:return this.getUnpackedSampler3D(e,o,i);case 4:return this.getUnpackedSampler4D(e,o,i);case 5:return this.getUnpackedSampler5D(e,o,i);case 6:return this.getUnpackedSampler6D(e,o,i);default:throw new Error(`Unsupported dimension ${s.length}-D`)}}getPackedSamplerScalar(e,o){let i=G(this.context.glContext.version),s=`
          vec4 ${e}() {
            return ${i.texture2D}(${o}, halfCR);
          }
        `;return new k(s)}getPackedSampler1D(e,o,i){let s=[i.width,i.height],h=[s[1],s[0]],a=G(this.context.glContext.version),d=`vec4 ${e}(int index) {
      vec2 uv = packedUVfrom1D(
      ${h[0]}, ${h[1]}, index);
      return ${a.texture2D}(${o}, uv);
    }`;return new k(d,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,o,i){let s=i.unpackedShape,h=[i.width,i.height],a=G(this.context.glContext.version),d=h[0],et=h[1];if(h!=null&&Ge.arraysEqual(s,h)){let g=`vec4 ${e}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${et}.0, ${d}.0);
        return ${a.texture2D}(${o}, uv);
      }`;return new k(g)}let $=h,c=Math.ceil(s[1]/2),b=`vec4 ${e}(int row, int col) {
      vec2 uv = packedUVfrom2D(${$[1]}, ${$[0]}, ${c}, row, col);
      return ${a.texture2D}(${o}, uv);
    }`;return new k(b,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,o,i){let s=i.unpackedShape,h=[i.width,i.height],a=[h[0],h[1]],d=G(this.context.glContext.version);if(s[0]===1){let nt=s.slice(1),at=[1,2],Ot=lr(s,nt),At=["b","row","col"],Ct=JSON.parse(JSON.stringify(i));Ct.unpackedShape=Ot;let St=this.getPackedSamplerFromInput(e,o,Ct),xt=`${St.routineBody}
      vec4 ${e}(int b, int row, int col) {
        return ${e}(${fr(At,at)});
      } `;return new k(xt,St.dependencies)}let et=a[0],$=a[1],c=Math.ceil(s[2]/2),b=c*Math.ceil(s[1]/2),g=`vec4 ${e}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${$}, ${et}, ${b}, ${c}, b, row, col);
      return ${d.texture2D}(${o}, uv);}`;return new k(g,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,o,i){let s=i.unpackedShape,h=s.length,a=[i.width,i.height],d=G(this.context.glContext.version),et=[a[0],a[1]],$=et[1],c=et[0],b=Math.ceil(s[h-1]/2),g=b*Math.ceil(s[h-2]/2),nt="int b, int row, int col",at=`b * ${g} + (row / 2) * ${b} + (col / 2)`;for(let At=2;At<h-1;At++)nt=`int b${At}, `+nt,g*=s[h-At-1],at=`b${At} * ${g} + `+at;let Ot=`vec4 ${e}(${nt}) {
      int index = ${at};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${$});
      return ${d.texture2D}(${o}, uv);
    }`;return new k(Ot)}getUnpackedSamplerScalar(e,o,i){let[s,h]=[i.width,i.height];if(s===1&&h===1){let d=`
          float ${e}() {
            return sampleTexture(${o}, halfCR);
          }
        `;return new k(d,["coordinates.sampleTexture"])}let a=`
        float ${e}() {
          int offset_${o} = coordsToOffset(TexCoords, ${s}, ${h});
          vec2 uv = uvFromFlat(${s}, ${h}, offset_${o});
          return sampleTexture(${o}, uv);
        }
      `;return new k(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,o,i){let s=i.width,h=i.height;if(h===1&&s===1){let d=`
        float ${e}(int index) {
          return sampleTexture(${o}, halfCR);
        }
      `;return new k(d,["coordinates.sampleTexture"])}if(h===1){let d=`
          float ${e}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${s}.0, 0.5);
            return sampleTexture(${o}, uv);
          }
        `;return new k(d,["coordinates.sampleTexture"])}if(s===1){let d=`
          float ${e}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${h}.0);
            return sampleTexture(${o}, uv);
          }
        `;return new k(d,["coordinates.sampleTexture"])}let a=`
        float ${e}(int index) {
          vec2 uv = uvFromFlat(${s}, ${h}, index);
          return sampleTexture(${o}, uv);
        }
      `;return new k(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,o,i){let s=i.unpackedShape,h=[i.height,i.width];if(h!=null&&Ge.arraysEqual(s,h)){let g=h[1],nt=h[0],at=`
          float ${e}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${g}.0, ${nt}.0);
            return sampleTexture(${o}, uv);
          }
        `;return new k(at,["coordinates.sampleTexture"])}let{newShape:a,keptDims:d}=hr(s),et=a;if(et.length<s.length){let g=lr(s,et),nt=JSON.parse(JSON.stringify(i));nt.unpackedShape=g;let at=["col","row"],Ot=`
          ${this.getUnpackedSamplerFromInput(e,o,nt).routineBody}
          float ${e}(int row, int col) {
            return ${e}(${fr(at,d)});
          }
        `;return new k(Ot,["coordinates.sampleTexture"])}let $=h[1],c=h[0];if(c===1){let g=`
          float ${e}(int row, int col) {
            int offset_${o} = coordsToOffset(TexCoords, ${$}, ${c});
            float index = dot(vec3(row, col, offset_${o}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${$}.0);
            return sampleTexture(${o}, uv);
          }
        `;return new k(g,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if($===1){let g=`
          float ${e}(int row, int col) {
            int offset_${o} = coordsToOffset(TexCoords, ${$}, ${c});
            float index = dot(vec3(row, col, offset_${o}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
            return sampleTexture(${o}, uv);
          }
        `;return new k(g,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let b=`
        float ${e}(int row, int col) {
          int index = col * ${s[1]} + row;
          vec2 uv = uvFromFlat(${$}, ${c}, index);
          return sampleTexture(${o}, uv);
        }
      `;return new k(b,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,o,i){let s=i.unpackedShape,h=s[1]*s[2],a=s[2],{newShape:d,keptDims:et}=hr(s),$=d;if($.length<s.length){let nt=lr(s,$),at=["batch","col","row"],Ot=JSON.parse(JSON.stringify(i));Ot.unpackedShape=nt;let At=this.getUnpackedSamplerFromInput(e,o,Ot),Ct=et.reverse(),St=`
          ${At.routineBody}
          float ${e}(int batch, int row, int col) {
            return ${e}(${fr(at,Ct)});
          }
        `;return new k(St,At.dependencies)}let c=i.width,b=i.height,g=`
          float ${e}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${h} + col * ${a} + row;
            vec2 uv = uvFromFlat(${c}, ${b}, index);
            return sampleTexture(${o}, uv);
          }
      `;return new k(g,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,o,i){let s=i.unpackedShape,h=s[3],a=s[2]*h,d=s[1]*a,et=i.width,$=i.height,c=`
        float ${e}(int row, int col, int depth, int depth2) {
          int index = row * ${d} + col * ${a} +
              depth2 * ${h} + depth;
          vec2 uv = uvFromFlat(${et}, ${$}, index);
          return sampleTexture(${o}, uv);
        }
      `;return new k(c,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,o,i){let s=i.unpackedShape,h=s[4],a=s[3]*h,d=s[2]*a,et=s[1]*d,{newShape:$,keptDims:c}=hr(s);if($.length<s.length){let at=lr(s,$),Ot=["row","col","depth","depth2","depth3"],At=JSON.parse(JSON.stringify(i));At.unpackedShape=at;let Ct=`
          ${this.getUnpackedSamplerFromInput(e,o,At).routineBody}
          float ${e}(int row, int col, int depth, int depth2, int depth3) {
            return ${e}(${fr(Ot,c)});
          }
        `;return new k(Ct,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let b=i.width,g=i.height,nt=`
        float ${e}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${et} + col * ${d} + depth * ${a} +
          depth3 * ${h} + depth2;
          vec2 uv = uvFromFlat(${b}, ${g}, index);
          return sampleTexture(${o}, uv);
        }
      `;return new k(nt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,o,i){let s=i.unpackedShape,h=s[5],a=s[4]*h,d=s[3]*a,et=s[2]*d,$=s[1]*et,{newShape:c,keptDims:b}=hr(s);if(c.length<s.length){let Ot=lr(s,c),At=["row","col","depth","depth2","depth3","depth4"],Ct=JSON.parse(JSON.stringify(i));Ct.unpackedShape=Ot;let St=`
            ${this.getUnpackedSamplerFromInput(e,o,Ct).routineBody}
            float ${e}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e}(${fr(At,b)});
            }
          `;return new k(St,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let g=i.width,nt=i.height,at=`
          float ${e}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${$} + col * ${et} + depth * ${d} +
            depth2 * ${a} + depth3 * ${h} + depth4;
            vec2 uv = uvFromFlat(${g}, ${nt}, index);
            return sampleTexture(${o}, uv);
          }
        `;return new k(at,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let e=this.context.outputTextureLayout,o=e.shape.length,i=e.strides,s=e.width,h=e.height,a=[];for(let et=0;et<o-1;++et)a.push(`
        c[${et}] = offset / ${i[et]};`),a.push(`
        offset -= c[${et}] * ${i[et]};`);a.push(`
        c[${o-1}] = offset;`);let d=`
      void toVec(vec2 texCoords, out int c[${o}]) {
        int offset = coordsToOffset(texCoords, ${s}, ${h});
        ${a.join("")}
      }
      void toVec(int offset, out int c[${o}]) {
        ${a.join("")}
      }
    `;return{toVec:new k(d,["coordinates.coordsToOffset"])}}valueFrom(){let e={};return this.context.programInfo.inputNames.forEach((o,i)=>{let s=this.context.inputTextureLayouts[i],h=(s.unpackedShape.length>0?s.unpackedShape:s.shape).length,a=`_${o}`;e[a]=new k(this.getValueFromSingle(o,h,s.width,s.height,!1),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),a=a+"_T",e[a]=new k(this.getValueFromSingle(o,h,s.width,s.height,!0),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),e}getValueFromSingle(e,o,i,s,h){let a=`_${e}`;h&&(a=a+"_T");let d=G(this.context.glContext.version);return`
        float ${a}(int m[${o}]) {
          int offset = indicesToOffset${a}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${s});
          float value = getColorAsFloat(${d.texture2D}(${e}, coords));
          return value;
        }
        `}getPackedValueFrom(e,o,i,s,h){let a=`_${e}_Pack`;h&&(a=a+"_T");let d=G(this.context.glContext.version);return`
        vec4 ${a}(int m[${o}]) {
          int offset = indicesToOffset_${e}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${s});
          return ${d.texture2D}(${e}, coords);
        }
        `}}}),Un,fp=O(()=>{be(),Un=class g$ extends Wt{constructor(o){super(o)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new k(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new k(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let o=g$.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new k(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${o}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let o=g$.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new k(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${o}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let o=new ArrayBuffer(4),i=new Uint32Array(o),s=new Uint8Array(o);if(i[0]=3735928559,s[0]===239)return!0;if(s[0]===222)return!1;throw new Error("unknown endianness")}}}),Vn,cp=O(()=>{be(),st(),Vn=class extends Wt{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=G(this.context.glContext.version);return{setFragColor:new k(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new k(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),zn,pp=O(()=>{be(),zn=class yE extends Wt{constructor(o){super(o)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let o=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((s,h)=>{let a=this.context.inputTextureLayouts[h].unpackedShape;if(a.length<=o){let d=a.length,et=o-d,$=`bcastIndices_${s}`,c="";for(let g=0;g<d;++g)c+=`
          realIndices[${g}] = int( mod(float(bcastedIndices[${et+g}]), ${a[g]}.0) );
          `;let b=`
        void ${$} (int bcastedIndices[${o}], out int realIndices[${d}]) {
          ${c}
        }
        `;i[$]=new k(b)}}),i}bcastMatmulIndex(){let o=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((s,h)=>{let a=this.context.inputTextureLayouts[h].shape;if(!(a.length<2||a.length>o)){let d=a.length,et=o-d,$=`bcastMatmulIndices_${s}`,c="";for(let g=0;g<d-2;++g)c+=`
          realIndices[${g}] = int( mod(float(bcastedIndices[${et+g}]), ${a[g]}.0) );
          `;let b=`
        void ${$}(int bcastedIndices[${o}], out int realIndices[${d}]) {
          ${c}
          realIndices[${d-1}] = bcastedIndices[${o-1}];
          realIndices[${d-2}] = bcastedIndices[${o-2}];
        }
        `;i[$]=new k(b)}}),i}indicesToOffset(){let o={};return this.context.programInfo.inputNames.forEach((i,s)=>{let h=this.context.inputTextureLayouts[s].shape,a=this.context.inputTextureLayouts[s].strides,d=h.length,et=`indicesToOffset_${i}`;o[et]=new k(yE.indexToOffsetSingle(et,d,a)),et=`indicesToOffset_${i}_T`,o[et]=new k(yE.indexToOffsetSingle(et,d,a.slice().reverse()))}),o}static indexToOffsetSingle(o,i,s){let h="";for(let a=i-1;a>=0;--a)h+=`
        offset += indices[${a}] * ${s[a]};
        `;return`
      int ${o}(int indices[${i}]) {
        int offset = 0;
        ${h}
        return offset;
      }
      `}offsetToIndices(){let o={};return this.context.programInfo.inputNames.forEach((i,s)=>{let h=this.context.inputTextureLayouts[s].shape,a=this.context.inputTextureLayouts[s].strides,d=h.length,et=`offsetToIndices_${i}`;o[et]=new k(yE.offsetToIndicesSingle(et,d,a)),et=`offsetToIndices_${i}_T`,o[et]=new k(yE.offsetToIndicesSingle(et,d,a.slice().reverse()))}),o}static offsetToIndicesSingle(o,i,s){let h=[];for(let a=0;a<i-1;++a)h.push(`
      indices[${a}] = offset / ${s[a]};`),h.push(`
        offset -= indices[${a}] * ${s[a]};`);return h.push(`
      indices[${i-1}] = offset;`),`
      void ${o}(int offset, out int indices[${i}]) {
        ${h.join("")}
      }
      `}incrementIndices(){let o={};return this.context.programInfo.inputNames.forEach((i,s)=>{let h=this.context.inputTextureLayouts[s].shape,a=h.length,d=`incrementIndices_${i}`,et="";for(let c=0;c<a;++c)et+=`
        shape[${c}] = ${h[c]};`;let $=`
        void ${d}(int axis, out int indices[${a}]) {
          int shape[${a}];
          ${et};
          for(int i = ${a} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;o[d]=new k($)}),o}}}),Wn,dp=O(()=>{be(),Wn=class extends Wt{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let e=this.context.outputTextureLayout.shape.length,o={add:"+=",sub:"-=",mul:"*=",div:"/="},i={};for(let s in o){let h=`${s}Vec`,a="";for(let et=0;et<e;++et)a+=`
          dest[${et}] ${o[s]} src[${et}];
          `;let d=`
        void ${h}(int src[${e}], out int dest[${e}]) {
          ${a}
        }
        `;i[h]=new k(d)}return i}copyVec(){let e=this.context.outputTextureLayout.shape.length,o="";for(let s=0;s<e;++s)o+=`
        dest[${s}] = src[${s}];
        `;let i=`
      void copyVec(int src[${e}], out int dest[${e}]) {
        ${o}
      }
      `;return{copyVec:new k(i)}}setVecItem(){let e=this.context.outputTextureLayout.shape.length,o=`
        if(index < 0)
            index =${e} + index;
        if (index == 0)
            m[0] = value;
        `;for(let s=1;s<e-1;++s)o+=`
        else if (index == ${s})
            m[${s}] = value;
            `;o+=`
        else
            m[${e-1}] = value;
        `;let i=`
      void setVecItem(out int m[${e}], int index, int value) {
        ${o}
      }
        `;return{setVecItem:new k(i)}}getVecItem(){let e=this.context.outputTextureLayout.shape.length,o=`
        if(index < 0)
            index = ${e} + index;
        if (index == 0)
            return m[0];
      `;for(let s=1;s<e-1;++s)o+=`
        else if (index == ${s})
            return m[${s}];
      `;o+=`
        else
            return m[${e-1}];
        `;let i=`
      int getVecItem(int m[${e}], int index) {
        ${o}
      }
    `;return{getVecItem:new k(i)}}}}),Fi,hp=O(()=>{lp(),fp(),cp(),pp(),dp(),Fi={encoding:Un,fragcolor:Vn,vec:Wn,shapeUtils:zn,coordinates:Mn}}),Hn,mp=O(()=>{be(),sp(),hp(),st(),Hn=class{constructor(e,o,i,s){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new En(e,o,i,s),Object.keys(Fi).forEach(a=>{let d=new Fi[a](this.context);this.libs[a]=d});let h=this.glslLibRoutineDependencyGraph;for(let a in this.libs){let d=this.libs[a].getFunctions();for(let et in d){let $=a+"."+et,c;h[$]?(c=h[$],c.routineBody=d[et].routineBody):(c=new Nr($,d[et].routineBody),h[$]=c);let b=d[et].dependencies;if(b)for(let g=0;g<b.length;++g)if(h[b[g]])c.addDependency(h[b[g]]);else{let nt=new Nr(b[g]);h[b[g]]=nt,c.addDependency(nt)}}}}preprocess(){let e=this.context.programInfo,o=e.shaderSource;return this.context.programInfo.hasMain||(o=`${o}
      ${Xu(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),o=ap(o),`${ju(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(o)}
    ${o}`}getImports(e){let o=this.selectGlslLibRoutinesToBeIncluded(e);if(o.length===0)return"";let i="";for(let s=0;s<o.length;++s)if(o[s].routineBody)i+=o[s].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${o[s].name}`);return i}selectGlslLibRoutinesToBeIncluded(e){let o=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(i=>{let s=i.split(".")[1];e.indexOf(s)!==-1&&o.push(this.glslLibRoutineDependencyGraph[i])}),Dn.returnOrderedNodes(o)}getUniforms(e,o){let i=[];if(e)for(let s of e)i.push(`uniform sampler2D ${s};`);if(o)for(let s of o)i.push(`uniform ${s.type} ${s.name}${s.arrayLength?`[${s.arrayLength}]`:""};`);return i.join(`
`)}}}),qn,bp=O(()=>{Kt(),Mt(),mp(),st(),qn=class{constructor(e,o,i){this.profiler=e,this.glContext=o,this.textureLayoutStrategy=i,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,o){this.repo.set(e,o)}run(e,o,i){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let s=this.glContext.gl,h=e.program;s.useProgram(h);try{this.bindOutput(i),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],o)}catch(a){throw tt.error("ProgramManager",e.programInfo.shaderSource),a}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,o,i){return this.profiler.event("backend","ProgramManager.build",()=>{let s=new Hn(this.glContext,e,o,i),h=s.preprocess(),a=this.compile(h);return{programInfo:e,program:a,uniformLocations:this.getUniformLocations(a,s.context.programInfo.inputNames,s.context.programInfo.variables),attribLocations:this.getAttribLocations(a)}})}compile(e){if(!this.vertexShader){tt.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let s=qu(this.glContext.version);this.vertexShader=this.glContext.compileShader(s,this.glContext.gl.VERTEX_SHADER)}z.debug&&tt.verbose("ProrgramManager",`FragShader:
${e}
`);let o=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),i=this.glContext.createProgram(this.vertexShader,o);return this.glContext.deleteShader(o),i}bindOutput(e){let o=e.width,i=e.height;tt.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${o}/${i}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,o,i)}bindAttributes(e){let o=e.position,i=e.textureCoord;this.glContext.setVertexAttributes(o,i),this.attributesBound=!0}bindUniforms(e,o,i){let s=this.glContext.gl,h=0;for(let{name:a,type:d,location:et,arrayLength:$}of e){let c=o.find(b=>b.name===a)?.data;if(d!=="sampler2D"&&!c)throw new Error(`variable '${a}' does not have data defined in program info`);switch(d){case"sampler2D":this.bindTexture(i[h],et,h),h++;break;case"float":$?s.uniform1fv(et,c):s.uniform1f(et,c);break;case"int":$?s.uniform1iv(et,c):s.uniform1i(et,c);break;default:throw new Error(`Uniform not implemented: ${d}`)}}}bindTexture(e,o,i){this.glContext.bindTextureToUniform(e.texture,i,o)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,o,i){let s=[];if(o)for(let h of o)s.push({name:h,type:"sampler2D",location:this.getUniformLocation(e,h)});if(i)for(let h of i)s.push({...h,location:this.getUniformLocation(e,h.name)});return s}getUniformLocation(e,o){let i=this.glContext.gl.getUniformLocation(e,o);if(i===null)throw new Error(`Uniform ${o} not found.`);return i}getAttribLocation(e,o){return this.glContext.gl.getAttribLocation(e,o)}}}),jn,gp=O(()=>{Mt(),Fr(),jn=class{constructor(e,o,i,s){this.glContext=e,this.layoutStrategy=o,this.profiler=i,this.config=s,this.pendingRead=new Map,s.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,o,i,s){let h=this.toEncoderType(e),a=this.glContext.getEncoder(h,o.channels||1,s);if(o.isPacked&&s===1)throw new Error("not implemented");let d=o.width,et=o.height,$,c;if(this.config.reuseTextures){$=`${d}x${et}_${a.format}_${a.internalFormat}_${a.textureType}`,c=this.inUseTextures.get($),c||(c=[],this.inUseTextures.set($,c));let g=this.idleTextures.get($);if(g&&g.length>0){let nt=g.pop();return c.push(nt),s===1&&this.glContext.updateTexture(nt,d,et,a,this.toTextureData(e,i)),nt}}tt.verbose("TextureManager",`Creating new texture of size ${o.width}x${o.height}`);let b=this.glContext.allocateTexture(d,et,a,this.toTextureData(e,i));return this.config.reuseTextures&&(c.push(b),this.textureLookup.set(b,$)),b}readTexture(e,o,i){return i||(i=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let s=e.shape.reduce((a,d)=>a*d)*i,h=this.glContext.readTexture(e.texture,e.width,e.height,s,this.toEncoderType(o),i);return this.toTensorData(o,h)})}async readTextureAsync(e,o,i){let s=e.tensor.dataId;if(i||(i=1),this.pendingRead.has(s)){let h=this.pendingRead.get(s);return new Promise(a=>h?.push(a))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(s,[]);let h=e.shape.reduce(($,c)=>$*c)*i;await this.glContext.createAndWaitForFence();let a=this.glContext.readTexture(e.texture,e.width,e.height,h,this.toEncoderType(o),i),d=this.toTensorData(o,a),et=this.pendingRead.get(s);return this.pendingRead.delete(s),et?.forEach($=>$(d)),d})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let o=e.shape.reduce((s,h)=>s*h),i=this.glContext.readTexture(e.texture,e.width,e.height,o*4,"byte",4);return new Float32Array(i.buffer,i.byteOffset,o)})}releaseTexture(e,o){let i;if(this.config.reuseTextures&&(i=this.textureLookup.get(e.texture),i)){o&&this.textureLookup.delete(i);let s=this.inUseTextures.get(i);if(s){let h=s.indexOf(e.texture);if(h!==-1){s.splice(h,1);let a=this.idleTextures.get(i);a||(a=[],this.idleTextures.set(i,a)),a.push(e.texture)}}}(!i||o)&&(tt.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,o){switch(e){case"int16":return o instanceof Int16Array?o:Int16Array.from(o);case"int32":return o instanceof Int32Array?o:Int32Array.from(o);case"int8":return o instanceof Int8Array?o:Int8Array.from(o);case"uint16":return o instanceof Uint16Array?o:Uint16Array.from(o);case"uint32":return o instanceof Uint32Array?o:Uint32Array.from(o);case"uint8":case"bool":return o instanceof Uint8Array?o:Uint8Array.from(o);case"float32":return o instanceof Float32Array?o:Float32Array.from(o);case"float64":return o instanceof Float64Array?o:Float64Array.from(o);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,o){if(o)return o instanceof Float32Array?o:new Float32Array(o)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),Xn,yp=O(()=>{Mt(),$s(),ll(),op(),bp(),Bi(),gp(),Xn=class{constructor(e,o){this.backend=e,this.context=o,this.layoutStrategy=new Gn(e.glContext.maxTextureSize),this.programManager=new qn(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new jn(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Pn(this)}onGraphInitialized(e){let o=e.getValues().filter(i=>i.from===-1&&i.tensor).map(i=>i.tensor.dataId);this.initializers=new Set(o)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,o){return o?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,o,i=!1){tt.verbose("WebGLSessionHandler","Storing Texture data in cache"),i?this.packedTextureDataCache.set(e,o):this.unpackedTextureDataCache.set(e,o)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,o,i){let s=Ls(e,o,np);return{impl:s.opImpl,context:s.opInit?s.opInit(e,i):e}}}});function hg(e){let o=0;for(;o<e.length&&e[o]();++o);return o-1}var Mr,xp=O(()=>{Kt(),Fr(),Fr(),ue(),Mr=class{constructor(e,o){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=o,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,o,i,s){let h=this.gl,a=h.createTexture();h.bindTexture(h.TEXTURE_2D,a),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MIN_FILTER,h.NEAREST),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MAG_FILTER,h.NEAREST),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_S,h.CLAMP_TO_EDGE),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_T,h.CLAMP_TO_EDGE);let d=s?i.encode(s,e*o):null;return h.texImage2D(h.TEXTURE_2D,0,i.internalFormat,e,o,0,i.format,i.textureType,d),this.checkError(),a}updateTexture(e,o,i,s,h){let a=this.gl;a.bindTexture(a.TEXTURE_2D,e);let d=s.encode(h,o*i);a.texSubImage2D(a.TEXTURE_2D,0,0,0,o,i,s.format,s.textureType,d),this.checkError()}attachFramebuffer(e,o,i){let s=this.gl;s.bindTexture(s.TEXTURE_2D,e),s.bindFramebuffer(s.FRAMEBUFFER,this.framebuffer),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0),this.checkError(),s.viewport(0,0,o,i),s.scissor(0,0,o,i)}readTexture(e,o,i,s,h,a){let d=this.gl;a||(a=1),this.frameBufferBound||this.attachFramebuffer(e,o,i);let et=this.getEncoder(h,a),$=et.allocate(o*i);return d.bindTexture(d.TEXTURE_2D,e),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,e,0),d.readPixels(0,0,o,i,d.RGBA,et.textureType,$),this.checkError(),et.decode($,s)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,o){let i=this.gl;i.vertexAttribPointer(e,3,i.FLOAT,!1,20,0),i.enableVertexAttribArray(e),o!==-1&&(i.vertexAttribPointer(o,2,i.FLOAT,!1,20,12),i.enableVertexAttribArray(o)),this.checkError()}createProgram(e,o){let i=this.gl,s=i.createProgram();return i.attachShader(s,e),i.attachShader(s,o),i.linkProgram(s),s}compileShader(e,o){let i=this.gl,s=i.createShader(o);if(!s)throw new Error(`createShader() returned null with type ${o}`);if(i.shaderSource(s,e),i.compileShader(s),i.getShaderParameter(s,i.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${i.getShaderInfoLog(s)}
Shader source:
${e}`);return s}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,o,i){let s=this.gl;s.activeTexture(s.TEXTURE0+o),this.checkError(),s.bindTexture(s.TEXTURE_2D,e),this.checkError(),s.uniform1i(i,o),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(z.debug){let e=this.gl,o=e.getError(),i="";switch(o){case e.NO_ERROR:return;case e.INVALID_ENUM:i="INVALID_ENUM";break;case e.INVALID_VALUE:i="INVALID_VALUE";break;case e.INVALID_OPERATION:i="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:i="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:i="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:i="CONTEXT_LOST_WEBGL";break;default:i=`Unknown WebGL Error: ${o.toString(16)}`}throw new Error(i)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,o,i=0){if(this.version===2)return new Sn(this.gl,o);switch(e){case"float":return i===1||this.isRenderFloat32Supported?new Br(this.gl,o):new Br(this.gl,o,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new An(this.gl,o);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let o=0;o<this.maxTextureImageUnits;++o)e.activeTexture(e.TEXTURE0+o),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,o=e.createBuffer();if(!o)throw new Error("createBuffer() returned null");let i=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW),this.checkError(),o}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o);let i=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,e.RGBA,e.FLOAT,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);let h=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(o),e.deleteFramebuffer(s),h}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,o,i,s,h,a;try{o=e.createTexture(),i=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,o);let d=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,d,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0),e.enable(e.BLEND),s=e.createShader(e.VERTEX_SHADER),!s||(e.shaderSource(s,"void main(){}"),e.compileShader(s),h=e.createShader(e.FRAGMENT_SHADER),!h)||(e.shaderSource(h,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(h),a=e.createProgram(),!a)?!1:(e.attachShader(a,s),e.attachShader(a,h),e.linkProgram(a),e.useProgram(a),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),a&&e.deleteProgram(a),s&&e.deleteShader(s),h&&e.deleteShader(h),i&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(i)),o&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(o))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,o=this.disjointTimerQueryWebgl2Extension,i=e.createQuery();return e.beginQuery(o.TIME_ELAPSED_EXT,i),i}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,o=this.disjointTimerQueryWebgl2Extension;e.endQuery(o.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let o=!1,i=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let s=this.gl,h=this.disjointTimerQueryWebgl2Extension;o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE),i=s.getParameter(h.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return o&&!i}getTimerResult(e){let o=0;if(this.version===2){let i=this.gl;o=i.getQueryParameter(e,i.QUERY_RESULT),i.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return o/1e6}async waitForQueryAndGetTime(e){return await ai(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let o,i=e,s=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),s===null?o=()=>!0:o=()=>{let h=i.clientWaitSync(s,0,0);return h===i.ALREADY_SIGNALED||h===i.CONDITION_SATISFIED},{query:s,isFencePassed:o}}async pollFence(e){return new Promise(o=>{this.addItemToPoll(()=>e.isFencePassed(),()=>o())})}pollItems(){let e=hg(this.itemsToPoll.map(o=>o.isDoneFn));for(let o=0;o<=e;++o){let{resolveFn:i}=this.itemsToPoll[o];i()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,o){this.itemsToPoll.push({isDoneFn:e,resolveFn:o}),!(this.itemsToPoll.length>1)&&await ai(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function Ci(e){let o;if((!e||e==="webgl2")&&"webgl2"in mr?o=mr.webgl2:(!e||e==="webgl")&&"webgl"in mr&&(o=mr.webgl),!o)try{let s=bg();o=Tp(s,e)}catch{let s=mg();o=Tp(s,e)}e=e||o.version===1?"webgl":"webgl2";let i=o.gl;return mr[e]=o,i.isContextLost()?(delete mr[e],Ci(e)):(i.disable(i.DEPTH_TEST),i.disable(i.STENCIL_TEST),i.disable(i.BLEND),i.disable(i.DITHER),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SAMPLE_COVERAGE),i.enable(i.SCISSOR_TEST),i.enable(i.CULL_FACE),i.cullFace(i.BACK),o)}function Tp(e,o){let i={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},s,h=i;if((!o||o==="webgl2")&&(s=e.getContext("webgl2",h),s))try{return new Mr(s,2)}catch(a){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${a}`)}if((!o||o==="webgl")&&(s=e.getContext("webgl",h)||e.getContext("experimental-webgl",h),s))try{return new Mr(s,1)}catch(a){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${a}`)}throw new Error("WebGL is not supported")}function mg(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let e=document.createElement("canvas");return e.width=1,e.height=1,e}function bg(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var mr,wp=O(()=>{Mt(),xp(),mr={}}),Kn,vp=O(()=>{Kt(),Mt(),yp(),wp(),Kn=class{get contextId(){return z.webgl.contextId}set contextId(e){z.webgl.contextId=e}get matmulMaxBatchSize(){return z.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){z.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return z.webgl.textureCacheMode}set textureCacheMode(e){z.webgl.textureCacheMode=e}get pack(){return z.webgl.pack}set pack(e){z.webgl.pack=e}get async(){return z.webgl.async}set async(e){z.webgl.async=e}initialize(){try{return this.glContext=Ci(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),tt.setWithEnv(z),z.webgl.context||Object.defineProperty(z.webgl,"context",{value:this.glContext.gl}),tt.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return tt.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new Xn(this,e)}dispose(){this.glContext.dispose()}}});async function Ni(e){if(e){let o=typeof e=="string"?[e]:e;for(let i of o){let s=Ip.get(i);if(s)return s;let h=await yg(i);if(h)return h}}else return Ni(["webgl"]);throw new Error("no available backend to use")}async function yg(e){let o=gg;if(typeof o[e]<"u"&&xg(o[e])){let i=o[e],s=i.initialize();if(typeof s=="object"&&"then"in s&&(s=await s),s)return Ip.set(e,i),i}}function xg(e){let o=e;return"initialize"in o&&typeof o.initialize=="function"&&"createSessionHandler"in o&&typeof o.createSessionHandler=="function"&&"dispose"in o&&typeof o.dispose=="function"}var Ip,gg,_p=O(()=>{vp(),Ip=new Map,gg={webgl:new Kn}}),Ri,Jn,Op=O(()=>{Mt(),Ri=class{constructor(e,o){this.op=e,this.node=o}},Jn=class{constructor(e,o,i){this.graph=e,this.profiler=i,this.initialize(o)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let o=this.graph.getNodes();if(o.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((i,s)=>new Ri(i,o[s])),this.reset(),this._starter=[],this._ops.forEach((i,s)=>{let h=!0;for(let a of i.node.inputs)if(!this._values[a]&&this.graph.getInputIndices().indexOf(a)===-1){h=!1;break}h&&this._starter.push(s)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,o){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let i=e.createInferenceHandler(),s=this.graph.getInputIndices();if(o.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${o.length} expected: ${s.length}`);o.forEach((c,b)=>{let g=s[b];this._values[g]=c});let h=this._starter.slice(0),a=this.graph.getValues(),d=this.graph.getNodes(),et=0;for(;et<h.length;){let c=h[et++],b=this._ops[c],g=b.node.inputs.map(At=>this._values[At]);if(g.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${b.node}`);let nt=g;tt.verbose("ExecPlan",`Running op:${b.node.name} (${nt.map((At,Ct)=>`'${b.node.inputs[Ct]}': ${At.type}[${At.dims.join(",")}]`).join(", ")})`);let at=await this.profiler.event("node",b.node.name,async()=>b.op.impl(i,nt,b.op.context));if(at.length!==b.node.outputs.length)throw new Error("the size of output does not match model definition.");at.forEach((At,Ct)=>{let St=b.node.outputs[Ct];if(this._values[St])throw new Error(`output [${St}] already has value: op:${b.node.name}`);this._values[St]=At});let Ot=new Set;at.forEach((At,Ct)=>{let St=b.node.outputs[Ct];for(let xt of a[St].to){let Dt=d[xt],Qt=!0;for(let Zt of Dt.inputs)if(!this._values[Zt]){Qt=!1;break}Qt&&Ot.add(xt)}}),h.push(...Ot)}let $=[];for(let c=0;c<this.graph.getOutputIndices().length;c++){let b=this.graph.getOutputIndices()[c],g=this._values[b];if(g===void 0)throw new Error(`required output [${b}] does not have value`);b===0?await g.getData():g.data,$.push(g)}return tt.verbose("ExecPlan","disposing of inferenceHandler"),i.dispose(),$})}}}),q,jt,Ur,Sp=O(()=>{Pr(),q=rr(sr()),ze(),Y(),jt=F.experimental.fbs,Ur=class bE{constructor(o){if(this._attributes=new Map,o!=null){for(let i of o)i instanceof q.onnx.AttributeProto?this._attributes.set(i.name,[bE.getValue(i),bE.getType(i)]):i instanceof jt.Attribute&&this._attributes.set(i.name(),[bE.getValue(i),bE.getType(i)]);if(this._attributes.size<o.length)throw new Error("duplicated attribute names")}}set(o,i,s){this._attributes.set(o,[s,i])}delete(o){this._attributes.delete(o)}getFloat(o,i){return this.get(o,"float",i)}getInt(o,i){return this.get(o,"int",i)}getString(o,i){return this.get(o,"string",i)}getTensor(o,i){return this.get(o,"tensor",i)}getFloats(o,i){return this.get(o,"floats",i)}getInts(o,i){return this.get(o,"ints",i)}getStrings(o,i){return this.get(o,"strings",i)}getTensors(o,i){return this.get(o,"tensors",i)}get(o,i,s){let h=this._attributes.get(o);if(h===void 0){if(s!==void 0)return s;throw new Error(`required attribute not found: ${o}`)}if(h[1]!==i)throw new Error(`type mismatch: expected ${i} but got ${h[1]}`);return h[0]}static getType(o){let i=o instanceof q.onnx.AttributeProto?o.type:o.type();switch(i){case q.onnx.AttributeProto.AttributeType.FLOAT:return"float";case q.onnx.AttributeProto.AttributeType.INT:return"int";case q.onnx.AttributeProto.AttributeType.STRING:return"string";case q.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case q.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case q.onnx.AttributeProto.AttributeType.INTS:return"ints";case q.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case q.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${q.onnx.AttributeProto.AttributeType[i]}`)}}static getValue(o){let i=o instanceof q.onnx.AttributeProto?o.type:o.type();if(i===q.onnx.AttributeProto.AttributeType.GRAPH||i===q.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let s=this.getValueNoCheck(o);if(i===q.onnx.AttributeProto.AttributeType.INT&&Nt.isLong(s))return Nt.longToNumber(s);if(i===q.onnx.AttributeProto.AttributeType.INTS){let h=s,a=new Array(h.length);for(let d=0;d<h.length;d++){let et=h[d];a[d]=Nt.longToNumber(et)}return a}if(i===q.onnx.AttributeProto.AttributeType.TENSOR)return o instanceof q.onnx.AttributeProto?bt.fromProto(s):bt.fromOrtTensor(s);if(i===q.onnx.AttributeProto.AttributeType.TENSORS){if(o instanceof q.onnx.AttributeProto)return s.map(h=>bt.fromProto(h));if(o instanceof jt.Attribute)return s.map(h=>bt.fromOrtTensor(h))}return i===q.onnx.AttributeProto.AttributeType.STRING&&o instanceof q.onnx.AttributeProto?kr(s):i===q.onnx.AttributeProto.AttributeType.STRINGS&&o instanceof q.onnx.AttributeProto?s.map(kr):s}static getValueNoCheck(o){return o instanceof q.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(o):this.getValueNoCheckFromOrtFormat(o)}static getValueNoCheckFromOnnxFormat(o){switch(o.type){case q.onnx.AttributeProto.AttributeType.FLOAT:return o.f;case q.onnx.AttributeProto.AttributeType.INT:return o.i;case q.onnx.AttributeProto.AttributeType.STRING:return o.s;case q.onnx.AttributeProto.AttributeType.TENSOR:return o.t;case q.onnx.AttributeProto.AttributeType.GRAPH:return o.g;case q.onnx.AttributeProto.AttributeType.FLOATS:return o.floats;case q.onnx.AttributeProto.AttributeType.INTS:return o.ints;case q.onnx.AttributeProto.AttributeType.STRINGS:return o.strings;case q.onnx.AttributeProto.AttributeType.TENSORS:return o.tensors;case q.onnx.AttributeProto.AttributeType.GRAPHS:return o.graphs;default:throw new Error(`unsupported attribute type: ${q.onnx.AttributeProto.AttributeType[o.type]}`)}}static getValueNoCheckFromOrtFormat(o){switch(o.type()){case jt.AttributeType.FLOAT:return o.f();case jt.AttributeType.INT:return o.i();case jt.AttributeType.STRING:return o.s();case jt.AttributeType.TENSOR:return o.t();case jt.AttributeType.GRAPH:return o.g();case jt.AttributeType.FLOATS:return o.floatsArray();case jt.AttributeType.INTS:{let i=[];for(let s=0;s<o.intsLength();s++)i.push(o.ints(s));return i}case jt.AttributeType.STRINGS:{let i=[];for(let s=0;s<o.stringsLength();s++)i.push(o.strings(s));return i}case jt.AttributeType.TENSORS:{let i=[];for(let s=0;s<o.tensorsLength();s++)i.push(o.tensors(s));return i}default:throw new Error(`unsupported attribute type: ${jt.AttributeType[o.type()]}`)}}}}),Mi,Yn,Ui,ce,Zn,Gi,Ap=O(()=>{Sp(),Pr(),Mi=rr(sr()),ze(),Y(),Yn=F.experimental.fbs,Ui={from:(e,o)=>new Gi(e,o)},ce=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=_t.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},Zn=class{constructor(e,o){e instanceof Mi.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new Ur(e.attribute)):e instanceof Yn.Node&&(this.name=o??e.name(),this.opType=e.opType(),this.attributes=new Ur(_t.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Gi=class{constructor(e,o){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(o),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof Mi.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof Yn.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let o=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map;if(!e.input)throw new Error("missing information in graph: input");let s=[];for(let h of e.input){if(o.has(h.name))throw new Error(`duplicated input name: ${h.name}`);let a=this._allData.push(new ce(h))-1;o.set(h.name,a),s.push(h.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let h of e.initializer){let a=o.get(h.name);if(a===void 0){let d=new ce;d.type={shape:{dims:_t.tensorDimsFromProto(h.dims)},tensorType:_t.tensorDataTypeFromProto(h.dataType)},a=this._allData.push(d)-1,o.set(h.name,a)}this._allData[a]._from=-1,this._allData[a].tensor=bt.fromProto(h)}for(let h=0;h<this._allData.length;h++)this._allData[h].tensor||(this._allInputIndices.push(h),this._allInputNames.push(s[h]));if(!e.output)throw new Error("missing information in graph: output");for(let h of e.output){if(o.has(h.name))throw new Error(`duplicated output name: ${h.name}`);let a=this._allData.push(new ce(h))-1;o.set(h.name,a),this._allOutputIndices.push(a),this._allOutputNames.push(h.name)}if(!e.node)throw new Error("missing information in graph: node");for(let h of e.node){if(!h.name)for(let d=0;;d++){let et=`unnamed_${h.opType}_${d}`;if(!i.has(et)){h.name=et;break}}if(i.has(h.name))throw new Error(`duplicated node name: ${h.name}`);let a=this._nodes.push(new Zn(h))-1;i.set(h.name,a)}for(let h=0;h<this._nodes.length;h++){let a=this._nodes[h],d=e.node[h];if(!d.output)throw new Error(`missing output for node: ${d.name}`);for(let et of d.output){let $=o.get(et);if(typeof $>"u"&&($=this._allData.push(new ce)-1,o.set(et,$)),a.outputs.push($),this._allData[$]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${$}`);if(this._allData[$]._from=h,d.opType==="Constant"){if(!d.attribute||d.attribute.length!==1||!d.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!d.output||d.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");a.outputs.pop(),a.executeNode=!1,this._allData[$]._from=-1,this._allData[$].tensor=bt.fromProto(d.attribute[0].t)}}}for(let h=0;h<this._nodes.length;h++){let a=this._nodes[h],d=e.node[h];if(!d.input)throw new Error(`missing input for node: ${d.name}`);for(let et of d.input){let $=o.get(et);if(typeof $>"u"){if(et===""&&(d.input.length===3||d.input.length===4)&&d.opType==="Resize")continue;throw new Error(`unrecognized input '${et}' for node: ${d.name}`)}a.inputs.push($),this._allData[$]._to.push(h)}}return!0}buildGraphFromOrtFormat(e){let o=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map,s=[];for(let h=0;h<e.inputsLength();h++){let a=e.inputs(h);if(o.has(a))throw new Error(`duplicated input name: ${a}`);for(let d=0;d<e.nodeArgsLength();d++)if(e.nodeArgs(d)?.name()===a){let et=new ce;if(e.nodeArgs(d)?.type()?.valueType()!==Yn.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let $=e.nodeArgs(d).type().value(new Yn.TensorTypeAndShape),c=_t.tensorDataTypeFromProto($.elemType()),b=$.shape(),g=[];for(let at=0;at<b.dimLength();at++)g.push(Nt.longToNumber(b.dim(at).value().dimValue()));et.type={shape:{dims:g},tensorType:c};let nt=this._allData.push(et)-1;o.set(a,nt),s.push(a)}}for(let h=0;h<e.initializersLength();h++){let a=e.initializers(h),d=o.get(a.name());if(d===void 0){let et=new ce,$=_t.tensorDimsFromORTFormat(a),c=_t.tensorDataTypeFromProto(a.dataType());et.type={shape:{dims:$},tensorType:c},d=this._allData.push(et)-1,o.set(a.name(),d)}this._allData[d]._from=-1,this._allData[d].tensor=bt.fromOrtTensor(a)}for(let h=0;h<this._allData.length;h++)this._allData[h].tensor||(this._allInputIndices.push(h),this._allInputNames.push(s[h]));for(let h=0;h<e.outputsLength();h++){let a=e.outputs(h);if(o.has(a))throw new Error(`duplicated output name: ${a}`);let d=this._allData.push(new ce)-1;o.set(a,d),this._allOutputIndices.push(d),this._allOutputNames.push(a)}if(!e.nodes)throw new Error("missing information in graph: node");for(let h=0;h<e.nodesLength();h++){let a=e.nodes(h),d=a.name();if(!d)for(let $=0;d=`unnamed_${a.opType()}_${$}`,!!i.has(d);$++);if(i.has(d))throw new Error(`duplicated node name: ${d}`);let et=this._nodes.push(new Zn(a,d))-1;i.set(d,et)}for(let h=0;h<this._nodes.length;h++){let a=this._nodes[h],d=e.nodes(h);if(d==null)throw new Error(`No node exists at index ${h}`);if(d?.outputsLength()===0)throw new Error(`missing output for node: ${d.name}`);for(let et=0;et<d?.outputsLength();et++){let $=d?.outputs(et),c=o.get($);if(typeof c>"u"&&(c=this._allData.push(new ce)-1,o.set($,c)),a.outputs.push(c),this._allData[c]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${c}`);if(this._allData[c]._from=h,d.opType()==="Constant"){if(d.attributesLength()!==1||!d.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(d.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");a.outputs.pop(),a.executeNode=!1,this._allData[c]._from=-1,this._allData[c].tensor=bt.fromOrtTensor(d.attributes(0).t())}}}for(let h=0;h<this._nodes.length;h++){let a=this._nodes[h],d=e.nodes(h);if(d.inputsLength()===0)throw new Error(`missing input for node: ${d.name}`);for(let et=0;et<d.inputsLength();et++){let $=d.inputs(et),c=o.get($);if(typeof c>"u")throw new Error(`unrecognized input '${$}' for node: ${d.name()}`);a.inputs.push(c),this._allData[c]._to.push(h)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(s=>{this._allData[s]._to.forEach(h=>{e.add(h)})});let o=Array.from(e),i=new Array(this._nodes.length).fill("white");for(;o.length>0;){let s=o.pop();i[s]==="gray"?i[s]="black":(o.push(s),i[s]="gray",this._nodes[s].outputs.forEach(h=>{let a=this._allData[h];if(typeof a.tensor<"u")throw new Error("node outputs should not be initialized");if(a._from!==s)throw new Error("from property of the Value object doesn't match index of Node being processed");a._to.forEach(d=>{if(i[d]==="gray")throw new Error("model graph is cyclic");i[d]==="white"&&o.push(d)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,o=new Array(this._nodes.length,0),i=0;for(let s=0;s<this._nodes.length;s++)o[s]=i,this._nodes[s].executeNode?(i!==s&&(this._nodes[i]=this._nodes[s]),i++):this._nodes[s].outputs.forEach(h=>{this._allData[h]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let s=0;s<this._allData.length;s++){let h=this._allData[s];h._from!==void 0&&h._from!==-1&&h._from!==-2&&(h._from=o[h._from]);for(let a=0;a<h._to.length;a++)if(h._to[a]>=0)h._to[a]=o[h._to[a]];else throw new Error("Trying to update a removed node")}e=0;for(let s=0;s<this._allData.length;s++){if(this._allData[s].from===-2&&this._allOutputIndices.indexOf(s+e)===-1){e++,this._allData.splice(s,1),s--;continue}if(e>0){let h=-1;this._allData[s].from!==void 0&&this._allData[s].from!==-1?(h=this._nodes[this._allData[s].from].outputs.indexOf(s+e),h!==-1&&(this._nodes[this._allData[s].from].outputs[h]=s)):(h=this._allInputIndices.indexOf(s+e),h!==-1&&(this._allInputIndices[h]=s)),this._allData[s].to.forEach(a=>{h=this._nodes[a].inputs.indexOf(s+e),h!==-1&&(this._nodes[a].inputs[h]=s)}),this._allData[s].to.length===0&&(h=this._allOutputIndices.indexOf(s+e),h!==-1&&(this._allOutputIndices[h]=s))}}}deleteNode(e){let o=this._nodes[e];if(o.outputs.length>1){for(let d=1;d<o.outputs.length;d++)if(this._allData[o.outputs[d]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}o.executeNode=!1;let i=o.inputs[0],s=o.outputs[0],h=this._allData[s].to;for(let d=0;d<o.inputs.length;d++){let et=this._allData[o.inputs[d]].to.indexOf(e);if(et===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[o.inputs[d]].to.splice(et,1)}this._allData[s]._to=[];let a=this._allOutputIndices.indexOf(s);if(a!==-1&&(this._allOutputIndices[a]=i),h&&h.length>0)for(let d of h){let et=this._nodes[d].inputs.indexOf(s);if(et===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[d].inputs[et]=i,this._allData[i].to.push(d)}}removeAllDropoutNodes(){let e=0;for(let o of this._nodes){if(o.opType==="Dropout"){if(o.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(o.outputs.length!==1&&o.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(o.outputs.length===2&&this._allData[o.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let o of this._nodes)o.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let o=this._allData[e.outputs[0]]._to;if(o.length===1&&this.isActivation(this._nodes[o[0]])){let i=this._nodes[o[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{e.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[Ue,Ve])}else if(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",i.opType),this.deleteNode(o[0])}}}}}),Pp,Tg,Qn,Ep=O(()=>{xn(),Ap(),Pr(),Pp=rr(sr()),Y(),Tg=F.experimental.fbs,Qn=class{constructor(){}load(e,o,i){let s;if(!i)try{this.loadFromOnnxFormat(e,o);return}catch(h){if(i!==void 0)throw h;s=h}try{this.loadFromOrtFormat(e,o)}catch(h){throw i!==void 0?h:new Error(`Failed to load model as ONNX format: ${s}
as ORT format: ${h}`)}}loadFromOnnxFormat(e,o){let i=Pp.onnx.ModelProto.decode(e);if(Nt.longToNumber(i.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=i.opsetImport.map(s=>({domain:s.domain,version:Nt.longToNumber(s.version)})),this._graph=Ui.from(i.graph,o)}loadFromOrtFormat(e,o){let i=new T.ByteBuffer(e),s=Tg.InferenceSession.getRootAsInferenceSession(i).model();if(Nt.longToNumber(s.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let h=0;h<s.opsetImportLength();h++){let a=s.opsetImport(h);this._opsets.push({domain:a?.domain(),version:Nt.longToNumber(a.version())})}this._graph=Ui.from(s.graph(),o)}get graph(){return this._graph}get opsets(){return this._opsets}}}),to,Dp=O(()=>{_p(),Op(),Mt(),Ep(),to=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=gn.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,o,i){await this.profiler.event("session","Session.loadModel",async()=>{let s=await Ni(this.backendHint);if(this.sessionHandler=s.createSessionHandler(this.context),this._model=new Qn,typeof e=="string"){let h=e.endsWith(".ort");{let a=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(a),h)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let h=new Uint8Array(e,o||0,i||e.byteLength);this.initialize(h)}})}initialize(e,o){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let i=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,i,o),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Jn(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let o=this.normalizeAndValidateInputs(e),i=await this._executionPlan.execute(this.sessionHandler,o);return this.createOutput(i)})}normalizeAndValidateInputs(e){let o=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==o.length)throw new Error(`incorrect input array length: expected ${o.length} but got ${e.length}`)}else{if(e.size!==o.length)throw new Error(`incorrect input map size: expected ${o.length} but got ${e.size}`);let i=new Array(e.size),s=0;for(let h=0;h<o.length;++h){let a=e.get(o[h]);if(!a)throw new Error(`missing input tensor for: '${name}'`);i[s++]=a}e=i}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let i=this._model.graph.getInputIndices(),s=this._model.graph.getValues(),h=new Array(i.length);for(let a=0;a<i.length;++a){let d=s[i[a]];h[a]=d.type.shape.dims,this.context.graphInputTypes.push(d.type.tensorType),this.context.graphInputDims.push(e[a].dims)}this.validateInputTensorDims(h,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,o){for(let i=0;i<o.length;i++){let s=e[i],h=o[i].type;if(s!==h)throw new Error(`input tensor[${i}] check failed: expected type '${s}' but got ${h}`)}}validateInputTensorDims(e,o,i){for(let s=0;s<o.length;s++){let h=e[s],a=o[s].dims;if(!this.compareTensorDims(h,a,i))throw new Error(`input tensor[${s}] check failed: expected shape '[${h.join(",")}]' but got [${a.join(",")}]`)}}compareTensorDims(e,o,i){if(e.length!==o.length)return!1;for(let s=0;s<e.length;++s)if(e[s]!==o[s]&&(!i||e[s]!==0))return!1;return!0}createOutput(e){let o=this._model.graph.getOutputNames();if(e.length!==o.length)throw new Error("expected number of outputs do not match number of generated outputs");let i=new Map;for(let s=0;s<o.length;++s)i.set(o[s],e[s]);return i}initializeOps(e){let o=e.getNodes();this._ops=new Array(o.length);for(let i=0;i<o.length;i++)this._ops[i]=this.sessionHandler.resolve(o[i],this._model.opsets,e)}}}),eo,Lp=O(()=>{Kt(),ze(),eo=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,o,i){let s=new Map;for(let d in e)if(Object.hasOwnProperty.call(e,d)){let et=e[d];s.set(d,new bt(et.dims,et.type,void 0,void 0,et.data))}let h=await this.session.run(s),a={};return h.forEach((d,et)=>{a[et]=new Tt(d.type,d.data,d.dims)}),a}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),$p={};Or($p,{onnxjsBackend:()=>wg});var Vi,wg,kp=O(()=>{Dp(),Lp(),Vi=class{async init(){}async createInferenceSessionHandler(e,o){let i=new to(o);return typeof e=="string"?await i.loadModel(e):await i.loadModel(e),new eo(i)}},wg=new Vi}),ro=O(()=>{}),Cp={};Or(Cp,{default:()=>vg});var Bp,Fp,vg,Np=O(()=>{zi(),Xe(),Vr(),Bp="ort-wasm-proxy-worker",Fp=globalThis.self?.name===Bp,Fp&&(self.onmessage=e=>{let{type:o,in:i}=e.data;try{switch(o){case"init-wasm":no(i.wasm).then(()=>{oo(i).then(()=>{postMessage({type:o})},s=>{postMessage({type:o,err:s})})},s=>{postMessage({type:o,err:s})});break;case"init-ep":{let{epName:s,env:h}=i;io(h,s).then(()=>{postMessage({type:o})},a=>{postMessage({type:o,err:a})});break}case"copy-from":{let{buffer:s}=i,h=zr(s);postMessage({type:o,out:h});break}case"create":{let{model:s,options:h}=i;ao(s,h).then(a=>{postMessage({type:o,out:a})},a=>{postMessage({type:o,err:a})});break}case"release":so(i),postMessage({type:o});break;case"run":{let{sessionId:s,inputIndices:h,inputs:a,outputIndices:d,options:et}=i;uo(s,h,a,d,new Array(d.length).fill(null),et).then($=>{$.some(c=>c[3]!=="cpu")?postMessage({type:o,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:o,out:$},fo([...a,...$]))},$=>{postMessage({type:o,err:$})});break}case"end-profiling":lo(i),postMessage({type:o});break;default:}}catch(s){postMessage({type:o,err:s})}}),vg=Fp?null:e=>new Worker(e??br,{type:"module",name:Bp})}),Gp={};Or(Gp,{default:()=>Ig});var Wi,Rp,Ig,Mp=O(()=>{Rp=(Wi=import.meta.url,async function(e={}){function o(){return Js.buffer!=Ir.buffer&&Jr(),Ir}function i(){return Js.buffer!=Ir.buffer&&Jr(),Yo}function s(){return Js.buffer!=Ir.buffer&&Jr(),Bu}function h(){return Js.buffer!=Ir.buffer&&Jr(),Ho}function a(){return Js.buffer!=Ir.buffer&&Jr(),To}var d,et,$=Object.assign({},e),c=new Promise((Xr,Xo)=>{d=Xr,et=Xo}),b=typeof window=="object",g=typeof importScripts=="function",nt=g&&self.name=="em-pthread";$.mountExternalData=(Xr,Xo)=>{Xr.startsWith("./")&&(Xr=Xr.substring(2)),($.Ua||($.Ua=new Map)).set(Xr,Xo)},$.unmountExternalData=()=>{delete $.Ua};var at,Ot,At=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor,Ct=Object.assign({},$),St="./this.program",xt=(Xr,Xo)=>{throw Xo},Dt="";(b||g)&&(g?Dt=self.location.href:typeof document<"u"&&document.currentScript&&(Dt=document.currentScript.src),Wi&&(Dt=Wi),Dt=Dt.startsWith("blob:")?"":Dt.substr(0,Dt.replace(/[?#].*/,"").lastIndexOf("/")+1),g&&(Ot=Xr=>{var Xo=new XMLHttpRequest;return Xo.open("GET",Xr,!1),Xo.responseType="arraybuffer",Xo.send(null),new Uint8Array(Xo.response)}),at=(Xr,Xo,ru)=>{var Pu=new XMLHttpRequest;Pu.open("GET",Xr,!0),Pu.responseType="arraybuffer",Pu.onload=()=>{Pu.status==200||Pu.status==0&&Pu.response?Xo(Pu.response):ru()},Pu.onerror=ru,Pu.send(null)});var Qt,Zt=console.log.bind(console),gr=console.error.bind(console),vr=Zt,Er=gr;if(Object.assign($,Ct),Ct=null,nt){let Xr=function(Xo){try{var ru=Xo.data,Pu=ru.cmd;if(Pu==="load"){let Nu=[];self.onmessage=n_=>Nu.push(n_),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let n_ of Nu)Xr(n_);self.onmessage=Xr};for(let n_ of ru.handlers)$[n_]&&!$[n_].proxy||($[n_]=(...oy)=>{postMessage({Za:"callHandler",kb:n_,args:oy})},n_=="print"&&(vr=$[n_]),n_=="printErr"&&(Er=$[n_]));Js=ru.wasmMemory,Jr(),wo(ru.wasmModule)}else if(Pu==="run"){e0(ru.pthread_ptr,0,0,1,0,0),G0(ru.pthread_ptr),O_(),L_(),Do||=!0;try{g_(ru.start_routine,ru.arg)}catch(Nu){if(Nu!="unwind")throw Nu}}else Pu==="cancel"?J_()&&_y(-1):ru.target!=="setimmediate"&&(Pu==="checkMailbox"?Do&&N0():Pu&&(Er(`worker: received unknown command ${Pu}`),Er(ru)))}catch(Nu){throw jy(),Nu}};var wo,Do=!1;Er=function(...Xo){Xo=Xo.join(" "),console.error(Xo)},self.alert=function(...Xo){postMessage({Za:"alert",text:Xo.join(" "),nb:J_()})},$.instantiateWasm=(Xo,ru)=>new Promise(Pu=>{wo=Nu=>{Nu=new WebAssembly.Instance(Nu,ar()),ru(Nu),Pu()}}),self.onunhandledrejection=Xo=>{throw Xo.reason||Xo},self.onmessage=Xr}$.wasmBinary&&(Qt=$.wasmBinary);var Js,In,Wo,Ir,Yo,Bu,Ho,tn,To,Qo=!1;function Jr(){var Xr=Js.buffer;$.HEAP8=Ir=new Int8Array(Xr),$.HEAP16=new Int16Array(Xr),$.HEAPU8=Yo=new Uint8Array(Xr),$.HEAPU16=new Uint16Array(Xr),$.HEAP32=Bu=new Int32Array(Xr),$.HEAPU32=Ho=new Uint32Array(Xr),$.HEAPF32=new Float32Array(Xr),$.HEAPF64=To=new Float64Array(Xr),$.HEAP64=tn=new BigInt64Array(Xr),$.HEAPU64=new BigUint64Array(Xr)}if(!nt){if(!((Js=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof At))throw Er("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");Jr()}var Lo=[],Du=[],_u=[],du=0,wu=null;function r_(){if(--du==0&&wu){var Xr=wu;wu=null,Xr()}}function d_(Xr){throw Er(Xr="Aborted("+Xr+")"),Qo=!0,Wo=1,Xr=new WebAssembly.RuntimeError(Xr+". Build with -sASSERTIONS for more info."),et(Xr),Xr}var na,Ko=Xr=>Xr.startsWith("data:application/octet-stream;base64,"),vu=Xr=>Xr.startsWith("file://");function Cu(Xr){if(Xr==na&&Qt)return new Uint8Array(Qt);if(Ot)return Ot(Xr);throw"both async and sync fetching of the wasm failed"}function e_(Xr,Xo,ru){return function(Pu){if(!Qt&&(b||g)){if(typeof fetch=="function"&&!vu(Pu))return fetch(Pu,{credentials:"same-origin"}).then(Nu=>{if(!Nu.ok)throw`failed to load wasm binary file at '${Pu}'`;return Nu.arrayBuffer()}).catch(()=>Cu(Pu));if(at)return new Promise((Nu,n_)=>{at(Pu,oy=>Nu(new Uint8Array(oy)),n_)})}return Promise.resolve().then(()=>Cu(Pu))}(Xr).then(Pu=>WebAssembly.instantiate(Pu,Xo)).then(ru,Pu=>{Er(`failed to asynchronously prepare wasm: ${Pu}`),d_(Pu)})}function ar(){return{a:{j:_a,b:Xs,E:w_,g:S_,V:B_,A:H_,C:j_,W:pu,T:T_,L:E_,S:iy,o:Ry,B:Zy,y:hy,U:Ay,z:Sy,_:K0,Z:n0,P:A0,w:xw,F:i0,k:q0,O:G0,Y:M0,I:Cw,J:Y0,K:U0,G:_w,H:tw,v:ly,q:Tw,l:Ew,p:yw,e:Yy,X:nw,x:ow,d:rw,f:Jy,i:R0,u:xu,t:ba,s:Iu,Q:z_,R:C_,D:Mo,h:Cy,n:ay,M:wy,m:Ey,a:Js,r:Kr,N:g0,c:Iy}}}var Qs={830756:(Xr,Xo,ru,Pu,Nu)=>{if($===void 0||!$.Ua)return 1;if((Xr=k_(Xr>>>0)).startsWith("./")&&(Xr=Xr.substring(2)),!(Xr=$.Ua.get(Xr)))return 2;if(Pu>>>=0,(Xo>>>=0)+(ru>>>=0)>Xr.byteLength)return 3;try{let n_=Xr.subarray(Xo,Xo+ru);switch(Nu){case 0:i().set(n_,Pu>>>0);break;case 1:$.mb(Pu,n_);break;default:return 4}return 0}catch{return 4}},831439:()=>typeof wasmOffsetConverter<"u"};function _a(){return typeof wasmOffsetConverter<"u"}function $o(Xr){this.name="ExitStatus",this.message=`Program terminated with exit(${Xr})`,this.status=Xr}var Eo=Xr=>{Xr.terminate(),Xr.onmessage=()=>{}},js=Xr=>{qs.length==0&&(Ty(),Z_(qs[0]));var Xo=qs.pop();if(!Xo)return 6;au.push(Xo),$u[Xr.Ra]=Xo,Xo.Ra=Xr.Ra;var ru={cmd:"run",start_routine:Xr.cb,arg:Xr.ab,pthread_ptr:Xr.Ra};return Xo.postMessage(ru,Xr.ib),0},Lr=0,rn=(Xr,Xo,...ru)=>{for(var Pu=2*ru.length,Nu=$w(),n_=X_(8*Pu),oy=n_>>>3,Qy=0;Qy<ru.length;Qy++){var p0=ru[Qy];typeof p0=="bigint"?(tn[oy+2*Qy]=1n,tn[oy+2*Qy+1]=p0):(tn[oy+2*Qy]=0n,a()[oy+2*Qy+1>>>0]=p0)}return Xr=zy(Xr,0,Pu,n_,Xo),S0(Nu),Xr};function Kr(Xr){if(nt)return rn(0,1,Xr);if(Wo=Xr,!(0<Lr)){for(var Xo of au)Eo(Xo);for(Xo of qs)Eo(Xo);qs=[],au=[],$u=[],Qo=!0}xt(Xr,new $o(Xr))}function Oo(Xr){if(nt)return rn(1,0,Xr);Mo(Xr)}var Mo=Xr=>{if(Wo=Xr,nt)throw Oo(Xr),"unwind";Kr(Xr)},qs=[],au=[],i_=[],$u={},m_=Xr=>{var Xo=Xr.Ra;delete $u[Xo],qs.push(Xr),au.splice(au.indexOf(Xr),1),Xr.Ra=0,U_(Xo)};function L_(){i_.forEach(Xr=>Xr())}var Z_=Xr=>new Promise(Xo=>{Xr.onmessage=Nu=>{var n_=(Nu=Nu.data).cmd;if(Nu.targetThread&&Nu.targetThread!=J_()){var oy=$u[Nu.targetThread];oy?oy.postMessage(Nu,Nu.transferList):Er(`Internal error! Worker sent a message "${n_}" to target pthread ${Nu.targetThread}, but that thread no longer exists!`)}else n_==="checkMailbox"?N0():n_==="spawnThread"?js(Nu):n_==="cleanupThread"?m_($u[Nu.thread]):n_==="killThread"?(Nu=Nu.thread,n_=$u[Nu],delete $u[Nu],Eo(n_),U_(Nu),au.splice(au.indexOf(n_),1),n_.Ra=0):n_==="cancelThread"?$u[Nu.thread].postMessage({cmd:"cancel"}):n_==="loaded"?(Xr.loaded=!0,Xo(Xr)):n_==="alert"?alert(`Thread ${Nu.threadId}: ${Nu.text}`):Nu.target==="setimmediate"?Xr.postMessage(Nu):n_==="callHandler"?$[Nu.handler](...Nu.args):n_&&Er(`worker sent an unknown command ${n_}`)},Xr.onerror=Nu=>{throw Er(`worker sent an error! ${Nu.filename}:${Nu.lineno}: ${Nu.message}`),Nu};var ru,Pu=[];for(ru of[])$.hasOwnProperty(ru)&&Pu.push(ru);Xr.postMessage({cmd:"load",handlers:Pu,wasmMemory:Js,wasmModule:In})});function Ty(){var Xr=new Worker(new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});qs.push(Xr)}var ey,yy=Xr=>{for(;0<Xr.length;)Xr.shift()($)},O_=()=>{var Xr=J_(),Xo=h()[Xr+52>>>2>>>0];Xr=h()[Xr+56>>>2>>>0],s0(Xo,Xo-Xr),S0(Xo)},fy=[],g_=(Xr,Xo)=>{Lr=0;var ru=fy[Xr];ru||(Xr>=fy.length&&(fy.length=Xr+1),fy[Xr]=ru=ey.get(Xr)),Xr=ru(Xo),0<Lr?Wo=Xr:_y(Xr)};class jo{constructor(Xo){this.Xa=Xo-24}}function Xs(Xr,Xo,ru){var Pu=new jo(Xr>>>=0);throw Xo>>>=0,ru>>>=0,h()[Pu.Xa+16>>>2>>>0]=0,h()[Pu.Xa+4>>>2>>>0]=Xo,h()[Pu.Xa+8>>>2>>>0]=ru,Xr}function _d(Xr,Xo,ru,Pu){return nt?rn(2,1,Xr,Xo,ru,Pu):w_(Xr,Xo,ru,Pu)}function w_(Xr,Xo,ru,Pu){if(Xr>>>=0,Xo>>>=0,ru>>>=0,Pu>>>=0,At===void 0)return Er("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Nu=[];return nt&&Nu.length===0?_d(Xr,Xo,ru,Pu):(Xr={cb:ru,Ra:Xr,ab:Pu,ib:Nu},nt?(Xr.Za="spawnThread",postMessage(Xr,Nu),0):js(Xr))}var mu=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,y_=(Xr,Xo,ru)=>{var Pu=(Xo>>>=0)+ru;for(ru=Xo;Xr[ru]&&!(ru>=Pu);)++ru;if(16<ru-Xo&&Xr.buffer&&mu)return mu.decode(Xr.buffer instanceof At?Xr.slice(Xo,ru):Xr.subarray(Xo,ru));for(Pu="";Xo<ru;){var Nu=Xr[Xo++];if(128&Nu){var n_=63&Xr[Xo++];if((224&Nu)==192)Pu+=String.fromCharCode((31&Nu)<<6|n_);else{var oy=63&Xr[Xo++];65536>(Nu=(240&Nu)==224?(15&Nu)<<12|n_<<6|oy:(7&Nu)<<18|n_<<12|oy<<6|63&Xr[Xo++])?Pu+=String.fromCharCode(Nu):(Nu-=65536,Pu+=String.fromCharCode(55296|Nu>>10,56320|1023&Nu))}}else Pu+=String.fromCharCode(Nu)}return Pu},k_=(Xr,Xo)=>(Xr>>>=0)?y_(i(),Xr,Xo):"";function S_(Xr,Xo,ru){return nt?rn(3,1,Xr,Xo,ru):0}function B_(Xr,Xo){if(nt)return rn(4,1,Xr,Xo)}var P_=Xr=>{for(var Xo=0,ru=0;ru<Xr.length;++ru){var Pu=Xr.charCodeAt(ru);127>=Pu?Xo++:2047>=Pu?Xo+=2:55296<=Pu&&57343>=Pu?(Xo+=4,++ru):Xo+=3}return Xo},N_=(Xr,Xo,ru,Pu)=>{if(!(0<Pu))return 0;var Nu=ru>>>=0;Pu=ru+Pu-1;for(var n_=0;n_<Xr.length;++n_){var oy=Xr.charCodeAt(n_);if(55296<=oy&&57343>=oy&&(oy=65536+((1023&oy)<<10)|1023&Xr.charCodeAt(++n_)),127>=oy){if(ru>=Pu)break;Xo[ru++>>>0]=oy}else{if(2047>=oy){if(ru+1>=Pu)break;Xo[ru++>>>0]=192|oy>>6}else{if(65535>=oy){if(ru+2>=Pu)break;Xo[ru++>>>0]=224|oy>>12}else{if(ru+3>=Pu)break;Xo[ru++>>>0]=240|oy>>18,Xo[ru++>>>0]=128|oy>>12&63}Xo[ru++>>>0]=128|oy>>6&63}Xo[ru++>>>0]=128|63&oy}}return Xo[ru>>>0]=0,ru-Nu},q_=(Xr,Xo,ru)=>N_(Xr,i(),Xo,ru);function H_(Xr,Xo){if(nt)return rn(5,1,Xr,Xo)}function j_(Xr,Xo,ru){if(nt)return rn(6,1,Xr,Xo,ru)}function pu(Xr,Xo,ru){return nt?rn(7,1,Xr,Xo,ru):0}function T_(Xr,Xo){if(nt)return rn(8,1,Xr,Xo)}function E_(Xr,Xo,ru){if(nt)return rn(9,1,Xr,Xo,ru)}function iy(Xr,Xo,ru,Pu){if(nt)return rn(10,1,Xr,Xo,ru,Pu)}function Ry(Xr,Xo,ru,Pu){if(nt)return rn(11,1,Xr,Xo,ru,Pu)}function Zy(Xr,Xo,ru,Pu){if(nt)return rn(12,1,Xr,Xo,ru,Pu)}function hy(Xr){if(nt)return rn(13,1,Xr)}function Ay(Xr,Xo){if(nt)return rn(14,1,Xr,Xo)}function Sy(Xr,Xo,ru){if(nt)return rn(15,1,Xr,Xo,ru)}var K0=()=>{d_("")},n0=()=>1;function A0(Xr){e0(Xr>>>0,!g,1,!b,131072,!1),L_()}function G0(Xr){Xr>>>=0,typeof Atomics.jb=="function"&&(Atomics.jb(s(),Xr>>>2,Xr).value.then(N0),Xr+=128,Atomics.store(s(),Xr>>>2,1))}var N0=()=>{var Xr=J_();if(Xr&&(G0(Xr),Xr=Ky,!Qo))try{if(Xr(),!(0<Lr))try{nt?_y(Wo):Mo(Wo)}catch(Xo){Xo instanceof $o||Xo=="unwind"||xt(1,Xo)}}catch(Xo){Xo instanceof $o||Xo=="unwind"||xt(1,Xo)}};function xw(Xr,Xo){(Xr>>>=0)==Xo>>>0?setTimeout(N0):nt?postMessage({targetThread:Xr,cmd:"checkMailbox"}):(Xr=$u[Xr])&&Xr.postMessage({cmd:"checkMailbox"})}var uw=[];function i0(Xr,Xo,ru,Pu,Nu){for(Xo>>>=0,Pu/=2,uw.length=Pu,ru=Nu>>>0>>>3,Nu=0;Nu<Pu;Nu++)uw[Nu]=tn[ru+2*Nu]?tn[ru+2*Nu+1]:a()[ru+2*Nu+1>>>0];return(Xo?Qs[Xo]:_0[Xr])(...uw)}function q0(Xr){Xr>>>=0,nt?postMessage({cmd:"cleanupThread",thread:Xr}):m_($u[Xr])}function M0(Xr){}function Cw(Xr,Xo){Xr=-9007199254740992>Xr||9007199254740992<Xr?NaN:Number(Xr),Xo>>>=0,Xr=new Date(1e3*Xr),s()[Xo>>>2>>>0]=Xr.getUTCSeconds(),s()[Xo+4>>>2>>>0]=Xr.getUTCMinutes(),s()[Xo+8>>>2>>>0]=Xr.getUTCHours(),s()[Xo+12>>>2>>>0]=Xr.getUTCDate(),s()[Xo+16>>>2>>>0]=Xr.getUTCMonth(),s()[Xo+20>>>2>>>0]=Xr.getUTCFullYear()-1900,s()[Xo+24>>>2>>>0]=Xr.getUTCDay(),Xr=(Xr.getTime()-Date.UTC(Xr.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[Xo+28>>>2>>>0]=Xr}var P0=Xr=>Xr%4==0&&(Xr%100!=0||Xr%400==0),F0=[0,31,60,91,121,152,182,213,244,274,305,335],X0=[0,31,59,90,120,151,181,212,243,273,304,334];function Y0(Xr,Xo){Xr=-9007199254740992>Xr||9007199254740992<Xr?NaN:Number(Xr),Xo>>>=0,Xr=new Date(1e3*Xr),s()[Xo>>>2>>>0]=Xr.getSeconds(),s()[Xo+4>>>2>>>0]=Xr.getMinutes(),s()[Xo+8>>>2>>>0]=Xr.getHours(),s()[Xo+12>>>2>>>0]=Xr.getDate(),s()[Xo+16>>>2>>>0]=Xr.getMonth(),s()[Xo+20>>>2>>>0]=Xr.getFullYear()-1900,s()[Xo+24>>>2>>>0]=Xr.getDay();var ru=(P0(Xr.getFullYear())?F0:X0)[Xr.getMonth()]+Xr.getDate()-1|0;s()[Xo+28>>>2>>>0]=ru,s()[Xo+36>>>2>>>0]=-60*Xr.getTimezoneOffset(),ru=new Date(Xr.getFullYear(),6,1).getTimezoneOffset();var Pu=new Date(Xr.getFullYear(),0,1).getTimezoneOffset();Xr=0|(ru!=Pu&&Xr.getTimezoneOffset()==Math.min(Pu,ru)),s()[Xo+32>>>2>>>0]=Xr}function U0(Xr){Xr>>>=0;var Xo=new Date(s()[Xr+20>>>2>>>0]+1900,s()[Xr+16>>>2>>>0],s()[Xr+12>>>2>>>0],s()[Xr+8>>>2>>>0],s()[Xr+4>>>2>>>0],s()[Xr>>>2>>>0],0),ru=s()[Xr+32>>>2>>>0],Pu=Xo.getTimezoneOffset(),Nu=new Date(Xo.getFullYear(),6,1).getTimezoneOffset(),n_=new Date(Xo.getFullYear(),0,1).getTimezoneOffset(),oy=Math.min(n_,Nu);return 0>ru?s()[Xr+32>>>2>>>0]=+(Nu!=n_&&oy==Pu):0<ru!=(oy==Pu)&&(Nu=Math.max(n_,Nu),Xo.setTime(Xo.getTime()+6e4*((0<ru?oy:Nu)-Pu))),s()[Xr+24>>>2>>>0]=Xo.getDay(),ru=(P0(Xo.getFullYear())?F0:X0)[Xo.getMonth()]+Xo.getDate()-1|0,s()[Xr+28>>>2>>>0]=ru,s()[Xr>>>2>>>0]=Xo.getSeconds(),s()[Xr+4>>>2>>>0]=Xo.getMinutes(),s()[Xr+8>>>2>>>0]=Xo.getHours(),s()[Xr+12>>>2>>>0]=Xo.getDate(),s()[Xr+16>>>2>>>0]=Xo.getMonth(),s()[Xr+20>>>2>>>0]=Xo.getYear(),Xr=Xo.getTime(),BigInt(isNaN(Xr)?-1:Xr/1e3)}function _w(Xr,Xo,ru,Pu,Nu,n_,oy){return nt?rn(16,1,Xr,Xo,ru,Pu,Nu,n_,oy):-52}function tw(Xr,Xo,ru,Pu,Nu,n_){if(nt)return rn(17,1,Xr,Xo,ru,Pu,Nu,n_)}function ly(Xr,Xo,ru,Pu){Xr>>>=0,Xo>>>=0,ru>>>=0,Pu>>>=0;var Nu=new Date().getFullYear(),n_=new Date(Nu,0,1),oy=new Date(Nu,6,1);Nu=n_.getTimezoneOffset();var Qy=oy.getTimezoneOffset(),p0=Math.max(Nu,Qy);h()[Xr>>>2>>>0]=60*p0,s()[Xo>>>2>>>0]=+(Nu!=Qy),n_=(Xr=y0=>y0.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(n_),oy=Xr(oy),Qy<Nu?(q_(n_,ru,17),q_(oy,Pu,17)):(q_(n_,Pu,17),q_(oy,ru,17))}var by=[];function Tw(Xr,Xo,ru){Xr>>>=0,Xo>>>=0,ru>>>=0,by.length=0;for(var Pu;Pu=i()[Xo++>>>0];){var Nu=Pu!=105;ru+=(Nu&=Pu!=112)&&ru%8?4:0,by.push(Pu==112?h()[ru>>>2>>>0]:Pu==106?tn[ru>>>3]:Pu==105?s()[ru>>>2>>>0]:a()[ru>>>3>>>0]),ru+=Nu?8:4}return Qs[Xr](...by)}var Ew=()=>{},yw=()=>Date.now();function Yy(Xr,Xo){return Er(k_(Xr>>>0,Xo>>>0))}var rw,nw=()=>{throw Lr+=1,"unwind"};function ow(){return 4294901760}rw=()=>performance.timeOrigin+performance.now();var Jy=()=>navigator.hardwareConcurrency;function R0(){return d_("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function xu(Xr){Xr>>>=0;var Xo=i().length;if(Xr<=Xo||4294901760<Xr)return!1;for(var ru=1;4>=ru;ru*=2){var Pu=Xo*(1+.2/ru);Pu=Math.min(Pu,Xr+100663296);var Nu=Math;Pu=Math.max(Xr,Pu);e:{Nu=(Nu.min.call(Nu,4294901760,Pu+(65536-Pu%65536)%65536)-Js.buffer.byteLength+65535)/65536;try{Js.grow(Nu),Jr();var n_=1;break e}catch{}n_=void 0}if(n_)return!0}return!1}var wr=()=>(d_("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Po={},Zs=Xr=>{Xr.forEach(Xo=>{wr()})};function ba(){var Xr=Error().stack.toString().split(`
`);return Xr[0]=="Error"&&Xr.shift(),Zs(Xr),Po.$a=wr(),Po.bb=Xr,Po.$a}function Iu(Xr,Xo,ru){if(Xr>>>=0,Xo>>>=0,Po.$a==Xr)var Pu=Po.bb;else(Pu=Error().stack.toString().split(`
`))[0]=="Error"&&Pu.shift(),Zs(Pu);for(var Nu=3;Pu[Nu]&&wr()!=Xr;)++Nu;for(Xr=0;Xr<ru&&Pu[Xr+Nu];++Xr)s()[Xo+4*Xr>>>2>>>0]=wr();return Xr}var a_,D_={},b_=()=>{if(!a_){var Xr,Xo={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:St};for(Xr in D_)D_[Xr]===void 0?delete Xo[Xr]:Xo[Xr]=D_[Xr];var ru=[];for(Xr in Xo)ru.push(`${Xr}=${Xo[Xr]}`);a_=ru}return a_};function z_(Xr,Xo){if(nt)return rn(18,1,Xr,Xo);Xr>>>=0,Xo>>>=0;var ru=0;return b_().forEach((Pu,Nu)=>{var n_=Xo+ru;for(Nu=h()[Xr+4*Nu>>>2>>>0]=n_,n_=0;n_<Pu.length;++n_)o()[Nu++>>>0]=Pu.charCodeAt(n_);o()[Nu>>>0]=0,ru+=Pu.length+1}),0}function C_(Xr,Xo){if(nt)return rn(19,1,Xr,Xo);Xr>>>=0,Xo>>>=0;var ru=b_();h()[Xr>>>2>>>0]=ru.length;var Pu=0;return ru.forEach(Nu=>Pu+=Nu.length+1),h()[Xo>>>2>>>0]=Pu,0}function Cy(Xr){return nt?rn(20,1,Xr):52}function ay(Xr,Xo,ru,Pu){return nt?rn(21,1,Xr,Xo,ru,Pu):52}function wy(Xr,Xo,ru,Pu){return nt?rn(22,1,Xr,Xo,ru,Pu):70}var sy=[null,[],[]];function Ey(Xr,Xo,ru,Pu){if(nt)return rn(23,1,Xr,Xo,ru,Pu);Xo>>>=0,ru>>>=0,Pu>>>=0;for(var Nu=0,n_=0;n_<ru;n_++){var oy=h()[Xo>>>2>>>0],Qy=h()[Xo+4>>>2>>>0];Xo+=8;for(var p0=0;p0<Qy;p0++){var y0=i()[oy+p0>>>0],v0=sy[Xr];y0===0||y0===10?((Xr===1?vr:Er)(y_(v0,0)),v0.length=0):v0.push(y0)}Nu+=Qy}return h()[Pu>>>2>>>0]=Nu,0}var L0=[31,29,31,30,31,30,31,31,30,31,30,31],h0=[31,28,31,30,31,30,31,31,30,31,30,31],Uu=(Xr,Xo)=>{o().set(Xr,Xo>>>0)};function g0(Xr,Xo,ru,Pu){function Nu(h_,$y,c0){for(h_=typeof h_=="number"?h_.toString():h_||"";h_.length<$y;)h_=c0[0]+h_;return h_}function n_(h_,$y){return Nu(h_,$y,"0")}function oy(h_,$y){function c0(Iw){return 0>Iw?-1:0<Iw?1:0}var iw;return(iw=c0(h_.getFullYear()-$y.getFullYear()))===0&&(iw=c0(h_.getMonth()-$y.getMonth()))===0&&(iw=c0(h_.getDate()-$y.getDate())),iw}function Qy(h_){switch(h_.getDay()){case 0:return new Date(h_.getFullYear()-1,11,29);case 1:return h_;case 2:return new Date(h_.getFullYear(),0,3);case 3:return new Date(h_.getFullYear(),0,2);case 4:return new Date(h_.getFullYear(),0,1);case 5:return new Date(h_.getFullYear()-1,11,31);case 6:return new Date(h_.getFullYear()-1,11,30)}}function p0(h_){var $y=h_.Sa;for(h_=new Date(new Date(h_.Ta+1900,0,1).getTime());0<$y;){var c0=h_.getMonth(),iw=(P0(h_.getFullYear())?L0:h0)[c0];if(!($y>iw-h_.getDate())){h_.setDate(h_.getDate()+$y);break}$y-=iw-h_.getDate()+1,h_.setDate(1),11>c0?h_.setMonth(c0+1):(h_.setMonth(0),h_.setFullYear(h_.getFullYear()+1))}return c0=new Date(h_.getFullYear()+1,0,4),$y=Qy(new Date(h_.getFullYear(),0,4)),c0=Qy(c0),0>=oy($y,h_)?0>=oy(c0,h_)?h_.getFullYear()+1:h_.getFullYear():h_.getFullYear()-1}Xr>>>=0,Xo>>>=0,ru>>>=0,Pu>>>=0;var y0=h()[Pu+40>>>2>>>0];for(var v0 in Pu={gb:s()[Pu>>>2>>>0],fb:s()[Pu+4>>>2>>>0],Va:s()[Pu+8>>>2>>>0],Ya:s()[Pu+12>>>2>>>0],Wa:s()[Pu+16>>>2>>>0],Ta:s()[Pu+20>>>2>>>0],Qa:s()[Pu+24>>>2>>>0],Sa:s()[Pu+28>>>2>>>0],ob:s()[Pu+32>>>2>>>0],eb:s()[Pu+36>>>2>>>0],hb:y0?k_(y0):""},ru=k_(ru),y0={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})ru=ru.replace(new RegExp(v0,"g"),y0[v0]);var B0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),e1="January February March April May June July August September October November December".split(" ");for(v0 in y0={"%a":h_=>B0[h_.Qa].substring(0,3),"%A":h_=>B0[h_.Qa],"%b":h_=>e1[h_.Wa].substring(0,3),"%B":h_=>e1[h_.Wa],"%C":h_=>n_((h_.Ta+1900)/100|0,2),"%d":h_=>n_(h_.Ya,2),"%e":h_=>Nu(h_.Ya,2," "),"%g":h_=>p0(h_).toString().substring(2),"%G":p0,"%H":h_=>n_(h_.Va,2),"%I":h_=>((h_=h_.Va)==0?h_=12:12<h_&&(h_-=12),n_(h_,2)),"%j":h_=>{for(var $y=0,c0=0;c0<=h_.Wa-1;$y+=(P0(h_.Ta+1900)?L0:h0)[c0++]);return n_(h_.Ya+$y,3)},"%m":h_=>n_(h_.Wa+1,2),"%M":h_=>n_(h_.fb,2),"%n":()=>`
`,"%p":h_=>0<=h_.Va&&12>h_.Va?"AM":"PM","%S":h_=>n_(h_.gb,2),"%t":()=>"	","%u":h_=>h_.Qa||7,"%U":h_=>n_(Math.floor((h_.Sa+7-h_.Qa)/7),2),"%V":h_=>{var $y=Math.floor((h_.Sa+7-(h_.Qa+6)%7)/7);if(2>=(h_.Qa+371-h_.Sa-2)%7&&$y++,$y)$y==53&&((c0=(h_.Qa+371-h_.Sa)%7)==4||c0==3&&P0(h_.Ta)||($y=1));else{$y=52;var c0=(h_.Qa+7-h_.Sa-1)%7;(c0==4||c0==5&&P0(h_.Ta%400-1))&&$y++}return n_($y,2)},"%w":h_=>h_.Qa,"%W":h_=>n_(Math.floor((h_.Sa+7-(h_.Qa+6)%7)/7),2),"%y":h_=>(h_.Ta+1900).toString().substring(2),"%Y":h_=>h_.Ta+1900,"%z":h_=>{var $y=0<=(h_=h_.eb);return h_=Math.abs(h_)/60,($y?"+":"-")+("0000"+(h_/60*100+h_%60)).slice(-4)},"%Z":h_=>h_.hb,"%%":()=>"%"},ru=ru.replace(/%%/g,"\0\0"),y0)ru.includes(v0)&&(ru=ru.replace(new RegExp(v0,"g"),y0[v0](Pu)));return v0=function(h_){var $y=Array(P_(h_)+1);return N_(h_,$y,0,$y.length),$y}(ru=ru.replace(/\0\0/g,"%")),v0.length>Xo?0:(Uu(v0,Xr),v0.length-1)}function Iy(Xr,Xo,ru,Pu){return g0(Xr>>>0,Xo>>>0,ru>>>0,Pu>>>0)}nt||function(){for(var Xr=$.numThreads-1;Xr--;)Ty();Lo.unshift(()=>{du++,function(Xo){nt?Xo():Promise.all(qs.map(Z_)).then(Xo)}(()=>r_())})}();var _0=[Kr,Oo,_d,S_,B_,H_,j_,pu,T_,E_,iy,Ry,Zy,hy,Ay,Sy,_w,tw,z_,C_,Cy,ay,wy,Ey],ry=function(){function Xr(ru,Pu){return ry=ru.exports,ry=function(){var Nu=ry,n_=Qy=>()=>Qy()>>>0,oy=Qy=>p0=>Qy(p0)>>>0;return(Nu=Object.assign({},Nu)).Ba=n_(Nu.Ba),Nu.Ca=oy(Nu.Ca),Nu.emscripten_main_runtime_thread_id=n_(Nu.emscripten_main_runtime_thread_id),Nu.Oa=oy(Nu.Oa),Nu.Pa=n_(Nu.Pa),Nu}(),i_.push(ry.Ea),ey=ry.Fa,Du.unshift(ry.$),In=Pu,r_(),ry}var Xo=ar();if(du++,$.instantiateWasm)try{return $.instantiateWasm(Xo,Xr)}catch(ru){Er(`Module.instantiateWasm callback failed with error: ${ru}`),et(ru)}return na||=$.locateFile?Ko("ort-wasm-simd-threaded.wasm")?"ort-wasm-simd-threaded.wasm":$.locateFile?$.locateFile("ort-wasm-simd-threaded.wasm",Dt):Dt+"ort-wasm-simd-threaded.wasm":new URL("/assets/ort-wasm-simd-threaded-jHavaOJV.wasm",import.meta.url).href,function(ru,Pu){var Nu=na;return Qt||typeof WebAssembly.instantiateStreaming!="function"||Ko(Nu)||vu(Nu)||typeof fetch!="function"?e_(Nu,ru,Pu):fetch(Nu,{credentials:"same-origin"}).then(n_=>WebAssembly.instantiateStreaming(n_,ru).then(Pu,function(oy){return Er(`wasm streaming compile failed: ${oy}`),Er("falling back to ArrayBuffer instantiation"),e_(Nu,ru,Pu)}))}(Xo,function(ru){Xr(ru.instance,ru.module)}).catch(et),{}}();$._OrtInit=(Xr,Xo)=>($._OrtInit=ry.aa)(Xr,Xo),$._OrtGetLastError=(Xr,Xo)=>($._OrtGetLastError=ry.ba)(Xr,Xo),$._OrtCreateSessionOptions=(Xr,Xo,ru,Pu,Nu,n_,oy,Qy,p0,y0)=>($._OrtCreateSessionOptions=ry.ca)(Xr,Xo,ru,Pu,Nu,n_,oy,Qy,p0,y0),$._OrtAppendExecutionProvider=(Xr,Xo)=>($._OrtAppendExecutionProvider=ry.da)(Xr,Xo),$._OrtAddFreeDimensionOverride=(Xr,Xo,ru)=>($._OrtAddFreeDimensionOverride=ry.ea)(Xr,Xo,ru),$._OrtAddSessionConfigEntry=(Xr,Xo,ru)=>($._OrtAddSessionConfigEntry=ry.fa)(Xr,Xo,ru),$._OrtReleaseSessionOptions=Xr=>($._OrtReleaseSessionOptions=ry.ga)(Xr),$._OrtCreateSession=(Xr,Xo,ru)=>($._OrtCreateSession=ry.ha)(Xr,Xo,ru),$._OrtReleaseSession=Xr=>($._OrtReleaseSession=ry.ia)(Xr),$._OrtGetInputOutputCount=(Xr,Xo,ru)=>($._OrtGetInputOutputCount=ry.ja)(Xr,Xo,ru),$._OrtGetInputName=(Xr,Xo)=>($._OrtGetInputName=ry.ka)(Xr,Xo),$._OrtGetOutputName=(Xr,Xo)=>($._OrtGetOutputName=ry.la)(Xr,Xo),$._OrtFree=Xr=>($._OrtFree=ry.ma)(Xr),$._OrtCreateTensor=(Xr,Xo,ru,Pu,Nu,n_)=>($._OrtCreateTensor=ry.na)(Xr,Xo,ru,Pu,Nu,n_),$._OrtGetTensorData=(Xr,Xo,ru,Pu,Nu)=>($._OrtGetTensorData=ry.oa)(Xr,Xo,ru,Pu,Nu),$._OrtReleaseTensor=Xr=>($._OrtReleaseTensor=ry.pa)(Xr),$._OrtCreateRunOptions=(Xr,Xo,ru,Pu)=>($._OrtCreateRunOptions=ry.qa)(Xr,Xo,ru,Pu),$._OrtAddRunConfigEntry=(Xr,Xo,ru)=>($._OrtAddRunConfigEntry=ry.ra)(Xr,Xo,ru),$._OrtReleaseRunOptions=Xr=>($._OrtReleaseRunOptions=ry.sa)(Xr),$._OrtCreateBinding=Xr=>($._OrtCreateBinding=ry.ta)(Xr),$._OrtBindInput=(Xr,Xo,ru)=>($._OrtBindInput=ry.ua)(Xr,Xo,ru),$._OrtBindOutput=(Xr,Xo,ru,Pu)=>($._OrtBindOutput=ry.va)(Xr,Xo,ru,Pu),$._OrtClearBoundOutputs=Xr=>($._OrtClearBoundOutputs=ry.wa)(Xr),$._OrtReleaseBinding=Xr=>($._OrtReleaseBinding=ry.xa)(Xr),$._OrtRunWithBinding=(Xr,Xo,ru,Pu,Nu)=>($._OrtRunWithBinding=ry.ya)(Xr,Xo,ru,Pu,Nu),$._OrtRun=(Xr,Xo,ru,Pu,Nu,n_,oy,Qy)=>($._OrtRun=ry.za)(Xr,Xo,ru,Pu,Nu,n_,oy,Qy),$._OrtEndProfiling=Xr=>($._OrtEndProfiling=ry.Aa)(Xr);var J_=()=>(J_=ry.Ba)();$._malloc=Xr=>($._malloc=ry.Ca)(Xr),$._free=Xr=>($._free=ry.Da)(Xr);var k0,e0=(Xr,Xo,ru,Pu,Nu,n_)=>(e0=ry.Ga)(Xr,Xo,ru,Pu,Nu,n_),jy=()=>(jy=ry.Ha)(),zy=(Xr,Xo,ru,Pu,Nu)=>(zy=ry.Ia)(Xr,Xo,ru,Pu,Nu),U_=Xr=>(U_=ry.Ja)(Xr),_y=Xr=>(_y=ry.Ka)(Xr),Ky=()=>(Ky=ry.La)(),s0=(Xr,Xo)=>(s0=ry.Ma)(Xr,Xo),S0=Xr=>(S0=ry.Na)(Xr),X_=Xr=>(X_=ry.Oa)(Xr),$w=()=>($w=ry.Pa)();function v_(){0<du||(nt?(d($),nt||yy(Du),startWorker($)):(yy(Lo),0<du||k0||(k0=!0,$.calledRun=!0,Qo||(nt||yy(Du),d($),nt||yy(_u)))))}return $.___start_em_js=831496,$.___stop_em_js=831557,$.stackSave=()=>$w(),$.stackRestore=Xr=>S0(Xr),$.stackAlloc=Xr=>X_(Xr),$.UTF8ToString=k_,$.stringToUTF8=q_,$.lengthBytesUTF8=P_,wu=function Xr(){k0||v_(),k0||(wu=Xr)},v_(),c}),Ig=Rp,globalThis.self?.name==="em-pthread"&&Rp()}),br,_g,Og,Sg,Up,Vp,Ag,zp,Vr=O(()=>{ro(),br=import.meta.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),_g=typeof location>"u"?void 0:location.origin,Og=(e,o)=>{try{let i=o??br;return(i?new URL(e,i):new URL(e)).origin===_g}catch{return!1}},Sg=async e=>{let o=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(o)},Up=(Np(),on(Cp)).default,Vp=async()=>{if(!br)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Og(br))return[void 0,Up()];let e=await Sg(br);return[e,Up(e)]},Ag=(Mp(),on(Gp)).default,zp=async(e,o,i)=>[void 0,Ag]}),Hi,qi,co,Wp,Pg,Eg,no,gt,Xe=O(()=>{Vr(),qi=!1,co=!1,Wp=!1,Pg=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Eg=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},no=async e=>{if(qi)return Promise.resolve();if(co)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Wp)throw new Error("previous call to 'initializeWebAssembly()' failed.");co=!0;let o=e.initTimeout,i=e.numThreads;if(!Eg())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=Pg();i>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+i+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=i=1);let h=e.wasmPaths,a=typeof h=="string"?h:void 0,d=h?.mjs,et=d?.href??d,$=h?.wasm,c=$?.href??$,b=e.wasmBinary,[g,nt]=await zp(et,a,i>1),at=!1,Ot=[];if(o>0&&Ot.push(new Promise(At=>{setTimeout(()=>{at=!0,At()},o)})),Ot.push(new Promise((At,Ct)=>{let St={numThreads:i};b?St.wasmBinary=b:(c||a)&&(St.locateFile=(xt,Dt)=>c??(a??Dt)+xt),nt(St).then(xt=>{co=!1,qi=!0,Hi=xt,At(),g&&URL.revokeObjectURL(g)},xt=>{co=!1,Wp=!0,Ct(xt)})})),await Promise.race(Ot),at)throw new Error(`WebAssembly backend initializing failed due to timeout: ${o}ms`)},gt=()=>{if(qi&&Hi)return Hi;throw new Error("WebAssembly is not initialized yet.")}}),yt,Wr,ht,po=O(()=>{Xe(),yt=(e,o)=>{let i=gt(),s=i.lengthBytesUTF8(e)+1,h=i._malloc(s);return i.stringToUTF8(e,h,s),o.push(h),h},Wr=(e,o,i,s)=>{if(typeof e=="object"&&e!==null){if(i.has(e))throw new Error("Circular reference in options");i.add(e)}Object.entries(e).forEach(([h,a])=>{let d=o?o+h:h;if(typeof a=="object")Wr(a,d+".",i,s);else if(typeof a=="string"||typeof a=="number")s(d,a.toString());else if(typeof a=="boolean")s(d,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},ht=e=>{let o=gt(),i=o.stackSave();try{let s=o.stackAlloc(8);o._OrtGetLastError(s,s+4);let h=o.HEAP32[s/4],a=o.HEAPU32[s/4+1],d=a?o.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${h}, ERROR_MESSAGE: ${d}`)}finally{o.stackRestore(i)}}}),Hp,qp=O(()=>{Xe(),po(),Hp=e=>{let o=gt(),i=0,s=[],h=e||{};try{if(e?.logSeverityLevel===void 0)h.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)h.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(h.terminate=!1);let a=0;return e?.tag!==void 0&&(a=yt(e.tag,s)),i=o._OrtCreateRunOptions(h.logSeverityLevel,h.logVerbosityLevel,!!h.terminate,a),i===0&&ht("Can't create run options."),e?.extra!==void 0&&Wr(e.extra,"",new WeakSet,(d,et)=>{let $=yt(d,s),c=yt(et,s);o._OrtAddRunConfigEntry(i,$,c)!==0&&ht(`Can't set a run config entry: ${d} - ${et}.`)}),[i,s]}catch(a){throw i!==0&&o._OrtReleaseRunOptions(i),s.forEach(d=>o._free(d)),a}}}),Dg,Lg,$g,kg,jp,Xp=O(()=>{Xe(),po(),Dg=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Lg=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},$g=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let o=e.extra.session;o.use_ort_model_bytes_directly||(o.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(i=>(typeof i=="string"?i:i.name)==="webgpu")&&(e.enableMemPattern=!1)},kg=(e,o,i)=>{for(let s of o){let h=typeof s=="string"?s:s.name;switch(h){case"webnn":if(h="WEBNN",typeof s!="string"){let d=s?.deviceType;if(d){let et=yt("deviceType",i),$=yt(d,i);gt()._OrtAddSessionConfigEntry(e,et,$)!==0&&ht(`Can't set a session config entry: 'deviceType' - ${d}.`)}}break;case"webgpu":if(h="JS",typeof s!="string"){let d=s;if(d?.preferredLayout){if(d.preferredLayout!=="NCHW"&&d.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${d.preferredLayout}`);let et=yt("preferredLayout",i),$=yt(d.preferredLayout,i);gt()._OrtAddSessionConfigEntry(e,et,$)!==0&&ht(`Can't set a session config entry: 'preferredLayout' - ${d.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${h}`)}let a=yt(h,i);gt()._OrtAppendExecutionProvider(e,a)!==0&&ht(`Can't append execution provider: ${h}.`)}},jp=e=>{let o=gt(),i=0,s=[],h=e||{};$g(h);try{let a=Dg(h.graphOptimizationLevel??"all"),d=Lg(h.executionMode??"sequential"),et=typeof h.logId=="string"?yt(h.logId,s):0,$=h.logSeverityLevel??2;if(!Number.isInteger($)||$<0||$>4)throw new Error(`log serverity level is not valid: ${$}`);let c=h.logVerbosityLevel??0;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log verbosity level is not valid: ${c}`);let b=typeof h.optimizedModelFilePath=="string"?yt(h.optimizedModelFilePath,s):0;if(i=o._OrtCreateSessionOptions(a,!!h.enableCpuMemArena,!!h.enableMemPattern,d,!!h.enableProfiling,0,et,$,c,b),i===0&&ht("Can't create session options."),h.executionProviders&&kg(i,h.executionProviders,s),h.enableGraphCapture!==void 0){if(typeof h.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${h.enableGraphCapture}`);let g=yt("enableGraphCapture",s),nt=yt(h.enableGraphCapture.toString(),s);o._OrtAddSessionConfigEntry(i,g,nt)!==0&&ht(`Can't set a session config entry: 'enableGraphCapture' - ${h.enableGraphCapture}.`)}if(h.freeDimensionOverrides)for(let[g,nt]of Object.entries(h.freeDimensionOverrides)){if(typeof g!="string")throw new Error(`free dimension override name must be a string: ${g}`);if(typeof nt!="number"||!Number.isInteger(nt)||nt<0)throw new Error(`free dimension override value must be a non-negative integer: ${nt}`);let at=yt(g,s);o._OrtAddFreeDimensionOverride(i,at,nt)!==0&&ht(`Can't set a free dimension override: ${g} - ${nt}.`)}return h.extra!==void 0&&Wr(h.extra,"",new WeakSet,(g,nt)=>{let at=yt(g,s),Ot=yt(nt,s);o._OrtAddSessionConfigEntry(i,at,Ot)!==0&&ht(`Can't set a session config entry: ${g} - ${nt}.`)}),[i,s]}catch(a){throw i!==0&&o._OrtReleaseSessionOptions(i),s.forEach(d=>o._free(d)),a}}}),ji,Kp,Xi,Jp,Yp,ho,Zp,Ki=O(()=>{ji=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Kp=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Xi=(e,o)=>{let i=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],s=typeof o=="number"?o:o.reduce((h,a)=>h*a,1);return i>0?Math.ceil(s*i):void 0},Jp=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Yp=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ho=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Zp=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}}),Hr,Ji=O(()=>{ro(),Hr=async e=>{if(typeof e=="string"){let o=await fetch(e);if(!o.ok)throw new Error(`failed to load external data file: ${e}`);let i=o.headers.get("Content-Length"),s=i?parseInt(i,10):0;if(s<1073741824)return new Uint8Array(await o.arrayBuffer());{if(!o.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let h=o.body.getReader(),a;try{a=new ArrayBuffer(s)}catch(et){if(et instanceof RangeError){let $=Math.ceil(s/65536);a=new WebAssembly.Memory({initial:$,maximum:$}).buffer}else throw et}let d=0;for(;;){let{done:et,value:$}=await h.read();if(et)break;let c=$.byteLength;new Uint8Array(a,d,c).set($),d+=c}return new Uint8Array(a,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),Bg,oo,io,yr,Fg,zr,ao,so,Qp,uo,lo,fo,zi=O(()=>{qp(),Xp(),Ki(),Xe(),po(),Ji(),Bg=(e,o)=>{gt()._OrtInit(e,o)!==0&&ht("Can't initialize onnxruntime.")},oo=async e=>{Bg(e.wasm.numThreads,Yp(e.logLevel))},io=async(e,o)=>{},yr=new Map,Fg=e=>{let o=gt(),i=o.stackSave();try{let s=o.stackAlloc(8);return o._OrtGetInputOutputCount(e,s,s+4)!==0&&ht("Can't get session input/output count."),[o.HEAP32[s/4],o.HEAP32[s/4+1]]}finally{o.stackRestore(i)}},zr=e=>{let o=gt(),i=o._malloc(e.byteLength);if(i===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return o.HEAPU8.set(e,i),[i,e.byteLength]},ao=async(e,o)=>{let i,s,h=gt();Array.isArray(e)?[i,s]=e:e.buffer===h.HEAPU8.buffer?[i,s]=[e.byteOffset,e.byteLength]:[i,s]=zr(e);let a=0,d=0,et=[],$=[],c=[];try{if([d,et]=jp(o),o?.externalData&&h.mountExternalData){let St=[];for(let xt of o.externalData){let Dt=typeof xt=="string"?xt:xt.path;St.push(Hr(typeof xt=="string"?xt:xt.data).then(Qt=>{h.mountExternalData(Dt,Qt)}))}await Promise.all(St)}for(let St of o?.executionProviders??[])if((typeof St=="string"?St:St.name)==="webnn"){if(h.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof St!="string"){let xt=St,Dt=xt?.context,Qt=xt?.gpuDevice,Zt=xt?.deviceType,gr=xt?.numThreads,vr=xt?.powerPreference;Dt?h.currentContext=Dt:Qt?h.currentContext=await navigator.ml.createContext(Qt):h.currentContext=await navigator.ml.createContext({deviceType:Zt,numThreads:gr,powerPreference:vr})}else h.currentContext=await navigator.ml.createContext();break}a=await h._OrtCreateSession(i,s,d),a===0&&ht("Can't create a session."),h.currentContext&&(h.currentContext=void 0);let[b,g]=Fg(a),nt=!!o?.enableGraphCapture,at=[],Ot=[],At=[];for(let St=0;St<b;St++){let xt=h._OrtGetInputName(a,St);xt===0&&ht("Can't get an input name."),$.push(xt),at.push(h.UTF8ToString(xt))}for(let St=0;St<g;St++){let xt=h._OrtGetOutputName(a,St);xt===0&&ht("Can't get an output name."),c.push(xt);let Dt=h.UTF8ToString(xt);Ot.push(Dt)}return yr.set(a,[a,$,c,null,nt,!1]),[a,at,Ot]}catch(b){throw $.forEach(g=>h._OrtFree(g)),c.forEach(g=>h._OrtFree(g)),a!==0&&h._OrtReleaseSession(a),b}finally{h._free(i),d!==0&&h._OrtReleaseSessionOptions(d),et.forEach(b=>h._free(b)),h.unmountExternalData?.()}},so=e=>{let o=gt(),i=yr.get(e);if(!i)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,h,a,d,et]=i;d&&(et&&o._OrtClearBoundOutputs(d.handle),o._OrtReleaseBinding(d.handle)),o.jsepOnReleaseSession?.(e),h.forEach($=>o._OrtFree($)),a.forEach($=>o._OrtFree($)),o._OrtReleaseSession(s),yr.delete(e)},Qp=(e,o,i,s,h,a=!1)=>{if(!e){o.push(0);return}let d=gt(),et=e[0],$=e[1],c=e[3],b,g;if(et==="string"&&c==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a&&c!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${h} when enableGraphCapture is true.`);if(c==="gpu-buffer"){let Ot=e[2].gpuBuffer;g=Xi(ji(et),$);let At=d.jsepRegisterBuffer;if(!At)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');b=At(s,h,Ot,g)}else{let Ot=e[2];if(Array.isArray(Ot)){g=4*Ot.length,b=d._malloc(g),i.push(b);let At=b/4;for(let Ct=0;Ct<Ot.length;Ct++){if(typeof Ot[Ct]!="string")throw new TypeError(`tensor data at index ${Ct} is not a string`);d.HEAPU32[At++]=yt(Ot[Ct],i)}}else g=Ot.byteLength,b=d._malloc(g),i.push(b),d.HEAPU8.set(new Uint8Array(Ot.buffer,Ot.byteOffset,g),b)}let nt=d.stackSave(),at=d.stackAlloc(4*$.length);try{let Ot=at/4;$.forEach(Ct=>d.HEAP32[Ot++]=Ct);let At=d._OrtCreateTensor(ji(et),b,g,at,$.length,Zp(c));At===0&&ht(`Can't create tensor for input/output. session=${s}, index=${h}.`),o.push(At)}finally{d.stackRestore(nt)}},uo=async(e,o,i,s,h,a)=>{let d=gt(),et=yr.get(e);if(!et)throw new Error(`cannot run inference. invalid session id: ${e}`);let $=et[0],c=et[1],b=et[2],g=et[3],nt=et[4];et[5];let at=o.length,Ot=s.length,At=0,Ct=[],St=[],xt=[],Dt=[],Qt=d.stackSave(),Zt=d.stackAlloc(at*4),gr=d.stackAlloc(at*4),vr=d.stackAlloc(Ot*4),Er=d.stackAlloc(Ot*4);try{[At,Ct]=Hp(a);for(let Yo=0;Yo<at;Yo++)Qp(i[Yo],St,Dt,e,o[Yo],nt);for(let Yo=0;Yo<Ot;Yo++)Qp(h[Yo],xt,Dt,e,at+s[Yo],nt);let wo=Zt/4,Do=gr/4,Js=vr/4,In=Er/4;for(let Yo=0;Yo<at;Yo++)d.HEAPU32[wo++]=St[Yo],d.HEAPU32[Do++]=c[o[Yo]];for(let Yo=0;Yo<Ot;Yo++)d.HEAPU32[Js++]=xt[Yo],d.HEAPU32[In++]=b[s[Yo]];d.jsepOnRunStart?.($);let Wo;Wo=await d._OrtRun($,gr,Zt,at,Er,Ot,vr,At),Wo!==0&&ht("failed to call OrtRun().");let Ir=[];for(let Yo=0;Yo<Ot;Yo++){let Bu=d.HEAPU32[vr/4+Yo];if(Bu===xt[Yo]){Ir.push(h[Yo]);continue}let Ho=d.stackSave(),tn=d.stackAlloc(4*4),To=!1,Qo,Jr=0;try{d._OrtGetTensorData(Bu,tn,tn+4,tn+8,tn+12)!==0&&ht(`Can't access output tensor data on index ${Yo}.`);let Lo=tn/4,Du=d.HEAPU32[Lo++];Jr=d.HEAPU32[Lo++];let _u=d.HEAPU32[Lo++],du=d.HEAPU32[Lo++],wu=[];for(let na=0;na<du;na++)wu.push(d.HEAPU32[_u/4+na]);d._OrtFree(_u);let r_=wu.reduce((na,Ko)=>na*Ko,1);Qo=Kp(Du);let d_=g?.outputPreferredLocations[s[Yo]];if(Qo==="string"){if(d_==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let na=[],Ko=Jr/4;for(let vu=0;vu<r_;vu++){let Cu=d.HEAPU32[Ko++],e_=vu===r_-1?void 0:d.HEAPU32[Ko]-Cu;na.push(d.UTF8ToString(Cu,e_))}Ir.push([Qo,wu,na,"cpu"])}else if(d_==="gpu-buffer"&&r_>0){let na=d.jsepGetBuffer;if(!na)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Ko=na(Jr),vu=Xi(Du,r_);if(vu===void 0||!ho(Qo))throw new Error(`Unsupported data type: ${Qo}`);To=!0,Ir.push([Qo,wu,{gpuBuffer:Ko,download:d.jsepCreateDownloader(Ko,vu,Qo),dispose:()=>{d._OrtReleaseTensor(Bu)}},"gpu-buffer"])}else{let na=Jp(Qo),Ko=new na(r_);new Uint8Array(Ko.buffer,Ko.byteOffset,Ko.byteLength).set(d.HEAPU8.subarray(Jr,Jr+Ko.byteLength)),Ir.push([Qo,wu,Ko,"cpu"])}}finally{d.stackRestore(Ho),Qo==="string"&&Jr&&d._free(Jr),To||d._OrtReleaseTensor(Bu)}}return g&&!nt&&(d._OrtClearBoundOutputs(g.handle),yr.set(e,[$,c,b,g,nt,!1])),Ir}finally{d.stackRestore(Qt),St.forEach(wo=>d._OrtReleaseTensor(wo)),xt.forEach(wo=>d._OrtReleaseTensor(wo)),Dt.forEach(wo=>d._free(wo)),At!==0&&d._OrtReleaseRunOptions(At),Ct.forEach(wo=>d._free(wo))}},lo=e=>{let o=gt(),i=yr.get(e);if(!i)throw new Error("invalid session id");let s=i[0],h=o._OrtEndProfiling(s);h===0&&ht("Can't get an profile file name."),o._OrtFree(h)},fo=e=>{let o=[];for(let i of e){let s=i[2];!Array.isArray(s)&&"buffer"in s&&o.push(s.buffer)}return o}}),Ke,Xt,qr,bo,go,mo,Yi,Zi,xr,Tr,Ng,td,ed,rd,nd,od,id,ad,Qi=O(()=>{Kt(),zi(),Xe(),Vr(),Ke=()=>!!z.wasm.proxy&&typeof document<"u",qr=!1,bo=!1,go=!1,Zi=new Map,xr=(e,o)=>{let i=Zi.get(e);i?i.push(o):Zi.set(e,[o])},Tr=()=>{if(qr||!bo||go||!Xt)throw new Error("worker not ready")},Ng=e=>{switch(e.data.type){case"init-wasm":qr=!1,e.data.err?(go=!0,Yi[1](e.data.err)):(bo=!0,Yi[0]()),mo&&(URL.revokeObjectURL(mo),mo=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let o=Zi.get(e.data.type);e.data.err?o.shift()[1](e.data.err):o.shift()[0](e.data.out);break}}},td=async()=>{if(!bo){if(qr)throw new Error("multiple calls to 'initWasm()' detected.");if(go)throw new Error("previous call to 'initWasm()' failed.");if(qr=!0,Ke())return new Promise((e,o)=>{Xt?.terminate(),Vp().then(([i,s])=>{try{Xt=s,Xt.onerror=a=>o(a),Xt.onmessage=Ng,Yi=[e,o];let h={type:"init-wasm",in:z};Xt.postMessage(h),mo=i}catch(h){o(h)}},o)});try{await no(z.wasm),await oo(z),bo=!0}catch(e){throw go=!0,e}finally{qr=!1}}},ed=async e=>{if(Ke())return Tr(),new Promise((o,i)=>{xr("init-ep",[o,i]);let s={type:"init-ep",in:{epName:e,env:z}};Xt.postMessage(s)});await io(z,e)},rd=async e=>Ke()?(Tr(),new Promise((o,i)=>{xr("copy-from",[o,i]);let s={type:"copy-from",in:{buffer:e}};Xt.postMessage(s,[e.buffer])})):zr(e),nd=async(e,o)=>{if(Ke()){if(o?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Tr(),new Promise((i,s)=>{xr("create",[i,s]);let h={type:"create",in:{model:e,options:{...o}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),Xt.postMessage(h,a)})}else return ao(e,o)},od=async e=>{if(Ke())return Tr(),new Promise((o,i)=>{xr("release",[o,i]);let s={type:"release",in:e};Xt.postMessage(s)});so(e)},id=async(e,o,i,s,h,a)=>{if(Ke()){if(i.some(d=>d[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(h.some(d=>d))throw new Error("pre-allocated output tensor is not supported for proxy.");return Tr(),new Promise((d,et)=>{xr("run",[d,et]);let $=i,c={type:"run",in:{sessionId:e,inputIndices:o,inputs:$,outputIndices:s,options:a}};Xt.postMessage(c,fo($))})}else return uo(e,o,i,s,h,a)},ad=async e=>{if(Ke())return Tr(),new Promise((o,i)=>{xr("end-profiling",[o,i]);let s={type:"end-profiling",in:e};Xt.postMessage(s)});lo(e)}}),sd,Rg,yo,ud=O(()=>{Kt(),Qi(),Ki(),ro(),Ji(),sd=(e,o)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${o()}`)}},Rg=e=>{switch(e[3]){case"cpu":return new Tt(e[0],e[2],e[1]);case"gpu-buffer":{let o=e[0];if(!ho(o))throw new Error(`not supported data type: ${o} for deserializing GPU tensor`);let{gpuBuffer:i,download:s,dispose:h}=e[2];return Tt.fromGpuBuffer(i,{dataType:o,dims:e[1],download:s,dispose:h})}default:throw new Error(`invalid data location: ${e[3]}`)}},yo=class{async fetchModelAndCopyToWasmMemory(e){return rd(await Hr(e))}async loadModel(e,o){Be();let i;typeof e=="string"?i=await this.fetchModelAndCopyToWasmMemory(e):i=e,[this.sessionId,this.inputNames,this.outputNames]=await nd(i,o),Fe()}async dispose(){return od(this.sessionId)}async run(e,o,i){Be();let s=[],h=[];Object.entries(e).forEach(g=>{let nt=g[0],at=g[1],Ot=this.inputNames.indexOf(nt);if(Ot===-1)throw new Error(`invalid input '${nt}'`);s.push(at),h.push(Ot)});let a=[],d=[];Object.entries(o).forEach(g=>{let nt=g[0],at=g[1],Ot=this.outputNames.indexOf(nt);if(Ot===-1)throw new Error(`invalid output '${nt}'`);a.push(at),d.push(Ot)});let et=s.map((g,nt)=>sd(g,()=>`input "${this.inputNames[h[nt]]}"`)),$=a.map((g,nt)=>g?sd(g,()=>`output "${this.outputNames[d[nt]]}"`):null),c=await id(this.sessionId,h,et,d,$,i),b={};for(let g=0;g<c.length;g++)b[this.outputNames[d[g]]]=a[g]??Rg(c[g]);return Fe(),b}startProfiling(){}endProfiling(){ad(this.sessionId)}}}),Gg,xo,ld=O(()=>{Kt(),Qi(),ud(),Vr(),Gg=()=>{if((typeof z.wasm.initTimeout!="number"||z.wasm.initTimeout<0)&&(z.wasm.initTimeout=0),z.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof z.wasm.proxy!="boolean"&&(z.wasm.proxy=!1),typeof z.wasm.trace!="boolean"&&(z.wasm.trace=!1),typeof z.wasm.numThreads!="number"||!Number.isInteger(z.wasm.numThreads)||z.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)z.wasm.numThreads=1;else{let e=typeof navigator>"u"?ko("node:os").cpus().length:navigator.hardwareConcurrency;z.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},xo=class{async init(e){Gg(),await td(),await ed(e)}async createInferenceSessionHandler(e,o){let i=new yo;return await i.loadModel(e,o),Promise.resolve(i)}}}),fd={};Or(fd,{wasmBackend:()=>Mg});var Mg,cd=O(()=>{ld(),Mg=new xo});Kt();Kt();Kt();var Ps="1.20.0-dev.20240908-de7a02beef";{let e=(kp(),on($p)).onnxjsBackend;nr("webgl",e,-10)}{let e=(cd(),on(fd)).wasmBackend;nr("cpu",e,10),nr("wasm",e,10)}Object.defineProperty(z.versions,"web",{value:Ps,enumerable:!0});/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/function App(){const[e,o]=reactExports.useState([]),[i,s]=reactExports.useState([]),[h,a]=reactExports.useState(!0),[d,et]=reactExports.useState(null),$=reactExports.useRef(null),c=reactExports.useRef(null);reactExports.useEffect(()=>{(async()=>{try{if(!navigator.gpu)throw console.log("WebGPU is not supported in this browser."),new Error("WebGPU is not supported in this browser.");const Qt="Xenova/modnet";__webpack_exports__env.backends.onnx.wasm.proxy=!1,$.current??=await __webpack_exports__AutoModel.from_pretrained(Qt,{device:"webgpu"}),c.current??=await __webpack_exports__AutoProcessor.from_pretrained(Qt)}catch(Qt){et(Qt)}a(!1)})()},[]);const b=reactExports.useCallback(async Qt=>{for(const Zt of Qt){const gr=await db$1.images.add({file:Zt,processedFile:"null"});console.log(`Added image with id ${gr}`)}await processImages()},[]),{getRootProps:g,getInputProps:nt,isDragActive:at,isDragAccept:Ot,isDragReject:At}=useDropzone({onDrop:b,accept:{"image/*":[".jpeg",".jpg",".png",".mp4"]}}),Ct=async()=>{const Qt=new JSZip,Zt=(await db$1.images.toArray()).map(vr=>vr.processedFile);for(const vr of Zt)Qt.file(vr.name,vr);const gr=await Qt.generateAsync({type:"blob"});FileSaver_minExports.saveAs(gr,"background-blasted.zip")},St=()=>{o([]),s([]),setIsDownloadReady(!1),db$1.images.where("id").above(0).delete()},xt=async Qt=>{try{const gr=await(await fetch(Qt)).blob(),vr=new ClipboardItem({[gr.type]:gr});await navigator.clipboard.write([vr]),console.log("Image copied to clipboard")}catch(Zt){console.error("Failed to copy image: ",Zt)}},Dt=Qt=>{const Zt=document.createElement("a");Zt.href=Qt,Zt.download="image.png",document.body.appendChild(Zt),Zt.click(),document.body.removeChild(Zt)};return d?jsxRuntimeExports.jsx("div",{className:"min-h-screen bg-black text-white flex items-center justify-center",children:jsxRuntimeExports.jsxs("div",{className:"text-center",children:[jsxRuntimeExports.jsx("h2",{className:"text-4xl mb-2",children:"ERROR"}),jsxRuntimeExports.jsx("p",{className:"text-xl max-w-[500px]",children:d.message})]})}):h?jsxRuntimeExports.jsx("div",{className:"min-h-screen bg-black text-white flex items-center justify-center",children:jsxRuntimeExports.jsxs("div",{className:"text-center",children:[jsxRuntimeExports.jsx("div",{className:"inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-white mb-4"}),jsxRuntimeExports.jsx("p",{className:"text-lg",children:"Loading background removal model..."})]})}):jsxRuntimeExports.jsx("div",{className:"min-h-screen text-white p-8",children:jsxRuntimeExports.jsxs("div",{className:"max-w-6xl mx-auto",children:[jsxRuntimeExports.jsx("h1",{className:"text-4xl font-bold mb-2 text-center",children:"Remove Background WebGPU"}),jsxRuntimeExports.jsxs("h2",{className:"text-lg font-semibold mb-2 text-center",children:["In-browser background removal, powered by"," ",jsxRuntimeExports.jsx("a",{className:"underline",target:"_blank",href:"https://github.com/xenova/transformers.js",children:" Transformers.js"})]}),jsxRuntimeExports.jsxs("div",{className:"flex justify-center mb-8 gap-8",children:[jsxRuntimeExports.jsx("a",{className:"underline",target:"_blank",href:"https://github.com/huggingface/transformers.js-examples/blob/main/LICENSE",children:"License (Apache 2.0)"}),jsxRuntimeExports.jsx("a",{className:"underline",target:"_blank",href:"https://huggingface.co/Xenova/modnet",children:"Model (MODNet)"}),jsxRuntimeExports.jsx("a",{className:"underline",target:"_blank",href:"https://github.com/huggingface/transformers.js-examples/tree/main/remove-background-webgpu/",children:"Code (GitHub)"})]}),jsxRuntimeExports.jsxs("div",{...g(),className:`p-8 mb-8 border-2 border-dashed rounded-lg text-center cursor-pointer transition-colors duration-300 ease-in-out
            ${Ot?"border-green-500 bg-green-900/20":""}
            ${At?"border-red-500 bg-red-900/20":""}
            ${at?"border-blue-500 bg-blue-900/20":"border-gray-700 hover:border-blue-500 hover:bg-blue-900/10"}
          `,children:[jsxRuntimeExports.jsx("input",{...nt(),className:"hidden"}),jsxRuntimeExports.jsx("p",{className:"text-lg mb-2",children:at?"Drop the images here...":"Drag and drop some images here"}),jsxRuntimeExports.jsx("p",{className:"text-sm text-gray-400",children:"or click to select files"})]}),jsxRuntimeExports.jsx("div",{className:"flex flex-col items-center gap-4 mb-8",children:jsxRuntimeExports.jsxs("div",{className:"flex gap-4",children:[jsxRuntimeExports.jsx("button",{onClick:Ct,className:"px-3 py-1 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-black disabled:bg-gray-700 disabled:cursor-not-allowed transition-colors duration-200 text-sm",children:"Download as ZIP"}),jsxRuntimeExports.jsx("button",{onClick:St,className:"px-3 py-1 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-black transition-colors duration-200 text-sm",children:"Clear All"})]})}),jsxRuntimeExports.jsx(Images,{}),jsxRuntimeExports.jsx("div",{className:"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6",children:e.map((Qt,Zt)=>jsxRuntimeExports.jsxs("div",{className:"relative group",children:[jsxRuntimeExports.jsx("img",{src:i[Zt]||Qt,alt:`Image ${Zt+1}`,className:"rounded-lg object-cover w-full h-48"}),i[Zt]&&jsxRuntimeExports.jsxs("div",{className:"absolute inset-0 bg-black bg-opacity-70 opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-lg flex items-center justify-center",children:[jsxRuntimeExports.jsx("button",{onClick:()=>xt(i[Zt]||Qt),className:"mx-2 px-3 py-1 bg-white text-gray-900 rounded-md hover:bg-gray-200 transition-colors duration-200 text-sm","aria-label":`Copy image ${Zt+1} to clipboard`,children:"Copy"}),jsxRuntimeExports.jsx("button",{onClick:()=>Dt(i[Zt]||Qt),className:"mx-2 px-3 py-1 bg-white text-gray-900 rounded-md hover:bg-gray-200 transition-colors duration-200 text-sm","aria-label":`Download image ${Zt+1}`,children:"Download"})]})]},Zt))})]})})}console.log("main.jsx");createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(reactExports.StrictMode,{children:jsxRuntimeExports.jsx(App,{})}));
